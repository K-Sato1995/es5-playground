/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@eslint/eslintrc/conf/config-schema.js":
/*!*************************************************************!*\
  !*** ./node_modules/@eslint/eslintrc/conf/config-schema.js ***!
  \*************************************************************/
/***/ ((module) => {

"use strict";
eval("/**\n * @fileoverview Defines a schema for configs.\n * @author Sylvan Mably\n */\n\n\n\nconst baseConfigProperties = {\n    $schema: { type: \"string\" },\n    env: { type: \"object\" },\n    extends: { $ref: \"#/definitions/stringOrStrings\" },\n    globals: { type: \"object\" },\n    overrides: {\n        type: \"array\",\n        items: { $ref: \"#/definitions/overrideConfig\" },\n        additionalItems: false\n    },\n    parser: { type: [\"string\", \"null\"] },\n    parserOptions: { type: \"object\" },\n    plugins: { type: \"array\" },\n    processor: { type: \"string\" },\n    rules: { type: \"object\" },\n    settings: { type: \"object\" },\n    noInlineConfig: { type: \"boolean\" },\n    reportUnusedDisableDirectives: { type: \"boolean\" },\n\n    ecmaFeatures: { type: \"object\" } // deprecated; logs a warning when used\n};\n\nconst configSchema = {\n    definitions: {\n        stringOrStrings: {\n            oneOf: [\n                { type: \"string\" },\n                {\n                    type: \"array\",\n                    items: { type: \"string\" },\n                    additionalItems: false\n                }\n            ]\n        },\n        stringOrStringsRequired: {\n            oneOf: [\n                { type: \"string\" },\n                {\n                    type: \"array\",\n                    items: { type: \"string\" },\n                    additionalItems: false,\n                    minItems: 1\n                }\n            ]\n        },\n\n        // Config at top-level.\n        objectConfig: {\n            type: \"object\",\n            properties: {\n                root: { type: \"boolean\" },\n                ignorePatterns: { $ref: \"#/definitions/stringOrStrings\" },\n                ...baseConfigProperties\n            },\n            additionalProperties: false\n        },\n\n        // Config in `overrides`.\n        overrideConfig: {\n            type: \"object\",\n            properties: {\n                excludedFiles: { $ref: \"#/definitions/stringOrStrings\" },\n                files: { $ref: \"#/definitions/stringOrStringsRequired\" },\n                ...baseConfigProperties\n            },\n            required: [\"files\"],\n            additionalProperties: false\n        }\n    },\n\n    $ref: \"#/definitions/objectConfig\"\n};\n\nmodule.exports = configSchema;\n\n\n//# sourceURL=webpack://javascript/./node_modules/@eslint/eslintrc/conf/config-schema.js?");

/***/ }),

/***/ "./node_modules/@eslint/eslintrc/conf/environments.js":
/*!************************************************************!*\
  !*** ./node_modules/@eslint/eslintrc/conf/environments.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * @fileoverview Defines environment settings and globals.\n * @author Elan Shanker\n */\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst globals = __webpack_require__(/*! globals */ \"./node_modules/globals/index.js\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Get the object that has difference.\n * @param {Record<string,boolean>} current The newer object.\n * @param {Record<string,boolean>} prev The older object.\n * @returns {Record<string,boolean>} The difference object.\n */\nfunction getDiff(current, prev) {\n    const retv = {};\n\n    for (const [key, value] of Object.entries(current)) {\n        if (!Object.hasOwnProperty.call(prev, key)) {\n            retv[key] = value;\n        }\n    }\n\n    return retv;\n}\n\nconst newGlobals2015 = getDiff(globals.es2015, globals.es5); // 19 variables such as Promise, Map, ...\nconst newGlobals2017 = {\n    Atomics: false,\n    SharedArrayBuffer: false\n};\nconst newGlobals2020 = {\n    BigInt: false,\n    BigInt64Array: false,\n    BigUint64Array: false,\n    globalThis: false\n};\n\nconst newGlobals2021 = {\n    AggregateError: false,\n    FinalizationRegistry: false,\n    WeakRef: false\n};\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/** @type {Map<string, import(\"../lib/shared/types\").Environment>} */\nmodule.exports = new Map(Object.entries({\n\n    // Language\n    builtin: {\n        globals: globals.es5\n    },\n    es6: {\n        globals: newGlobals2015,\n        parserOptions: {\n            ecmaVersion: 6\n        }\n    },\n    es2015: {\n        globals: newGlobals2015,\n        parserOptions: {\n            ecmaVersion: 6\n        }\n    },\n    es2017: {\n        globals: { ...newGlobals2015, ...newGlobals2017 },\n        parserOptions: {\n            ecmaVersion: 8\n        }\n    },\n    es2020: {\n        globals: { ...newGlobals2015, ...newGlobals2017, ...newGlobals2020 },\n        parserOptions: {\n            ecmaVersion: 11\n        }\n    },\n    es2021: {\n        globals: { ...newGlobals2015, ...newGlobals2017, ...newGlobals2020, ...newGlobals2021 },\n        parserOptions: {\n            ecmaVersion: 12\n        }\n    },\n\n    // Platforms\n    browser: {\n        globals: globals.browser\n    },\n    node: {\n        globals: globals.node,\n        parserOptions: {\n            ecmaFeatures: {\n                globalReturn: true\n            }\n        }\n    },\n    \"shared-node-browser\": {\n        globals: globals[\"shared-node-browser\"]\n    },\n    worker: {\n        globals: globals.worker\n    },\n    serviceworker: {\n        globals: globals.serviceworker\n    },\n\n    // Frameworks\n    commonjs: {\n        globals: globals.commonjs,\n        parserOptions: {\n            ecmaFeatures: {\n                globalReturn: true\n            }\n        }\n    },\n    amd: {\n        globals: globals.amd\n    },\n    mocha: {\n        globals: globals.mocha\n    },\n    jasmine: {\n        globals: globals.jasmine\n    },\n    jest: {\n        globals: globals.jest\n    },\n    phantomjs: {\n        globals: globals.phantomjs\n    },\n    jquery: {\n        globals: globals.jquery\n    },\n    qunit: {\n        globals: globals.qunit\n    },\n    prototypejs: {\n        globals: globals.prototypejs\n    },\n    shelljs: {\n        globals: globals.shelljs\n    },\n    meteor: {\n        globals: globals.meteor\n    },\n    mongo: {\n        globals: globals.mongo\n    },\n    protractor: {\n        globals: globals.protractor\n    },\n    applescript: {\n        globals: globals.applescript\n    },\n    nashorn: {\n        globals: globals.nashorn\n    },\n    atomtest: {\n        globals: globals.atomtest\n    },\n    embertest: {\n        globals: globals.embertest\n    },\n    webextensions: {\n        globals: globals.webextensions\n    },\n    greasemonkey: {\n        globals: globals.greasemonkey\n    }\n}));\n\n\n//# sourceURL=webpack://javascript/./node_modules/@eslint/eslintrc/conf/environments.js?");

/***/ }),

/***/ "./node_modules/@eslint/eslintrc/lib/shared/ajv.js":
/*!*********************************************************!*\
  !*** ./node_modules/@eslint/eslintrc/lib/shared/ajv.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * @fileoverview The instance of Ajv validator.\n * @author Evgeny Poberezkin\n */\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst Ajv = __webpack_require__(/*! ajv */ \"./node_modules/ajv/lib/ajv.js\"),\n    metaSchema = __webpack_require__(/*! ajv/lib/refs/json-schema-draft-04.json */ \"./node_modules/ajv/lib/refs/json-schema-draft-04.json\");\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\nmodule.exports = (additionalOptions = {}) => {\n    const ajv = new Ajv({\n        meta: false,\n        useDefaults: true,\n        validateSchema: false,\n        missingRefs: \"ignore\",\n        verbose: true,\n        schemaId: \"auto\",\n        ...additionalOptions\n    });\n\n    ajv.addMetaSchema(metaSchema);\n    // eslint-disable-next-line no-underscore-dangle\n    ajv._opts.defaultMeta = metaSchema.id;\n\n    return ajv;\n};\n\n\n//# sourceURL=webpack://javascript/./node_modules/@eslint/eslintrc/lib/shared/ajv.js?");

/***/ }),

/***/ "./node_modules/@eslint/eslintrc/lib/shared/config-ops.js":
/*!****************************************************************!*\
  !*** ./node_modules/@eslint/eslintrc/lib/shared/config-ops.js ***!
  \****************************************************************/
/***/ ((module) => {

"use strict";
eval("/**\n * @fileoverview Config file operations. This file must be usable in the browser,\n * so no Node-specific code can be here.\n * @author Nicholas C. Zakas\n */\n\n\n//------------------------------------------------------------------------------\n// Private\n//------------------------------------------------------------------------------\n\nconst RULE_SEVERITY_STRINGS = [\"off\", \"warn\", \"error\"],\n    RULE_SEVERITY = RULE_SEVERITY_STRINGS.reduce((map, value, index) => {\n        map[value] = index;\n        return map;\n    }, {}),\n    VALID_SEVERITIES = [0, 1, 2, \"off\", \"warn\", \"error\"];\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n\n    /**\n     * Normalizes the severity value of a rule's configuration to a number\n     * @param {(number|string|[number, ...*]|[string, ...*])} ruleConfig A rule's configuration value, generally\n     * received from the user. A valid config value is either 0, 1, 2, the string \"off\" (treated the same as 0),\n     * the string \"warn\" (treated the same as 1), the string \"error\" (treated the same as 2), or an array\n     * whose first element is one of the above values. Strings are matched case-insensitively.\n     * @returns {(0|1|2)} The numeric severity value if the config value was valid, otherwise 0.\n     */\n    getRuleSeverity(ruleConfig) {\n        const severityValue = Array.isArray(ruleConfig) ? ruleConfig[0] : ruleConfig;\n\n        if (severityValue === 0 || severityValue === 1 || severityValue === 2) {\n            return severityValue;\n        }\n\n        if (typeof severityValue === \"string\") {\n            return RULE_SEVERITY[severityValue.toLowerCase()] || 0;\n        }\n\n        return 0;\n    },\n\n    /**\n     * Converts old-style severity settings (0, 1, 2) into new-style\n     * severity settings (off, warn, error) for all rules. Assumption is that severity\n     * values have already been validated as correct.\n     * @param {Object} config The config object to normalize.\n     * @returns {void}\n     */\n    normalizeToStrings(config) {\n\n        if (config.rules) {\n            Object.keys(config.rules).forEach(ruleId => {\n                const ruleConfig = config.rules[ruleId];\n\n                if (typeof ruleConfig === \"number\") {\n                    config.rules[ruleId] = RULE_SEVERITY_STRINGS[ruleConfig] || RULE_SEVERITY_STRINGS[0];\n                } else if (Array.isArray(ruleConfig) && typeof ruleConfig[0] === \"number\") {\n                    ruleConfig[0] = RULE_SEVERITY_STRINGS[ruleConfig[0]] || RULE_SEVERITY_STRINGS[0];\n                }\n            });\n        }\n    },\n\n    /**\n     * Determines if the severity for the given rule configuration represents an error.\n     * @param {int|string|Array} ruleConfig The configuration for an individual rule.\n     * @returns {boolean} True if the rule represents an error, false if not.\n     */\n    isErrorSeverity(ruleConfig) {\n        return module.exports.getRuleSeverity(ruleConfig) === 2;\n    },\n\n    /**\n     * Checks whether a given config has valid severity or not.\n     * @param {number|string|Array} ruleConfig The configuration for an individual rule.\n     * @returns {boolean} `true` if the configuration has valid severity.\n     */\n    isValidSeverity(ruleConfig) {\n        let severity = Array.isArray(ruleConfig) ? ruleConfig[0] : ruleConfig;\n\n        if (typeof severity === \"string\") {\n            severity = severity.toLowerCase();\n        }\n        return VALID_SEVERITIES.indexOf(severity) !== -1;\n    },\n\n    /**\n     * Checks whether every rule of a given config has valid severity or not.\n     * @param {Object} config The configuration for rules.\n     * @returns {boolean} `true` if the configuration has valid severity.\n     */\n    isEverySeverityValid(config) {\n        return Object.keys(config).every(ruleId => this.isValidSeverity(config[ruleId]));\n    },\n\n    /**\n     * Normalizes a value for a global in a config\n     * @param {(boolean|string|null)} configuredValue The value given for a global in configuration or in\n     * a global directive comment\n     * @returns {(\"readable\"|\"writeable\"|\"off\")} The value normalized as a string\n     * @throws Error if global value is invalid\n     */\n    normalizeConfigGlobal(configuredValue) {\n        switch (configuredValue) {\n            case \"off\":\n                return \"off\";\n\n            case true:\n            case \"true\":\n            case \"writeable\":\n            case \"writable\":\n                return \"writable\";\n\n            case null:\n            case false:\n            case \"false\":\n            case \"readable\":\n            case \"readonly\":\n                return \"readonly\";\n\n            default:\n                throw new Error(`'${configuredValue}' is not a valid configuration for a global (use 'readonly', 'writable', or 'off')`);\n        }\n    }\n};\n\n\n//# sourceURL=webpack://javascript/./node_modules/@eslint/eslintrc/lib/shared/config-ops.js?");

/***/ }),

/***/ "./node_modules/@eslint/eslintrc/lib/shared/config-validator.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@eslint/eslintrc/lib/shared/config-validator.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * @fileoverview Validates configs.\n * @author Brandon Mills\n */\n\n\n\n/* eslint class-methods-use-this: \"off\" */\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst\n    util = __webpack_require__(/*! util */ \"./node_modules/util/util.js\"),\n    configSchema = __webpack_require__(/*! ../../conf/config-schema */ \"./node_modules/@eslint/eslintrc/conf/config-schema.js\"),\n    BuiltInEnvironments = __webpack_require__(/*! ../../conf/environments */ \"./node_modules/@eslint/eslintrc/conf/environments.js\"),\n    ConfigOps = __webpack_require__(/*! ./config-ops */ \"./node_modules/@eslint/eslintrc/lib/shared/config-ops.js\"),\n    { emitDeprecationWarning } = __webpack_require__(/*! ./deprecation-warnings */ \"./node_modules/@eslint/eslintrc/lib/shared/deprecation-warnings.js\");\n\nconst ajv = __webpack_require__(/*! ./ajv */ \"./node_modules/@eslint/eslintrc/lib/shared/ajv.js\")();\nconst ruleValidators = new WeakMap();\nconst noop = Function.prototype;\n\n//------------------------------------------------------------------------------\n// Private\n//------------------------------------------------------------------------------\nlet validateSchema;\nconst severityMap = {\n    error: 2,\n    warn: 1,\n    off: 0\n};\n\nconst validated = new WeakSet();\n\n//-----------------------------------------------------------------------------\n// Exports\n//-----------------------------------------------------------------------------\n\nmodule.exports = class ConfigValidator {\n    constructor({ builtInRules = new Map() } = {}) {\n        this.builtInRules = builtInRules;\n    }\n\n    /**\n     * Gets a complete options schema for a rule.\n     * @param {{create: Function, schema: (Array|null)}} rule A new-style rule object\n     * @returns {Object} JSON Schema for the rule's options.\n     */\n    getRuleOptionsSchema(rule) {\n        if (!rule) {\n            return null;\n        }\n\n        const schema = rule.schema || rule.meta && rule.meta.schema;\n\n        // Given a tuple of schemas, insert warning level at the beginning\n        if (Array.isArray(schema)) {\n            if (schema.length) {\n                return {\n                    type: \"array\",\n                    items: schema,\n                    minItems: 0,\n                    maxItems: schema.length\n                };\n            }\n            return {\n                type: \"array\",\n                minItems: 0,\n                maxItems: 0\n            };\n\n        }\n\n        // Given a full schema, leave it alone\n        return schema || null;\n    }\n\n    /**\n     * Validates a rule's severity and returns the severity value. Throws an error if the severity is invalid.\n     * @param {options} options The given options for the rule.\n     * @returns {number|string} The rule's severity value\n     */\n    validateRuleSeverity(options) {\n        const severity = Array.isArray(options) ? options[0] : options;\n        const normSeverity = typeof severity === \"string\" ? severityMap[severity.toLowerCase()] : severity;\n\n        if (normSeverity === 0 || normSeverity === 1 || normSeverity === 2) {\n            return normSeverity;\n        }\n\n        throw new Error(`\\tSeverity should be one of the following: 0 = off, 1 = warn, 2 = error (you passed '${util.inspect(severity).replace(/'/gu, \"\\\"\").replace(/\\n/gu, \"\")}').\\n`);\n\n    }\n\n    /**\n     * Validates the non-severity options passed to a rule, based on its schema.\n     * @param {{create: Function}} rule The rule to validate\n     * @param {Array} localOptions The options for the rule, excluding severity\n     * @returns {void}\n     */\n    validateRuleSchema(rule, localOptions) {\n        if (!ruleValidators.has(rule)) {\n            const schema = this.getRuleOptionsSchema(rule);\n\n            if (schema) {\n                ruleValidators.set(rule, ajv.compile(schema));\n            }\n        }\n\n        const validateRule = ruleValidators.get(rule);\n\n        if (validateRule) {\n            validateRule(localOptions);\n            if (validateRule.errors) {\n                throw new Error(validateRule.errors.map(\n                    error => `\\tValue ${JSON.stringify(error.data)} ${error.message}.\\n`\n                ).join(\"\"));\n            }\n        }\n    }\n\n    /**\n     * Validates a rule's options against its schema.\n     * @param {{create: Function}|null} rule The rule that the config is being validated for\n     * @param {string} ruleId The rule's unique name.\n     * @param {Array|number} options The given options for the rule.\n     * @param {string|null} source The name of the configuration source to report in any errors. If null or undefined,\n     * no source is prepended to the message.\n     * @returns {void}\n     */\n    validateRuleOptions(rule, ruleId, options, source = null) {\n        try {\n            const severity = this.validateRuleSeverity(options);\n\n            if (severity !== 0) {\n                this.validateRuleSchema(rule, Array.isArray(options) ? options.slice(1) : []);\n            }\n        } catch (err) {\n            const enhancedMessage = `Configuration for rule \"${ruleId}\" is invalid:\\n${err.message}`;\n\n            if (typeof source === \"string\") {\n                throw new Error(`${source}:\\n\\t${enhancedMessage}`);\n            } else {\n                throw new Error(enhancedMessage);\n            }\n        }\n    }\n\n    /**\n     * Validates an environment object\n     * @param {Object} environment The environment config object to validate.\n     * @param {string} source The name of the configuration source to report in any errors.\n     * @param {function(envId:string): Object} [getAdditionalEnv] A map from strings to loaded environments.\n     * @returns {void}\n     */\n    validateEnvironment(\n        environment,\n        source,\n        getAdditionalEnv = noop\n    ) {\n\n        // not having an environment is ok\n        if (!environment) {\n            return;\n        }\n\n        Object.keys(environment).forEach(id => {\n            const env = getAdditionalEnv(id) || BuiltInEnvironments.get(id) || null;\n\n            if (!env) {\n                const message = `${source}:\\n\\tEnvironment key \"${id}\" is unknown\\n`;\n\n                throw new Error(message);\n            }\n        });\n    }\n\n    /**\n     * Validates a rules config object\n     * @param {Object} rulesConfig The rules config object to validate.\n     * @param {string} source The name of the configuration source to report in any errors.\n     * @param {function(ruleId:string): Object} getAdditionalRule A map from strings to loaded rules\n     * @returns {void}\n     */\n    validateRules(\n        rulesConfig,\n        source,\n        getAdditionalRule = noop\n    ) {\n        if (!rulesConfig) {\n            return;\n        }\n\n        Object.keys(rulesConfig).forEach(id => {\n            const rule = getAdditionalRule(id) || this.builtInRules.get(id) || null;\n\n            this.validateRuleOptions(rule, id, rulesConfig[id], source);\n        });\n    }\n\n    /**\n     * Validates a `globals` section of a config file\n     * @param {Object} globalsConfig The `globals` section\n     * @param {string|null} source The name of the configuration source to report in the event of an error.\n     * @returns {void}\n     */\n    validateGlobals(globalsConfig, source = null) {\n        if (!globalsConfig) {\n            return;\n        }\n\n        Object.entries(globalsConfig)\n            .forEach(([configuredGlobal, configuredValue]) => {\n                try {\n                    ConfigOps.normalizeConfigGlobal(configuredValue);\n                } catch (err) {\n                    throw new Error(`ESLint configuration of global '${configuredGlobal}' in ${source} is invalid:\\n${err.message}`);\n                }\n            });\n    }\n\n    /**\n     * Validate `processor` configuration.\n     * @param {string|undefined} processorName The processor name.\n     * @param {string} source The name of config file.\n     * @param {function(id:string): Processor} getProcessor The getter of defined processors.\n     * @returns {void}\n     */\n    validateProcessor(processorName, source, getProcessor) {\n        if (processorName && !getProcessor(processorName)) {\n            throw new Error(`ESLint configuration of processor in '${source}' is invalid: '${processorName}' was not found.`);\n        }\n    }\n\n    /**\n     * Formats an array of schema validation errors.\n     * @param {Array} errors An array of error messages to format.\n     * @returns {string} Formatted error message\n     */\n    formatErrors(errors) {\n        return errors.map(error => {\n            if (error.keyword === \"additionalProperties\") {\n                const formattedPropertyPath = error.dataPath.length ? `${error.dataPath.slice(1)}.${error.params.additionalProperty}` : error.params.additionalProperty;\n\n                return `Unexpected top-level property \"${formattedPropertyPath}\"`;\n            }\n            if (error.keyword === \"type\") {\n                const formattedField = error.dataPath.slice(1);\n                const formattedExpectedType = Array.isArray(error.schema) ? error.schema.join(\"/\") : error.schema;\n                const formattedValue = JSON.stringify(error.data);\n\n                return `Property \"${formattedField}\" is the wrong type (expected ${formattedExpectedType} but got \\`${formattedValue}\\`)`;\n            }\n\n            const field = error.dataPath[0] === \".\" ? error.dataPath.slice(1) : error.dataPath;\n\n            return `\"${field}\" ${error.message}. Value: ${JSON.stringify(error.data)}`;\n        }).map(message => `\\t- ${message}.\\n`).join(\"\");\n    }\n\n    /**\n     * Validates the top level properties of the config object.\n     * @param {Object} config The config object to validate.\n     * @param {string} source The name of the configuration source to report in any errors.\n     * @returns {void}\n     */\n    validateConfigSchema(config, source = null) {\n        validateSchema = validateSchema || ajv.compile(configSchema);\n\n        if (!validateSchema(config)) {\n            throw new Error(`ESLint configuration in ${source} is invalid:\\n${this.formatErrors(validateSchema.errors)}`);\n        }\n\n        if (Object.hasOwnProperty.call(config, \"ecmaFeatures\")) {\n            emitDeprecationWarning(source, \"ESLINT_LEGACY_ECMAFEATURES\");\n        }\n    }\n\n    /**\n     * Validates an entire config object.\n     * @param {Object} config The config object to validate.\n     * @param {string} source The name of the configuration source to report in any errors.\n     * @param {function(ruleId:string): Object} [getAdditionalRule] A map from strings to loaded rules.\n     * @param {function(envId:string): Object} [getAdditionalEnv] A map from strings to loaded envs.\n     * @returns {void}\n     */\n    validate(config, source, getAdditionalRule, getAdditionalEnv) {\n        this.validateConfigSchema(config, source);\n        this.validateRules(config.rules, source, getAdditionalRule);\n        this.validateEnvironment(config.env, source, getAdditionalEnv);\n        this.validateGlobals(config.globals, source);\n\n        for (const override of config.overrides || []) {\n            this.validateRules(override.rules, source, getAdditionalRule);\n            this.validateEnvironment(override.env, source, getAdditionalEnv);\n            this.validateGlobals(config.globals, source);\n        }\n    }\n\n    /**\n     * Validate config array object.\n     * @param {ConfigArray} configArray The config array to validate.\n     * @returns {void}\n     */\n    validateConfigArray(configArray) {\n        const getPluginEnv = Map.prototype.get.bind(configArray.pluginEnvironments);\n        const getPluginProcessor = Map.prototype.get.bind(configArray.pluginProcessors);\n        const getPluginRule = Map.prototype.get.bind(configArray.pluginRules);\n\n        // Validate.\n        for (const element of configArray) {\n            if (validated.has(element)) {\n                continue;\n            }\n            validated.add(element);\n\n            this.validateEnvironment(element.env, element.name, getPluginEnv);\n            this.validateGlobals(element.globals, element.name);\n            this.validateProcessor(element.processor, element.name, getPluginProcessor);\n            this.validateRules(element.rules, element.name, getPluginRule);\n        }\n    }\n\n};\n\n\n//# sourceURL=webpack://javascript/./node_modules/@eslint/eslintrc/lib/shared/config-validator.js?");

/***/ }),

/***/ "./node_modules/@eslint/eslintrc/lib/shared/deprecation-warnings.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@eslint/eslintrc/lib/shared/deprecation-warnings.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* provided dependency */ var process = __webpack_require__(/*! ./node_modules/process/browser.js */ \"./node_modules/process/browser.js\");\n/**\n * @fileoverview Provide the function that emits deprecation warnings.\n * @author Toru Nagashima <http://github.com/mysticatea>\n */\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst path = __webpack_require__(/*! path */ \"./node_modules/path-browserify/index.js\");\n\n//------------------------------------------------------------------------------\n// Private\n//------------------------------------------------------------------------------\n\n// Defitions for deprecation warnings.\nconst deprecationWarningMessages = {\n    ESLINT_LEGACY_ECMAFEATURES:\n        \"The 'ecmaFeatures' config file property is deprecated and has no effect.\",\n    ESLINT_PERSONAL_CONFIG_LOAD:\n        \"'~/.eslintrc.*' config files have been deprecated. \" +\n        \"Please use a config file per project or the '--config' option.\",\n    ESLINT_PERSONAL_CONFIG_SUPPRESS:\n        \"'~/.eslintrc.*' config files have been deprecated. \" +\n        \"Please remove it or add 'root:true' to the config files in your \" +\n        \"projects in order to avoid loading '~/.eslintrc.*' accidentally.\"\n};\n\nconst sourceFileErrorCache = new Set();\n\n/**\n * Emits a deprecation warning containing a given filepath. A new deprecation warning is emitted\n * for each unique file path, but repeated invocations with the same file path have no effect.\n * No warnings are emitted if the `--no-deprecation` or `--no-warnings` Node runtime flags are active.\n * @param {string} source The name of the configuration source to report the warning for.\n * @param {string} errorCode The warning message to show.\n * @returns {void}\n */\nfunction emitDeprecationWarning(source, errorCode) {\n    const cacheKey = JSON.stringify({ source, errorCode });\n\n    if (sourceFileErrorCache.has(cacheKey)) {\n        return;\n    }\n    sourceFileErrorCache.add(cacheKey);\n\n    const rel = path.relative(process.cwd(), source);\n    const message = deprecationWarningMessages[errorCode];\n\n    process.emitWarning(\n        `${message} (found in \"${rel}\")`,\n        \"DeprecationWarning\",\n        errorCode\n    );\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    emitDeprecationWarning\n};\n\n\n//# sourceURL=webpack://javascript/./node_modules/@eslint/eslintrc/lib/shared/deprecation-warnings.js?");

/***/ }),

/***/ "./node_modules/acorn-jsx/index.js":
/*!*****************************************!*\
  !*** ./node_modules/acorn-jsx/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst XHTMLEntities = __webpack_require__(/*! ./xhtml */ \"./node_modules/acorn-jsx/xhtml.js\");\n\nconst hexNumber = /^[\\da-fA-F]+$/;\nconst decimalNumber = /^\\d+$/;\n\n// The map to `acorn-jsx` tokens from `acorn` namespace objects.\nconst acornJsxMap = new WeakMap();\n\n// Get the original tokens for the given `acorn` namespace object.\nfunction getJsxTokens(acorn) {\n  acorn = acorn.Parser.acorn || acorn;\n  let acornJsx = acornJsxMap.get(acorn);\n  if (!acornJsx) {\n    const tt = acorn.tokTypes;\n    const TokContext = acorn.TokContext;\n    const TokenType = acorn.TokenType;\n    const tc_oTag = new TokContext('<tag', false);\n    const tc_cTag = new TokContext('</tag', false);\n    const tc_expr = new TokContext('<tag>...</tag>', true, true);\n    const tokContexts = {\n      tc_oTag: tc_oTag,\n      tc_cTag: tc_cTag,\n      tc_expr: tc_expr\n    };\n    const tokTypes = {\n      jsxName: new TokenType('jsxName'),\n      jsxText: new TokenType('jsxText', {beforeExpr: true}),\n      jsxTagStart: new TokenType('jsxTagStart', {startsExpr: true}),\n      jsxTagEnd: new TokenType('jsxTagEnd')\n    };\n\n    tokTypes.jsxTagStart.updateContext = function() {\n      this.context.push(tc_expr); // treat as beginning of JSX expression\n      this.context.push(tc_oTag); // start opening tag context\n      this.exprAllowed = false;\n    };\n    tokTypes.jsxTagEnd.updateContext = function(prevType) {\n      let out = this.context.pop();\n      if (out === tc_oTag && prevType === tt.slash || out === tc_cTag) {\n        this.context.pop();\n        this.exprAllowed = this.curContext() === tc_expr;\n      } else {\n        this.exprAllowed = true;\n      }\n    };\n\n    acornJsx = { tokContexts: tokContexts, tokTypes: tokTypes };\n    acornJsxMap.set(acorn, acornJsx);\n  }\n\n  return acornJsx;\n}\n\n// Transforms JSX element name to string.\n\nfunction getQualifiedJSXName(object) {\n  if (!object)\n    return object;\n\n  if (object.type === 'JSXIdentifier')\n    return object.name;\n\n  if (object.type === 'JSXNamespacedName')\n    return object.namespace.name + ':' + object.name.name;\n\n  if (object.type === 'JSXMemberExpression')\n    return getQualifiedJSXName(object.object) + '.' +\n    getQualifiedJSXName(object.property);\n}\n\nmodule.exports = function(options) {\n  options = options || {};\n  return function(Parser) {\n    return plugin({\n      allowNamespaces: options.allowNamespaces !== false,\n      allowNamespacedObjects: !!options.allowNamespacedObjects\n    }, Parser);\n  };\n};\n\n// This is `tokTypes` of the peer dep.\n// This can be different instances from the actual `tokTypes` this plugin uses.\nObject.defineProperty(module.exports, \"tokTypes\", ({\n  get: function get_tokTypes() {\n    return getJsxTokens(__webpack_require__(/*! acorn */ \"./node_modules/acorn/dist/acorn.js\")).tokTypes;\n  },\n  configurable: true,\n  enumerable: true\n}));\n\nfunction plugin(options, Parser) {\n  const acorn = Parser.acorn || __webpack_require__(/*! acorn */ \"./node_modules/acorn/dist/acorn.js\");\n  const acornJsx = getJsxTokens(acorn);\n  const tt = acorn.tokTypes;\n  const tok = acornJsx.tokTypes;\n  const tokContexts = acorn.tokContexts;\n  const tc_oTag = acornJsx.tokContexts.tc_oTag;\n  const tc_cTag = acornJsx.tokContexts.tc_cTag;\n  const tc_expr = acornJsx.tokContexts.tc_expr;\n  const isNewLine = acorn.isNewLine;\n  const isIdentifierStart = acorn.isIdentifierStart;\n  const isIdentifierChar = acorn.isIdentifierChar;\n\n  return class extends Parser {\n    // Expose actual `tokTypes` and `tokContexts` to other plugins.\n    static get acornJsx() {\n      return acornJsx;\n    }\n\n    // Reads inline JSX contents token.\n    jsx_readToken() {\n      let out = '', chunkStart = this.pos;\n      for (;;) {\n        if (this.pos >= this.input.length)\n          this.raise(this.start, 'Unterminated JSX contents');\n        let ch = this.input.charCodeAt(this.pos);\n\n        switch (ch) {\n        case 60: // '<'\n        case 123: // '{'\n          if (this.pos === this.start) {\n            if (ch === 60 && this.exprAllowed) {\n              ++this.pos;\n              return this.finishToken(tok.jsxTagStart);\n            }\n            return this.getTokenFromCode(ch);\n          }\n          out += this.input.slice(chunkStart, this.pos);\n          return this.finishToken(tok.jsxText, out);\n\n        case 38: // '&'\n          out += this.input.slice(chunkStart, this.pos);\n          out += this.jsx_readEntity();\n          chunkStart = this.pos;\n          break;\n\n        case 62: // '>'\n        case 125: // '}'\n          this.raise(\n            this.pos,\n            \"Unexpected token `\" + this.input[this.pos] + \"`. Did you mean `\" +\n              (ch === 62 ? \"&gt;\" : \"&rbrace;\") + \"` or \" + \"`{\\\"\" + this.input[this.pos] + \"\\\"}\" + \"`?\"\n          );\n\n        default:\n          if (isNewLine(ch)) {\n            out += this.input.slice(chunkStart, this.pos);\n            out += this.jsx_readNewLine(true);\n            chunkStart = this.pos;\n          } else {\n            ++this.pos;\n          }\n        }\n      }\n    }\n\n    jsx_readNewLine(normalizeCRLF) {\n      let ch = this.input.charCodeAt(this.pos);\n      let out;\n      ++this.pos;\n      if (ch === 13 && this.input.charCodeAt(this.pos) === 10) {\n        ++this.pos;\n        out = normalizeCRLF ? '\\n' : '\\r\\n';\n      } else {\n        out = String.fromCharCode(ch);\n      }\n      if (this.options.locations) {\n        ++this.curLine;\n        this.lineStart = this.pos;\n      }\n\n      return out;\n    }\n\n    jsx_readString(quote) {\n      let out = '', chunkStart = ++this.pos;\n      for (;;) {\n        if (this.pos >= this.input.length)\n          this.raise(this.start, 'Unterminated string constant');\n        let ch = this.input.charCodeAt(this.pos);\n        if (ch === quote) break;\n        if (ch === 38) { // '&'\n          out += this.input.slice(chunkStart, this.pos);\n          out += this.jsx_readEntity();\n          chunkStart = this.pos;\n        } else if (isNewLine(ch)) {\n          out += this.input.slice(chunkStart, this.pos);\n          out += this.jsx_readNewLine(false);\n          chunkStart = this.pos;\n        } else {\n          ++this.pos;\n        }\n      }\n      out += this.input.slice(chunkStart, this.pos++);\n      return this.finishToken(tt.string, out);\n    }\n\n    jsx_readEntity() {\n      let str = '', count = 0, entity;\n      let ch = this.input[this.pos];\n      if (ch !== '&')\n        this.raise(this.pos, 'Entity must start with an ampersand');\n      let startPos = ++this.pos;\n      while (this.pos < this.input.length && count++ < 10) {\n        ch = this.input[this.pos++];\n        if (ch === ';') {\n          if (str[0] === '#') {\n            if (str[1] === 'x') {\n              str = str.substr(2);\n              if (hexNumber.test(str))\n                entity = String.fromCharCode(parseInt(str, 16));\n            } else {\n              str = str.substr(1);\n              if (decimalNumber.test(str))\n                entity = String.fromCharCode(parseInt(str, 10));\n            }\n          } else {\n            entity = XHTMLEntities[str];\n          }\n          break;\n        }\n        str += ch;\n      }\n      if (!entity) {\n        this.pos = startPos;\n        return '&';\n      }\n      return entity;\n    }\n\n    // Read a JSX identifier (valid tag or attribute name).\n    //\n    // Optimized version since JSX identifiers can't contain\n    // escape characters and so can be read as single slice.\n    // Also assumes that first character was already checked\n    // by isIdentifierStart in readToken.\n\n    jsx_readWord() {\n      let ch, start = this.pos;\n      do {\n        ch = this.input.charCodeAt(++this.pos);\n      } while (isIdentifierChar(ch) || ch === 45); // '-'\n      return this.finishToken(tok.jsxName, this.input.slice(start, this.pos));\n    }\n\n    // Parse next token as JSX identifier\n\n    jsx_parseIdentifier() {\n      let node = this.startNode();\n      if (this.type === tok.jsxName)\n        node.name = this.value;\n      else if (this.type.keyword)\n        node.name = this.type.keyword;\n      else\n        this.unexpected();\n      this.next();\n      return this.finishNode(node, 'JSXIdentifier');\n    }\n\n    // Parse namespaced identifier.\n\n    jsx_parseNamespacedName() {\n      let startPos = this.start, startLoc = this.startLoc;\n      let name = this.jsx_parseIdentifier();\n      if (!options.allowNamespaces || !this.eat(tt.colon)) return name;\n      var node = this.startNodeAt(startPos, startLoc);\n      node.namespace = name;\n      node.name = this.jsx_parseIdentifier();\n      return this.finishNode(node, 'JSXNamespacedName');\n    }\n\n    // Parses element name in any form - namespaced, member\n    // or single identifier.\n\n    jsx_parseElementName() {\n      if (this.type === tok.jsxTagEnd) return '';\n      let startPos = this.start, startLoc = this.startLoc;\n      let node = this.jsx_parseNamespacedName();\n      if (this.type === tt.dot && node.type === 'JSXNamespacedName' && !options.allowNamespacedObjects) {\n        this.unexpected();\n      }\n      while (this.eat(tt.dot)) {\n        let newNode = this.startNodeAt(startPos, startLoc);\n        newNode.object = node;\n        newNode.property = this.jsx_parseIdentifier();\n        node = this.finishNode(newNode, 'JSXMemberExpression');\n      }\n      return node;\n    }\n\n    // Parses any type of JSX attribute value.\n\n    jsx_parseAttributeValue() {\n      switch (this.type) {\n      case tt.braceL:\n        let node = this.jsx_parseExpressionContainer();\n        if (node.expression.type === 'JSXEmptyExpression')\n          this.raise(node.start, 'JSX attributes must only be assigned a non-empty expression');\n        return node;\n\n      case tok.jsxTagStart:\n      case tt.string:\n        return this.parseExprAtom();\n\n      default:\n        this.raise(this.start, 'JSX value should be either an expression or a quoted JSX text');\n      }\n    }\n\n    // JSXEmptyExpression is unique type since it doesn't actually parse anything,\n    // and so it should start at the end of last read token (left brace) and finish\n    // at the beginning of the next one (right brace).\n\n    jsx_parseEmptyExpression() {\n      let node = this.startNodeAt(this.lastTokEnd, this.lastTokEndLoc);\n      return this.finishNodeAt(node, 'JSXEmptyExpression', this.start, this.startLoc);\n    }\n\n    // Parses JSX expression enclosed into curly brackets.\n\n    jsx_parseExpressionContainer() {\n      let node = this.startNode();\n      this.next();\n      node.expression = this.type === tt.braceR\n        ? this.jsx_parseEmptyExpression()\n        : this.parseExpression();\n      this.expect(tt.braceR);\n      return this.finishNode(node, 'JSXExpressionContainer');\n    }\n\n    // Parses following JSX attribute name-value pair.\n\n    jsx_parseAttribute() {\n      let node = this.startNode();\n      if (this.eat(tt.braceL)) {\n        this.expect(tt.ellipsis);\n        node.argument = this.parseMaybeAssign();\n        this.expect(tt.braceR);\n        return this.finishNode(node, 'JSXSpreadAttribute');\n      }\n      node.name = this.jsx_parseNamespacedName();\n      node.value = this.eat(tt.eq) ? this.jsx_parseAttributeValue() : null;\n      return this.finishNode(node, 'JSXAttribute');\n    }\n\n    // Parses JSX opening tag starting after '<'.\n\n    jsx_parseOpeningElementAt(startPos, startLoc) {\n      let node = this.startNodeAt(startPos, startLoc);\n      node.attributes = [];\n      let nodeName = this.jsx_parseElementName();\n      if (nodeName) node.name = nodeName;\n      while (this.type !== tt.slash && this.type !== tok.jsxTagEnd)\n        node.attributes.push(this.jsx_parseAttribute());\n      node.selfClosing = this.eat(tt.slash);\n      this.expect(tok.jsxTagEnd);\n      return this.finishNode(node, nodeName ? 'JSXOpeningElement' : 'JSXOpeningFragment');\n    }\n\n    // Parses JSX closing tag starting after '</'.\n\n    jsx_parseClosingElementAt(startPos, startLoc) {\n      let node = this.startNodeAt(startPos, startLoc);\n      let nodeName = this.jsx_parseElementName();\n      if (nodeName) node.name = nodeName;\n      this.expect(tok.jsxTagEnd);\n      return this.finishNode(node, nodeName ? 'JSXClosingElement' : 'JSXClosingFragment');\n    }\n\n    // Parses entire JSX element, including it's opening tag\n    // (starting after '<'), attributes, contents and closing tag.\n\n    jsx_parseElementAt(startPos, startLoc) {\n      let node = this.startNodeAt(startPos, startLoc);\n      let children = [];\n      let openingElement = this.jsx_parseOpeningElementAt(startPos, startLoc);\n      let closingElement = null;\n\n      if (!openingElement.selfClosing) {\n        contents: for (;;) {\n          switch (this.type) {\n          case tok.jsxTagStart:\n            startPos = this.start; startLoc = this.startLoc;\n            this.next();\n            if (this.eat(tt.slash)) {\n              closingElement = this.jsx_parseClosingElementAt(startPos, startLoc);\n              break contents;\n            }\n            children.push(this.jsx_parseElementAt(startPos, startLoc));\n            break;\n\n          case tok.jsxText:\n            children.push(this.parseExprAtom());\n            break;\n\n          case tt.braceL:\n            children.push(this.jsx_parseExpressionContainer());\n            break;\n\n          default:\n            this.unexpected();\n          }\n        }\n        if (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) {\n          this.raise(\n            closingElement.start,\n            'Expected corresponding JSX closing tag for <' + getQualifiedJSXName(openingElement.name) + '>');\n        }\n      }\n      let fragmentOrElement = openingElement.name ? 'Element' : 'Fragment';\n\n      node['opening' + fragmentOrElement] = openingElement;\n      node['closing' + fragmentOrElement] = closingElement;\n      node.children = children;\n      if (this.type === tt.relational && this.value === \"<\") {\n        this.raise(this.start, \"Adjacent JSX elements must be wrapped in an enclosing tag\");\n      }\n      return this.finishNode(node, 'JSX' + fragmentOrElement);\n    }\n\n    // Parse JSX text\n\n    jsx_parseText() {\n      let node = this.parseLiteral(this.value);\n      node.type = \"JSXText\";\n      return node;\n    }\n\n    // Parses entire JSX element from current position.\n\n    jsx_parseElement() {\n      let startPos = this.start, startLoc = this.startLoc;\n      this.next();\n      return this.jsx_parseElementAt(startPos, startLoc);\n    }\n\n    parseExprAtom(refShortHandDefaultPos) {\n      if (this.type === tok.jsxText)\n        return this.jsx_parseText();\n      else if (this.type === tok.jsxTagStart)\n        return this.jsx_parseElement();\n      else\n        return super.parseExprAtom(refShortHandDefaultPos);\n    }\n\n    readToken(code) {\n      let context = this.curContext();\n\n      if (context === tc_expr) return this.jsx_readToken();\n\n      if (context === tc_oTag || context === tc_cTag) {\n        if (isIdentifierStart(code)) return this.jsx_readWord();\n\n        if (code == 62) {\n          ++this.pos;\n          return this.finishToken(tok.jsxTagEnd);\n        }\n\n        if ((code === 34 || code === 39) && context == tc_oTag)\n          return this.jsx_readString(code);\n      }\n\n      if (code === 60 && this.exprAllowed && this.input.charCodeAt(this.pos + 1) !== 33) {\n        ++this.pos;\n        return this.finishToken(tok.jsxTagStart);\n      }\n      return super.readToken(code);\n    }\n\n    updateContext(prevType) {\n      if (this.type == tt.braceL) {\n        var curContext = this.curContext();\n        if (curContext == tc_oTag) this.context.push(tokContexts.b_expr);\n        else if (curContext == tc_expr) this.context.push(tokContexts.b_tmpl);\n        else super.updateContext(prevType);\n        this.exprAllowed = true;\n      } else if (this.type === tt.slash && prevType === tok.jsxTagStart) {\n        this.context.length -= 2; // do not consider JSX expr -> JSX open tag -> ... anymore\n        this.context.push(tc_cTag); // reconsider as closing tag context\n        this.exprAllowed = false;\n      } else {\n        return super.updateContext(prevType);\n      }\n    }\n  };\n}\n\n\n//# sourceURL=webpack://javascript/./node_modules/acorn-jsx/index.js?");

/***/ }),

/***/ "./node_modules/acorn-jsx/xhtml.js":
/*!*****************************************!*\
  !*** ./node_modules/acorn-jsx/xhtml.js ***!
  \*****************************************/
/***/ ((module) => {

eval("module.exports = {\n  quot: '\\u0022',\n  amp: '&',\n  apos: '\\u0027',\n  lt: '<',\n  gt: '>',\n  nbsp: '\\u00A0',\n  iexcl: '\\u00A1',\n  cent: '\\u00A2',\n  pound: '\\u00A3',\n  curren: '\\u00A4',\n  yen: '\\u00A5',\n  brvbar: '\\u00A6',\n  sect: '\\u00A7',\n  uml: '\\u00A8',\n  copy: '\\u00A9',\n  ordf: '\\u00AA',\n  laquo: '\\u00AB',\n  not: '\\u00AC',\n  shy: '\\u00AD',\n  reg: '\\u00AE',\n  macr: '\\u00AF',\n  deg: '\\u00B0',\n  plusmn: '\\u00B1',\n  sup2: '\\u00B2',\n  sup3: '\\u00B3',\n  acute: '\\u00B4',\n  micro: '\\u00B5',\n  para: '\\u00B6',\n  middot: '\\u00B7',\n  cedil: '\\u00B8',\n  sup1: '\\u00B9',\n  ordm: '\\u00BA',\n  raquo: '\\u00BB',\n  frac14: '\\u00BC',\n  frac12: '\\u00BD',\n  frac34: '\\u00BE',\n  iquest: '\\u00BF',\n  Agrave: '\\u00C0',\n  Aacute: '\\u00C1',\n  Acirc: '\\u00C2',\n  Atilde: '\\u00C3',\n  Auml: '\\u00C4',\n  Aring: '\\u00C5',\n  AElig: '\\u00C6',\n  Ccedil: '\\u00C7',\n  Egrave: '\\u00C8',\n  Eacute: '\\u00C9',\n  Ecirc: '\\u00CA',\n  Euml: '\\u00CB',\n  Igrave: '\\u00CC',\n  Iacute: '\\u00CD',\n  Icirc: '\\u00CE',\n  Iuml: '\\u00CF',\n  ETH: '\\u00D0',\n  Ntilde: '\\u00D1',\n  Ograve: '\\u00D2',\n  Oacute: '\\u00D3',\n  Ocirc: '\\u00D4',\n  Otilde: '\\u00D5',\n  Ouml: '\\u00D6',\n  times: '\\u00D7',\n  Oslash: '\\u00D8',\n  Ugrave: '\\u00D9',\n  Uacute: '\\u00DA',\n  Ucirc: '\\u00DB',\n  Uuml: '\\u00DC',\n  Yacute: '\\u00DD',\n  THORN: '\\u00DE',\n  szlig: '\\u00DF',\n  agrave: '\\u00E0',\n  aacute: '\\u00E1',\n  acirc: '\\u00E2',\n  atilde: '\\u00E3',\n  auml: '\\u00E4',\n  aring: '\\u00E5',\n  aelig: '\\u00E6',\n  ccedil: '\\u00E7',\n  egrave: '\\u00E8',\n  eacute: '\\u00E9',\n  ecirc: '\\u00EA',\n  euml: '\\u00EB',\n  igrave: '\\u00EC',\n  iacute: '\\u00ED',\n  icirc: '\\u00EE',\n  iuml: '\\u00EF',\n  eth: '\\u00F0',\n  ntilde: '\\u00F1',\n  ograve: '\\u00F2',\n  oacute: '\\u00F3',\n  ocirc: '\\u00F4',\n  otilde: '\\u00F5',\n  ouml: '\\u00F6',\n  divide: '\\u00F7',\n  oslash: '\\u00F8',\n  ugrave: '\\u00F9',\n  uacute: '\\u00FA',\n  ucirc: '\\u00FB',\n  uuml: '\\u00FC',\n  yacute: '\\u00FD',\n  thorn: '\\u00FE',\n  yuml: '\\u00FF',\n  OElig: '\\u0152',\n  oelig: '\\u0153',\n  Scaron: '\\u0160',\n  scaron: '\\u0161',\n  Yuml: '\\u0178',\n  fnof: '\\u0192',\n  circ: '\\u02C6',\n  tilde: '\\u02DC',\n  Alpha: '\\u0391',\n  Beta: '\\u0392',\n  Gamma: '\\u0393',\n  Delta: '\\u0394',\n  Epsilon: '\\u0395',\n  Zeta: '\\u0396',\n  Eta: '\\u0397',\n  Theta: '\\u0398',\n  Iota: '\\u0399',\n  Kappa: '\\u039A',\n  Lambda: '\\u039B',\n  Mu: '\\u039C',\n  Nu: '\\u039D',\n  Xi: '\\u039E',\n  Omicron: '\\u039F',\n  Pi: '\\u03A0',\n  Rho: '\\u03A1',\n  Sigma: '\\u03A3',\n  Tau: '\\u03A4',\n  Upsilon: '\\u03A5',\n  Phi: '\\u03A6',\n  Chi: '\\u03A7',\n  Psi: '\\u03A8',\n  Omega: '\\u03A9',\n  alpha: '\\u03B1',\n  beta: '\\u03B2',\n  gamma: '\\u03B3',\n  delta: '\\u03B4',\n  epsilon: '\\u03B5',\n  zeta: '\\u03B6',\n  eta: '\\u03B7',\n  theta: '\\u03B8',\n  iota: '\\u03B9',\n  kappa: '\\u03BA',\n  lambda: '\\u03BB',\n  mu: '\\u03BC',\n  nu: '\\u03BD',\n  xi: '\\u03BE',\n  omicron: '\\u03BF',\n  pi: '\\u03C0',\n  rho: '\\u03C1',\n  sigmaf: '\\u03C2',\n  sigma: '\\u03C3',\n  tau: '\\u03C4',\n  upsilon: '\\u03C5',\n  phi: '\\u03C6',\n  chi: '\\u03C7',\n  psi: '\\u03C8',\n  omega: '\\u03C9',\n  thetasym: '\\u03D1',\n  upsih: '\\u03D2',\n  piv: '\\u03D6',\n  ensp: '\\u2002',\n  emsp: '\\u2003',\n  thinsp: '\\u2009',\n  zwnj: '\\u200C',\n  zwj: '\\u200D',\n  lrm: '\\u200E',\n  rlm: '\\u200F',\n  ndash: '\\u2013',\n  mdash: '\\u2014',\n  lsquo: '\\u2018',\n  rsquo: '\\u2019',\n  sbquo: '\\u201A',\n  ldquo: '\\u201C',\n  rdquo: '\\u201D',\n  bdquo: '\\u201E',\n  dagger: '\\u2020',\n  Dagger: '\\u2021',\n  bull: '\\u2022',\n  hellip: '\\u2026',\n  permil: '\\u2030',\n  prime: '\\u2032',\n  Prime: '\\u2033',\n  lsaquo: '\\u2039',\n  rsaquo: '\\u203A',\n  oline: '\\u203E',\n  frasl: '\\u2044',\n  euro: '\\u20AC',\n  image: '\\u2111',\n  weierp: '\\u2118',\n  real: '\\u211C',\n  trade: '\\u2122',\n  alefsym: '\\u2135',\n  larr: '\\u2190',\n  uarr: '\\u2191',\n  rarr: '\\u2192',\n  darr: '\\u2193',\n  harr: '\\u2194',\n  crarr: '\\u21B5',\n  lArr: '\\u21D0',\n  uArr: '\\u21D1',\n  rArr: '\\u21D2',\n  dArr: '\\u21D3',\n  hArr: '\\u21D4',\n  forall: '\\u2200',\n  part: '\\u2202',\n  exist: '\\u2203',\n  empty: '\\u2205',\n  nabla: '\\u2207',\n  isin: '\\u2208',\n  notin: '\\u2209',\n  ni: '\\u220B',\n  prod: '\\u220F',\n  sum: '\\u2211',\n  minus: '\\u2212',\n  lowast: '\\u2217',\n  radic: '\\u221A',\n  prop: '\\u221D',\n  infin: '\\u221E',\n  ang: '\\u2220',\n  and: '\\u2227',\n  or: '\\u2228',\n  cap: '\\u2229',\n  cup: '\\u222A',\n  'int': '\\u222B',\n  there4: '\\u2234',\n  sim: '\\u223C',\n  cong: '\\u2245',\n  asymp: '\\u2248',\n  ne: '\\u2260',\n  equiv: '\\u2261',\n  le: '\\u2264',\n  ge: '\\u2265',\n  sub: '\\u2282',\n  sup: '\\u2283',\n  nsub: '\\u2284',\n  sube: '\\u2286',\n  supe: '\\u2287',\n  oplus: '\\u2295',\n  otimes: '\\u2297',\n  perp: '\\u22A5',\n  sdot: '\\u22C5',\n  lceil: '\\u2308',\n  rceil: '\\u2309',\n  lfloor: '\\u230A',\n  rfloor: '\\u230B',\n  lang: '\\u2329',\n  rang: '\\u232A',\n  loz: '\\u25CA',\n  spades: '\\u2660',\n  clubs: '\\u2663',\n  hearts: '\\u2665',\n  diams: '\\u2666'\n};\n\n\n//# sourceURL=webpack://javascript/./node_modules/acorn-jsx/xhtml.js?");

/***/ }),

/***/ "./node_modules/acorn/dist/acorn.js":
/*!******************************************!*\
  !*** ./node_modules/acorn/dist/acorn.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("/* provided dependency */ var console = __webpack_require__(/*! ./node_modules/console-browserify/index.js */ \"./node_modules/console-browserify/index.js\");\n(function (global, factory) {\n   true ? factory(exports) :\n  0;\n})(this, (function (exports) { 'use strict';\n\n  // This file was generated. Do not modify manually!\n  var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 154, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 19306, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 262, 6, 10, 9, 357, 0, 62, 13, 1495, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];\n\n  // This file was generated. Do not modify manually!\n  var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 190, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1070, 4050, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 46, 2, 18, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 482, 44, 11, 6, 17, 0, 322, 29, 19, 43, 1269, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4152, 8, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938];\n\n  // This file was generated. Do not modify manually!\n  var nonASCIIidentifierChars = \"\\u200c\\u200d\\xb7\\u0300-\\u036f\\u0387\\u0483-\\u0487\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u0669\\u0670\\u06d6-\\u06dc\\u06df-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u06f0-\\u06f9\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07c0-\\u07c9\\u07eb-\\u07f3\\u07fd\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0859-\\u085b\\u0898-\\u089f\\u08ca-\\u08e1\\u08e3-\\u0903\\u093a-\\u093c\\u093e-\\u094f\\u0951-\\u0957\\u0962\\u0963\\u0966-\\u096f\\u0981-\\u0983\\u09bc\\u09be-\\u09c4\\u09c7\\u09c8\\u09cb-\\u09cd\\u09d7\\u09e2\\u09e3\\u09e6-\\u09ef\\u09fe\\u0a01-\\u0a03\\u0a3c\\u0a3e-\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a66-\\u0a71\\u0a75\\u0a81-\\u0a83\\u0abc\\u0abe-\\u0ac5\\u0ac7-\\u0ac9\\u0acb-\\u0acd\\u0ae2\\u0ae3\\u0ae6-\\u0aef\\u0afa-\\u0aff\\u0b01-\\u0b03\\u0b3c\\u0b3e-\\u0b44\\u0b47\\u0b48\\u0b4b-\\u0b4d\\u0b55-\\u0b57\\u0b62\\u0b63\\u0b66-\\u0b6f\\u0b82\\u0bbe-\\u0bc2\\u0bc6-\\u0bc8\\u0bca-\\u0bcd\\u0bd7\\u0be6-\\u0bef\\u0c00-\\u0c04\\u0c3c\\u0c3e-\\u0c44\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0c66-\\u0c6f\\u0c81-\\u0c83\\u0cbc\\u0cbe-\\u0cc4\\u0cc6-\\u0cc8\\u0cca-\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0ce6-\\u0cef\\u0d00-\\u0d03\\u0d3b\\u0d3c\\u0d3e-\\u0d44\\u0d46-\\u0d48\\u0d4a-\\u0d4d\\u0d57\\u0d62\\u0d63\\u0d66-\\u0d6f\\u0d81-\\u0d83\\u0dca\\u0dcf-\\u0dd4\\u0dd6\\u0dd8-\\u0ddf\\u0de6-\\u0def\\u0df2\\u0df3\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0e50-\\u0e59\\u0eb1\\u0eb4-\\u0ebc\\u0ec8-\\u0ecd\\u0ed0-\\u0ed9\\u0f18\\u0f19\\u0f20-\\u0f29\\u0f35\\u0f37\\u0f39\\u0f3e\\u0f3f\\u0f71-\\u0f84\\u0f86\\u0f87\\u0f8d-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102b-\\u103e\\u1040-\\u1049\\u1056-\\u1059\\u105e-\\u1060\\u1062-\\u1064\\u1067-\\u106d\\u1071-\\u1074\\u1082-\\u108d\\u108f-\\u109d\\u135d-\\u135f\\u1369-\\u1371\\u1712-\\u1715\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b4-\\u17d3\\u17dd\\u17e0-\\u17e9\\u180b-\\u180d\\u180f-\\u1819\\u18a9\\u1920-\\u192b\\u1930-\\u193b\\u1946-\\u194f\\u19d0-\\u19da\\u1a17-\\u1a1b\\u1a55-\\u1a5e\\u1a60-\\u1a7c\\u1a7f-\\u1a89\\u1a90-\\u1a99\\u1ab0-\\u1abd\\u1abf-\\u1ace\\u1b00-\\u1b04\\u1b34-\\u1b44\\u1b50-\\u1b59\\u1b6b-\\u1b73\\u1b80-\\u1b82\\u1ba1-\\u1bad\\u1bb0-\\u1bb9\\u1be6-\\u1bf3\\u1c24-\\u1c37\\u1c40-\\u1c49\\u1c50-\\u1c59\\u1cd0-\\u1cd2\\u1cd4-\\u1ce8\\u1ced\\u1cf4\\u1cf7-\\u1cf9\\u1dc0-\\u1dff\\u203f\\u2040\\u2054\\u20d0-\\u20dc\\u20e1\\u20e5-\\u20f0\\u2cef-\\u2cf1\\u2d7f\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\ua620-\\ua629\\ua66f\\ua674-\\ua67d\\ua69e\\ua69f\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua823-\\ua827\\ua82c\\ua880\\ua881\\ua8b4-\\ua8c5\\ua8d0-\\ua8d9\\ua8e0-\\ua8f1\\ua8ff-\\ua909\\ua926-\\ua92d\\ua947-\\ua953\\ua980-\\ua983\\ua9b3-\\ua9c0\\ua9d0-\\ua9d9\\ua9e5\\ua9f0-\\ua9f9\\uaa29-\\uaa36\\uaa43\\uaa4c\\uaa4d\\uaa50-\\uaa59\\uaa7b-\\uaa7d\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uaaeb-\\uaaef\\uaaf5\\uaaf6\\uabe3-\\uabea\\uabec\\uabed\\uabf0-\\uabf9\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe2f\\ufe33\\ufe34\\ufe4d-\\ufe4f\\uff10-\\uff19\\uff3f\";\n\n  // This file was generated. Do not modify manually!\n  var nonASCIIidentifierStartChars = \"\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u037f\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u052f\\u0531-\\u0556\\u0559\\u0560-\\u0588\\u05d0-\\u05ea\\u05ef-\\u05f2\\u0620-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06e5\\u06e6\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u0860-\\u086a\\u0870-\\u0887\\u0889-\\u088e\\u08a0-\\u08c9\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc\\u09dd\\u09df-\\u09e1\\u09f0\\u09f1\\u09fc\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0\\u0ae1\\u0af9\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c39\\u0c3d\\u0c58-\\u0c5a\\u0c5d\\u0c60\\u0c61\\u0c80\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cdd\\u0cde\\u0ce0\\u0ce1\\u0cf1\\u0cf2\\u0d04-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d54-\\u0d56\\u0d5f-\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32\\u0e33\\u0e40-\\u0e46\\u0e81\\u0e82\\u0e84\\u0e86-\\u0e8a\\u0e8c-\\u0ea3\\u0ea5\\u0ea7-\\u0eb0\\u0eb2\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f5\\u13f8-\\u13fd\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f8\\u1700-\\u1711\\u171f-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1878\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191e\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19b0-\\u19c9\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4c\\u1b83-\\u1ba0\\u1bae\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1c80-\\u1c88\\u1c90-\\u1cba\\u1cbd-\\u1cbf\\u1ce9-\\u1cec\\u1cee-\\u1cf3\\u1cf5\\u1cf6\\u1cfa\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2118-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2ce4\\u2ceb-\\u2cee\\u2cf2\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309b-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312f\\u3131-\\u318e\\u31a0-\\u31bf\\u31f0-\\u31ff\\u3400-\\u4dbf\\u4e00-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a\\ua62b\\ua640-\\ua66e\\ua67f-\\ua69d\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua7ca\\ua7d0\\ua7d1\\ua7d3\\ua7d5-\\ua7d9\\ua7f2-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua8fd\\ua8fe\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\ua9e0-\\ua9e4\\ua9e6-\\ua9ef\\ua9fa-\\ua9fe\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa7e-\\uaaaf\\uaab1\\uaab5\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uab30-\\uab5a\\uab5c-\\uab69\\uab70-\\uabe2\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc\";\n\n  // These are a run-length and offset encoded representation of the\n\n  // Reserved word lists for various dialects of the language\n\n  var reservedWords = {\n    3: \"abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile\",\n    5: \"class enum extends super const export import\",\n    6: \"enum\",\n    strict: \"implements interface let package private protected public static yield\",\n    strictBind: \"eval arguments\"\n  };\n\n  // And the keywords\n\n  var ecma5AndLessKeywords = \"break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this\";\n\n  var keywords$1 = {\n    5: ecma5AndLessKeywords,\n    \"5module\": ecma5AndLessKeywords + \" export import\",\n    6: ecma5AndLessKeywords + \" const class extends export import super\"\n  };\n\n  var keywordRelationalOperator = /^in(stanceof)?$/;\n\n  // ## Character categories\n\n  var nonASCIIidentifierStart = new RegExp(\"[\" + nonASCIIidentifierStartChars + \"]\");\n  var nonASCIIidentifier = new RegExp(\"[\" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + \"]\");\n\n  // This has a complexity linear to the value of the code. The\n  // assumption is that looking up astral identifier characters is\n  // rare.\n  function isInAstralSet(code, set) {\n    var pos = 0x10000;\n    for (var i = 0; i < set.length; i += 2) {\n      pos += set[i];\n      if (pos > code) { return false }\n      pos += set[i + 1];\n      if (pos >= code) { return true }\n    }\n  }\n\n  // Test whether a given character code starts an identifier.\n\n  function isIdentifierStart(code, astral) {\n    if (code < 65) { return code === 36 }\n    if (code < 91) { return true }\n    if (code < 97) { return code === 95 }\n    if (code < 123) { return true }\n    if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code)) }\n    if (astral === false) { return false }\n    return isInAstralSet(code, astralIdentifierStartCodes)\n  }\n\n  // Test whether a given character is part of an identifier.\n\n  function isIdentifierChar(code, astral) {\n    if (code < 48) { return code === 36 }\n    if (code < 58) { return true }\n    if (code < 65) { return false }\n    if (code < 91) { return true }\n    if (code < 97) { return code === 95 }\n    if (code < 123) { return true }\n    if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code)) }\n    if (astral === false) { return false }\n    return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes)\n  }\n\n  // ## Token types\n\n  // The assignment of fine-grained, information-carrying type objects\n  // allows the tokenizer to store the information it has about a\n  // token in a way that is very cheap for the parser to look up.\n\n  // All token type variables start with an underscore, to make them\n  // easy to recognize.\n\n  // The `beforeExpr` property is used to disambiguate between regular\n  // expressions and divisions. It is set on all token types that can\n  // be followed by an expression (thus, a slash after them would be a\n  // regular expression).\n  //\n  // The `startsExpr` property is used to check if the token ends a\n  // `yield` expression. It is set on all token types that either can\n  // directly start an expression (like a quotation mark) or can\n  // continue an expression (like the body of a string).\n  //\n  // `isLoop` marks a keyword as starting a loop, which is important\n  // to know when parsing a label, in order to allow or disallow\n  // continue jumps to that label.\n\n  var TokenType = function TokenType(label, conf) {\n    if ( conf === void 0 ) conf = {};\n\n    this.label = label;\n    this.keyword = conf.keyword;\n    this.beforeExpr = !!conf.beforeExpr;\n    this.startsExpr = !!conf.startsExpr;\n    this.isLoop = !!conf.isLoop;\n    this.isAssign = !!conf.isAssign;\n    this.prefix = !!conf.prefix;\n    this.postfix = !!conf.postfix;\n    this.binop = conf.binop || null;\n    this.updateContext = null;\n  };\n\n  function binop(name, prec) {\n    return new TokenType(name, {beforeExpr: true, binop: prec})\n  }\n  var beforeExpr = {beforeExpr: true}, startsExpr = {startsExpr: true};\n\n  // Map keyword names to token types.\n\n  var keywords = {};\n\n  // Succinct definitions of keyword token types\n  function kw(name, options) {\n    if ( options === void 0 ) options = {};\n\n    options.keyword = name;\n    return keywords[name] = new TokenType(name, options)\n  }\n\n  var types$1 = {\n    num: new TokenType(\"num\", startsExpr),\n    regexp: new TokenType(\"regexp\", startsExpr),\n    string: new TokenType(\"string\", startsExpr),\n    name: new TokenType(\"name\", startsExpr),\n    privateId: new TokenType(\"privateId\", startsExpr),\n    eof: new TokenType(\"eof\"),\n\n    // Punctuation token types.\n    bracketL: new TokenType(\"[\", {beforeExpr: true, startsExpr: true}),\n    bracketR: new TokenType(\"]\"),\n    braceL: new TokenType(\"{\", {beforeExpr: true, startsExpr: true}),\n    braceR: new TokenType(\"}\"),\n    parenL: new TokenType(\"(\", {beforeExpr: true, startsExpr: true}),\n    parenR: new TokenType(\")\"),\n    comma: new TokenType(\",\", beforeExpr),\n    semi: new TokenType(\";\", beforeExpr),\n    colon: new TokenType(\":\", beforeExpr),\n    dot: new TokenType(\".\"),\n    question: new TokenType(\"?\", beforeExpr),\n    questionDot: new TokenType(\"?.\"),\n    arrow: new TokenType(\"=>\", beforeExpr),\n    template: new TokenType(\"template\"),\n    invalidTemplate: new TokenType(\"invalidTemplate\"),\n    ellipsis: new TokenType(\"...\", beforeExpr),\n    backQuote: new TokenType(\"`\", startsExpr),\n    dollarBraceL: new TokenType(\"${\", {beforeExpr: true, startsExpr: true}),\n\n    // Operators. These carry several kinds of properties to help the\n    // parser use them properly (the presence of these properties is\n    // what categorizes them as operators).\n    //\n    // `binop`, when present, specifies that this operator is a binary\n    // operator, and will refer to its precedence.\n    //\n    // `prefix` and `postfix` mark the operator as a prefix or postfix\n    // unary operator.\n    //\n    // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as\n    // binary operators with a very low precedence, that should result\n    // in AssignmentExpression nodes.\n\n    eq: new TokenType(\"=\", {beforeExpr: true, isAssign: true}),\n    assign: new TokenType(\"_=\", {beforeExpr: true, isAssign: true}),\n    incDec: new TokenType(\"++/--\", {prefix: true, postfix: true, startsExpr: true}),\n    prefix: new TokenType(\"!/~\", {beforeExpr: true, prefix: true, startsExpr: true}),\n    logicalOR: binop(\"||\", 1),\n    logicalAND: binop(\"&&\", 2),\n    bitwiseOR: binop(\"|\", 3),\n    bitwiseXOR: binop(\"^\", 4),\n    bitwiseAND: binop(\"&\", 5),\n    equality: binop(\"==/!=/===/!==\", 6),\n    relational: binop(\"</>/<=/>=\", 7),\n    bitShift: binop(\"<</>>/>>>\", 8),\n    plusMin: new TokenType(\"+/-\", {beforeExpr: true, binop: 9, prefix: true, startsExpr: true}),\n    modulo: binop(\"%\", 10),\n    star: binop(\"*\", 10),\n    slash: binop(\"/\", 10),\n    starstar: new TokenType(\"**\", {beforeExpr: true}),\n    coalesce: binop(\"??\", 1),\n\n    // Keyword token types.\n    _break: kw(\"break\"),\n    _case: kw(\"case\", beforeExpr),\n    _catch: kw(\"catch\"),\n    _continue: kw(\"continue\"),\n    _debugger: kw(\"debugger\"),\n    _default: kw(\"default\", beforeExpr),\n    _do: kw(\"do\", {isLoop: true, beforeExpr: true}),\n    _else: kw(\"else\", beforeExpr),\n    _finally: kw(\"finally\"),\n    _for: kw(\"for\", {isLoop: true}),\n    _function: kw(\"function\", startsExpr),\n    _if: kw(\"if\"),\n    _return: kw(\"return\", beforeExpr),\n    _switch: kw(\"switch\"),\n    _throw: kw(\"throw\", beforeExpr),\n    _try: kw(\"try\"),\n    _var: kw(\"var\"),\n    _const: kw(\"const\"),\n    _while: kw(\"while\", {isLoop: true}),\n    _with: kw(\"with\"),\n    _new: kw(\"new\", {beforeExpr: true, startsExpr: true}),\n    _this: kw(\"this\", startsExpr),\n    _super: kw(\"super\", startsExpr),\n    _class: kw(\"class\", startsExpr),\n    _extends: kw(\"extends\", beforeExpr),\n    _export: kw(\"export\"),\n    _import: kw(\"import\", startsExpr),\n    _null: kw(\"null\", startsExpr),\n    _true: kw(\"true\", startsExpr),\n    _false: kw(\"false\", startsExpr),\n    _in: kw(\"in\", {beforeExpr: true, binop: 7}),\n    _instanceof: kw(\"instanceof\", {beforeExpr: true, binop: 7}),\n    _typeof: kw(\"typeof\", {beforeExpr: true, prefix: true, startsExpr: true}),\n    _void: kw(\"void\", {beforeExpr: true, prefix: true, startsExpr: true}),\n    _delete: kw(\"delete\", {beforeExpr: true, prefix: true, startsExpr: true})\n  };\n\n  // Matches a whole line break (where CRLF is considered a single\n  // line break). Used to count lines.\n\n  var lineBreak = /\\r\\n?|\\n|\\u2028|\\u2029/;\n  var lineBreakG = new RegExp(lineBreak.source, \"g\");\n\n  function isNewLine(code) {\n    return code === 10 || code === 13 || code === 0x2028 || code === 0x2029\n  }\n\n  function nextLineBreak(code, from, end) {\n    if ( end === void 0 ) end = code.length;\n\n    for (var i = from; i < end; i++) {\n      var next = code.charCodeAt(i);\n      if (isNewLine(next))\n        { return i < end - 1 && next === 13 && code.charCodeAt(i + 1) === 10 ? i + 2 : i + 1 }\n    }\n    return -1\n  }\n\n  var nonASCIIwhitespace = /[\\u1680\\u2000-\\u200a\\u202f\\u205f\\u3000\\ufeff]/;\n\n  var skipWhiteSpace = /(?:\\s|\\/\\/.*|\\/\\*[^]*?\\*\\/)*/g;\n\n  var ref = Object.prototype;\n  var hasOwnProperty = ref.hasOwnProperty;\n  var toString = ref.toString;\n\n  var hasOwn = Object.hasOwn || (function (obj, propName) { return (\n    hasOwnProperty.call(obj, propName)\n  ); });\n\n  var isArray = Array.isArray || (function (obj) { return (\n    toString.call(obj) === \"[object Array]\"\n  ); });\n\n  function wordsRegexp(words) {\n    return new RegExp(\"^(?:\" + words.replace(/ /g, \"|\") + \")$\")\n  }\n\n  function codePointToString(code) {\n    // UTF-16 Decoding\n    if (code <= 0xFFFF) { return String.fromCharCode(code) }\n    code -= 0x10000;\n    return String.fromCharCode((code >> 10) + 0xD800, (code & 1023) + 0xDC00)\n  }\n\n  var loneSurrogate = /(?:[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])/;\n\n  // These are used when `options.locations` is on, for the\n  // `startLoc` and `endLoc` properties.\n\n  var Position = function Position(line, col) {\n    this.line = line;\n    this.column = col;\n  };\n\n  Position.prototype.offset = function offset (n) {\n    return new Position(this.line, this.column + n)\n  };\n\n  var SourceLocation = function SourceLocation(p, start, end) {\n    this.start = start;\n    this.end = end;\n    if (p.sourceFile !== null) { this.source = p.sourceFile; }\n  };\n\n  // The `getLineInfo` function is mostly useful when the\n  // `locations` option is off (for performance reasons) and you\n  // want to find the line/column position for a given character\n  // offset. `input` should be the code string that the offset refers\n  // into.\n\n  function getLineInfo(input, offset) {\n    for (var line = 1, cur = 0;;) {\n      var nextBreak = nextLineBreak(input, cur, offset);\n      if (nextBreak < 0) { return new Position(line, offset - cur) }\n      ++line;\n      cur = nextBreak;\n    }\n  }\n\n  // A second argument must be given to configure the parser process.\n  // These options are recognized (only `ecmaVersion` is required):\n\n  var defaultOptions = {\n    // `ecmaVersion` indicates the ECMAScript version to parse. Must be\n    // either 3, 5, 6 (or 2015), 7 (2016), 8 (2017), 9 (2018), 10\n    // (2019), 11 (2020), 12 (2021), 13 (2022), or `\"latest\"` (the\n    // latest version the library supports). This influences support\n    // for strict mode, the set of reserved words, and support for\n    // new syntax features.\n    ecmaVersion: null,\n    // `sourceType` indicates the mode the code should be parsed in.\n    // Can be either `\"script\"` or `\"module\"`. This influences global\n    // strict mode and parsing of `import` and `export` declarations.\n    sourceType: \"script\",\n    // `onInsertedSemicolon` can be a callback that will be called\n    // when a semicolon is automatically inserted. It will be passed\n    // the position of the comma as an offset, and if `locations` is\n    // enabled, it is given the location as a `{line, column}` object\n    // as second argument.\n    onInsertedSemicolon: null,\n    // `onTrailingComma` is similar to `onInsertedSemicolon`, but for\n    // trailing commas.\n    onTrailingComma: null,\n    // By default, reserved words are only enforced if ecmaVersion >= 5.\n    // Set `allowReserved` to a boolean value to explicitly turn this on\n    // an off. When this option has the value \"never\", reserved words\n    // and keywords can also not be used as property names.\n    allowReserved: null,\n    // When enabled, a return at the top level is not considered an\n    // error.\n    allowReturnOutsideFunction: false,\n    // When enabled, import/export statements are not constrained to\n    // appearing at the top of the program, and an import.meta expression\n    // in a script isn't considered an error.\n    allowImportExportEverywhere: false,\n    // By default, await identifiers are allowed to appear at the top-level scope only if ecmaVersion >= 2022.\n    // When enabled, await identifiers are allowed to appear at the top-level scope,\n    // but they are still not allowed in non-async functions.\n    allowAwaitOutsideFunction: null,\n    // When enabled, super identifiers are not constrained to\n    // appearing in methods and do not raise an error when they appear elsewhere.\n    allowSuperOutsideMethod: null,\n    // When enabled, hashbang directive in the beginning of file\n    // is allowed and treated as a line comment.\n    allowHashBang: false,\n    // When `locations` is on, `loc` properties holding objects with\n    // `start` and `end` properties in `{line, column}` form (with\n    // line being 1-based and column 0-based) will be attached to the\n    // nodes.\n    locations: false,\n    // A function can be passed as `onToken` option, which will\n    // cause Acorn to call that function with object in the same\n    // format as tokens returned from `tokenizer().getToken()`. Note\n    // that you are not allowed to call the parser from the\n    // callbackthat will corrupt its internal state.\n    onToken: null,\n    // A function can be passed as `onComment` option, which will\n    // cause Acorn to call that function with `(block, text, start,\n    // end)` parameters whenever a comment is skipped. `block` is a\n    // boolean indicating whether this is a block (`/* */`) comment,\n    // `text` is the content of the comment, and `start` and `end` are\n    // character offsets that denote the start and end of the comment.\n    // When the `locations` option is on, two more parameters are\n    // passed, the full `{line, column}` locations of the start and\n    // end of the comments. Note that you are not allowed to call the\n    // parser from the callbackthat will corrupt its internal state.\n    onComment: null,\n    // Nodes have their start and end characters offsets recorded in\n    // `start` and `end` properties (directly on the node, rather than\n    // the `loc` object, which holds line/column data. To also add a\n    // [semi-standardized][range] `range` property holding a `[start,\n    // end]` array with the same numbers, set the `ranges` option to\n    // `true`.\n    //\n    // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678\n    ranges: false,\n    // It is possible to parse multiple files into a single AST by\n    // passing the tree produced by parsing the first file as\n    // `program` option in subsequent parses. This will add the\n    // toplevel forms of the parsed file to the `Program` (top) node\n    // of an existing parse tree.\n    program: null,\n    // When `locations` is on, you can pass this to record the source\n    // file in every node's `loc` object.\n    sourceFile: null,\n    // This value, if given, is stored in every node, whether\n    // `locations` is on or off.\n    directSourceFile: null,\n    // When enabled, parenthesized expressions are represented by\n    // (non-standard) ParenthesizedExpression nodes\n    preserveParens: false\n  };\n\n  // Interpret and default an options object\n\n  var warnedAboutEcmaVersion = false;\n\n  function getOptions(opts) {\n    var options = {};\n\n    for (var opt in defaultOptions)\n      { options[opt] = opts && hasOwn(opts, opt) ? opts[opt] : defaultOptions[opt]; }\n\n    if (options.ecmaVersion === \"latest\") {\n      options.ecmaVersion = 1e8;\n    } else if (options.ecmaVersion == null) {\n      if (!warnedAboutEcmaVersion && typeof console === \"object\" && console.warn) {\n        warnedAboutEcmaVersion = true;\n        console.warn(\"Since Acorn 8.0.0, options.ecmaVersion is required.\\nDefaulting to 2020, but this will stop working in the future.\");\n      }\n      options.ecmaVersion = 11;\n    } else if (options.ecmaVersion >= 2015) {\n      options.ecmaVersion -= 2009;\n    }\n\n    if (options.allowReserved == null)\n      { options.allowReserved = options.ecmaVersion < 5; }\n\n    if (isArray(options.onToken)) {\n      var tokens = options.onToken;\n      options.onToken = function (token) { return tokens.push(token); };\n    }\n    if (isArray(options.onComment))\n      { options.onComment = pushComment(options, options.onComment); }\n\n    return options\n  }\n\n  function pushComment(options, array) {\n    return function(block, text, start, end, startLoc, endLoc) {\n      var comment = {\n        type: block ? \"Block\" : \"Line\",\n        value: text,\n        start: start,\n        end: end\n      };\n      if (options.locations)\n        { comment.loc = new SourceLocation(this, startLoc, endLoc); }\n      if (options.ranges)\n        { comment.range = [start, end]; }\n      array.push(comment);\n    }\n  }\n\n  // Each scope gets a bitset that may contain these flags\n  var\n      SCOPE_TOP = 1,\n      SCOPE_FUNCTION = 2,\n      SCOPE_ASYNC = 4,\n      SCOPE_GENERATOR = 8,\n      SCOPE_ARROW = 16,\n      SCOPE_SIMPLE_CATCH = 32,\n      SCOPE_SUPER = 64,\n      SCOPE_DIRECT_SUPER = 128,\n      SCOPE_CLASS_STATIC_BLOCK = 256,\n      SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK;\n\n  function functionFlags(async, generator) {\n    return SCOPE_FUNCTION | (async ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0)\n  }\n\n  // Used in checkLVal* and declareName to determine the type of a binding\n  var\n      BIND_NONE = 0, // Not a binding\n      BIND_VAR = 1, // Var-style binding\n      BIND_LEXICAL = 2, // Let- or const-style binding\n      BIND_FUNCTION = 3, // Function declaration\n      BIND_SIMPLE_CATCH = 4, // Simple (identifier pattern) catch binding\n      BIND_OUTSIDE = 5; // Special case for function names as bound inside the function\n\n  var Parser = function Parser(options, input, startPos) {\n    this.options = options = getOptions(options);\n    this.sourceFile = options.sourceFile;\n    this.keywords = wordsRegexp(keywords$1[options.ecmaVersion >= 6 ? 6 : options.sourceType === \"module\" ? \"5module\" : 5]);\n    var reserved = \"\";\n    if (options.allowReserved !== true) {\n      reserved = reservedWords[options.ecmaVersion >= 6 ? 6 : options.ecmaVersion === 5 ? 5 : 3];\n      if (options.sourceType === \"module\") { reserved += \" await\"; }\n    }\n    this.reservedWords = wordsRegexp(reserved);\n    var reservedStrict = (reserved ? reserved + \" \" : \"\") + reservedWords.strict;\n    this.reservedWordsStrict = wordsRegexp(reservedStrict);\n    this.reservedWordsStrictBind = wordsRegexp(reservedStrict + \" \" + reservedWords.strictBind);\n    this.input = String(input);\n\n    // Used to signal to callers of `readWord1` whether the word\n    // contained any escape sequences. This is needed because words with\n    // escape sequences must not be interpreted as keywords.\n    this.containsEsc = false;\n\n    // Set up token state\n\n    // The current position of the tokenizer in the input.\n    if (startPos) {\n      this.pos = startPos;\n      this.lineStart = this.input.lastIndexOf(\"\\n\", startPos - 1) + 1;\n      this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;\n    } else {\n      this.pos = this.lineStart = 0;\n      this.curLine = 1;\n    }\n\n    // Properties of the current token:\n    // Its type\n    this.type = types$1.eof;\n    // For tokens that include more information than their type, the value\n    this.value = null;\n    // Its start and end offset\n    this.start = this.end = this.pos;\n    // And, if locations are used, the {line, column} object\n    // corresponding to those offsets\n    this.startLoc = this.endLoc = this.curPosition();\n\n    // Position information for the previous token\n    this.lastTokEndLoc = this.lastTokStartLoc = null;\n    this.lastTokStart = this.lastTokEnd = this.pos;\n\n    // The context stack is used to superficially track syntactic\n    // context to predict whether a regular expression is allowed in a\n    // given position.\n    this.context = this.initialContext();\n    this.exprAllowed = true;\n\n    // Figure out if it's a module code.\n    this.inModule = options.sourceType === \"module\";\n    this.strict = this.inModule || this.strictDirective(this.pos);\n\n    // Used to signify the start of a potential arrow function\n    this.potentialArrowAt = -1;\n    this.potentialArrowInForAwait = false;\n\n    // Positions to delayed-check that yield/await does not exist in default parameters.\n    this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;\n    // Labels in scope.\n    this.labels = [];\n    // Thus-far undefined exports.\n    this.undefinedExports = Object.create(null);\n\n    // If enabled, skip leading hashbang line.\n    if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === \"#!\")\n      { this.skipLineComment(2); }\n\n    // Scope tracking for duplicate variable names (see scope.js)\n    this.scopeStack = [];\n    this.enterScope(SCOPE_TOP);\n\n    // For RegExp validation\n    this.regexpState = null;\n\n    // The stack of private names.\n    // Each element has two properties: 'declared' and 'used'.\n    // When it exited from the outermost class definition, all used private names must be declared.\n    this.privateNameStack = [];\n  };\n\n  var prototypeAccessors = { inFunction: { configurable: true },inGenerator: { configurable: true },inAsync: { configurable: true },canAwait: { configurable: true },allowSuper: { configurable: true },allowDirectSuper: { configurable: true },treatFunctionsAsVar: { configurable: true },allowNewDotTarget: { configurable: true },inClassStaticBlock: { configurable: true } };\n\n  Parser.prototype.parse = function parse () {\n    var node = this.options.program || this.startNode();\n    this.nextToken();\n    return this.parseTopLevel(node)\n  };\n\n  prototypeAccessors.inFunction.get = function () { return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0 };\n\n  prototypeAccessors.inGenerator.get = function () { return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0 && !this.currentVarScope().inClassFieldInit };\n\n  prototypeAccessors.inAsync.get = function () { return (this.currentVarScope().flags & SCOPE_ASYNC) > 0 && !this.currentVarScope().inClassFieldInit };\n\n  prototypeAccessors.canAwait.get = function () {\n    for (var i = this.scopeStack.length - 1; i >= 0; i--) {\n      var scope = this.scopeStack[i];\n      if (scope.inClassFieldInit || scope.flags & SCOPE_CLASS_STATIC_BLOCK) { return false }\n      if (scope.flags & SCOPE_FUNCTION) { return (scope.flags & SCOPE_ASYNC) > 0 }\n    }\n    return (this.inModule && this.options.ecmaVersion >= 13) || this.options.allowAwaitOutsideFunction\n  };\n\n  prototypeAccessors.allowSuper.get = function () {\n    var ref = this.currentThisScope();\n      var flags = ref.flags;\n      var inClassFieldInit = ref.inClassFieldInit;\n    return (flags & SCOPE_SUPER) > 0 || inClassFieldInit || this.options.allowSuperOutsideMethod\n  };\n\n  prototypeAccessors.allowDirectSuper.get = function () { return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0 };\n\n  prototypeAccessors.treatFunctionsAsVar.get = function () { return this.treatFunctionsAsVarInScope(this.currentScope()) };\n\n  prototypeAccessors.allowNewDotTarget.get = function () {\n    var ref = this.currentThisScope();\n      var flags = ref.flags;\n      var inClassFieldInit = ref.inClassFieldInit;\n    return (flags & (SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK)) > 0 || inClassFieldInit\n  };\n\n  prototypeAccessors.inClassStaticBlock.get = function () {\n    return (this.currentVarScope().flags & SCOPE_CLASS_STATIC_BLOCK) > 0\n  };\n\n  Parser.extend = function extend () {\n      var plugins = [], len = arguments.length;\n      while ( len-- ) plugins[ len ] = arguments[ len ];\n\n    var cls = this;\n    for (var i = 0; i < plugins.length; i++) { cls = plugins[i](cls); }\n    return cls\n  };\n\n  Parser.parse = function parse (input, options) {\n    return new this(options, input).parse()\n  };\n\n  Parser.parseExpressionAt = function parseExpressionAt (input, pos, options) {\n    var parser = new this(options, input, pos);\n    parser.nextToken();\n    return parser.parseExpression()\n  };\n\n  Parser.tokenizer = function tokenizer (input, options) {\n    return new this(options, input)\n  };\n\n  Object.defineProperties( Parser.prototype, prototypeAccessors );\n\n  var pp$9 = Parser.prototype;\n\n  // ## Parser utilities\n\n  var literal = /^(?:'((?:\\\\.|[^'\\\\])*?)'|\"((?:\\\\.|[^\"\\\\])*?)\")/;\n  pp$9.strictDirective = function(start) {\n    if (this.options.ecmaVersion < 5) { return false }\n    for (;;) {\n      // Try to find string literal.\n      skipWhiteSpace.lastIndex = start;\n      start += skipWhiteSpace.exec(this.input)[0].length;\n      var match = literal.exec(this.input.slice(start));\n      if (!match) { return false }\n      if ((match[1] || match[2]) === \"use strict\") {\n        skipWhiteSpace.lastIndex = start + match[0].length;\n        var spaceAfter = skipWhiteSpace.exec(this.input), end = spaceAfter.index + spaceAfter[0].length;\n        var next = this.input.charAt(end);\n        return next === \";\" || next === \"}\" ||\n          (lineBreak.test(spaceAfter[0]) &&\n           !(/[(`.[+\\-/*%<>=,?^&]/.test(next) || next === \"!\" && this.input.charAt(end + 1) === \"=\"))\n      }\n      start += match[0].length;\n\n      // Skip semicolon, if any.\n      skipWhiteSpace.lastIndex = start;\n      start += skipWhiteSpace.exec(this.input)[0].length;\n      if (this.input[start] === \";\")\n        { start++; }\n    }\n  };\n\n  // Predicate that tests whether the next token is of the given\n  // type, and if yes, consumes it as a side effect.\n\n  pp$9.eat = function(type) {\n    if (this.type === type) {\n      this.next();\n      return true\n    } else {\n      return false\n    }\n  };\n\n  // Tests whether parsed token is a contextual keyword.\n\n  pp$9.isContextual = function(name) {\n    return this.type === types$1.name && this.value === name && !this.containsEsc\n  };\n\n  // Consumes contextual keyword if possible.\n\n  pp$9.eatContextual = function(name) {\n    if (!this.isContextual(name)) { return false }\n    this.next();\n    return true\n  };\n\n  // Asserts that following token is given contextual keyword.\n\n  pp$9.expectContextual = function(name) {\n    if (!this.eatContextual(name)) { this.unexpected(); }\n  };\n\n  // Test whether a semicolon can be inserted at the current position.\n\n  pp$9.canInsertSemicolon = function() {\n    return this.type === types$1.eof ||\n      this.type === types$1.braceR ||\n      lineBreak.test(this.input.slice(this.lastTokEnd, this.start))\n  };\n\n  pp$9.insertSemicolon = function() {\n    if (this.canInsertSemicolon()) {\n      if (this.options.onInsertedSemicolon)\n        { this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc); }\n      return true\n    }\n  };\n\n  // Consume a semicolon, or, failing that, see if we are allowed to\n  // pretend that there is a semicolon at this position.\n\n  pp$9.semicolon = function() {\n    if (!this.eat(types$1.semi) && !this.insertSemicolon()) { this.unexpected(); }\n  };\n\n  pp$9.afterTrailingComma = function(tokType, notNext) {\n    if (this.type === tokType) {\n      if (this.options.onTrailingComma)\n        { this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc); }\n      if (!notNext)\n        { this.next(); }\n      return true\n    }\n  };\n\n  // Expect a token of a given type. If found, consume it, otherwise,\n  // raise an unexpected token error.\n\n  pp$9.expect = function(type) {\n    this.eat(type) || this.unexpected();\n  };\n\n  // Raise an unexpected token error.\n\n  pp$9.unexpected = function(pos) {\n    this.raise(pos != null ? pos : this.start, \"Unexpected token\");\n  };\n\n  var DestructuringErrors = function DestructuringErrors() {\n    this.shorthandAssign =\n    this.trailingComma =\n    this.parenthesizedAssign =\n    this.parenthesizedBind =\n    this.doubleProto =\n      -1;\n  };\n\n  pp$9.checkPatternErrors = function(refDestructuringErrors, isAssign) {\n    if (!refDestructuringErrors) { return }\n    if (refDestructuringErrors.trailingComma > -1)\n      { this.raiseRecoverable(refDestructuringErrors.trailingComma, \"Comma is not permitted after the rest element\"); }\n    var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;\n    if (parens > -1) { this.raiseRecoverable(parens, \"Parenthesized pattern\"); }\n  };\n\n  pp$9.checkExpressionErrors = function(refDestructuringErrors, andThrow) {\n    if (!refDestructuringErrors) { return false }\n    var shorthandAssign = refDestructuringErrors.shorthandAssign;\n    var doubleProto = refDestructuringErrors.doubleProto;\n    if (!andThrow) { return shorthandAssign >= 0 || doubleProto >= 0 }\n    if (shorthandAssign >= 0)\n      { this.raise(shorthandAssign, \"Shorthand property assignments are valid only in destructuring patterns\"); }\n    if (doubleProto >= 0)\n      { this.raiseRecoverable(doubleProto, \"Redefinition of __proto__ property\"); }\n  };\n\n  pp$9.checkYieldAwaitInDefaultParams = function() {\n    if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos))\n      { this.raise(this.yieldPos, \"Yield expression cannot be a default value\"); }\n    if (this.awaitPos)\n      { this.raise(this.awaitPos, \"Await expression cannot be a default value\"); }\n  };\n\n  pp$9.isSimpleAssignTarget = function(expr) {\n    if (expr.type === \"ParenthesizedExpression\")\n      { return this.isSimpleAssignTarget(expr.expression) }\n    return expr.type === \"Identifier\" || expr.type === \"MemberExpression\"\n  };\n\n  var pp$8 = Parser.prototype;\n\n  // ### Statement parsing\n\n  // Parse a program. Initializes the parser, reads any number of\n  // statements, and wraps them in a Program node.  Optionally takes a\n  // `program` argument.  If present, the statements will be appended\n  // to its body instead of creating a new node.\n\n  pp$8.parseTopLevel = function(node) {\n    var exports = Object.create(null);\n    if (!node.body) { node.body = []; }\n    while (this.type !== types$1.eof) {\n      var stmt = this.parseStatement(null, true, exports);\n      node.body.push(stmt);\n    }\n    if (this.inModule)\n      { for (var i = 0, list = Object.keys(this.undefinedExports); i < list.length; i += 1)\n        {\n          var name = list[i];\n\n          this.raiseRecoverable(this.undefinedExports[name].start, (\"Export '\" + name + \"' is not defined\"));\n        } }\n    this.adaptDirectivePrologue(node.body);\n    this.next();\n    node.sourceType = this.options.sourceType;\n    return this.finishNode(node, \"Program\")\n  };\n\n  var loopLabel = {kind: \"loop\"}, switchLabel = {kind: \"switch\"};\n\n  pp$8.isLet = function(context) {\n    if (this.options.ecmaVersion < 6 || !this.isContextual(\"let\")) { return false }\n    skipWhiteSpace.lastIndex = this.pos;\n    var skip = skipWhiteSpace.exec(this.input);\n    var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);\n    // For ambiguous cases, determine if a LexicalDeclaration (or only a\n    // Statement) is allowed here. If context is not empty then only a Statement\n    // is allowed. However, `let [` is an explicit negative lookahead for\n    // ExpressionStatement, so special-case it first.\n    if (nextCh === 91 || nextCh === 92 || nextCh > 0xd7ff && nextCh < 0xdc00) { return true } // '[', '/', astral\n    if (context) { return false }\n\n    if (nextCh === 123) { return true } // '{'\n    if (isIdentifierStart(nextCh, true)) {\n      var pos = next + 1;\n      while (isIdentifierChar(nextCh = this.input.charCodeAt(pos), true)) { ++pos; }\n      if (nextCh === 92 || nextCh > 0xd7ff && nextCh < 0xdc00) { return true }\n      var ident = this.input.slice(next, pos);\n      if (!keywordRelationalOperator.test(ident)) { return true }\n    }\n    return false\n  };\n\n  // check 'async [no LineTerminator here] function'\n  // - 'async /*foo*/ function' is OK.\n  // - 'async /*\\n*/ function' is invalid.\n  pp$8.isAsyncFunction = function() {\n    if (this.options.ecmaVersion < 8 || !this.isContextual(\"async\"))\n      { return false }\n\n    skipWhiteSpace.lastIndex = this.pos;\n    var skip = skipWhiteSpace.exec(this.input);\n    var next = this.pos + skip[0].length, after;\n    return !lineBreak.test(this.input.slice(this.pos, next)) &&\n      this.input.slice(next, next + 8) === \"function\" &&\n      (next + 8 === this.input.length ||\n       !(isIdentifierChar(after = this.input.charCodeAt(next + 8)) || after > 0xd7ff && after < 0xdc00))\n  };\n\n  // Parse a single statement.\n  //\n  // If expecting a statement and finding a slash operator, parse a\n  // regular expression literal. This is to handle cases like\n  // `if (foo) /blah/.exec(foo)`, where looking at the previous token\n  // does not help.\n\n  pp$8.parseStatement = function(context, topLevel, exports) {\n    var starttype = this.type, node = this.startNode(), kind;\n\n    if (this.isLet(context)) {\n      starttype = types$1._var;\n      kind = \"let\";\n    }\n\n    // Most types of statements are recognized by the keyword they\n    // start with. Many are trivial to parse, some require a bit of\n    // complexity.\n\n    switch (starttype) {\n    case types$1._break: case types$1._continue: return this.parseBreakContinueStatement(node, starttype.keyword)\n    case types$1._debugger: return this.parseDebuggerStatement(node)\n    case types$1._do: return this.parseDoStatement(node)\n    case types$1._for: return this.parseForStatement(node)\n    case types$1._function:\n      // Function as sole body of either an if statement or a labeled statement\n      // works, but not when it is part of a labeled statement that is the sole\n      // body of an if statement.\n      if ((context && (this.strict || context !== \"if\" && context !== \"label\")) && this.options.ecmaVersion >= 6) { this.unexpected(); }\n      return this.parseFunctionStatement(node, false, !context)\n    case types$1._class:\n      if (context) { this.unexpected(); }\n      return this.parseClass(node, true)\n    case types$1._if: return this.parseIfStatement(node)\n    case types$1._return: return this.parseReturnStatement(node)\n    case types$1._switch: return this.parseSwitchStatement(node)\n    case types$1._throw: return this.parseThrowStatement(node)\n    case types$1._try: return this.parseTryStatement(node)\n    case types$1._const: case types$1._var:\n      kind = kind || this.value;\n      if (context && kind !== \"var\") { this.unexpected(); }\n      return this.parseVarStatement(node, kind)\n    case types$1._while: return this.parseWhileStatement(node)\n    case types$1._with: return this.parseWithStatement(node)\n    case types$1.braceL: return this.parseBlock(true, node)\n    case types$1.semi: return this.parseEmptyStatement(node)\n    case types$1._export:\n    case types$1._import:\n      if (this.options.ecmaVersion > 10 && starttype === types$1._import) {\n        skipWhiteSpace.lastIndex = this.pos;\n        var skip = skipWhiteSpace.exec(this.input);\n        var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);\n        if (nextCh === 40 || nextCh === 46) // '(' or '.'\n          { return this.parseExpressionStatement(node, this.parseExpression()) }\n      }\n\n      if (!this.options.allowImportExportEverywhere) {\n        if (!topLevel)\n          { this.raise(this.start, \"'import' and 'export' may only appear at the top level\"); }\n        if (!this.inModule)\n          { this.raise(this.start, \"'import' and 'export' may appear only with 'sourceType: module'\"); }\n      }\n      return starttype === types$1._import ? this.parseImport(node) : this.parseExport(node, exports)\n\n      // If the statement does not start with a statement keyword or a\n      // brace, it's an ExpressionStatement or LabeledStatement. We\n      // simply start parsing an expression, and afterwards, if the\n      // next token is a colon and the expression was a simple\n      // Identifier node, we switch to interpreting it as a label.\n    default:\n      if (this.isAsyncFunction()) {\n        if (context) { this.unexpected(); }\n        this.next();\n        return this.parseFunctionStatement(node, true, !context)\n      }\n\n      var maybeName = this.value, expr = this.parseExpression();\n      if (starttype === types$1.name && expr.type === \"Identifier\" && this.eat(types$1.colon))\n        { return this.parseLabeledStatement(node, maybeName, expr, context) }\n      else { return this.parseExpressionStatement(node, expr) }\n    }\n  };\n\n  pp$8.parseBreakContinueStatement = function(node, keyword) {\n    var isBreak = keyword === \"break\";\n    this.next();\n    if (this.eat(types$1.semi) || this.insertSemicolon()) { node.label = null; }\n    else if (this.type !== types$1.name) { this.unexpected(); }\n    else {\n      node.label = this.parseIdent();\n      this.semicolon();\n    }\n\n    // Verify that there is an actual destination to break or\n    // continue to.\n    var i = 0;\n    for (; i < this.labels.length; ++i) {\n      var lab = this.labels[i];\n      if (node.label == null || lab.name === node.label.name) {\n        if (lab.kind != null && (isBreak || lab.kind === \"loop\")) { break }\n        if (node.label && isBreak) { break }\n      }\n    }\n    if (i === this.labels.length) { this.raise(node.start, \"Unsyntactic \" + keyword); }\n    return this.finishNode(node, isBreak ? \"BreakStatement\" : \"ContinueStatement\")\n  };\n\n  pp$8.parseDebuggerStatement = function(node) {\n    this.next();\n    this.semicolon();\n    return this.finishNode(node, \"DebuggerStatement\")\n  };\n\n  pp$8.parseDoStatement = function(node) {\n    this.next();\n    this.labels.push(loopLabel);\n    node.body = this.parseStatement(\"do\");\n    this.labels.pop();\n    this.expect(types$1._while);\n    node.test = this.parseParenExpression();\n    if (this.options.ecmaVersion >= 6)\n      { this.eat(types$1.semi); }\n    else\n      { this.semicolon(); }\n    return this.finishNode(node, \"DoWhileStatement\")\n  };\n\n  // Disambiguating between a `for` and a `for`/`in` or `for`/`of`\n  // loop is non-trivial. Basically, we have to parse the init `var`\n  // statement or expression, disallowing the `in` operator (see\n  // the second parameter to `parseExpression`), and then check\n  // whether the next token is `in` or `of`. When there is no init\n  // part (semicolon immediately after the opening parenthesis), it\n  // is a regular `for` loop.\n\n  pp$8.parseForStatement = function(node) {\n    this.next();\n    var awaitAt = (this.options.ecmaVersion >= 9 && this.canAwait && this.eatContextual(\"await\")) ? this.lastTokStart : -1;\n    this.labels.push(loopLabel);\n    this.enterScope(0);\n    this.expect(types$1.parenL);\n    if (this.type === types$1.semi) {\n      if (awaitAt > -1) { this.unexpected(awaitAt); }\n      return this.parseFor(node, null)\n    }\n    var isLet = this.isLet();\n    if (this.type === types$1._var || this.type === types$1._const || isLet) {\n      var init$1 = this.startNode(), kind = isLet ? \"let\" : this.value;\n      this.next();\n      this.parseVar(init$1, true, kind);\n      this.finishNode(init$1, \"VariableDeclaration\");\n      if ((this.type === types$1._in || (this.options.ecmaVersion >= 6 && this.isContextual(\"of\"))) && init$1.declarations.length === 1) {\n        if (this.options.ecmaVersion >= 9) {\n          if (this.type === types$1._in) {\n            if (awaitAt > -1) { this.unexpected(awaitAt); }\n          } else { node.await = awaitAt > -1; }\n        }\n        return this.parseForIn(node, init$1)\n      }\n      if (awaitAt > -1) { this.unexpected(awaitAt); }\n      return this.parseFor(node, init$1)\n    }\n    var startsWithLet = this.isContextual(\"let\"), isForOf = false;\n    var refDestructuringErrors = new DestructuringErrors;\n    var init = this.parseExpression(awaitAt > -1 ? \"await\" : true, refDestructuringErrors);\n    if (this.type === types$1._in || (isForOf = this.options.ecmaVersion >= 6 && this.isContextual(\"of\"))) {\n      if (this.options.ecmaVersion >= 9) {\n        if (this.type === types$1._in) {\n          if (awaitAt > -1) { this.unexpected(awaitAt); }\n        } else { node.await = awaitAt > -1; }\n      }\n      if (startsWithLet && isForOf) { this.raise(init.start, \"The left-hand side of a for-of loop may not start with 'let'.\"); }\n      this.toAssignable(init, false, refDestructuringErrors);\n      this.checkLValPattern(init);\n      return this.parseForIn(node, init)\n    } else {\n      this.checkExpressionErrors(refDestructuringErrors, true);\n    }\n    if (awaitAt > -1) { this.unexpected(awaitAt); }\n    return this.parseFor(node, init)\n  };\n\n  pp$8.parseFunctionStatement = function(node, isAsync, declarationPosition) {\n    this.next();\n    return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync)\n  };\n\n  pp$8.parseIfStatement = function(node) {\n    this.next();\n    node.test = this.parseParenExpression();\n    // allow function declarations in branches, but only in non-strict mode\n    node.consequent = this.parseStatement(\"if\");\n    node.alternate = this.eat(types$1._else) ? this.parseStatement(\"if\") : null;\n    return this.finishNode(node, \"IfStatement\")\n  };\n\n  pp$8.parseReturnStatement = function(node) {\n    if (!this.inFunction && !this.options.allowReturnOutsideFunction)\n      { this.raise(this.start, \"'return' outside of function\"); }\n    this.next();\n\n    // In `return` (and `break`/`continue`), the keywords with\n    // optional arguments, we eagerly look for a semicolon or the\n    // possibility to insert one.\n\n    if (this.eat(types$1.semi) || this.insertSemicolon()) { node.argument = null; }\n    else { node.argument = this.parseExpression(); this.semicolon(); }\n    return this.finishNode(node, \"ReturnStatement\")\n  };\n\n  pp$8.parseSwitchStatement = function(node) {\n    this.next();\n    node.discriminant = this.parseParenExpression();\n    node.cases = [];\n    this.expect(types$1.braceL);\n    this.labels.push(switchLabel);\n    this.enterScope(0);\n\n    // Statements under must be grouped (by label) in SwitchCase\n    // nodes. `cur` is used to keep the node that we are currently\n    // adding statements to.\n\n    var cur;\n    for (var sawDefault = false; this.type !== types$1.braceR;) {\n      if (this.type === types$1._case || this.type === types$1._default) {\n        var isCase = this.type === types$1._case;\n        if (cur) { this.finishNode(cur, \"SwitchCase\"); }\n        node.cases.push(cur = this.startNode());\n        cur.consequent = [];\n        this.next();\n        if (isCase) {\n          cur.test = this.parseExpression();\n        } else {\n          if (sawDefault) { this.raiseRecoverable(this.lastTokStart, \"Multiple default clauses\"); }\n          sawDefault = true;\n          cur.test = null;\n        }\n        this.expect(types$1.colon);\n      } else {\n        if (!cur) { this.unexpected(); }\n        cur.consequent.push(this.parseStatement(null));\n      }\n    }\n    this.exitScope();\n    if (cur) { this.finishNode(cur, \"SwitchCase\"); }\n    this.next(); // Closing brace\n    this.labels.pop();\n    return this.finishNode(node, \"SwitchStatement\")\n  };\n\n  pp$8.parseThrowStatement = function(node) {\n    this.next();\n    if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start)))\n      { this.raise(this.lastTokEnd, \"Illegal newline after throw\"); }\n    node.argument = this.parseExpression();\n    this.semicolon();\n    return this.finishNode(node, \"ThrowStatement\")\n  };\n\n  // Reused empty array added for node fields that are always empty.\n\n  var empty$1 = [];\n\n  pp$8.parseTryStatement = function(node) {\n    this.next();\n    node.block = this.parseBlock();\n    node.handler = null;\n    if (this.type === types$1._catch) {\n      var clause = this.startNode();\n      this.next();\n      if (this.eat(types$1.parenL)) {\n        clause.param = this.parseBindingAtom();\n        var simple = clause.param.type === \"Identifier\";\n        this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);\n        this.checkLValPattern(clause.param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL);\n        this.expect(types$1.parenR);\n      } else {\n        if (this.options.ecmaVersion < 10) { this.unexpected(); }\n        clause.param = null;\n        this.enterScope(0);\n      }\n      clause.body = this.parseBlock(false);\n      this.exitScope();\n      node.handler = this.finishNode(clause, \"CatchClause\");\n    }\n    node.finalizer = this.eat(types$1._finally) ? this.parseBlock() : null;\n    if (!node.handler && !node.finalizer)\n      { this.raise(node.start, \"Missing catch or finally clause\"); }\n    return this.finishNode(node, \"TryStatement\")\n  };\n\n  pp$8.parseVarStatement = function(node, kind) {\n    this.next();\n    this.parseVar(node, false, kind);\n    this.semicolon();\n    return this.finishNode(node, \"VariableDeclaration\")\n  };\n\n  pp$8.parseWhileStatement = function(node) {\n    this.next();\n    node.test = this.parseParenExpression();\n    this.labels.push(loopLabel);\n    node.body = this.parseStatement(\"while\");\n    this.labels.pop();\n    return this.finishNode(node, \"WhileStatement\")\n  };\n\n  pp$8.parseWithStatement = function(node) {\n    if (this.strict) { this.raise(this.start, \"'with' in strict mode\"); }\n    this.next();\n    node.object = this.parseParenExpression();\n    node.body = this.parseStatement(\"with\");\n    return this.finishNode(node, \"WithStatement\")\n  };\n\n  pp$8.parseEmptyStatement = function(node) {\n    this.next();\n    return this.finishNode(node, \"EmptyStatement\")\n  };\n\n  pp$8.parseLabeledStatement = function(node, maybeName, expr, context) {\n    for (var i$1 = 0, list = this.labels; i$1 < list.length; i$1 += 1)\n      {\n      var label = list[i$1];\n\n      if (label.name === maybeName)\n        { this.raise(expr.start, \"Label '\" + maybeName + \"' is already declared\");\n    } }\n    var kind = this.type.isLoop ? \"loop\" : this.type === types$1._switch ? \"switch\" : null;\n    for (var i = this.labels.length - 1; i >= 0; i--) {\n      var label$1 = this.labels[i];\n      if (label$1.statementStart === node.start) {\n        // Update information about previous labels on this node\n        label$1.statementStart = this.start;\n        label$1.kind = kind;\n      } else { break }\n    }\n    this.labels.push({name: maybeName, kind: kind, statementStart: this.start});\n    node.body = this.parseStatement(context ? context.indexOf(\"label\") === -1 ? context + \"label\" : context : \"label\");\n    this.labels.pop();\n    node.label = expr;\n    return this.finishNode(node, \"LabeledStatement\")\n  };\n\n  pp$8.parseExpressionStatement = function(node, expr) {\n    node.expression = expr;\n    this.semicolon();\n    return this.finishNode(node, \"ExpressionStatement\")\n  };\n\n  // Parse a semicolon-enclosed block of statements, handling `\"use\n  // strict\"` declarations when `allowStrict` is true (used for\n  // function bodies).\n\n  pp$8.parseBlock = function(createNewLexicalScope, node, exitStrict) {\n    if ( createNewLexicalScope === void 0 ) createNewLexicalScope = true;\n    if ( node === void 0 ) node = this.startNode();\n\n    node.body = [];\n    this.expect(types$1.braceL);\n    if (createNewLexicalScope) { this.enterScope(0); }\n    while (this.type !== types$1.braceR) {\n      var stmt = this.parseStatement(null);\n      node.body.push(stmt);\n    }\n    if (exitStrict) { this.strict = false; }\n    this.next();\n    if (createNewLexicalScope) { this.exitScope(); }\n    return this.finishNode(node, \"BlockStatement\")\n  };\n\n  // Parse a regular `for` loop. The disambiguation code in\n  // `parseStatement` will already have parsed the init statement or\n  // expression.\n\n  pp$8.parseFor = function(node, init) {\n    node.init = init;\n    this.expect(types$1.semi);\n    node.test = this.type === types$1.semi ? null : this.parseExpression();\n    this.expect(types$1.semi);\n    node.update = this.type === types$1.parenR ? null : this.parseExpression();\n    this.expect(types$1.parenR);\n    node.body = this.parseStatement(\"for\");\n    this.exitScope();\n    this.labels.pop();\n    return this.finishNode(node, \"ForStatement\")\n  };\n\n  // Parse a `for`/`in` and `for`/`of` loop, which are almost\n  // same from parser's perspective.\n\n  pp$8.parseForIn = function(node, init) {\n    var isForIn = this.type === types$1._in;\n    this.next();\n\n    if (\n      init.type === \"VariableDeclaration\" &&\n      init.declarations[0].init != null &&\n      (\n        !isForIn ||\n        this.options.ecmaVersion < 8 ||\n        this.strict ||\n        init.kind !== \"var\" ||\n        init.declarations[0].id.type !== \"Identifier\"\n      )\n    ) {\n      this.raise(\n        init.start,\n        ((isForIn ? \"for-in\" : \"for-of\") + \" loop variable declaration may not have an initializer\")\n      );\n    }\n    node.left = init;\n    node.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();\n    this.expect(types$1.parenR);\n    node.body = this.parseStatement(\"for\");\n    this.exitScope();\n    this.labels.pop();\n    return this.finishNode(node, isForIn ? \"ForInStatement\" : \"ForOfStatement\")\n  };\n\n  // Parse a list of variable declarations.\n\n  pp$8.parseVar = function(node, isFor, kind) {\n    node.declarations = [];\n    node.kind = kind;\n    for (;;) {\n      var decl = this.startNode();\n      this.parseVarId(decl, kind);\n      if (this.eat(types$1.eq)) {\n        decl.init = this.parseMaybeAssign(isFor);\n      } else if (kind === \"const\" && !(this.type === types$1._in || (this.options.ecmaVersion >= 6 && this.isContextual(\"of\")))) {\n        this.unexpected();\n      } else if (decl.id.type !== \"Identifier\" && !(isFor && (this.type === types$1._in || this.isContextual(\"of\")))) {\n        this.raise(this.lastTokEnd, \"Complex binding patterns require an initialization value\");\n      } else {\n        decl.init = null;\n      }\n      node.declarations.push(this.finishNode(decl, \"VariableDeclarator\"));\n      if (!this.eat(types$1.comma)) { break }\n    }\n    return node\n  };\n\n  pp$8.parseVarId = function(decl, kind) {\n    decl.id = this.parseBindingAtom();\n    this.checkLValPattern(decl.id, kind === \"var\" ? BIND_VAR : BIND_LEXICAL, false);\n  };\n\n  var FUNC_STATEMENT = 1, FUNC_HANGING_STATEMENT = 2, FUNC_NULLABLE_ID = 4;\n\n  // Parse a function declaration or literal (depending on the\n  // `statement & FUNC_STATEMENT`).\n\n  // Remove `allowExpressionBody` for 7.0.0, as it is only called with false\n  pp$8.parseFunction = function(node, statement, allowExpressionBody, isAsync, forInit) {\n    this.initFunction(node);\n    if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {\n      if (this.type === types$1.star && (statement & FUNC_HANGING_STATEMENT))\n        { this.unexpected(); }\n      node.generator = this.eat(types$1.star);\n    }\n    if (this.options.ecmaVersion >= 8)\n      { node.async = !!isAsync; }\n\n    if (statement & FUNC_STATEMENT) {\n      node.id = (statement & FUNC_NULLABLE_ID) && this.type !== types$1.name ? null : this.parseIdent();\n      if (node.id && !(statement & FUNC_HANGING_STATEMENT))\n        // If it is a regular function declaration in sloppy mode, then it is\n        // subject to Annex B semantics (BIND_FUNCTION). Otherwise, the binding\n        // mode depends on properties of the current scope (see\n        // treatFunctionsAsVar).\n        { this.checkLValSimple(node.id, (this.strict || node.generator || node.async) ? this.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION); }\n    }\n\n    var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;\n    this.yieldPos = 0;\n    this.awaitPos = 0;\n    this.awaitIdentPos = 0;\n    this.enterScope(functionFlags(node.async, node.generator));\n\n    if (!(statement & FUNC_STATEMENT))\n      { node.id = this.type === types$1.name ? this.parseIdent() : null; }\n\n    this.parseFunctionParams(node);\n    this.parseFunctionBody(node, allowExpressionBody, false, forInit);\n\n    this.yieldPos = oldYieldPos;\n    this.awaitPos = oldAwaitPos;\n    this.awaitIdentPos = oldAwaitIdentPos;\n    return this.finishNode(node, (statement & FUNC_STATEMENT) ? \"FunctionDeclaration\" : \"FunctionExpression\")\n  };\n\n  pp$8.parseFunctionParams = function(node) {\n    this.expect(types$1.parenL);\n    node.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);\n    this.checkYieldAwaitInDefaultParams();\n  };\n\n  // Parse a class declaration or literal (depending on the\n  // `isStatement` parameter).\n\n  pp$8.parseClass = function(node, isStatement) {\n    this.next();\n\n    // ecma-262 14.6 Class Definitions\n    // A class definition is always strict mode code.\n    var oldStrict = this.strict;\n    this.strict = true;\n\n    this.parseClassId(node, isStatement);\n    this.parseClassSuper(node);\n    var privateNameMap = this.enterClassBody();\n    var classBody = this.startNode();\n    var hadConstructor = false;\n    classBody.body = [];\n    this.expect(types$1.braceL);\n    while (this.type !== types$1.braceR) {\n      var element = this.parseClassElement(node.superClass !== null);\n      if (element) {\n        classBody.body.push(element);\n        if (element.type === \"MethodDefinition\" && element.kind === \"constructor\") {\n          if (hadConstructor) { this.raise(element.start, \"Duplicate constructor in the same class\"); }\n          hadConstructor = true;\n        } else if (element.key && element.key.type === \"PrivateIdentifier\" && isPrivateNameConflicted(privateNameMap, element)) {\n          this.raiseRecoverable(element.key.start, (\"Identifier '#\" + (element.key.name) + \"' has already been declared\"));\n        }\n      }\n    }\n    this.strict = oldStrict;\n    this.next();\n    node.body = this.finishNode(classBody, \"ClassBody\");\n    this.exitClassBody();\n    return this.finishNode(node, isStatement ? \"ClassDeclaration\" : \"ClassExpression\")\n  };\n\n  pp$8.parseClassElement = function(constructorAllowsSuper) {\n    if (this.eat(types$1.semi)) { return null }\n\n    var ecmaVersion = this.options.ecmaVersion;\n    var node = this.startNode();\n    var keyName = \"\";\n    var isGenerator = false;\n    var isAsync = false;\n    var kind = \"method\";\n    var isStatic = false;\n\n    if (this.eatContextual(\"static\")) {\n      // Parse static init block\n      if (ecmaVersion >= 13 && this.eat(types$1.braceL)) {\n        this.parseClassStaticBlock(node);\n        return node\n      }\n      if (this.isClassElementNameStart() || this.type === types$1.star) {\n        isStatic = true;\n      } else {\n        keyName = \"static\";\n      }\n    }\n    node.static = isStatic;\n    if (!keyName && ecmaVersion >= 8 && this.eatContextual(\"async\")) {\n      if ((this.isClassElementNameStart() || this.type === types$1.star) && !this.canInsertSemicolon()) {\n        isAsync = true;\n      } else {\n        keyName = \"async\";\n      }\n    }\n    if (!keyName && (ecmaVersion >= 9 || !isAsync) && this.eat(types$1.star)) {\n      isGenerator = true;\n    }\n    if (!keyName && !isAsync && !isGenerator) {\n      var lastValue = this.value;\n      if (this.eatContextual(\"get\") || this.eatContextual(\"set\")) {\n        if (this.isClassElementNameStart()) {\n          kind = lastValue;\n        } else {\n          keyName = lastValue;\n        }\n      }\n    }\n\n    // Parse element name\n    if (keyName) {\n      // 'async', 'get', 'set', or 'static' were not a keyword contextually.\n      // The last token is any of those. Make it the element name.\n      node.computed = false;\n      node.key = this.startNodeAt(this.lastTokStart, this.lastTokStartLoc);\n      node.key.name = keyName;\n      this.finishNode(node.key, \"Identifier\");\n    } else {\n      this.parseClassElementName(node);\n    }\n\n    // Parse element value\n    if (ecmaVersion < 13 || this.type === types$1.parenL || kind !== \"method\" || isGenerator || isAsync) {\n      var isConstructor = !node.static && checkKeyName(node, \"constructor\");\n      var allowsDirectSuper = isConstructor && constructorAllowsSuper;\n      // Couldn't move this check into the 'parseClassMethod' method for backward compatibility.\n      if (isConstructor && kind !== \"method\") { this.raise(node.key.start, \"Constructor can't have get/set modifier\"); }\n      node.kind = isConstructor ? \"constructor\" : kind;\n      this.parseClassMethod(node, isGenerator, isAsync, allowsDirectSuper);\n    } else {\n      this.parseClassField(node);\n    }\n\n    return node\n  };\n\n  pp$8.isClassElementNameStart = function() {\n    return (\n      this.type === types$1.name ||\n      this.type === types$1.privateId ||\n      this.type === types$1.num ||\n      this.type === types$1.string ||\n      this.type === types$1.bracketL ||\n      this.type.keyword\n    )\n  };\n\n  pp$8.parseClassElementName = function(element) {\n    if (this.type === types$1.privateId) {\n      if (this.value === \"constructor\") {\n        this.raise(this.start, \"Classes can't have an element named '#constructor'\");\n      }\n      element.computed = false;\n      element.key = this.parsePrivateIdent();\n    } else {\n      this.parsePropertyName(element);\n    }\n  };\n\n  pp$8.parseClassMethod = function(method, isGenerator, isAsync, allowsDirectSuper) {\n    // Check key and flags\n    var key = method.key;\n    if (method.kind === \"constructor\") {\n      if (isGenerator) { this.raise(key.start, \"Constructor can't be a generator\"); }\n      if (isAsync) { this.raise(key.start, \"Constructor can't be an async method\"); }\n    } else if (method.static && checkKeyName(method, \"prototype\")) {\n      this.raise(key.start, \"Classes may not have a static property named prototype\");\n    }\n\n    // Parse value\n    var value = method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);\n\n    // Check value\n    if (method.kind === \"get\" && value.params.length !== 0)\n      { this.raiseRecoverable(value.start, \"getter should have no params\"); }\n    if (method.kind === \"set\" && value.params.length !== 1)\n      { this.raiseRecoverable(value.start, \"setter should have exactly one param\"); }\n    if (method.kind === \"set\" && value.params[0].type === \"RestElement\")\n      { this.raiseRecoverable(value.params[0].start, \"Setter cannot use rest params\"); }\n\n    return this.finishNode(method, \"MethodDefinition\")\n  };\n\n  pp$8.parseClassField = function(field) {\n    if (checkKeyName(field, \"constructor\")) {\n      this.raise(field.key.start, \"Classes can't have a field named 'constructor'\");\n    } else if (field.static && checkKeyName(field, \"prototype\")) {\n      this.raise(field.key.start, \"Classes can't have a static field named 'prototype'\");\n    }\n\n    if (this.eat(types$1.eq)) {\n      // To raise SyntaxError if 'arguments' exists in the initializer.\n      var scope = this.currentThisScope();\n      var inClassFieldInit = scope.inClassFieldInit;\n      scope.inClassFieldInit = true;\n      field.value = this.parseMaybeAssign();\n      scope.inClassFieldInit = inClassFieldInit;\n    } else {\n      field.value = null;\n    }\n    this.semicolon();\n\n    return this.finishNode(field, \"PropertyDefinition\")\n  };\n\n  pp$8.parseClassStaticBlock = function(node) {\n    node.body = [];\n\n    var oldLabels = this.labels;\n    this.labels = [];\n    this.enterScope(SCOPE_CLASS_STATIC_BLOCK | SCOPE_SUPER);\n    while (this.type !== types$1.braceR) {\n      var stmt = this.parseStatement(null);\n      node.body.push(stmt);\n    }\n    this.next();\n    this.exitScope();\n    this.labels = oldLabels;\n\n    return this.finishNode(node, \"StaticBlock\")\n  };\n\n  pp$8.parseClassId = function(node, isStatement) {\n    if (this.type === types$1.name) {\n      node.id = this.parseIdent();\n      if (isStatement)\n        { this.checkLValSimple(node.id, BIND_LEXICAL, false); }\n    } else {\n      if (isStatement === true)\n        { this.unexpected(); }\n      node.id = null;\n    }\n  };\n\n  pp$8.parseClassSuper = function(node) {\n    node.superClass = this.eat(types$1._extends) ? this.parseExprSubscripts(false) : null;\n  };\n\n  pp$8.enterClassBody = function() {\n    var element = {declared: Object.create(null), used: []};\n    this.privateNameStack.push(element);\n    return element.declared\n  };\n\n  pp$8.exitClassBody = function() {\n    var ref = this.privateNameStack.pop();\n    var declared = ref.declared;\n    var used = ref.used;\n    var len = this.privateNameStack.length;\n    var parent = len === 0 ? null : this.privateNameStack[len - 1];\n    for (var i = 0; i < used.length; ++i) {\n      var id = used[i];\n      if (!hasOwn(declared, id.name)) {\n        if (parent) {\n          parent.used.push(id);\n        } else {\n          this.raiseRecoverable(id.start, (\"Private field '#\" + (id.name) + \"' must be declared in an enclosing class\"));\n        }\n      }\n    }\n  };\n\n  function isPrivateNameConflicted(privateNameMap, element) {\n    var name = element.key.name;\n    var curr = privateNameMap[name];\n\n    var next = \"true\";\n    if (element.type === \"MethodDefinition\" && (element.kind === \"get\" || element.kind === \"set\")) {\n      next = (element.static ? \"s\" : \"i\") + element.kind;\n    }\n\n    // `class { get #a(){}; static set #a(_){} }` is also conflict.\n    if (\n      curr === \"iget\" && next === \"iset\" ||\n      curr === \"iset\" && next === \"iget\" ||\n      curr === \"sget\" && next === \"sset\" ||\n      curr === \"sset\" && next === \"sget\"\n    ) {\n      privateNameMap[name] = \"true\";\n      return false\n    } else if (!curr) {\n      privateNameMap[name] = next;\n      return false\n    } else {\n      return true\n    }\n  }\n\n  function checkKeyName(node, name) {\n    var computed = node.computed;\n    var key = node.key;\n    return !computed && (\n      key.type === \"Identifier\" && key.name === name ||\n      key.type === \"Literal\" && key.value === name\n    )\n  }\n\n  // Parses module export declaration.\n\n  pp$8.parseExport = function(node, exports) {\n    this.next();\n    // export * from '...'\n    if (this.eat(types$1.star)) {\n      if (this.options.ecmaVersion >= 11) {\n        if (this.eatContextual(\"as\")) {\n          node.exported = this.parseModuleExportName();\n          this.checkExport(exports, node.exported, this.lastTokStart);\n        } else {\n          node.exported = null;\n        }\n      }\n      this.expectContextual(\"from\");\n      if (this.type !== types$1.string) { this.unexpected(); }\n      node.source = this.parseExprAtom();\n      this.semicolon();\n      return this.finishNode(node, \"ExportAllDeclaration\")\n    }\n    if (this.eat(types$1._default)) { // export default ...\n      this.checkExport(exports, \"default\", this.lastTokStart);\n      var isAsync;\n      if (this.type === types$1._function || (isAsync = this.isAsyncFunction())) {\n        var fNode = this.startNode();\n        this.next();\n        if (isAsync) { this.next(); }\n        node.declaration = this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);\n      } else if (this.type === types$1._class) {\n        var cNode = this.startNode();\n        node.declaration = this.parseClass(cNode, \"nullableID\");\n      } else {\n        node.declaration = this.parseMaybeAssign();\n        this.semicolon();\n      }\n      return this.finishNode(node, \"ExportDefaultDeclaration\")\n    }\n    // export var|const|let|function|class ...\n    if (this.shouldParseExportStatement()) {\n      node.declaration = this.parseStatement(null);\n      if (node.declaration.type === \"VariableDeclaration\")\n        { this.checkVariableExport(exports, node.declaration.declarations); }\n      else\n        { this.checkExport(exports, node.declaration.id, node.declaration.id.start); }\n      node.specifiers = [];\n      node.source = null;\n    } else { // export { x, y as z } [from '...']\n      node.declaration = null;\n      node.specifiers = this.parseExportSpecifiers(exports);\n      if (this.eatContextual(\"from\")) {\n        if (this.type !== types$1.string) { this.unexpected(); }\n        node.source = this.parseExprAtom();\n      } else {\n        for (var i = 0, list = node.specifiers; i < list.length; i += 1) {\n          // check for keywords used as local names\n          var spec = list[i];\n\n          this.checkUnreserved(spec.local);\n          // check if export is defined\n          this.checkLocalExport(spec.local);\n\n          if (spec.local.type === \"Literal\") {\n            this.raise(spec.local.start, \"A string literal cannot be used as an exported binding without `from`.\");\n          }\n        }\n\n        node.source = null;\n      }\n      this.semicolon();\n    }\n    return this.finishNode(node, \"ExportNamedDeclaration\")\n  };\n\n  pp$8.checkExport = function(exports, name, pos) {\n    if (!exports) { return }\n    if (typeof name !== \"string\")\n      { name = name.type === \"Identifier\" ? name.name : name.value; }\n    if (hasOwn(exports, name))\n      { this.raiseRecoverable(pos, \"Duplicate export '\" + name + \"'\"); }\n    exports[name] = true;\n  };\n\n  pp$8.checkPatternExport = function(exports, pat) {\n    var type = pat.type;\n    if (type === \"Identifier\")\n      { this.checkExport(exports, pat, pat.start); }\n    else if (type === \"ObjectPattern\")\n      { for (var i = 0, list = pat.properties; i < list.length; i += 1)\n        {\n          var prop = list[i];\n\n          this.checkPatternExport(exports, prop);\n        } }\n    else if (type === \"ArrayPattern\")\n      { for (var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1) {\n        var elt = list$1[i$1];\n\n          if (elt) { this.checkPatternExport(exports, elt); }\n      } }\n    else if (type === \"Property\")\n      { this.checkPatternExport(exports, pat.value); }\n    else if (type === \"AssignmentPattern\")\n      { this.checkPatternExport(exports, pat.left); }\n    else if (type === \"RestElement\")\n      { this.checkPatternExport(exports, pat.argument); }\n    else if (type === \"ParenthesizedExpression\")\n      { this.checkPatternExport(exports, pat.expression); }\n  };\n\n  pp$8.checkVariableExport = function(exports, decls) {\n    if (!exports) { return }\n    for (var i = 0, list = decls; i < list.length; i += 1)\n      {\n      var decl = list[i];\n\n      this.checkPatternExport(exports, decl.id);\n    }\n  };\n\n  pp$8.shouldParseExportStatement = function() {\n    return this.type.keyword === \"var\" ||\n      this.type.keyword === \"const\" ||\n      this.type.keyword === \"class\" ||\n      this.type.keyword === \"function\" ||\n      this.isLet() ||\n      this.isAsyncFunction()\n  };\n\n  // Parses a comma-separated list of module exports.\n\n  pp$8.parseExportSpecifiers = function(exports) {\n    var nodes = [], first = true;\n    // export { x, y as z } [from '...']\n    this.expect(types$1.braceL);\n    while (!this.eat(types$1.braceR)) {\n      if (!first) {\n        this.expect(types$1.comma);\n        if (this.afterTrailingComma(types$1.braceR)) { break }\n      } else { first = false; }\n\n      var node = this.startNode();\n      node.local = this.parseModuleExportName();\n      node.exported = this.eatContextual(\"as\") ? this.parseModuleExportName() : node.local;\n      this.checkExport(\n        exports,\n        node.exported,\n        node.exported.start\n      );\n      nodes.push(this.finishNode(node, \"ExportSpecifier\"));\n    }\n    return nodes\n  };\n\n  // Parses import declaration.\n\n  pp$8.parseImport = function(node) {\n    this.next();\n    // import '...'\n    if (this.type === types$1.string) {\n      node.specifiers = empty$1;\n      node.source = this.parseExprAtom();\n    } else {\n      node.specifiers = this.parseImportSpecifiers();\n      this.expectContextual(\"from\");\n      node.source = this.type === types$1.string ? this.parseExprAtom() : this.unexpected();\n    }\n    this.semicolon();\n    return this.finishNode(node, \"ImportDeclaration\")\n  };\n\n  // Parses a comma-separated list of module imports.\n\n  pp$8.parseImportSpecifiers = function() {\n    var nodes = [], first = true;\n    if (this.type === types$1.name) {\n      // import defaultObj, { x, y as z } from '...'\n      var node = this.startNode();\n      node.local = this.parseIdent();\n      this.checkLValSimple(node.local, BIND_LEXICAL);\n      nodes.push(this.finishNode(node, \"ImportDefaultSpecifier\"));\n      if (!this.eat(types$1.comma)) { return nodes }\n    }\n    if (this.type === types$1.star) {\n      var node$1 = this.startNode();\n      this.next();\n      this.expectContextual(\"as\");\n      node$1.local = this.parseIdent();\n      this.checkLValSimple(node$1.local, BIND_LEXICAL);\n      nodes.push(this.finishNode(node$1, \"ImportNamespaceSpecifier\"));\n      return nodes\n    }\n    this.expect(types$1.braceL);\n    while (!this.eat(types$1.braceR)) {\n      if (!first) {\n        this.expect(types$1.comma);\n        if (this.afterTrailingComma(types$1.braceR)) { break }\n      } else { first = false; }\n\n      var node$2 = this.startNode();\n      node$2.imported = this.parseModuleExportName();\n      if (this.eatContextual(\"as\")) {\n        node$2.local = this.parseIdent();\n      } else {\n        this.checkUnreserved(node$2.imported);\n        node$2.local = node$2.imported;\n      }\n      this.checkLValSimple(node$2.local, BIND_LEXICAL);\n      nodes.push(this.finishNode(node$2, \"ImportSpecifier\"));\n    }\n    return nodes\n  };\n\n  pp$8.parseModuleExportName = function() {\n    if (this.options.ecmaVersion >= 13 && this.type === types$1.string) {\n      var stringLiteral = this.parseLiteral(this.value);\n      if (loneSurrogate.test(stringLiteral.value)) {\n        this.raise(stringLiteral.start, \"An export name cannot include a lone surrogate.\");\n      }\n      return stringLiteral\n    }\n    return this.parseIdent(true)\n  };\n\n  // Set `ExpressionStatement#directive` property for directive prologues.\n  pp$8.adaptDirectivePrologue = function(statements) {\n    for (var i = 0; i < statements.length && this.isDirectiveCandidate(statements[i]); ++i) {\n      statements[i].directive = statements[i].expression.raw.slice(1, -1);\n    }\n  };\n  pp$8.isDirectiveCandidate = function(statement) {\n    return (\n      statement.type === \"ExpressionStatement\" &&\n      statement.expression.type === \"Literal\" &&\n      typeof statement.expression.value === \"string\" &&\n      // Reject parenthesized strings.\n      (this.input[statement.start] === \"\\\"\" || this.input[statement.start] === \"'\")\n    )\n  };\n\n  var pp$7 = Parser.prototype;\n\n  // Convert existing expression atom to assignable pattern\n  // if possible.\n\n  pp$7.toAssignable = function(node, isBinding, refDestructuringErrors) {\n    if (this.options.ecmaVersion >= 6 && node) {\n      switch (node.type) {\n      case \"Identifier\":\n        if (this.inAsync && node.name === \"await\")\n          { this.raise(node.start, \"Cannot use 'await' as identifier inside an async function\"); }\n        break\n\n      case \"ObjectPattern\":\n      case \"ArrayPattern\":\n      case \"AssignmentPattern\":\n      case \"RestElement\":\n        break\n\n      case \"ObjectExpression\":\n        node.type = \"ObjectPattern\";\n        if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }\n        for (var i = 0, list = node.properties; i < list.length; i += 1) {\n          var prop = list[i];\n\n        this.toAssignable(prop, isBinding);\n          // Early error:\n          //   AssignmentRestProperty[Yield, Await] :\n          //     `...` DestructuringAssignmentTarget[Yield, Await]\n          //\n          //   It is a Syntax Error if |DestructuringAssignmentTarget| is an |ArrayLiteral| or an |ObjectLiteral|.\n          if (\n            prop.type === \"RestElement\" &&\n            (prop.argument.type === \"ArrayPattern\" || prop.argument.type === \"ObjectPattern\")\n          ) {\n            this.raise(prop.argument.start, \"Unexpected token\");\n          }\n        }\n        break\n\n      case \"Property\":\n        // AssignmentProperty has type === \"Property\"\n        if (node.kind !== \"init\") { this.raise(node.key.start, \"Object pattern can't contain getter or setter\"); }\n        this.toAssignable(node.value, isBinding);\n        break\n\n      case \"ArrayExpression\":\n        node.type = \"ArrayPattern\";\n        if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }\n        this.toAssignableList(node.elements, isBinding);\n        break\n\n      case \"SpreadElement\":\n        node.type = \"RestElement\";\n        this.toAssignable(node.argument, isBinding);\n        if (node.argument.type === \"AssignmentPattern\")\n          { this.raise(node.argument.start, \"Rest elements cannot have a default value\"); }\n        break\n\n      case \"AssignmentExpression\":\n        if (node.operator !== \"=\") { this.raise(node.left.end, \"Only '=' operator can be used for specifying default value.\"); }\n        node.type = \"AssignmentPattern\";\n        delete node.operator;\n        this.toAssignable(node.left, isBinding);\n        break\n\n      case \"ParenthesizedExpression\":\n        this.toAssignable(node.expression, isBinding, refDestructuringErrors);\n        break\n\n      case \"ChainExpression\":\n        this.raiseRecoverable(node.start, \"Optional chaining cannot appear in left-hand side\");\n        break\n\n      case \"MemberExpression\":\n        if (!isBinding) { break }\n\n      default:\n        this.raise(node.start, \"Assigning to rvalue\");\n      }\n    } else if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }\n    return node\n  };\n\n  // Convert list of expression atoms to binding list.\n\n  pp$7.toAssignableList = function(exprList, isBinding) {\n    var end = exprList.length;\n    for (var i = 0; i < end; i++) {\n      var elt = exprList[i];\n      if (elt) { this.toAssignable(elt, isBinding); }\n    }\n    if (end) {\n      var last = exprList[end - 1];\n      if (this.options.ecmaVersion === 6 && isBinding && last && last.type === \"RestElement\" && last.argument.type !== \"Identifier\")\n        { this.unexpected(last.argument.start); }\n    }\n    return exprList\n  };\n\n  // Parses spread element.\n\n  pp$7.parseSpread = function(refDestructuringErrors) {\n    var node = this.startNode();\n    this.next();\n    node.argument = this.parseMaybeAssign(false, refDestructuringErrors);\n    return this.finishNode(node, \"SpreadElement\")\n  };\n\n  pp$7.parseRestBinding = function() {\n    var node = this.startNode();\n    this.next();\n\n    // RestElement inside of a function parameter must be an identifier\n    if (this.options.ecmaVersion === 6 && this.type !== types$1.name)\n      { this.unexpected(); }\n\n    node.argument = this.parseBindingAtom();\n\n    return this.finishNode(node, \"RestElement\")\n  };\n\n  // Parses lvalue (assignable) atom.\n\n  pp$7.parseBindingAtom = function() {\n    if (this.options.ecmaVersion >= 6) {\n      switch (this.type) {\n      case types$1.bracketL:\n        var node = this.startNode();\n        this.next();\n        node.elements = this.parseBindingList(types$1.bracketR, true, true);\n        return this.finishNode(node, \"ArrayPattern\")\n\n      case types$1.braceL:\n        return this.parseObj(true)\n      }\n    }\n    return this.parseIdent()\n  };\n\n  pp$7.parseBindingList = function(close, allowEmpty, allowTrailingComma) {\n    var elts = [], first = true;\n    while (!this.eat(close)) {\n      if (first) { first = false; }\n      else { this.expect(types$1.comma); }\n      if (allowEmpty && this.type === types$1.comma) {\n        elts.push(null);\n      } else if (allowTrailingComma && this.afterTrailingComma(close)) {\n        break\n      } else if (this.type === types$1.ellipsis) {\n        var rest = this.parseRestBinding();\n        this.parseBindingListItem(rest);\n        elts.push(rest);\n        if (this.type === types$1.comma) { this.raise(this.start, \"Comma is not permitted after the rest element\"); }\n        this.expect(close);\n        break\n      } else {\n        var elem = this.parseMaybeDefault(this.start, this.startLoc);\n        this.parseBindingListItem(elem);\n        elts.push(elem);\n      }\n    }\n    return elts\n  };\n\n  pp$7.parseBindingListItem = function(param) {\n    return param\n  };\n\n  // Parses assignment pattern around given atom if possible.\n\n  pp$7.parseMaybeDefault = function(startPos, startLoc, left) {\n    left = left || this.parseBindingAtom();\n    if (this.options.ecmaVersion < 6 || !this.eat(types$1.eq)) { return left }\n    var node = this.startNodeAt(startPos, startLoc);\n    node.left = left;\n    node.right = this.parseMaybeAssign();\n    return this.finishNode(node, \"AssignmentPattern\")\n  };\n\n  // The following three functions all verify that a node is an lvalue \n  // something that can be bound, or assigned to. In order to do so, they perform\n  // a variety of checks:\n  //\n  // - Check that none of the bound/assigned-to identifiers are reserved words.\n  // - Record name declarations for bindings in the appropriate scope.\n  // - Check duplicate argument names, if checkClashes is set.\n  //\n  // If a complex binding pattern is encountered (e.g., object and array\n  // destructuring), the entire pattern is recursively checked.\n  //\n  // There are three versions of checkLVal*() appropriate for different\n  // circumstances:\n  //\n  // - checkLValSimple() shall be used if the syntactic construct supports\n  //   nothing other than identifiers and member expressions. Parenthesized\n  //   expressions are also correctly handled. This is generally appropriate for\n  //   constructs for which the spec says\n  //\n  //   > It is a Syntax Error if AssignmentTargetType of [the production] is not\n  //   > simple.\n  //\n  //   It is also appropriate for checking if an identifier is valid and not\n  //   defined elsewhere, like import declarations or function/class identifiers.\n  //\n  //   Examples where this is used include:\n  //     a += ;\n  //     import a from '';\n  //   where a is the node to be checked.\n  //\n  // - checkLValPattern() shall be used if the syntactic construct supports\n  //   anything checkLValSimple() supports, as well as object and array\n  //   destructuring patterns. This is generally appropriate for constructs for\n  //   which the spec says\n  //\n  //   > It is a Syntax Error if [the production] is neither an ObjectLiteral nor\n  //   > an ArrayLiteral and AssignmentTargetType of [the production] is not\n  //   > simple.\n  //\n  //   Examples where this is used include:\n  //     (a = );\n  //     const a = ;\n  //     try {  } catch (a) {  }\n  //   where a is the node to be checked.\n  //\n  // - checkLValInnerPattern() shall be used if the syntactic construct supports\n  //   anything checkLValPattern() supports, as well as default assignment\n  //   patterns, rest elements, and other constructs that may appear within an\n  //   object or array destructuring pattern.\n  //\n  //   As a special case, function parameters also use checkLValInnerPattern(),\n  //   as they also support defaults and rest constructs.\n  //\n  // These functions deliberately support both assignment and binding constructs,\n  // as the logic for both is exceedingly similar. If the node is the target of\n  // an assignment, then bindingType should be set to BIND_NONE. Otherwise, it\n  // should be set to the appropriate BIND_* constant, like BIND_VAR or\n  // BIND_LEXICAL.\n  //\n  // If the function is called with a non-BIND_NONE bindingType, then\n  // additionally a checkClashes object may be specified to allow checking for\n  // duplicate argument names. checkClashes is ignored if the provided construct\n  // is an assignment (i.e., bindingType is BIND_NONE).\n\n  pp$7.checkLValSimple = function(expr, bindingType, checkClashes) {\n    if ( bindingType === void 0 ) bindingType = BIND_NONE;\n\n    var isBind = bindingType !== BIND_NONE;\n\n    switch (expr.type) {\n    case \"Identifier\":\n      if (this.strict && this.reservedWordsStrictBind.test(expr.name))\n        { this.raiseRecoverable(expr.start, (isBind ? \"Binding \" : \"Assigning to \") + expr.name + \" in strict mode\"); }\n      if (isBind) {\n        if (bindingType === BIND_LEXICAL && expr.name === \"let\")\n          { this.raiseRecoverable(expr.start, \"let is disallowed as a lexically bound name\"); }\n        if (checkClashes) {\n          if (hasOwn(checkClashes, expr.name))\n            { this.raiseRecoverable(expr.start, \"Argument name clash\"); }\n          checkClashes[expr.name] = true;\n        }\n        if (bindingType !== BIND_OUTSIDE) { this.declareName(expr.name, bindingType, expr.start); }\n      }\n      break\n\n    case \"ChainExpression\":\n      this.raiseRecoverable(expr.start, \"Optional chaining cannot appear in left-hand side\");\n      break\n\n    case \"MemberExpression\":\n      if (isBind) { this.raiseRecoverable(expr.start, \"Binding member expression\"); }\n      break\n\n    case \"ParenthesizedExpression\":\n      if (isBind) { this.raiseRecoverable(expr.start, \"Binding parenthesized expression\"); }\n      return this.checkLValSimple(expr.expression, bindingType, checkClashes)\n\n    default:\n      this.raise(expr.start, (isBind ? \"Binding\" : \"Assigning to\") + \" rvalue\");\n    }\n  };\n\n  pp$7.checkLValPattern = function(expr, bindingType, checkClashes) {\n    if ( bindingType === void 0 ) bindingType = BIND_NONE;\n\n    switch (expr.type) {\n    case \"ObjectPattern\":\n      for (var i = 0, list = expr.properties; i < list.length; i += 1) {\n        var prop = list[i];\n\n      this.checkLValInnerPattern(prop, bindingType, checkClashes);\n      }\n      break\n\n    case \"ArrayPattern\":\n      for (var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1) {\n        var elem = list$1[i$1];\n\n      if (elem) { this.checkLValInnerPattern(elem, bindingType, checkClashes); }\n      }\n      break\n\n    default:\n      this.checkLValSimple(expr, bindingType, checkClashes);\n    }\n  };\n\n  pp$7.checkLValInnerPattern = function(expr, bindingType, checkClashes) {\n    if ( bindingType === void 0 ) bindingType = BIND_NONE;\n\n    switch (expr.type) {\n    case \"Property\":\n      // AssignmentProperty has type === \"Property\"\n      this.checkLValInnerPattern(expr.value, bindingType, checkClashes);\n      break\n\n    case \"AssignmentPattern\":\n      this.checkLValPattern(expr.left, bindingType, checkClashes);\n      break\n\n    case \"RestElement\":\n      this.checkLValPattern(expr.argument, bindingType, checkClashes);\n      break\n\n    default:\n      this.checkLValPattern(expr, bindingType, checkClashes);\n    }\n  };\n\n  // The algorithm used to determine whether a regexp can appear at a\n\n  var TokContext = function TokContext(token, isExpr, preserveSpace, override, generator) {\n    this.token = token;\n    this.isExpr = !!isExpr;\n    this.preserveSpace = !!preserveSpace;\n    this.override = override;\n    this.generator = !!generator;\n  };\n\n  var types = {\n    b_stat: new TokContext(\"{\", false),\n    b_expr: new TokContext(\"{\", true),\n    b_tmpl: new TokContext(\"${\", false),\n    p_stat: new TokContext(\"(\", false),\n    p_expr: new TokContext(\"(\", true),\n    q_tmpl: new TokContext(\"`\", true, true, function (p) { return p.tryReadTemplateToken(); }),\n    f_stat: new TokContext(\"function\", false),\n    f_expr: new TokContext(\"function\", true),\n    f_expr_gen: new TokContext(\"function\", true, false, null, true),\n    f_gen: new TokContext(\"function\", false, false, null, true)\n  };\n\n  var pp$6 = Parser.prototype;\n\n  pp$6.initialContext = function() {\n    return [types.b_stat]\n  };\n\n  pp$6.curContext = function() {\n    return this.context[this.context.length - 1]\n  };\n\n  pp$6.braceIsBlock = function(prevType) {\n    var parent = this.curContext();\n    if (parent === types.f_expr || parent === types.f_stat)\n      { return true }\n    if (prevType === types$1.colon && (parent === types.b_stat || parent === types.b_expr))\n      { return !parent.isExpr }\n\n    // The check for `tt.name && exprAllowed` detects whether we are\n    // after a `yield` or `of` construct. See the `updateContext` for\n    // `tt.name`.\n    if (prevType === types$1._return || prevType === types$1.name && this.exprAllowed)\n      { return lineBreak.test(this.input.slice(this.lastTokEnd, this.start)) }\n    if (prevType === types$1._else || prevType === types$1.semi || prevType === types$1.eof || prevType === types$1.parenR || prevType === types$1.arrow)\n      { return true }\n    if (prevType === types$1.braceL)\n      { return parent === types.b_stat }\n    if (prevType === types$1._var || prevType === types$1._const || prevType === types$1.name)\n      { return false }\n    return !this.exprAllowed\n  };\n\n  pp$6.inGeneratorContext = function() {\n    for (var i = this.context.length - 1; i >= 1; i--) {\n      var context = this.context[i];\n      if (context.token === \"function\")\n        { return context.generator }\n    }\n    return false\n  };\n\n  pp$6.updateContext = function(prevType) {\n    var update, type = this.type;\n    if (type.keyword && prevType === types$1.dot)\n      { this.exprAllowed = false; }\n    else if (update = type.updateContext)\n      { update.call(this, prevType); }\n    else\n      { this.exprAllowed = type.beforeExpr; }\n  };\n\n  // Used to handle egde case when token context could not be inferred correctly in tokenize phase\n  pp$6.overrideContext = function(tokenCtx) {\n    if (this.curContext() !== tokenCtx) {\n      this.context[this.context.length - 1] = tokenCtx;\n    }\n  };\n\n  // Token-specific context update code\n\n  types$1.parenR.updateContext = types$1.braceR.updateContext = function() {\n    if (this.context.length === 1) {\n      this.exprAllowed = true;\n      return\n    }\n    var out = this.context.pop();\n    if (out === types.b_stat && this.curContext().token === \"function\") {\n      out = this.context.pop();\n    }\n    this.exprAllowed = !out.isExpr;\n  };\n\n  types$1.braceL.updateContext = function(prevType) {\n    this.context.push(this.braceIsBlock(prevType) ? types.b_stat : types.b_expr);\n    this.exprAllowed = true;\n  };\n\n  types$1.dollarBraceL.updateContext = function() {\n    this.context.push(types.b_tmpl);\n    this.exprAllowed = true;\n  };\n\n  types$1.parenL.updateContext = function(prevType) {\n    var statementParens = prevType === types$1._if || prevType === types$1._for || prevType === types$1._with || prevType === types$1._while;\n    this.context.push(statementParens ? types.p_stat : types.p_expr);\n    this.exprAllowed = true;\n  };\n\n  types$1.incDec.updateContext = function() {\n    // tokExprAllowed stays unchanged\n  };\n\n  types$1._function.updateContext = types$1._class.updateContext = function(prevType) {\n    if (prevType.beforeExpr && prevType !== types$1._else &&\n        !(prevType === types$1.semi && this.curContext() !== types.p_stat) &&\n        !(prevType === types$1._return && lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) &&\n        !((prevType === types$1.colon || prevType === types$1.braceL) && this.curContext() === types.b_stat))\n      { this.context.push(types.f_expr); }\n    else\n      { this.context.push(types.f_stat); }\n    this.exprAllowed = false;\n  };\n\n  types$1.backQuote.updateContext = function() {\n    if (this.curContext() === types.q_tmpl)\n      { this.context.pop(); }\n    else\n      { this.context.push(types.q_tmpl); }\n    this.exprAllowed = false;\n  };\n\n  types$1.star.updateContext = function(prevType) {\n    if (prevType === types$1._function) {\n      var index = this.context.length - 1;\n      if (this.context[index] === types.f_expr)\n        { this.context[index] = types.f_expr_gen; }\n      else\n        { this.context[index] = types.f_gen; }\n    }\n    this.exprAllowed = true;\n  };\n\n  types$1.name.updateContext = function(prevType) {\n    var allowed = false;\n    if (this.options.ecmaVersion >= 6 && prevType !== types$1.dot) {\n      if (this.value === \"of\" && !this.exprAllowed ||\n          this.value === \"yield\" && this.inGeneratorContext())\n        { allowed = true; }\n    }\n    this.exprAllowed = allowed;\n  };\n\n  // A recursive descent parser operates by defining functions for all\n\n  var pp$5 = Parser.prototype;\n\n  // Check if property name clashes with already added.\n  // Object/class getters and setters are not allowed to clash \n  // either with each other or with an init property  and in\n  // strict mode, init properties are also not allowed to be repeated.\n\n  pp$5.checkPropClash = function(prop, propHash, refDestructuringErrors) {\n    if (this.options.ecmaVersion >= 9 && prop.type === \"SpreadElement\")\n      { return }\n    if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand))\n      { return }\n    var key = prop.key;\n    var name;\n    switch (key.type) {\n    case \"Identifier\": name = key.name; break\n    case \"Literal\": name = String(key.value); break\n    default: return\n    }\n    var kind = prop.kind;\n    if (this.options.ecmaVersion >= 6) {\n      if (name === \"__proto__\" && kind === \"init\") {\n        if (propHash.proto) {\n          if (refDestructuringErrors) {\n            if (refDestructuringErrors.doubleProto < 0) {\n              refDestructuringErrors.doubleProto = key.start;\n            }\n          } else {\n            this.raiseRecoverable(key.start, \"Redefinition of __proto__ property\");\n          }\n        }\n        propHash.proto = true;\n      }\n      return\n    }\n    name = \"$\" + name;\n    var other = propHash[name];\n    if (other) {\n      var redefinition;\n      if (kind === \"init\") {\n        redefinition = this.strict && other.init || other.get || other.set;\n      } else {\n        redefinition = other.init || other[kind];\n      }\n      if (redefinition)\n        { this.raiseRecoverable(key.start, \"Redefinition of property\"); }\n    } else {\n      other = propHash[name] = {\n        init: false,\n        get: false,\n        set: false\n      };\n    }\n    other[kind] = true;\n  };\n\n  // ### Expression parsing\n\n  // These nest, from the most general expression type at the top to\n  // 'atomic', nondivisible expression types at the bottom. Most of\n  // the functions will simply let the function(s) below them parse,\n  // and, *if* the syntactic construct they handle is present, wrap\n  // the AST node that the inner parser gave them in another node.\n\n  // Parse a full expression. The optional arguments are used to\n  // forbid the `in` operator (in for loops initalization expressions)\n  // and provide reference for storing '=' operator inside shorthand\n  // property assignment in contexts where both object expression\n  // and object pattern might appear (so it's possible to raise\n  // delayed syntax error at correct position).\n\n  pp$5.parseExpression = function(forInit, refDestructuringErrors) {\n    var startPos = this.start, startLoc = this.startLoc;\n    var expr = this.parseMaybeAssign(forInit, refDestructuringErrors);\n    if (this.type === types$1.comma) {\n      var node = this.startNodeAt(startPos, startLoc);\n      node.expressions = [expr];\n      while (this.eat(types$1.comma)) { node.expressions.push(this.parseMaybeAssign(forInit, refDestructuringErrors)); }\n      return this.finishNode(node, \"SequenceExpression\")\n    }\n    return expr\n  };\n\n  // Parse an assignment expression. This includes applications of\n  // operators like `+=`.\n\n  pp$5.parseMaybeAssign = function(forInit, refDestructuringErrors, afterLeftParse) {\n    if (this.isContextual(\"yield\")) {\n      if (this.inGenerator) { return this.parseYield(forInit) }\n      // The tokenizer will assume an expression is allowed after\n      // `yield`, but this isn't that kind of yield\n      else { this.exprAllowed = false; }\n    }\n\n    var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1, oldDoubleProto = -1;\n    if (refDestructuringErrors) {\n      oldParenAssign = refDestructuringErrors.parenthesizedAssign;\n      oldTrailingComma = refDestructuringErrors.trailingComma;\n      oldDoubleProto = refDestructuringErrors.doubleProto;\n      refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;\n    } else {\n      refDestructuringErrors = new DestructuringErrors;\n      ownDestructuringErrors = true;\n    }\n\n    var startPos = this.start, startLoc = this.startLoc;\n    if (this.type === types$1.parenL || this.type === types$1.name) {\n      this.potentialArrowAt = this.start;\n      this.potentialArrowInForAwait = forInit === \"await\";\n    }\n    var left = this.parseMaybeConditional(forInit, refDestructuringErrors);\n    if (afterLeftParse) { left = afterLeftParse.call(this, left, startPos, startLoc); }\n    if (this.type.isAssign) {\n      var node = this.startNodeAt(startPos, startLoc);\n      node.operator = this.value;\n      if (this.type === types$1.eq)\n        { left = this.toAssignable(left, false, refDestructuringErrors); }\n      if (!ownDestructuringErrors) {\n        refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.doubleProto = -1;\n      }\n      if (refDestructuringErrors.shorthandAssign >= left.start)\n        { refDestructuringErrors.shorthandAssign = -1; } // reset because shorthand default was used correctly\n      if (this.type === types$1.eq)\n        { this.checkLValPattern(left); }\n      else\n        { this.checkLValSimple(left); }\n      node.left = left;\n      this.next();\n      node.right = this.parseMaybeAssign(forInit);\n      if (oldDoubleProto > -1) { refDestructuringErrors.doubleProto = oldDoubleProto; }\n      return this.finishNode(node, \"AssignmentExpression\")\n    } else {\n      if (ownDestructuringErrors) { this.checkExpressionErrors(refDestructuringErrors, true); }\n    }\n    if (oldParenAssign > -1) { refDestructuringErrors.parenthesizedAssign = oldParenAssign; }\n    if (oldTrailingComma > -1) { refDestructuringErrors.trailingComma = oldTrailingComma; }\n    return left\n  };\n\n  // Parse a ternary conditional (`?:`) operator.\n\n  pp$5.parseMaybeConditional = function(forInit, refDestructuringErrors) {\n    var startPos = this.start, startLoc = this.startLoc;\n    var expr = this.parseExprOps(forInit, refDestructuringErrors);\n    if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }\n    if (this.eat(types$1.question)) {\n      var node = this.startNodeAt(startPos, startLoc);\n      node.test = expr;\n      node.consequent = this.parseMaybeAssign();\n      this.expect(types$1.colon);\n      node.alternate = this.parseMaybeAssign(forInit);\n      return this.finishNode(node, \"ConditionalExpression\")\n    }\n    return expr\n  };\n\n  // Start the precedence parser.\n\n  pp$5.parseExprOps = function(forInit, refDestructuringErrors) {\n    var startPos = this.start, startLoc = this.startLoc;\n    var expr = this.parseMaybeUnary(refDestructuringErrors, false, false, forInit);\n    if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }\n    return expr.start === startPos && expr.type === \"ArrowFunctionExpression\" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, forInit)\n  };\n\n  // Parse binary operators with the operator precedence parsing\n  // algorithm. `left` is the left-hand side of the operator.\n  // `minPrec` provides context that allows the function to stop and\n  // defer further parser to one of its callers when it encounters an\n  // operator that has a lower precedence than the set it is parsing.\n\n  pp$5.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, forInit) {\n    var prec = this.type.binop;\n    if (prec != null && (!forInit || this.type !== types$1._in)) {\n      if (prec > minPrec) {\n        var logical = this.type === types$1.logicalOR || this.type === types$1.logicalAND;\n        var coalesce = this.type === types$1.coalesce;\n        if (coalesce) {\n          // Handle the precedence of `tt.coalesce` as equal to the range of logical expressions.\n          // In other words, `node.right` shouldn't contain logical expressions in order to check the mixed error.\n          prec = types$1.logicalAND.binop;\n        }\n        var op = this.value;\n        this.next();\n        var startPos = this.start, startLoc = this.startLoc;\n        var right = this.parseExprOp(this.parseMaybeUnary(null, false, false, forInit), startPos, startLoc, prec, forInit);\n        var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical || coalesce);\n        if ((logical && this.type === types$1.coalesce) || (coalesce && (this.type === types$1.logicalOR || this.type === types$1.logicalAND))) {\n          this.raiseRecoverable(this.start, \"Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses\");\n        }\n        return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, forInit)\n      }\n    }\n    return left\n  };\n\n  pp$5.buildBinary = function(startPos, startLoc, left, right, op, logical) {\n    if (right.type === \"PrivateIdentifier\") { this.raise(right.start, \"Private identifier can only be left side of binary expression\"); }\n    var node = this.startNodeAt(startPos, startLoc);\n    node.left = left;\n    node.operator = op;\n    node.right = right;\n    return this.finishNode(node, logical ? \"LogicalExpression\" : \"BinaryExpression\")\n  };\n\n  // Parse unary operators, both prefix and postfix.\n\n  pp$5.parseMaybeUnary = function(refDestructuringErrors, sawUnary, incDec, forInit) {\n    var startPos = this.start, startLoc = this.startLoc, expr;\n    if (this.isContextual(\"await\") && this.canAwait) {\n      expr = this.parseAwait(forInit);\n      sawUnary = true;\n    } else if (this.type.prefix) {\n      var node = this.startNode(), update = this.type === types$1.incDec;\n      node.operator = this.value;\n      node.prefix = true;\n      this.next();\n      node.argument = this.parseMaybeUnary(null, true, update, forInit);\n      this.checkExpressionErrors(refDestructuringErrors, true);\n      if (update) { this.checkLValSimple(node.argument); }\n      else if (this.strict && node.operator === \"delete\" &&\n               node.argument.type === \"Identifier\")\n        { this.raiseRecoverable(node.start, \"Deleting local variable in strict mode\"); }\n      else if (node.operator === \"delete\" && isPrivateFieldAccess(node.argument))\n        { this.raiseRecoverable(node.start, \"Private fields can not be deleted\"); }\n      else { sawUnary = true; }\n      expr = this.finishNode(node, update ? \"UpdateExpression\" : \"UnaryExpression\");\n    } else if (!sawUnary && this.type === types$1.privateId) {\n      if (forInit || this.privateNameStack.length === 0) { this.unexpected(); }\n      expr = this.parsePrivateIdent();\n      // only could be private fields in 'in', such as #x in obj\n      if (this.type !== types$1._in) { this.unexpected(); }\n    } else {\n      expr = this.parseExprSubscripts(refDestructuringErrors, forInit);\n      if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }\n      while (this.type.postfix && !this.canInsertSemicolon()) {\n        var node$1 = this.startNodeAt(startPos, startLoc);\n        node$1.operator = this.value;\n        node$1.prefix = false;\n        node$1.argument = expr;\n        this.checkLValSimple(expr);\n        this.next();\n        expr = this.finishNode(node$1, \"UpdateExpression\");\n      }\n    }\n\n    if (!incDec && this.eat(types$1.starstar)) {\n      if (sawUnary)\n        { this.unexpected(this.lastTokStart); }\n      else\n        { return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false, false, forInit), \"**\", false) }\n    } else {\n      return expr\n    }\n  };\n\n  function isPrivateFieldAccess(node) {\n    return (\n      node.type === \"MemberExpression\" && node.property.type === \"PrivateIdentifier\" ||\n      node.type === \"ChainExpression\" && isPrivateFieldAccess(node.expression)\n    )\n  }\n\n  // Parse call, dot, and `[]`-subscript expressions.\n\n  pp$5.parseExprSubscripts = function(refDestructuringErrors, forInit) {\n    var startPos = this.start, startLoc = this.startLoc;\n    var expr = this.parseExprAtom(refDestructuringErrors, forInit);\n    if (expr.type === \"ArrowFunctionExpression\" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== \")\")\n      { return expr }\n    var result = this.parseSubscripts(expr, startPos, startLoc, false, forInit);\n    if (refDestructuringErrors && result.type === \"MemberExpression\") {\n      if (refDestructuringErrors.parenthesizedAssign >= result.start) { refDestructuringErrors.parenthesizedAssign = -1; }\n      if (refDestructuringErrors.parenthesizedBind >= result.start) { refDestructuringErrors.parenthesizedBind = -1; }\n      if (refDestructuringErrors.trailingComma >= result.start) { refDestructuringErrors.trailingComma = -1; }\n    }\n    return result\n  };\n\n  pp$5.parseSubscripts = function(base, startPos, startLoc, noCalls, forInit) {\n    var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === \"Identifier\" && base.name === \"async\" &&\n        this.lastTokEnd === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 &&\n        this.potentialArrowAt === base.start;\n    var optionalChained = false;\n\n    while (true) {\n      var element = this.parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit);\n\n      if (element.optional) { optionalChained = true; }\n      if (element === base || element.type === \"ArrowFunctionExpression\") {\n        if (optionalChained) {\n          var chainNode = this.startNodeAt(startPos, startLoc);\n          chainNode.expression = element;\n          element = this.finishNode(chainNode, \"ChainExpression\");\n        }\n        return element\n      }\n\n      base = element;\n    }\n  };\n\n  pp$5.parseSubscript = function(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit) {\n    var optionalSupported = this.options.ecmaVersion >= 11;\n    var optional = optionalSupported && this.eat(types$1.questionDot);\n    if (noCalls && optional) { this.raise(this.lastTokStart, \"Optional chaining cannot appear in the callee of new expressions\"); }\n\n    var computed = this.eat(types$1.bracketL);\n    if (computed || (optional && this.type !== types$1.parenL && this.type !== types$1.backQuote) || this.eat(types$1.dot)) {\n      var node = this.startNodeAt(startPos, startLoc);\n      node.object = base;\n      if (computed) {\n        node.property = this.parseExpression();\n        this.expect(types$1.bracketR);\n      } else if (this.type === types$1.privateId && base.type !== \"Super\") {\n        node.property = this.parsePrivateIdent();\n      } else {\n        node.property = this.parseIdent(this.options.allowReserved !== \"never\");\n      }\n      node.computed = !!computed;\n      if (optionalSupported) {\n        node.optional = optional;\n      }\n      base = this.finishNode(node, \"MemberExpression\");\n    } else if (!noCalls && this.eat(types$1.parenL)) {\n      var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;\n      this.yieldPos = 0;\n      this.awaitPos = 0;\n      this.awaitIdentPos = 0;\n      var exprList = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false, refDestructuringErrors);\n      if (maybeAsyncArrow && !optional && !this.canInsertSemicolon() && this.eat(types$1.arrow)) {\n        this.checkPatternErrors(refDestructuringErrors, false);\n        this.checkYieldAwaitInDefaultParams();\n        if (this.awaitIdentPos > 0)\n          { this.raise(this.awaitIdentPos, \"Cannot use 'await' as identifier inside an async function\"); }\n        this.yieldPos = oldYieldPos;\n        this.awaitPos = oldAwaitPos;\n        this.awaitIdentPos = oldAwaitIdentPos;\n        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true, forInit)\n      }\n      this.checkExpressionErrors(refDestructuringErrors, true);\n      this.yieldPos = oldYieldPos || this.yieldPos;\n      this.awaitPos = oldAwaitPos || this.awaitPos;\n      this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;\n      var node$1 = this.startNodeAt(startPos, startLoc);\n      node$1.callee = base;\n      node$1.arguments = exprList;\n      if (optionalSupported) {\n        node$1.optional = optional;\n      }\n      base = this.finishNode(node$1, \"CallExpression\");\n    } else if (this.type === types$1.backQuote) {\n      if (optional || optionalChained) {\n        this.raise(this.start, \"Optional chaining cannot appear in the tag of tagged template expressions\");\n      }\n      var node$2 = this.startNodeAt(startPos, startLoc);\n      node$2.tag = base;\n      node$2.quasi = this.parseTemplate({isTagged: true});\n      base = this.finishNode(node$2, \"TaggedTemplateExpression\");\n    }\n    return base\n  };\n\n  // Parse an atomic expression  either a single token that is an\n  // expression, an expression started by a keyword like `function` or\n  // `new`, or an expression wrapped in punctuation like `()`, `[]`,\n  // or `{}`.\n\n  pp$5.parseExprAtom = function(refDestructuringErrors, forInit) {\n    // If a division operator appears in an expression position, the\n    // tokenizer got confused, and we force it to read a regexp instead.\n    if (this.type === types$1.slash) { this.readRegexp(); }\n\n    var node, canBeArrow = this.potentialArrowAt === this.start;\n    switch (this.type) {\n    case types$1._super:\n      if (!this.allowSuper)\n        { this.raise(this.start, \"'super' keyword outside a method\"); }\n      node = this.startNode();\n      this.next();\n      if (this.type === types$1.parenL && !this.allowDirectSuper)\n        { this.raise(node.start, \"super() call outside constructor of a subclass\"); }\n      // The `super` keyword can appear at below:\n      // SuperProperty:\n      //     super [ Expression ]\n      //     super . IdentifierName\n      // SuperCall:\n      //     super ( Arguments )\n      if (this.type !== types$1.dot && this.type !== types$1.bracketL && this.type !== types$1.parenL)\n        { this.unexpected(); }\n      return this.finishNode(node, \"Super\")\n\n    case types$1._this:\n      node = this.startNode();\n      this.next();\n      return this.finishNode(node, \"ThisExpression\")\n\n    case types$1.name:\n      var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;\n      var id = this.parseIdent(false);\n      if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === \"async\" && !this.canInsertSemicolon() && this.eat(types$1._function)) {\n        this.overrideContext(types.f_expr);\n        return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true, forInit)\n      }\n      if (canBeArrow && !this.canInsertSemicolon()) {\n        if (this.eat(types$1.arrow))\n          { return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false, forInit) }\n        if (this.options.ecmaVersion >= 8 && id.name === \"async\" && this.type === types$1.name && !containsEsc &&\n            (!this.potentialArrowInForAwait || this.value !== \"of\" || this.containsEsc)) {\n          id = this.parseIdent(false);\n          if (this.canInsertSemicolon() || !this.eat(types$1.arrow))\n            { this.unexpected(); }\n          return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true, forInit)\n        }\n      }\n      return id\n\n    case types$1.regexp:\n      var value = this.value;\n      node = this.parseLiteral(value.value);\n      node.regex = {pattern: value.pattern, flags: value.flags};\n      return node\n\n    case types$1.num: case types$1.string:\n      return this.parseLiteral(this.value)\n\n    case types$1._null: case types$1._true: case types$1._false:\n      node = this.startNode();\n      node.value = this.type === types$1._null ? null : this.type === types$1._true;\n      node.raw = this.type.keyword;\n      this.next();\n      return this.finishNode(node, \"Literal\")\n\n    case types$1.parenL:\n      var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow, forInit);\n      if (refDestructuringErrors) {\n        if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr))\n          { refDestructuringErrors.parenthesizedAssign = start; }\n        if (refDestructuringErrors.parenthesizedBind < 0)\n          { refDestructuringErrors.parenthesizedBind = start; }\n      }\n      return expr\n\n    case types$1.bracketL:\n      node = this.startNode();\n      this.next();\n      node.elements = this.parseExprList(types$1.bracketR, true, true, refDestructuringErrors);\n      return this.finishNode(node, \"ArrayExpression\")\n\n    case types$1.braceL:\n      this.overrideContext(types.b_expr);\n      return this.parseObj(false, refDestructuringErrors)\n\n    case types$1._function:\n      node = this.startNode();\n      this.next();\n      return this.parseFunction(node, 0)\n\n    case types$1._class:\n      return this.parseClass(this.startNode(), false)\n\n    case types$1._new:\n      return this.parseNew()\n\n    case types$1.backQuote:\n      return this.parseTemplate()\n\n    case types$1._import:\n      if (this.options.ecmaVersion >= 11) {\n        return this.parseExprImport()\n      } else {\n        return this.unexpected()\n      }\n\n    default:\n      this.unexpected();\n    }\n  };\n\n  pp$5.parseExprImport = function() {\n    var node = this.startNode();\n\n    // Consume `import` as an identifier for `import.meta`.\n    // Because `this.parseIdent(true)` doesn't check escape sequences, it needs the check of `this.containsEsc`.\n    if (this.containsEsc) { this.raiseRecoverable(this.start, \"Escape sequence in keyword import\"); }\n    var meta = this.parseIdent(true);\n\n    switch (this.type) {\n    case types$1.parenL:\n      return this.parseDynamicImport(node)\n    case types$1.dot:\n      node.meta = meta;\n      return this.parseImportMeta(node)\n    default:\n      this.unexpected();\n    }\n  };\n\n  pp$5.parseDynamicImport = function(node) {\n    this.next(); // skip `(`\n\n    // Parse node.source.\n    node.source = this.parseMaybeAssign();\n\n    // Verify ending.\n    if (!this.eat(types$1.parenR)) {\n      var errorPos = this.start;\n      if (this.eat(types$1.comma) && this.eat(types$1.parenR)) {\n        this.raiseRecoverable(errorPos, \"Trailing comma is not allowed in import()\");\n      } else {\n        this.unexpected(errorPos);\n      }\n    }\n\n    return this.finishNode(node, \"ImportExpression\")\n  };\n\n  pp$5.parseImportMeta = function(node) {\n    this.next(); // skip `.`\n\n    var containsEsc = this.containsEsc;\n    node.property = this.parseIdent(true);\n\n    if (node.property.name !== \"meta\")\n      { this.raiseRecoverable(node.property.start, \"The only valid meta property for import is 'import.meta'\"); }\n    if (containsEsc)\n      { this.raiseRecoverable(node.start, \"'import.meta' must not contain escaped characters\"); }\n    if (this.options.sourceType !== \"module\" && !this.options.allowImportExportEverywhere)\n      { this.raiseRecoverable(node.start, \"Cannot use 'import.meta' outside a module\"); }\n\n    return this.finishNode(node, \"MetaProperty\")\n  };\n\n  pp$5.parseLiteral = function(value) {\n    var node = this.startNode();\n    node.value = value;\n    node.raw = this.input.slice(this.start, this.end);\n    if (node.raw.charCodeAt(node.raw.length - 1) === 110) { node.bigint = node.raw.slice(0, -1).replace(/_/g, \"\"); }\n    this.next();\n    return this.finishNode(node, \"Literal\")\n  };\n\n  pp$5.parseParenExpression = function() {\n    this.expect(types$1.parenL);\n    var val = this.parseExpression();\n    this.expect(types$1.parenR);\n    return val\n  };\n\n  pp$5.parseParenAndDistinguishExpression = function(canBeArrow, forInit) {\n    var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;\n    if (this.options.ecmaVersion >= 6) {\n      this.next();\n\n      var innerStartPos = this.start, innerStartLoc = this.startLoc;\n      var exprList = [], first = true, lastIsComma = false;\n      var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;\n      this.yieldPos = 0;\n      this.awaitPos = 0;\n      // Do not save awaitIdentPos to allow checking awaits nested in parameters\n      while (this.type !== types$1.parenR) {\n        first ? first = false : this.expect(types$1.comma);\n        if (allowTrailingComma && this.afterTrailingComma(types$1.parenR, true)) {\n          lastIsComma = true;\n          break\n        } else if (this.type === types$1.ellipsis) {\n          spreadStart = this.start;\n          exprList.push(this.parseParenItem(this.parseRestBinding()));\n          if (this.type === types$1.comma) { this.raise(this.start, \"Comma is not permitted after the rest element\"); }\n          break\n        } else {\n          exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));\n        }\n      }\n      var innerEndPos = this.lastTokEnd, innerEndLoc = this.lastTokEndLoc;\n      this.expect(types$1.parenR);\n\n      if (canBeArrow && !this.canInsertSemicolon() && this.eat(types$1.arrow)) {\n        this.checkPatternErrors(refDestructuringErrors, false);\n        this.checkYieldAwaitInDefaultParams();\n        this.yieldPos = oldYieldPos;\n        this.awaitPos = oldAwaitPos;\n        return this.parseParenArrowList(startPos, startLoc, exprList, forInit)\n      }\n\n      if (!exprList.length || lastIsComma) { this.unexpected(this.lastTokStart); }\n      if (spreadStart) { this.unexpected(spreadStart); }\n      this.checkExpressionErrors(refDestructuringErrors, true);\n      this.yieldPos = oldYieldPos || this.yieldPos;\n      this.awaitPos = oldAwaitPos || this.awaitPos;\n\n      if (exprList.length > 1) {\n        val = this.startNodeAt(innerStartPos, innerStartLoc);\n        val.expressions = exprList;\n        this.finishNodeAt(val, \"SequenceExpression\", innerEndPos, innerEndLoc);\n      } else {\n        val = exprList[0];\n      }\n    } else {\n      val = this.parseParenExpression();\n    }\n\n    if (this.options.preserveParens) {\n      var par = this.startNodeAt(startPos, startLoc);\n      par.expression = val;\n      return this.finishNode(par, \"ParenthesizedExpression\")\n    } else {\n      return val\n    }\n  };\n\n  pp$5.parseParenItem = function(item) {\n    return item\n  };\n\n  pp$5.parseParenArrowList = function(startPos, startLoc, exprList, forInit) {\n    return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, false, forInit)\n  };\n\n  // New's precedence is slightly tricky. It must allow its argument to\n  // be a `[]` or dot subscript expression, but not a call  at least,\n  // not without wrapping it in parentheses. Thus, it uses the noCalls\n  // argument to parseSubscripts to prevent it from consuming the\n  // argument list.\n\n  var empty = [];\n\n  pp$5.parseNew = function() {\n    if (this.containsEsc) { this.raiseRecoverable(this.start, \"Escape sequence in keyword new\"); }\n    var node = this.startNode();\n    var meta = this.parseIdent(true);\n    if (this.options.ecmaVersion >= 6 && this.eat(types$1.dot)) {\n      node.meta = meta;\n      var containsEsc = this.containsEsc;\n      node.property = this.parseIdent(true);\n      if (node.property.name !== \"target\")\n        { this.raiseRecoverable(node.property.start, \"The only valid meta property for new is 'new.target'\"); }\n      if (containsEsc)\n        { this.raiseRecoverable(node.start, \"'new.target' must not contain escaped characters\"); }\n      if (!this.allowNewDotTarget)\n        { this.raiseRecoverable(node.start, \"'new.target' can only be used in functions and class static block\"); }\n      return this.finishNode(node, \"MetaProperty\")\n    }\n    var startPos = this.start, startLoc = this.startLoc, isImport = this.type === types$1._import;\n    node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true, false);\n    if (isImport && node.callee.type === \"ImportExpression\") {\n      this.raise(startPos, \"Cannot use new with import()\");\n    }\n    if (this.eat(types$1.parenL)) { node.arguments = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false); }\n    else { node.arguments = empty; }\n    return this.finishNode(node, \"NewExpression\")\n  };\n\n  // Parse template expression.\n\n  pp$5.parseTemplateElement = function(ref) {\n    var isTagged = ref.isTagged;\n\n    var elem = this.startNode();\n    if (this.type === types$1.invalidTemplate) {\n      if (!isTagged) {\n        this.raiseRecoverable(this.start, \"Bad escape sequence in untagged template literal\");\n      }\n      elem.value = {\n        raw: this.value,\n        cooked: null\n      };\n    } else {\n      elem.value = {\n        raw: this.input.slice(this.start, this.end).replace(/\\r\\n?/g, \"\\n\"),\n        cooked: this.value\n      };\n    }\n    this.next();\n    elem.tail = this.type === types$1.backQuote;\n    return this.finishNode(elem, \"TemplateElement\")\n  };\n\n  pp$5.parseTemplate = function(ref) {\n    if ( ref === void 0 ) ref = {};\n    var isTagged = ref.isTagged; if ( isTagged === void 0 ) isTagged = false;\n\n    var node = this.startNode();\n    this.next();\n    node.expressions = [];\n    var curElt = this.parseTemplateElement({isTagged: isTagged});\n    node.quasis = [curElt];\n    while (!curElt.tail) {\n      if (this.type === types$1.eof) { this.raise(this.pos, \"Unterminated template literal\"); }\n      this.expect(types$1.dollarBraceL);\n      node.expressions.push(this.parseExpression());\n      this.expect(types$1.braceR);\n      node.quasis.push(curElt = this.parseTemplateElement({isTagged: isTagged}));\n    }\n    this.next();\n    return this.finishNode(node, \"TemplateLiteral\")\n  };\n\n  pp$5.isAsyncProp = function(prop) {\n    return !prop.computed && prop.key.type === \"Identifier\" && prop.key.name === \"async\" &&\n      (this.type === types$1.name || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword || (this.options.ecmaVersion >= 9 && this.type === types$1.star)) &&\n      !lineBreak.test(this.input.slice(this.lastTokEnd, this.start))\n  };\n\n  // Parse an object literal or binding pattern.\n\n  pp$5.parseObj = function(isPattern, refDestructuringErrors) {\n    var node = this.startNode(), first = true, propHash = {};\n    node.properties = [];\n    this.next();\n    while (!this.eat(types$1.braceR)) {\n      if (!first) {\n        this.expect(types$1.comma);\n        if (this.options.ecmaVersion >= 5 && this.afterTrailingComma(types$1.braceR)) { break }\n      } else { first = false; }\n\n      var prop = this.parseProperty(isPattern, refDestructuringErrors);\n      if (!isPattern) { this.checkPropClash(prop, propHash, refDestructuringErrors); }\n      node.properties.push(prop);\n    }\n    return this.finishNode(node, isPattern ? \"ObjectPattern\" : \"ObjectExpression\")\n  };\n\n  pp$5.parseProperty = function(isPattern, refDestructuringErrors) {\n    var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;\n    if (this.options.ecmaVersion >= 9 && this.eat(types$1.ellipsis)) {\n      if (isPattern) {\n        prop.argument = this.parseIdent(false);\n        if (this.type === types$1.comma) {\n          this.raise(this.start, \"Comma is not permitted after the rest element\");\n        }\n        return this.finishNode(prop, \"RestElement\")\n      }\n      // To disallow parenthesized identifier via `this.toAssignable()`.\n      if (this.type === types$1.parenL && refDestructuringErrors) {\n        if (refDestructuringErrors.parenthesizedAssign < 0) {\n          refDestructuringErrors.parenthesizedAssign = this.start;\n        }\n        if (refDestructuringErrors.parenthesizedBind < 0) {\n          refDestructuringErrors.parenthesizedBind = this.start;\n        }\n      }\n      // Parse argument.\n      prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);\n      // To disallow trailing comma via `this.toAssignable()`.\n      if (this.type === types$1.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {\n        refDestructuringErrors.trailingComma = this.start;\n      }\n      // Finish\n      return this.finishNode(prop, \"SpreadElement\")\n    }\n    if (this.options.ecmaVersion >= 6) {\n      prop.method = false;\n      prop.shorthand = false;\n      if (isPattern || refDestructuringErrors) {\n        startPos = this.start;\n        startLoc = this.startLoc;\n      }\n      if (!isPattern)\n        { isGenerator = this.eat(types$1.star); }\n    }\n    var containsEsc = this.containsEsc;\n    this.parsePropertyName(prop);\n    if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {\n      isAsync = true;\n      isGenerator = this.options.ecmaVersion >= 9 && this.eat(types$1.star);\n      this.parsePropertyName(prop, refDestructuringErrors);\n    } else {\n      isAsync = false;\n    }\n    this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);\n    return this.finishNode(prop, \"Property\")\n  };\n\n  pp$5.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {\n    if ((isGenerator || isAsync) && this.type === types$1.colon)\n      { this.unexpected(); }\n\n    if (this.eat(types$1.colon)) {\n      prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);\n      prop.kind = \"init\";\n    } else if (this.options.ecmaVersion >= 6 && this.type === types$1.parenL) {\n      if (isPattern) { this.unexpected(); }\n      prop.kind = \"init\";\n      prop.method = true;\n      prop.value = this.parseMethod(isGenerator, isAsync);\n    } else if (!isPattern && !containsEsc &&\n               this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === \"Identifier\" &&\n               (prop.key.name === \"get\" || prop.key.name === \"set\") &&\n               (this.type !== types$1.comma && this.type !== types$1.braceR && this.type !== types$1.eq)) {\n      if (isGenerator || isAsync) { this.unexpected(); }\n      prop.kind = prop.key.name;\n      this.parsePropertyName(prop);\n      prop.value = this.parseMethod(false);\n      var paramCount = prop.kind === \"get\" ? 0 : 1;\n      if (prop.value.params.length !== paramCount) {\n        var start = prop.value.start;\n        if (prop.kind === \"get\")\n          { this.raiseRecoverable(start, \"getter should have no params\"); }\n        else\n          { this.raiseRecoverable(start, \"setter should have exactly one param\"); }\n      } else {\n        if (prop.kind === \"set\" && prop.value.params[0].type === \"RestElement\")\n          { this.raiseRecoverable(prop.value.params[0].start, \"Setter cannot use rest params\"); }\n      }\n    } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === \"Identifier\") {\n      if (isGenerator || isAsync) { this.unexpected(); }\n      this.checkUnreserved(prop.key);\n      if (prop.key.name === \"await\" && !this.awaitIdentPos)\n        { this.awaitIdentPos = startPos; }\n      prop.kind = \"init\";\n      if (isPattern) {\n        prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));\n      } else if (this.type === types$1.eq && refDestructuringErrors) {\n        if (refDestructuringErrors.shorthandAssign < 0)\n          { refDestructuringErrors.shorthandAssign = this.start; }\n        prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));\n      } else {\n        prop.value = this.copyNode(prop.key);\n      }\n      prop.shorthand = true;\n    } else { this.unexpected(); }\n  };\n\n  pp$5.parsePropertyName = function(prop) {\n    if (this.options.ecmaVersion >= 6) {\n      if (this.eat(types$1.bracketL)) {\n        prop.computed = true;\n        prop.key = this.parseMaybeAssign();\n        this.expect(types$1.bracketR);\n        return prop.key\n      } else {\n        prop.computed = false;\n      }\n    }\n    return prop.key = this.type === types$1.num || this.type === types$1.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== \"never\")\n  };\n\n  // Initialize empty function node.\n\n  pp$5.initFunction = function(node) {\n    node.id = null;\n    if (this.options.ecmaVersion >= 6) { node.generator = node.expression = false; }\n    if (this.options.ecmaVersion >= 8) { node.async = false; }\n  };\n\n  // Parse object or class method.\n\n  pp$5.parseMethod = function(isGenerator, isAsync, allowDirectSuper) {\n    var node = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;\n\n    this.initFunction(node);\n    if (this.options.ecmaVersion >= 6)\n      { node.generator = isGenerator; }\n    if (this.options.ecmaVersion >= 8)\n      { node.async = !!isAsync; }\n\n    this.yieldPos = 0;\n    this.awaitPos = 0;\n    this.awaitIdentPos = 0;\n    this.enterScope(functionFlags(isAsync, node.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));\n\n    this.expect(types$1.parenL);\n    node.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);\n    this.checkYieldAwaitInDefaultParams();\n    this.parseFunctionBody(node, false, true, false);\n\n    this.yieldPos = oldYieldPos;\n    this.awaitPos = oldAwaitPos;\n    this.awaitIdentPos = oldAwaitIdentPos;\n    return this.finishNode(node, \"FunctionExpression\")\n  };\n\n  // Parse arrow function expression with given parameters.\n\n  pp$5.parseArrowExpression = function(node, params, isAsync, forInit) {\n    var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;\n\n    this.enterScope(functionFlags(isAsync, false) | SCOPE_ARROW);\n    this.initFunction(node);\n    if (this.options.ecmaVersion >= 8) { node.async = !!isAsync; }\n\n    this.yieldPos = 0;\n    this.awaitPos = 0;\n    this.awaitIdentPos = 0;\n\n    node.params = this.toAssignableList(params, true);\n    this.parseFunctionBody(node, true, false, forInit);\n\n    this.yieldPos = oldYieldPos;\n    this.awaitPos = oldAwaitPos;\n    this.awaitIdentPos = oldAwaitIdentPos;\n    return this.finishNode(node, \"ArrowFunctionExpression\")\n  };\n\n  // Parse function body and check parameters.\n\n  pp$5.parseFunctionBody = function(node, isArrowFunction, isMethod, forInit) {\n    var isExpression = isArrowFunction && this.type !== types$1.braceL;\n    var oldStrict = this.strict, useStrict = false;\n\n    if (isExpression) {\n      node.body = this.parseMaybeAssign(forInit);\n      node.expression = true;\n      this.checkParams(node, false);\n    } else {\n      var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);\n      if (!oldStrict || nonSimple) {\n        useStrict = this.strictDirective(this.end);\n        // If this is a strict mode function, verify that argument names\n        // are not repeated, and it does not try to bind the words `eval`\n        // or `arguments`.\n        if (useStrict && nonSimple)\n          { this.raiseRecoverable(node.start, \"Illegal 'use strict' directive in function with non-simple parameter list\"); }\n      }\n      // Start a new scope with regard to labels and the `inFunction`\n      // flag (restore them to their old value afterwards).\n      var oldLabels = this.labels;\n      this.labels = [];\n      if (useStrict) { this.strict = true; }\n\n      // Add the params to varDeclaredNames to ensure that an error is thrown\n      // if a let/const declaration in the function clashes with one of the params.\n      this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node.params));\n      // Ensure the function name isn't a forbidden identifier in strict mode, e.g. 'eval'\n      if (this.strict && node.id) { this.checkLValSimple(node.id, BIND_OUTSIDE); }\n      node.body = this.parseBlock(false, undefined, useStrict && !oldStrict);\n      node.expression = false;\n      this.adaptDirectivePrologue(node.body.body);\n      this.labels = oldLabels;\n    }\n    this.exitScope();\n  };\n\n  pp$5.isSimpleParamList = function(params) {\n    for (var i = 0, list = params; i < list.length; i += 1)\n      {\n      var param = list[i];\n\n      if (param.type !== \"Identifier\") { return false\n    } }\n    return true\n  };\n\n  // Checks function params for various disallowed patterns such as using \"eval\"\n  // or \"arguments\" and duplicate parameters.\n\n  pp$5.checkParams = function(node, allowDuplicates) {\n    var nameHash = Object.create(null);\n    for (var i = 0, list = node.params; i < list.length; i += 1)\n      {\n      var param = list[i];\n\n      this.checkLValInnerPattern(param, BIND_VAR, allowDuplicates ? null : nameHash);\n    }\n  };\n\n  // Parses a comma-separated list of expressions, and returns them as\n  // an array. `close` is the token type that ends the list, and\n  // `allowEmpty` can be turned on to allow subsequent commas with\n  // nothing in between them to be parsed as `null` (which is needed\n  // for array literals).\n\n  pp$5.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {\n    var elts = [], first = true;\n    while (!this.eat(close)) {\n      if (!first) {\n        this.expect(types$1.comma);\n        if (allowTrailingComma && this.afterTrailingComma(close)) { break }\n      } else { first = false; }\n\n      var elt = (void 0);\n      if (allowEmpty && this.type === types$1.comma)\n        { elt = null; }\n      else if (this.type === types$1.ellipsis) {\n        elt = this.parseSpread(refDestructuringErrors);\n        if (refDestructuringErrors && this.type === types$1.comma && refDestructuringErrors.trailingComma < 0)\n          { refDestructuringErrors.trailingComma = this.start; }\n      } else {\n        elt = this.parseMaybeAssign(false, refDestructuringErrors);\n      }\n      elts.push(elt);\n    }\n    return elts\n  };\n\n  pp$5.checkUnreserved = function(ref) {\n    var start = ref.start;\n    var end = ref.end;\n    var name = ref.name;\n\n    if (this.inGenerator && name === \"yield\")\n      { this.raiseRecoverable(start, \"Cannot use 'yield' as identifier inside a generator\"); }\n    if (this.inAsync && name === \"await\")\n      { this.raiseRecoverable(start, \"Cannot use 'await' as identifier inside an async function\"); }\n    if (this.currentThisScope().inClassFieldInit && name === \"arguments\")\n      { this.raiseRecoverable(start, \"Cannot use 'arguments' in class field initializer\"); }\n    if (this.inClassStaticBlock && (name === \"arguments\" || name === \"await\"))\n      { this.raise(start, (\"Cannot use \" + name + \" in class static initialization block\")); }\n    if (this.keywords.test(name))\n      { this.raise(start, (\"Unexpected keyword '\" + name + \"'\")); }\n    if (this.options.ecmaVersion < 6 &&\n      this.input.slice(start, end).indexOf(\"\\\\\") !== -1) { return }\n    var re = this.strict ? this.reservedWordsStrict : this.reservedWords;\n    if (re.test(name)) {\n      if (!this.inAsync && name === \"await\")\n        { this.raiseRecoverable(start, \"Cannot use keyword 'await' outside an async function\"); }\n      this.raiseRecoverable(start, (\"The keyword '\" + name + \"' is reserved\"));\n    }\n  };\n\n  // Parse the next token as an identifier. If `liberal` is true (used\n  // when parsing properties), it will also convert keywords into\n  // identifiers.\n\n  pp$5.parseIdent = function(liberal, isBinding) {\n    var node = this.startNode();\n    if (this.type === types$1.name) {\n      node.name = this.value;\n    } else if (this.type.keyword) {\n      node.name = this.type.keyword;\n\n      // To fix https://github.com/acornjs/acorn/issues/575\n      // `class` and `function` keywords push new context into this.context.\n      // But there is no chance to pop the context if the keyword is consumed as an identifier such as a property name.\n      // If the previous token is a dot, this does not apply because the context-managing code already ignored the keyword\n      if ((node.name === \"class\" || node.name === \"function\") &&\n          (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {\n        this.context.pop();\n      }\n    } else {\n      this.unexpected();\n    }\n    this.next(!!liberal);\n    this.finishNode(node, \"Identifier\");\n    if (!liberal) {\n      this.checkUnreserved(node);\n      if (node.name === \"await\" && !this.awaitIdentPos)\n        { this.awaitIdentPos = node.start; }\n    }\n    return node\n  };\n\n  pp$5.parsePrivateIdent = function() {\n    var node = this.startNode();\n    if (this.type === types$1.privateId) {\n      node.name = this.value;\n    } else {\n      this.unexpected();\n    }\n    this.next();\n    this.finishNode(node, \"PrivateIdentifier\");\n\n    // For validating existence\n    if (this.privateNameStack.length === 0) {\n      this.raise(node.start, (\"Private field '#\" + (node.name) + \"' must be declared in an enclosing class\"));\n    } else {\n      this.privateNameStack[this.privateNameStack.length - 1].used.push(node);\n    }\n\n    return node\n  };\n\n  // Parses yield expression inside generator.\n\n  pp$5.parseYield = function(forInit) {\n    if (!this.yieldPos) { this.yieldPos = this.start; }\n\n    var node = this.startNode();\n    this.next();\n    if (this.type === types$1.semi || this.canInsertSemicolon() || (this.type !== types$1.star && !this.type.startsExpr)) {\n      node.delegate = false;\n      node.argument = null;\n    } else {\n      node.delegate = this.eat(types$1.star);\n      node.argument = this.parseMaybeAssign(forInit);\n    }\n    return this.finishNode(node, \"YieldExpression\")\n  };\n\n  pp$5.parseAwait = function(forInit) {\n    if (!this.awaitPos) { this.awaitPos = this.start; }\n\n    var node = this.startNode();\n    this.next();\n    node.argument = this.parseMaybeUnary(null, true, false, forInit);\n    return this.finishNode(node, \"AwaitExpression\")\n  };\n\n  var pp$4 = Parser.prototype;\n\n  // This function is used to raise exceptions on parse errors. It\n  // takes an offset integer (into the current `input`) to indicate\n  // the location of the error, attaches the position to the end\n  // of the error message, and then raises a `SyntaxError` with that\n  // message.\n\n  pp$4.raise = function(pos, message) {\n    var loc = getLineInfo(this.input, pos);\n    message += \" (\" + loc.line + \":\" + loc.column + \")\";\n    var err = new SyntaxError(message);\n    err.pos = pos; err.loc = loc; err.raisedAt = this.pos;\n    throw err\n  };\n\n  pp$4.raiseRecoverable = pp$4.raise;\n\n  pp$4.curPosition = function() {\n    if (this.options.locations) {\n      return new Position(this.curLine, this.pos - this.lineStart)\n    }\n  };\n\n  var pp$3 = Parser.prototype;\n\n  var Scope = function Scope(flags) {\n    this.flags = flags;\n    // A list of var-declared names in the current lexical scope\n    this.var = [];\n    // A list of lexically-declared names in the current lexical scope\n    this.lexical = [];\n    // A list of lexically-declared FunctionDeclaration names in the current lexical scope\n    this.functions = [];\n    // A switch to disallow the identifier reference 'arguments'\n    this.inClassFieldInit = false;\n  };\n\n  // The functions in this module keep track of declared variables in the current scope in order to detect duplicate variable names.\n\n  pp$3.enterScope = function(flags) {\n    this.scopeStack.push(new Scope(flags));\n  };\n\n  pp$3.exitScope = function() {\n    this.scopeStack.pop();\n  };\n\n  // The spec says:\n  // > At the top level of a function, or script, function declarations are\n  // > treated like var declarations rather than like lexical declarations.\n  pp$3.treatFunctionsAsVarInScope = function(scope) {\n    return (scope.flags & SCOPE_FUNCTION) || !this.inModule && (scope.flags & SCOPE_TOP)\n  };\n\n  pp$3.declareName = function(name, bindingType, pos) {\n    var redeclared = false;\n    if (bindingType === BIND_LEXICAL) {\n      var scope = this.currentScope();\n      redeclared = scope.lexical.indexOf(name) > -1 || scope.functions.indexOf(name) > -1 || scope.var.indexOf(name) > -1;\n      scope.lexical.push(name);\n      if (this.inModule && (scope.flags & SCOPE_TOP))\n        { delete this.undefinedExports[name]; }\n    } else if (bindingType === BIND_SIMPLE_CATCH) {\n      var scope$1 = this.currentScope();\n      scope$1.lexical.push(name);\n    } else if (bindingType === BIND_FUNCTION) {\n      var scope$2 = this.currentScope();\n      if (this.treatFunctionsAsVar)\n        { redeclared = scope$2.lexical.indexOf(name) > -1; }\n      else\n        { redeclared = scope$2.lexical.indexOf(name) > -1 || scope$2.var.indexOf(name) > -1; }\n      scope$2.functions.push(name);\n    } else {\n      for (var i = this.scopeStack.length - 1; i >= 0; --i) {\n        var scope$3 = this.scopeStack[i];\n        if (scope$3.lexical.indexOf(name) > -1 && !((scope$3.flags & SCOPE_SIMPLE_CATCH) && scope$3.lexical[0] === name) ||\n            !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name) > -1) {\n          redeclared = true;\n          break\n        }\n        scope$3.var.push(name);\n        if (this.inModule && (scope$3.flags & SCOPE_TOP))\n          { delete this.undefinedExports[name]; }\n        if (scope$3.flags & SCOPE_VAR) { break }\n      }\n    }\n    if (redeclared) { this.raiseRecoverable(pos, (\"Identifier '\" + name + \"' has already been declared\")); }\n  };\n\n  pp$3.checkLocalExport = function(id) {\n    // scope.functions must be empty as Module code is always strict.\n    if (this.scopeStack[0].lexical.indexOf(id.name) === -1 &&\n        this.scopeStack[0].var.indexOf(id.name) === -1) {\n      this.undefinedExports[id.name] = id;\n    }\n  };\n\n  pp$3.currentScope = function() {\n    return this.scopeStack[this.scopeStack.length - 1]\n  };\n\n  pp$3.currentVarScope = function() {\n    for (var i = this.scopeStack.length - 1;; i--) {\n      var scope = this.scopeStack[i];\n      if (scope.flags & SCOPE_VAR) { return scope }\n    }\n  };\n\n  // Could be useful for `this`, `new.target`, `super()`, `super.property`, and `super[property]`.\n  pp$3.currentThisScope = function() {\n    for (var i = this.scopeStack.length - 1;; i--) {\n      var scope = this.scopeStack[i];\n      if (scope.flags & SCOPE_VAR && !(scope.flags & SCOPE_ARROW)) { return scope }\n    }\n  };\n\n  var Node = function Node(parser, pos, loc) {\n    this.type = \"\";\n    this.start = pos;\n    this.end = 0;\n    if (parser.options.locations)\n      { this.loc = new SourceLocation(parser, loc); }\n    if (parser.options.directSourceFile)\n      { this.sourceFile = parser.options.directSourceFile; }\n    if (parser.options.ranges)\n      { this.range = [pos, 0]; }\n  };\n\n  // Start an AST node, attaching a start offset.\n\n  var pp$2 = Parser.prototype;\n\n  pp$2.startNode = function() {\n    return new Node(this, this.start, this.startLoc)\n  };\n\n  pp$2.startNodeAt = function(pos, loc) {\n    return new Node(this, pos, loc)\n  };\n\n  // Finish an AST node, adding `type` and `end` properties.\n\n  function finishNodeAt(node, type, pos, loc) {\n    node.type = type;\n    node.end = pos;\n    if (this.options.locations)\n      { node.loc.end = loc; }\n    if (this.options.ranges)\n      { node.range[1] = pos; }\n    return node\n  }\n\n  pp$2.finishNode = function(node, type) {\n    return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc)\n  };\n\n  // Finish node at given position\n\n  pp$2.finishNodeAt = function(node, type, pos, loc) {\n    return finishNodeAt.call(this, node, type, pos, loc)\n  };\n\n  pp$2.copyNode = function(node) {\n    var newNode = new Node(this, node.start, this.startLoc);\n    for (var prop in node) { newNode[prop] = node[prop]; }\n    return newNode\n  };\n\n  // This file contains Unicode properties extracted from the ECMAScript\n  // specification. The lists are extracted like so:\n  // $$('#table-binary-unicode-properties > figure > table > tbody > tr > td:nth-child(1) code').map(el => el.innerText)\n\n  // #table-binary-unicode-properties\n  var ecma9BinaryProperties = \"ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS\";\n  var ecma10BinaryProperties = ecma9BinaryProperties + \" Extended_Pictographic\";\n  var ecma11BinaryProperties = ecma10BinaryProperties;\n  var ecma12BinaryProperties = ecma11BinaryProperties + \" EBase EComp EMod EPres ExtPict\";\n  var ecma13BinaryProperties = ecma12BinaryProperties;\n  var unicodeBinaryProperties = {\n    9: ecma9BinaryProperties,\n    10: ecma10BinaryProperties,\n    11: ecma11BinaryProperties,\n    12: ecma12BinaryProperties,\n    13: ecma13BinaryProperties\n  };\n\n  // #table-unicode-general-category-values\n  var unicodeGeneralCategoryValues = \"Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu\";\n\n  // #table-unicode-script-values\n  var ecma9ScriptValues = \"Adlam Adlm Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb\";\n  var ecma10ScriptValues = ecma9ScriptValues + \" Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd\";\n  var ecma11ScriptValues = ecma10ScriptValues + \" Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho\";\n  var ecma12ScriptValues = ecma11ScriptValues + \" Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi\";\n  var ecma13ScriptValues = ecma12ScriptValues + \" Cypro_Minoan Cpmn Old_Uyghur Ougr Tangsa Tnsa Toto Vithkuqi Vith\";\n  var unicodeScriptValues = {\n    9: ecma9ScriptValues,\n    10: ecma10ScriptValues,\n    11: ecma11ScriptValues,\n    12: ecma12ScriptValues,\n    13: ecma13ScriptValues\n  };\n\n  var data = {};\n  function buildUnicodeData(ecmaVersion) {\n    var d = data[ecmaVersion] = {\n      binary: wordsRegexp(unicodeBinaryProperties[ecmaVersion] + \" \" + unicodeGeneralCategoryValues),\n      nonBinary: {\n        General_Category: wordsRegexp(unicodeGeneralCategoryValues),\n        Script: wordsRegexp(unicodeScriptValues[ecmaVersion])\n      }\n    };\n    d.nonBinary.Script_Extensions = d.nonBinary.Script;\n\n    d.nonBinary.gc = d.nonBinary.General_Category;\n    d.nonBinary.sc = d.nonBinary.Script;\n    d.nonBinary.scx = d.nonBinary.Script_Extensions;\n  }\n\n  for (var i = 0, list = [9, 10, 11, 12, 13]; i < list.length; i += 1) {\n    var ecmaVersion = list[i];\n\n    buildUnicodeData(ecmaVersion);\n  }\n\n  var pp$1 = Parser.prototype;\n\n  var RegExpValidationState = function RegExpValidationState(parser) {\n    this.parser = parser;\n    this.validFlags = \"gim\" + (parser.options.ecmaVersion >= 6 ? \"uy\" : \"\") + (parser.options.ecmaVersion >= 9 ? \"s\" : \"\") + (parser.options.ecmaVersion >= 13 ? \"d\" : \"\");\n    this.unicodeProperties = data[parser.options.ecmaVersion >= 13 ? 13 : parser.options.ecmaVersion];\n    this.source = \"\";\n    this.flags = \"\";\n    this.start = 0;\n    this.switchU = false;\n    this.switchN = false;\n    this.pos = 0;\n    this.lastIntValue = 0;\n    this.lastStringValue = \"\";\n    this.lastAssertionIsQuantifiable = false;\n    this.numCapturingParens = 0;\n    this.maxBackReference = 0;\n    this.groupNames = [];\n    this.backReferenceNames = [];\n  };\n\n  RegExpValidationState.prototype.reset = function reset (start, pattern, flags) {\n    var unicode = flags.indexOf(\"u\") !== -1;\n    this.start = start | 0;\n    this.source = pattern + \"\";\n    this.flags = flags;\n    this.switchU = unicode && this.parser.options.ecmaVersion >= 6;\n    this.switchN = unicode && this.parser.options.ecmaVersion >= 9;\n  };\n\n  RegExpValidationState.prototype.raise = function raise (message) {\n    this.parser.raiseRecoverable(this.start, (\"Invalid regular expression: /\" + (this.source) + \"/: \" + message));\n  };\n\n  // If u flag is given, this returns the code point at the index (it combines a surrogate pair).\n  // Otherwise, this returns the code unit of the index (can be a part of a surrogate pair).\n  RegExpValidationState.prototype.at = function at (i, forceU) {\n      if ( forceU === void 0 ) forceU = false;\n\n    var s = this.source;\n    var l = s.length;\n    if (i >= l) {\n      return -1\n    }\n    var c = s.charCodeAt(i);\n    if (!(forceU || this.switchU) || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l) {\n      return c\n    }\n    var next = s.charCodeAt(i + 1);\n    return next >= 0xDC00 && next <= 0xDFFF ? (c << 10) + next - 0x35FDC00 : c\n  };\n\n  RegExpValidationState.prototype.nextIndex = function nextIndex (i, forceU) {\n      if ( forceU === void 0 ) forceU = false;\n\n    var s = this.source;\n    var l = s.length;\n    if (i >= l) {\n      return l\n    }\n    var c = s.charCodeAt(i), next;\n    if (!(forceU || this.switchU) || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l ||\n        (next = s.charCodeAt(i + 1)) < 0xDC00 || next > 0xDFFF) {\n      return i + 1\n    }\n    return i + 2\n  };\n\n  RegExpValidationState.prototype.current = function current (forceU) {\n      if ( forceU === void 0 ) forceU = false;\n\n    return this.at(this.pos, forceU)\n  };\n\n  RegExpValidationState.prototype.lookahead = function lookahead (forceU) {\n      if ( forceU === void 0 ) forceU = false;\n\n    return this.at(this.nextIndex(this.pos, forceU), forceU)\n  };\n\n  RegExpValidationState.prototype.advance = function advance (forceU) {\n      if ( forceU === void 0 ) forceU = false;\n\n    this.pos = this.nextIndex(this.pos, forceU);\n  };\n\n  RegExpValidationState.prototype.eat = function eat (ch, forceU) {\n      if ( forceU === void 0 ) forceU = false;\n\n    if (this.current(forceU) === ch) {\n      this.advance(forceU);\n      return true\n    }\n    return false\n  };\n\n  /**\n   * Validate the flags part of a given RegExpLiteral.\n   *\n   * @param {RegExpValidationState} state The state to validate RegExp.\n   * @returns {void}\n   */\n  pp$1.validateRegExpFlags = function(state) {\n    var validFlags = state.validFlags;\n    var flags = state.flags;\n\n    for (var i = 0; i < flags.length; i++) {\n      var flag = flags.charAt(i);\n      if (validFlags.indexOf(flag) === -1) {\n        this.raise(state.start, \"Invalid regular expression flag\");\n      }\n      if (flags.indexOf(flag, i + 1) > -1) {\n        this.raise(state.start, \"Duplicate regular expression flag\");\n      }\n    }\n  };\n\n  /**\n   * Validate the pattern part of a given RegExpLiteral.\n   *\n   * @param {RegExpValidationState} state The state to validate RegExp.\n   * @returns {void}\n   */\n  pp$1.validateRegExpPattern = function(state) {\n    this.regexp_pattern(state);\n\n    // The goal symbol for the parse is |Pattern[~U, ~N]|. If the result of\n    // parsing contains a |GroupName|, reparse with the goal symbol\n    // |Pattern[~U, +N]| and use this result instead. Throw a *SyntaxError*\n    // exception if _P_ did not conform to the grammar, if any elements of _P_\n    // were not matched by the parse, or if any Early Error conditions exist.\n    if (!state.switchN && this.options.ecmaVersion >= 9 && state.groupNames.length > 0) {\n      state.switchN = true;\n      this.regexp_pattern(state);\n    }\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-Pattern\n  pp$1.regexp_pattern = function(state) {\n    state.pos = 0;\n    state.lastIntValue = 0;\n    state.lastStringValue = \"\";\n    state.lastAssertionIsQuantifiable = false;\n    state.numCapturingParens = 0;\n    state.maxBackReference = 0;\n    state.groupNames.length = 0;\n    state.backReferenceNames.length = 0;\n\n    this.regexp_disjunction(state);\n\n    if (state.pos !== state.source.length) {\n      // Make the same messages as V8.\n      if (state.eat(0x29 /* ) */)) {\n        state.raise(\"Unmatched ')'\");\n      }\n      if (state.eat(0x5D /* ] */) || state.eat(0x7D /* } */)) {\n        state.raise(\"Lone quantifier brackets\");\n      }\n    }\n    if (state.maxBackReference > state.numCapturingParens) {\n      state.raise(\"Invalid escape\");\n    }\n    for (var i = 0, list = state.backReferenceNames; i < list.length; i += 1) {\n      var name = list[i];\n\n      if (state.groupNames.indexOf(name) === -1) {\n        state.raise(\"Invalid named capture referenced\");\n      }\n    }\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-Disjunction\n  pp$1.regexp_disjunction = function(state) {\n    this.regexp_alternative(state);\n    while (state.eat(0x7C /* | */)) {\n      this.regexp_alternative(state);\n    }\n\n    // Make the same message as V8.\n    if (this.regexp_eatQuantifier(state, true)) {\n      state.raise(\"Nothing to repeat\");\n    }\n    if (state.eat(0x7B /* { */)) {\n      state.raise(\"Lone quantifier brackets\");\n    }\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-Alternative\n  pp$1.regexp_alternative = function(state) {\n    while (state.pos < state.source.length && this.regexp_eatTerm(state))\n      { }\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Term\n  pp$1.regexp_eatTerm = function(state) {\n    if (this.regexp_eatAssertion(state)) {\n      // Handle `QuantifiableAssertion Quantifier` alternative.\n      // `state.lastAssertionIsQuantifiable` is true if the last eaten Assertion\n      // is a QuantifiableAssertion.\n      if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {\n        // Make the same message as V8.\n        if (state.switchU) {\n          state.raise(\"Invalid quantifier\");\n        }\n      }\n      return true\n    }\n\n    if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {\n      this.regexp_eatQuantifier(state);\n      return true\n    }\n\n    return false\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Assertion\n  pp$1.regexp_eatAssertion = function(state) {\n    var start = state.pos;\n    state.lastAssertionIsQuantifiable = false;\n\n    // ^, $\n    if (state.eat(0x5E /* ^ */) || state.eat(0x24 /* $ */)) {\n      return true\n    }\n\n    // \\b \\B\n    if (state.eat(0x5C /* \\ */)) {\n      if (state.eat(0x42 /* B */) || state.eat(0x62 /* b */)) {\n        return true\n      }\n      state.pos = start;\n    }\n\n    // Lookahead / Lookbehind\n    if (state.eat(0x28 /* ( */) && state.eat(0x3F /* ? */)) {\n      var lookbehind = false;\n      if (this.options.ecmaVersion >= 9) {\n        lookbehind = state.eat(0x3C /* < */);\n      }\n      if (state.eat(0x3D /* = */) || state.eat(0x21 /* ! */)) {\n        this.regexp_disjunction(state);\n        if (!state.eat(0x29 /* ) */)) {\n          state.raise(\"Unterminated group\");\n        }\n        state.lastAssertionIsQuantifiable = !lookbehind;\n        return true\n      }\n    }\n\n    state.pos = start;\n    return false\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-Quantifier\n  pp$1.regexp_eatQuantifier = function(state, noError) {\n    if ( noError === void 0 ) noError = false;\n\n    if (this.regexp_eatQuantifierPrefix(state, noError)) {\n      state.eat(0x3F /* ? */);\n      return true\n    }\n    return false\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-QuantifierPrefix\n  pp$1.regexp_eatQuantifierPrefix = function(state, noError) {\n    return (\n      state.eat(0x2A /* * */) ||\n      state.eat(0x2B /* + */) ||\n      state.eat(0x3F /* ? */) ||\n      this.regexp_eatBracedQuantifier(state, noError)\n    )\n  };\n  pp$1.regexp_eatBracedQuantifier = function(state, noError) {\n    var start = state.pos;\n    if (state.eat(0x7B /* { */)) {\n      var min = 0, max = -1;\n      if (this.regexp_eatDecimalDigits(state)) {\n        min = state.lastIntValue;\n        if (state.eat(0x2C /* , */) && this.regexp_eatDecimalDigits(state)) {\n          max = state.lastIntValue;\n        }\n        if (state.eat(0x7D /* } */)) {\n          // SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-term\n          if (max !== -1 && max < min && !noError) {\n            state.raise(\"numbers out of order in {} quantifier\");\n          }\n          return true\n        }\n      }\n      if (state.switchU && !noError) {\n        state.raise(\"Incomplete quantifier\");\n      }\n      state.pos = start;\n    }\n    return false\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-Atom\n  pp$1.regexp_eatAtom = function(state) {\n    return (\n      this.regexp_eatPatternCharacters(state) ||\n      state.eat(0x2E /* . */) ||\n      this.regexp_eatReverseSolidusAtomEscape(state) ||\n      this.regexp_eatCharacterClass(state) ||\n      this.regexp_eatUncapturingGroup(state) ||\n      this.regexp_eatCapturingGroup(state)\n    )\n  };\n  pp$1.regexp_eatReverseSolidusAtomEscape = function(state) {\n    var start = state.pos;\n    if (state.eat(0x5C /* \\ */)) {\n      if (this.regexp_eatAtomEscape(state)) {\n        return true\n      }\n      state.pos = start;\n    }\n    return false\n  };\n  pp$1.regexp_eatUncapturingGroup = function(state) {\n    var start = state.pos;\n    if (state.eat(0x28 /* ( */)) {\n      if (state.eat(0x3F /* ? */) && state.eat(0x3A /* : */)) {\n        this.regexp_disjunction(state);\n        if (state.eat(0x29 /* ) */)) {\n          return true\n        }\n        state.raise(\"Unterminated group\");\n      }\n      state.pos = start;\n    }\n    return false\n  };\n  pp$1.regexp_eatCapturingGroup = function(state) {\n    if (state.eat(0x28 /* ( */)) {\n      if (this.options.ecmaVersion >= 9) {\n        this.regexp_groupSpecifier(state);\n      } else if (state.current() === 0x3F /* ? */) {\n        state.raise(\"Invalid group\");\n      }\n      this.regexp_disjunction(state);\n      if (state.eat(0x29 /* ) */)) {\n        state.numCapturingParens += 1;\n        return true\n      }\n      state.raise(\"Unterminated group\");\n    }\n    return false\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedAtom\n  pp$1.regexp_eatExtendedAtom = function(state) {\n    return (\n      state.eat(0x2E /* . */) ||\n      this.regexp_eatReverseSolidusAtomEscape(state) ||\n      this.regexp_eatCharacterClass(state) ||\n      this.regexp_eatUncapturingGroup(state) ||\n      this.regexp_eatCapturingGroup(state) ||\n      this.regexp_eatInvalidBracedQuantifier(state) ||\n      this.regexp_eatExtendedPatternCharacter(state)\n    )\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-InvalidBracedQuantifier\n  pp$1.regexp_eatInvalidBracedQuantifier = function(state) {\n    if (this.regexp_eatBracedQuantifier(state, true)) {\n      state.raise(\"Nothing to repeat\");\n    }\n    return false\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-SyntaxCharacter\n  pp$1.regexp_eatSyntaxCharacter = function(state) {\n    var ch = state.current();\n    if (isSyntaxCharacter(ch)) {\n      state.lastIntValue = ch;\n      state.advance();\n      return true\n    }\n    return false\n  };\n  function isSyntaxCharacter(ch) {\n    return (\n      ch === 0x24 /* $ */ ||\n      ch >= 0x28 /* ( */ && ch <= 0x2B /* + */ ||\n      ch === 0x2E /* . */ ||\n      ch === 0x3F /* ? */ ||\n      ch >= 0x5B /* [ */ && ch <= 0x5E /* ^ */ ||\n      ch >= 0x7B /* { */ && ch <= 0x7D /* } */\n    )\n  }\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-PatternCharacter\n  // But eat eager.\n  pp$1.regexp_eatPatternCharacters = function(state) {\n    var start = state.pos;\n    var ch = 0;\n    while ((ch = state.current()) !== -1 && !isSyntaxCharacter(ch)) {\n      state.advance();\n    }\n    return state.pos !== start\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedPatternCharacter\n  pp$1.regexp_eatExtendedPatternCharacter = function(state) {\n    var ch = state.current();\n    if (\n      ch !== -1 &&\n      ch !== 0x24 /* $ */ &&\n      !(ch >= 0x28 /* ( */ && ch <= 0x2B /* + */) &&\n      ch !== 0x2E /* . */ &&\n      ch !== 0x3F /* ? */ &&\n      ch !== 0x5B /* [ */ &&\n      ch !== 0x5E /* ^ */ &&\n      ch !== 0x7C /* | */\n    ) {\n      state.advance();\n      return true\n    }\n    return false\n  };\n\n  // GroupSpecifier ::\n  //   [empty]\n  //   `?` GroupName\n  pp$1.regexp_groupSpecifier = function(state) {\n    if (state.eat(0x3F /* ? */)) {\n      if (this.regexp_eatGroupName(state)) {\n        if (state.groupNames.indexOf(state.lastStringValue) !== -1) {\n          state.raise(\"Duplicate capture group name\");\n        }\n        state.groupNames.push(state.lastStringValue);\n        return\n      }\n      state.raise(\"Invalid group\");\n    }\n  };\n\n  // GroupName ::\n  //   `<` RegExpIdentifierName `>`\n  // Note: this updates `state.lastStringValue` property with the eaten name.\n  pp$1.regexp_eatGroupName = function(state) {\n    state.lastStringValue = \"\";\n    if (state.eat(0x3C /* < */)) {\n      if (this.regexp_eatRegExpIdentifierName(state) && state.eat(0x3E /* > */)) {\n        return true\n      }\n      state.raise(\"Invalid capture group name\");\n    }\n    return false\n  };\n\n  // RegExpIdentifierName ::\n  //   RegExpIdentifierStart\n  //   RegExpIdentifierName RegExpIdentifierPart\n  // Note: this updates `state.lastStringValue` property with the eaten name.\n  pp$1.regexp_eatRegExpIdentifierName = function(state) {\n    state.lastStringValue = \"\";\n    if (this.regexp_eatRegExpIdentifierStart(state)) {\n      state.lastStringValue += codePointToString(state.lastIntValue);\n      while (this.regexp_eatRegExpIdentifierPart(state)) {\n        state.lastStringValue += codePointToString(state.lastIntValue);\n      }\n      return true\n    }\n    return false\n  };\n\n  // RegExpIdentifierStart ::\n  //   UnicodeIDStart\n  //   `$`\n  //   `_`\n  //   `\\` RegExpUnicodeEscapeSequence[+U]\n  pp$1.regexp_eatRegExpIdentifierStart = function(state) {\n    var start = state.pos;\n    var forceU = this.options.ecmaVersion >= 11;\n    var ch = state.current(forceU);\n    state.advance(forceU);\n\n    if (ch === 0x5C /* \\ */ && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {\n      ch = state.lastIntValue;\n    }\n    if (isRegExpIdentifierStart(ch)) {\n      state.lastIntValue = ch;\n      return true\n    }\n\n    state.pos = start;\n    return false\n  };\n  function isRegExpIdentifierStart(ch) {\n    return isIdentifierStart(ch, true) || ch === 0x24 /* $ */ || ch === 0x5F /* _ */\n  }\n\n  // RegExpIdentifierPart ::\n  //   UnicodeIDContinue\n  //   `$`\n  //   `_`\n  //   `\\` RegExpUnicodeEscapeSequence[+U]\n  //   <ZWNJ>\n  //   <ZWJ>\n  pp$1.regexp_eatRegExpIdentifierPart = function(state) {\n    var start = state.pos;\n    var forceU = this.options.ecmaVersion >= 11;\n    var ch = state.current(forceU);\n    state.advance(forceU);\n\n    if (ch === 0x5C /* \\ */ && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {\n      ch = state.lastIntValue;\n    }\n    if (isRegExpIdentifierPart(ch)) {\n      state.lastIntValue = ch;\n      return true\n    }\n\n    state.pos = start;\n    return false\n  };\n  function isRegExpIdentifierPart(ch) {\n    return isIdentifierChar(ch, true) || ch === 0x24 /* $ */ || ch === 0x5F /* _ */ || ch === 0x200C /* <ZWNJ> */ || ch === 0x200D /* <ZWJ> */\n  }\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-AtomEscape\n  pp$1.regexp_eatAtomEscape = function(state) {\n    if (\n      this.regexp_eatBackReference(state) ||\n      this.regexp_eatCharacterClassEscape(state) ||\n      this.regexp_eatCharacterEscape(state) ||\n      (state.switchN && this.regexp_eatKGroupName(state))\n    ) {\n      return true\n    }\n    if (state.switchU) {\n      // Make the same message as V8.\n      if (state.current() === 0x63 /* c */) {\n        state.raise(\"Invalid unicode escape\");\n      }\n      state.raise(\"Invalid escape\");\n    }\n    return false\n  };\n  pp$1.regexp_eatBackReference = function(state) {\n    var start = state.pos;\n    if (this.regexp_eatDecimalEscape(state)) {\n      var n = state.lastIntValue;\n      if (state.switchU) {\n        // For SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-atomescape\n        if (n > state.maxBackReference) {\n          state.maxBackReference = n;\n        }\n        return true\n      }\n      if (n <= state.numCapturingParens) {\n        return true\n      }\n      state.pos = start;\n    }\n    return false\n  };\n  pp$1.regexp_eatKGroupName = function(state) {\n    if (state.eat(0x6B /* k */)) {\n      if (this.regexp_eatGroupName(state)) {\n        state.backReferenceNames.push(state.lastStringValue);\n        return true\n      }\n      state.raise(\"Invalid named reference\");\n    }\n    return false\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-CharacterEscape\n  pp$1.regexp_eatCharacterEscape = function(state) {\n    return (\n      this.regexp_eatControlEscape(state) ||\n      this.regexp_eatCControlLetter(state) ||\n      this.regexp_eatZero(state) ||\n      this.regexp_eatHexEscapeSequence(state) ||\n      this.regexp_eatRegExpUnicodeEscapeSequence(state, false) ||\n      (!state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state)) ||\n      this.regexp_eatIdentityEscape(state)\n    )\n  };\n  pp$1.regexp_eatCControlLetter = function(state) {\n    var start = state.pos;\n    if (state.eat(0x63 /* c */)) {\n      if (this.regexp_eatControlLetter(state)) {\n        return true\n      }\n      state.pos = start;\n    }\n    return false\n  };\n  pp$1.regexp_eatZero = function(state) {\n    if (state.current() === 0x30 /* 0 */ && !isDecimalDigit(state.lookahead())) {\n      state.lastIntValue = 0;\n      state.advance();\n      return true\n    }\n    return false\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-ControlEscape\n  pp$1.regexp_eatControlEscape = function(state) {\n    var ch = state.current();\n    if (ch === 0x74 /* t */) {\n      state.lastIntValue = 0x09; /* \\t */\n      state.advance();\n      return true\n    }\n    if (ch === 0x6E /* n */) {\n      state.lastIntValue = 0x0A; /* \\n */\n      state.advance();\n      return true\n    }\n    if (ch === 0x76 /* v */) {\n      state.lastIntValue = 0x0B; /* \\v */\n      state.advance();\n      return true\n    }\n    if (ch === 0x66 /* f */) {\n      state.lastIntValue = 0x0C; /* \\f */\n      state.advance();\n      return true\n    }\n    if (ch === 0x72 /* r */) {\n      state.lastIntValue = 0x0D; /* \\r */\n      state.advance();\n      return true\n    }\n    return false\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-ControlLetter\n  pp$1.regexp_eatControlLetter = function(state) {\n    var ch = state.current();\n    if (isControlLetter(ch)) {\n      state.lastIntValue = ch % 0x20;\n      state.advance();\n      return true\n    }\n    return false\n  };\n  function isControlLetter(ch) {\n    return (\n      (ch >= 0x41 /* A */ && ch <= 0x5A /* Z */) ||\n      (ch >= 0x61 /* a */ && ch <= 0x7A /* z */)\n    )\n  }\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-RegExpUnicodeEscapeSequence\n  pp$1.regexp_eatRegExpUnicodeEscapeSequence = function(state, forceU) {\n    if ( forceU === void 0 ) forceU = false;\n\n    var start = state.pos;\n    var switchU = forceU || state.switchU;\n\n    if (state.eat(0x75 /* u */)) {\n      if (this.regexp_eatFixedHexDigits(state, 4)) {\n        var lead = state.lastIntValue;\n        if (switchU && lead >= 0xD800 && lead <= 0xDBFF) {\n          var leadSurrogateEnd = state.pos;\n          if (state.eat(0x5C /* \\ */) && state.eat(0x75 /* u */) && this.regexp_eatFixedHexDigits(state, 4)) {\n            var trail = state.lastIntValue;\n            if (trail >= 0xDC00 && trail <= 0xDFFF) {\n              state.lastIntValue = (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;\n              return true\n            }\n          }\n          state.pos = leadSurrogateEnd;\n          state.lastIntValue = lead;\n        }\n        return true\n      }\n      if (\n        switchU &&\n        state.eat(0x7B /* { */) &&\n        this.regexp_eatHexDigits(state) &&\n        state.eat(0x7D /* } */) &&\n        isValidUnicode(state.lastIntValue)\n      ) {\n        return true\n      }\n      if (switchU) {\n        state.raise(\"Invalid unicode escape\");\n      }\n      state.pos = start;\n    }\n\n    return false\n  };\n  function isValidUnicode(ch) {\n    return ch >= 0 && ch <= 0x10FFFF\n  }\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-IdentityEscape\n  pp$1.regexp_eatIdentityEscape = function(state) {\n    if (state.switchU) {\n      if (this.regexp_eatSyntaxCharacter(state)) {\n        return true\n      }\n      if (state.eat(0x2F /* / */)) {\n        state.lastIntValue = 0x2F; /* / */\n        return true\n      }\n      return false\n    }\n\n    var ch = state.current();\n    if (ch !== 0x63 /* c */ && (!state.switchN || ch !== 0x6B /* k */)) {\n      state.lastIntValue = ch;\n      state.advance();\n      return true\n    }\n\n    return false\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalEscape\n  pp$1.regexp_eatDecimalEscape = function(state) {\n    state.lastIntValue = 0;\n    var ch = state.current();\n    if (ch >= 0x31 /* 1 */ && ch <= 0x39 /* 9 */) {\n      do {\n        state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */);\n        state.advance();\n      } while ((ch = state.current()) >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */)\n      return true\n    }\n    return false\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClassEscape\n  pp$1.regexp_eatCharacterClassEscape = function(state) {\n    var ch = state.current();\n\n    if (isCharacterClassEscape(ch)) {\n      state.lastIntValue = -1;\n      state.advance();\n      return true\n    }\n\n    if (\n      state.switchU &&\n      this.options.ecmaVersion >= 9 &&\n      (ch === 0x50 /* P */ || ch === 0x70 /* p */)\n    ) {\n      state.lastIntValue = -1;\n      state.advance();\n      if (\n        state.eat(0x7B /* { */) &&\n        this.regexp_eatUnicodePropertyValueExpression(state) &&\n        state.eat(0x7D /* } */)\n      ) {\n        return true\n      }\n      state.raise(\"Invalid property name\");\n    }\n\n    return false\n  };\n  function isCharacterClassEscape(ch) {\n    return (\n      ch === 0x64 /* d */ ||\n      ch === 0x44 /* D */ ||\n      ch === 0x73 /* s */ ||\n      ch === 0x53 /* S */ ||\n      ch === 0x77 /* w */ ||\n      ch === 0x57 /* W */\n    )\n  }\n\n  // UnicodePropertyValueExpression ::\n  //   UnicodePropertyName `=` UnicodePropertyValue\n  //   LoneUnicodePropertyNameOrValue\n  pp$1.regexp_eatUnicodePropertyValueExpression = function(state) {\n    var start = state.pos;\n\n    // UnicodePropertyName `=` UnicodePropertyValue\n    if (this.regexp_eatUnicodePropertyName(state) && state.eat(0x3D /* = */)) {\n      var name = state.lastStringValue;\n      if (this.regexp_eatUnicodePropertyValue(state)) {\n        var value = state.lastStringValue;\n        this.regexp_validateUnicodePropertyNameAndValue(state, name, value);\n        return true\n      }\n    }\n    state.pos = start;\n\n    // LoneUnicodePropertyNameOrValue\n    if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {\n      var nameOrValue = state.lastStringValue;\n      this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);\n      return true\n    }\n    return false\n  };\n  pp$1.regexp_validateUnicodePropertyNameAndValue = function(state, name, value) {\n    if (!hasOwn(state.unicodeProperties.nonBinary, name))\n      { state.raise(\"Invalid property name\"); }\n    if (!state.unicodeProperties.nonBinary[name].test(value))\n      { state.raise(\"Invalid property value\"); }\n  };\n  pp$1.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {\n    if (!state.unicodeProperties.binary.test(nameOrValue))\n      { state.raise(\"Invalid property name\"); }\n  };\n\n  // UnicodePropertyName ::\n  //   UnicodePropertyNameCharacters\n  pp$1.regexp_eatUnicodePropertyName = function(state) {\n    var ch = 0;\n    state.lastStringValue = \"\";\n    while (isUnicodePropertyNameCharacter(ch = state.current())) {\n      state.lastStringValue += codePointToString(ch);\n      state.advance();\n    }\n    return state.lastStringValue !== \"\"\n  };\n  function isUnicodePropertyNameCharacter(ch) {\n    return isControlLetter(ch) || ch === 0x5F /* _ */\n  }\n\n  // UnicodePropertyValue ::\n  //   UnicodePropertyValueCharacters\n  pp$1.regexp_eatUnicodePropertyValue = function(state) {\n    var ch = 0;\n    state.lastStringValue = \"\";\n    while (isUnicodePropertyValueCharacter(ch = state.current())) {\n      state.lastStringValue += codePointToString(ch);\n      state.advance();\n    }\n    return state.lastStringValue !== \"\"\n  };\n  function isUnicodePropertyValueCharacter(ch) {\n    return isUnicodePropertyNameCharacter(ch) || isDecimalDigit(ch)\n  }\n\n  // LoneUnicodePropertyNameOrValue ::\n  //   UnicodePropertyValueCharacters\n  pp$1.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {\n    return this.regexp_eatUnicodePropertyValue(state)\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClass\n  pp$1.regexp_eatCharacterClass = function(state) {\n    if (state.eat(0x5B /* [ */)) {\n      state.eat(0x5E /* ^ */);\n      this.regexp_classRanges(state);\n      if (state.eat(0x5D /* ] */)) {\n        return true\n      }\n      // Unreachable since it threw \"unterminated regular expression\" error before.\n      state.raise(\"Unterminated character class\");\n    }\n    return false\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-ClassRanges\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRanges\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRangesNoDash\n  pp$1.regexp_classRanges = function(state) {\n    while (this.regexp_eatClassAtom(state)) {\n      var left = state.lastIntValue;\n      if (state.eat(0x2D /* - */) && this.regexp_eatClassAtom(state)) {\n        var right = state.lastIntValue;\n        if (state.switchU && (left === -1 || right === -1)) {\n          state.raise(\"Invalid character class\");\n        }\n        if (left !== -1 && right !== -1 && left > right) {\n          state.raise(\"Range out of order in character class\");\n        }\n      }\n    }\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtom\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtomNoDash\n  pp$1.regexp_eatClassAtom = function(state) {\n    var start = state.pos;\n\n    if (state.eat(0x5C /* \\ */)) {\n      if (this.regexp_eatClassEscape(state)) {\n        return true\n      }\n      if (state.switchU) {\n        // Make the same message as V8.\n        var ch$1 = state.current();\n        if (ch$1 === 0x63 /* c */ || isOctalDigit(ch$1)) {\n          state.raise(\"Invalid class escape\");\n        }\n        state.raise(\"Invalid escape\");\n      }\n      state.pos = start;\n    }\n\n    var ch = state.current();\n    if (ch !== 0x5D /* ] */) {\n      state.lastIntValue = ch;\n      state.advance();\n      return true\n    }\n\n    return false\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassEscape\n  pp$1.regexp_eatClassEscape = function(state) {\n    var start = state.pos;\n\n    if (state.eat(0x62 /* b */)) {\n      state.lastIntValue = 0x08; /* <BS> */\n      return true\n    }\n\n    if (state.switchU && state.eat(0x2D /* - */)) {\n      state.lastIntValue = 0x2D; /* - */\n      return true\n    }\n\n    if (!state.switchU && state.eat(0x63 /* c */)) {\n      if (this.regexp_eatClassControlLetter(state)) {\n        return true\n      }\n      state.pos = start;\n    }\n\n    return (\n      this.regexp_eatCharacterClassEscape(state) ||\n      this.regexp_eatCharacterEscape(state)\n    )\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassControlLetter\n  pp$1.regexp_eatClassControlLetter = function(state) {\n    var ch = state.current();\n    if (isDecimalDigit(ch) || ch === 0x5F /* _ */) {\n      state.lastIntValue = ch % 0x20;\n      state.advance();\n      return true\n    }\n    return false\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence\n  pp$1.regexp_eatHexEscapeSequence = function(state) {\n    var start = state.pos;\n    if (state.eat(0x78 /* x */)) {\n      if (this.regexp_eatFixedHexDigits(state, 2)) {\n        return true\n      }\n      if (state.switchU) {\n        state.raise(\"Invalid escape\");\n      }\n      state.pos = start;\n    }\n    return false\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalDigits\n  pp$1.regexp_eatDecimalDigits = function(state) {\n    var start = state.pos;\n    var ch = 0;\n    state.lastIntValue = 0;\n    while (isDecimalDigit(ch = state.current())) {\n      state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */);\n      state.advance();\n    }\n    return state.pos !== start\n  };\n  function isDecimalDigit(ch) {\n    return ch >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */\n  }\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigits\n  pp$1.regexp_eatHexDigits = function(state) {\n    var start = state.pos;\n    var ch = 0;\n    state.lastIntValue = 0;\n    while (isHexDigit(ch = state.current())) {\n      state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);\n      state.advance();\n    }\n    return state.pos !== start\n  };\n  function isHexDigit(ch) {\n    return (\n      (ch >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */) ||\n      (ch >= 0x41 /* A */ && ch <= 0x46 /* F */) ||\n      (ch >= 0x61 /* a */ && ch <= 0x66 /* f */)\n    )\n  }\n  function hexToInt(ch) {\n    if (ch >= 0x41 /* A */ && ch <= 0x46 /* F */) {\n      return 10 + (ch - 0x41 /* A */)\n    }\n    if (ch >= 0x61 /* a */ && ch <= 0x66 /* f */) {\n      return 10 + (ch - 0x61 /* a */)\n    }\n    return ch - 0x30 /* 0 */\n  }\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-LegacyOctalEscapeSequence\n  // Allows only 0-377(octal) i.e. 0-255(decimal).\n  pp$1.regexp_eatLegacyOctalEscapeSequence = function(state) {\n    if (this.regexp_eatOctalDigit(state)) {\n      var n1 = state.lastIntValue;\n      if (this.regexp_eatOctalDigit(state)) {\n        var n2 = state.lastIntValue;\n        if (n1 <= 3 && this.regexp_eatOctalDigit(state)) {\n          state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;\n        } else {\n          state.lastIntValue = n1 * 8 + n2;\n        }\n      } else {\n        state.lastIntValue = n1;\n      }\n      return true\n    }\n    return false\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-OctalDigit\n  pp$1.regexp_eatOctalDigit = function(state) {\n    var ch = state.current();\n    if (isOctalDigit(ch)) {\n      state.lastIntValue = ch - 0x30; /* 0 */\n      state.advance();\n      return true\n    }\n    state.lastIntValue = 0;\n    return false\n  };\n  function isOctalDigit(ch) {\n    return ch >= 0x30 /* 0 */ && ch <= 0x37 /* 7 */\n  }\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-Hex4Digits\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigit\n  // And HexDigit HexDigit in https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence\n  pp$1.regexp_eatFixedHexDigits = function(state, length) {\n    var start = state.pos;\n    state.lastIntValue = 0;\n    for (var i = 0; i < length; ++i) {\n      var ch = state.current();\n      if (!isHexDigit(ch)) {\n        state.pos = start;\n        return false\n      }\n      state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);\n      state.advance();\n    }\n    return true\n  };\n\n  // Object type used to represent tokens. Note that normally, tokens\n  // simply exist as properties on the parser object. This is only\n  // used for the onToken callback and the external tokenizer.\n\n  var Token = function Token(p) {\n    this.type = p.type;\n    this.value = p.value;\n    this.start = p.start;\n    this.end = p.end;\n    if (p.options.locations)\n      { this.loc = new SourceLocation(p, p.startLoc, p.endLoc); }\n    if (p.options.ranges)\n      { this.range = [p.start, p.end]; }\n  };\n\n  // ## Tokenizer\n\n  var pp = Parser.prototype;\n\n  // Move to the next token\n\n  pp.next = function(ignoreEscapeSequenceInKeyword) {\n    if (!ignoreEscapeSequenceInKeyword && this.type.keyword && this.containsEsc)\n      { this.raiseRecoverable(this.start, \"Escape sequence in keyword \" + this.type.keyword); }\n    if (this.options.onToken)\n      { this.options.onToken(new Token(this)); }\n\n    this.lastTokEnd = this.end;\n    this.lastTokStart = this.start;\n    this.lastTokEndLoc = this.endLoc;\n    this.lastTokStartLoc = this.startLoc;\n    this.nextToken();\n  };\n\n  pp.getToken = function() {\n    this.next();\n    return new Token(this)\n  };\n\n  // If we're in an ES6 environment, make parsers iterable\n  if (typeof Symbol !== \"undefined\")\n    { pp[Symbol.iterator] = function() {\n      var this$1$1 = this;\n\n      return {\n        next: function () {\n          var token = this$1$1.getToken();\n          return {\n            done: token.type === types$1.eof,\n            value: token\n          }\n        }\n      }\n    }; }\n\n  // Toggle strict mode. Re-reads the next number or string to please\n  // pedantic tests (`\"use strict\"; 010;` should fail).\n\n  // Read a single token, updating the parser object's token-related\n  // properties.\n\n  pp.nextToken = function() {\n    var curContext = this.curContext();\n    if (!curContext || !curContext.preserveSpace) { this.skipSpace(); }\n\n    this.start = this.pos;\n    if (this.options.locations) { this.startLoc = this.curPosition(); }\n    if (this.pos >= this.input.length) { return this.finishToken(types$1.eof) }\n\n    if (curContext.override) { return curContext.override(this) }\n    else { this.readToken(this.fullCharCodeAtPos()); }\n  };\n\n  pp.readToken = function(code) {\n    // Identifier or keyword. '\\uXXXX' sequences are allowed in\n    // identifiers, so '\\' also dispatches to that.\n    if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92 /* '\\' */)\n      { return this.readWord() }\n\n    return this.getTokenFromCode(code)\n  };\n\n  pp.fullCharCodeAtPos = function() {\n    var code = this.input.charCodeAt(this.pos);\n    if (code <= 0xd7ff || code >= 0xdc00) { return code }\n    var next = this.input.charCodeAt(this.pos + 1);\n    return next <= 0xdbff || next >= 0xe000 ? code : (code << 10) + next - 0x35fdc00\n  };\n\n  pp.skipBlockComment = function() {\n    var startLoc = this.options.onComment && this.curPosition();\n    var start = this.pos, end = this.input.indexOf(\"*/\", this.pos += 2);\n    if (end === -1) { this.raise(this.pos - 2, \"Unterminated comment\"); }\n    this.pos = end + 2;\n    if (this.options.locations) {\n      for (var nextBreak = (void 0), pos = start; (nextBreak = nextLineBreak(this.input, pos, this.pos)) > -1;) {\n        ++this.curLine;\n        pos = this.lineStart = nextBreak;\n      }\n    }\n    if (this.options.onComment)\n      { this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos,\n                             startLoc, this.curPosition()); }\n  };\n\n  pp.skipLineComment = function(startSkip) {\n    var start = this.pos;\n    var startLoc = this.options.onComment && this.curPosition();\n    var ch = this.input.charCodeAt(this.pos += startSkip);\n    while (this.pos < this.input.length && !isNewLine(ch)) {\n      ch = this.input.charCodeAt(++this.pos);\n    }\n    if (this.options.onComment)\n      { this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos,\n                             startLoc, this.curPosition()); }\n  };\n\n  // Called at the start of the parse and after every token. Skips\n  // whitespace and comments, and.\n\n  pp.skipSpace = function() {\n    loop: while (this.pos < this.input.length) {\n      var ch = this.input.charCodeAt(this.pos);\n      switch (ch) {\n      case 32: case 160: // ' '\n        ++this.pos;\n        break\n      case 13:\n        if (this.input.charCodeAt(this.pos + 1) === 10) {\n          ++this.pos;\n        }\n      case 10: case 8232: case 8233:\n        ++this.pos;\n        if (this.options.locations) {\n          ++this.curLine;\n          this.lineStart = this.pos;\n        }\n        break\n      case 47: // '/'\n        switch (this.input.charCodeAt(this.pos + 1)) {\n        case 42: // '*'\n          this.skipBlockComment();\n          break\n        case 47:\n          this.skipLineComment(2);\n          break\n        default:\n          break loop\n        }\n        break\n      default:\n        if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {\n          ++this.pos;\n        } else {\n          break loop\n        }\n      }\n    }\n  };\n\n  // Called at the end of every token. Sets `end`, `val`, and\n  // maintains `context` and `exprAllowed`, and skips the space after\n  // the token, so that the next one's `start` will point at the\n  // right position.\n\n  pp.finishToken = function(type, val) {\n    this.end = this.pos;\n    if (this.options.locations) { this.endLoc = this.curPosition(); }\n    var prevType = this.type;\n    this.type = type;\n    this.value = val;\n\n    this.updateContext(prevType);\n  };\n\n  // ### Token reading\n\n  // This is the function that is called to fetch the next token. It\n  // is somewhat obscure, because it works in character codes rather\n  // than characters, and because operator parsing has been inlined\n  // into it.\n  //\n  // All in the name of speed.\n  //\n  pp.readToken_dot = function() {\n    var next = this.input.charCodeAt(this.pos + 1);\n    if (next >= 48 && next <= 57) { return this.readNumber(true) }\n    var next2 = this.input.charCodeAt(this.pos + 2);\n    if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) { // 46 = dot '.'\n      this.pos += 3;\n      return this.finishToken(types$1.ellipsis)\n    } else {\n      ++this.pos;\n      return this.finishToken(types$1.dot)\n    }\n  };\n\n  pp.readToken_slash = function() { // '/'\n    var next = this.input.charCodeAt(this.pos + 1);\n    if (this.exprAllowed) { ++this.pos; return this.readRegexp() }\n    if (next === 61) { return this.finishOp(types$1.assign, 2) }\n    return this.finishOp(types$1.slash, 1)\n  };\n\n  pp.readToken_mult_modulo_exp = function(code) { // '%*'\n    var next = this.input.charCodeAt(this.pos + 1);\n    var size = 1;\n    var tokentype = code === 42 ? types$1.star : types$1.modulo;\n\n    // exponentiation operator ** and **=\n    if (this.options.ecmaVersion >= 7 && code === 42 && next === 42) {\n      ++size;\n      tokentype = types$1.starstar;\n      next = this.input.charCodeAt(this.pos + 2);\n    }\n\n    if (next === 61) { return this.finishOp(types$1.assign, size + 1) }\n    return this.finishOp(tokentype, size)\n  };\n\n  pp.readToken_pipe_amp = function(code) { // '|&'\n    var next = this.input.charCodeAt(this.pos + 1);\n    if (next === code) {\n      if (this.options.ecmaVersion >= 12) {\n        var next2 = this.input.charCodeAt(this.pos + 2);\n        if (next2 === 61) { return this.finishOp(types$1.assign, 3) }\n      }\n      return this.finishOp(code === 124 ? types$1.logicalOR : types$1.logicalAND, 2)\n    }\n    if (next === 61) { return this.finishOp(types$1.assign, 2) }\n    return this.finishOp(code === 124 ? types$1.bitwiseOR : types$1.bitwiseAND, 1)\n  };\n\n  pp.readToken_caret = function() { // '^'\n    var next = this.input.charCodeAt(this.pos + 1);\n    if (next === 61) { return this.finishOp(types$1.assign, 2) }\n    return this.finishOp(types$1.bitwiseXOR, 1)\n  };\n\n  pp.readToken_plus_min = function(code) { // '+-'\n    var next = this.input.charCodeAt(this.pos + 1);\n    if (next === code) {\n      if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 &&\n          (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {\n        // A `-->` line comment\n        this.skipLineComment(3);\n        this.skipSpace();\n        return this.nextToken()\n      }\n      return this.finishOp(types$1.incDec, 2)\n    }\n    if (next === 61) { return this.finishOp(types$1.assign, 2) }\n    return this.finishOp(types$1.plusMin, 1)\n  };\n\n  pp.readToken_lt_gt = function(code) { // '<>'\n    var next = this.input.charCodeAt(this.pos + 1);\n    var size = 1;\n    if (next === code) {\n      size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;\n      if (this.input.charCodeAt(this.pos + size) === 61) { return this.finishOp(types$1.assign, size + 1) }\n      return this.finishOp(types$1.bitShift, size)\n    }\n    if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 &&\n        this.input.charCodeAt(this.pos + 3) === 45) {\n      // `<!--`, an XML-style comment that should be interpreted as a line comment\n      this.skipLineComment(4);\n      this.skipSpace();\n      return this.nextToken()\n    }\n    if (next === 61) { size = 2; }\n    return this.finishOp(types$1.relational, size)\n  };\n\n  pp.readToken_eq_excl = function(code) { // '=!'\n    var next = this.input.charCodeAt(this.pos + 1);\n    if (next === 61) { return this.finishOp(types$1.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2) }\n    if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) { // '=>'\n      this.pos += 2;\n      return this.finishToken(types$1.arrow)\n    }\n    return this.finishOp(code === 61 ? types$1.eq : types$1.prefix, 1)\n  };\n\n  pp.readToken_question = function() { // '?'\n    var ecmaVersion = this.options.ecmaVersion;\n    if (ecmaVersion >= 11) {\n      var next = this.input.charCodeAt(this.pos + 1);\n      if (next === 46) {\n        var next2 = this.input.charCodeAt(this.pos + 2);\n        if (next2 < 48 || next2 > 57) { return this.finishOp(types$1.questionDot, 2) }\n      }\n      if (next === 63) {\n        if (ecmaVersion >= 12) {\n          var next2$1 = this.input.charCodeAt(this.pos + 2);\n          if (next2$1 === 61) { return this.finishOp(types$1.assign, 3) }\n        }\n        return this.finishOp(types$1.coalesce, 2)\n      }\n    }\n    return this.finishOp(types$1.question, 1)\n  };\n\n  pp.readToken_numberSign = function() { // '#'\n    var ecmaVersion = this.options.ecmaVersion;\n    var code = 35; // '#'\n    if (ecmaVersion >= 13) {\n      ++this.pos;\n      code = this.fullCharCodeAtPos();\n      if (isIdentifierStart(code, true) || code === 92 /* '\\' */) {\n        return this.finishToken(types$1.privateId, this.readWord1())\n      }\n    }\n\n    this.raise(this.pos, \"Unexpected character '\" + codePointToString(code) + \"'\");\n  };\n\n  pp.getTokenFromCode = function(code) {\n    switch (code) {\n    // The interpretation of a dot depends on whether it is followed\n    // by a digit or another two dots.\n    case 46: // '.'\n      return this.readToken_dot()\n\n    // Punctuation tokens.\n    case 40: ++this.pos; return this.finishToken(types$1.parenL)\n    case 41: ++this.pos; return this.finishToken(types$1.parenR)\n    case 59: ++this.pos; return this.finishToken(types$1.semi)\n    case 44: ++this.pos; return this.finishToken(types$1.comma)\n    case 91: ++this.pos; return this.finishToken(types$1.bracketL)\n    case 93: ++this.pos; return this.finishToken(types$1.bracketR)\n    case 123: ++this.pos; return this.finishToken(types$1.braceL)\n    case 125: ++this.pos; return this.finishToken(types$1.braceR)\n    case 58: ++this.pos; return this.finishToken(types$1.colon)\n\n    case 96: // '`'\n      if (this.options.ecmaVersion < 6) { break }\n      ++this.pos;\n      return this.finishToken(types$1.backQuote)\n\n    case 48: // '0'\n      var next = this.input.charCodeAt(this.pos + 1);\n      if (next === 120 || next === 88) { return this.readRadixNumber(16) } // '0x', '0X' - hex number\n      if (this.options.ecmaVersion >= 6) {\n        if (next === 111 || next === 79) { return this.readRadixNumber(8) } // '0o', '0O' - octal number\n        if (next === 98 || next === 66) { return this.readRadixNumber(2) } // '0b', '0B' - binary number\n      }\n\n    // Anything else beginning with a digit is an integer, octal\n    // number, or float.\n    case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: // 1-9\n      return this.readNumber(false)\n\n    // Quotes produce strings.\n    case 34: case 39: // '\"', \"'\"\n      return this.readString(code)\n\n    // Operators are parsed inline in tiny state machines. '=' (61) is\n    // often referred to. `finishOp` simply skips the amount of\n    // characters it is given as second argument, and returns a token\n    // of the type given by its first argument.\n    case 47: // '/'\n      return this.readToken_slash()\n\n    case 37: case 42: // '%*'\n      return this.readToken_mult_modulo_exp(code)\n\n    case 124: case 38: // '|&'\n      return this.readToken_pipe_amp(code)\n\n    case 94: // '^'\n      return this.readToken_caret()\n\n    case 43: case 45: // '+-'\n      return this.readToken_plus_min(code)\n\n    case 60: case 62: // '<>'\n      return this.readToken_lt_gt(code)\n\n    case 61: case 33: // '=!'\n      return this.readToken_eq_excl(code)\n\n    case 63: // '?'\n      return this.readToken_question()\n\n    case 126: // '~'\n      return this.finishOp(types$1.prefix, 1)\n\n    case 35: // '#'\n      return this.readToken_numberSign()\n    }\n\n    this.raise(this.pos, \"Unexpected character '\" + codePointToString(code) + \"'\");\n  };\n\n  pp.finishOp = function(type, size) {\n    var str = this.input.slice(this.pos, this.pos + size);\n    this.pos += size;\n    return this.finishToken(type, str)\n  };\n\n  pp.readRegexp = function() {\n    var escaped, inClass, start = this.pos;\n    for (;;) {\n      if (this.pos >= this.input.length) { this.raise(start, \"Unterminated regular expression\"); }\n      var ch = this.input.charAt(this.pos);\n      if (lineBreak.test(ch)) { this.raise(start, \"Unterminated regular expression\"); }\n      if (!escaped) {\n        if (ch === \"[\") { inClass = true; }\n        else if (ch === \"]\" && inClass) { inClass = false; }\n        else if (ch === \"/\" && !inClass) { break }\n        escaped = ch === \"\\\\\";\n      } else { escaped = false; }\n      ++this.pos;\n    }\n    var pattern = this.input.slice(start, this.pos);\n    ++this.pos;\n    var flagsStart = this.pos;\n    var flags = this.readWord1();\n    if (this.containsEsc) { this.unexpected(flagsStart); }\n\n    // Validate pattern\n    var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));\n    state.reset(start, pattern, flags);\n    this.validateRegExpFlags(state);\n    this.validateRegExpPattern(state);\n\n    // Create Literal#value property value.\n    var value = null;\n    try {\n      value = new RegExp(pattern, flags);\n    } catch (e) {\n      // ESTree requires null if it failed to instantiate RegExp object.\n      // https://github.com/estree/estree/blob/a27003adf4fd7bfad44de9cef372a2eacd527b1c/es5.md#regexpliteral\n    }\n\n    return this.finishToken(types$1.regexp, {pattern: pattern, flags: flags, value: value})\n  };\n\n  // Read an integer in the given radix. Return null if zero digits\n  // were read, the integer value otherwise. When `len` is given, this\n  // will return `null` unless the integer has exactly `len` digits.\n\n  pp.readInt = function(radix, len, maybeLegacyOctalNumericLiteral) {\n    // `len` is used for character escape sequences. In that case, disallow separators.\n    var allowSeparators = this.options.ecmaVersion >= 12 && len === undefined;\n\n    // `maybeLegacyOctalNumericLiteral` is true if it doesn't have prefix (0x,0o,0b)\n    // and isn't fraction part nor exponent part. In that case, if the first digit\n    // is zero then disallow separators.\n    var isLegacyOctalNumericLiteral = maybeLegacyOctalNumericLiteral && this.input.charCodeAt(this.pos) === 48;\n\n    var start = this.pos, total = 0, lastCode = 0;\n    for (var i = 0, e = len == null ? Infinity : len; i < e; ++i, ++this.pos) {\n      var code = this.input.charCodeAt(this.pos), val = (void 0);\n\n      if (allowSeparators && code === 95) {\n        if (isLegacyOctalNumericLiteral) { this.raiseRecoverable(this.pos, \"Numeric separator is not allowed in legacy octal numeric literals\"); }\n        if (lastCode === 95) { this.raiseRecoverable(this.pos, \"Numeric separator must be exactly one underscore\"); }\n        if (i === 0) { this.raiseRecoverable(this.pos, \"Numeric separator is not allowed at the first of digits\"); }\n        lastCode = code;\n        continue\n      }\n\n      if (code >= 97) { val = code - 97 + 10; } // a\n      else if (code >= 65) { val = code - 65 + 10; } // A\n      else if (code >= 48 && code <= 57) { val = code - 48; } // 0-9\n      else { val = Infinity; }\n      if (val >= radix) { break }\n      lastCode = code;\n      total = total * radix + val;\n    }\n\n    if (allowSeparators && lastCode === 95) { this.raiseRecoverable(this.pos - 1, \"Numeric separator is not allowed at the last of digits\"); }\n    if (this.pos === start || len != null && this.pos - start !== len) { return null }\n\n    return total\n  };\n\n  function stringToNumber(str, isLegacyOctalNumericLiteral) {\n    if (isLegacyOctalNumericLiteral) {\n      return parseInt(str, 8)\n    }\n\n    // `parseFloat(value)` stops parsing at the first numeric separator then returns a wrong value.\n    return parseFloat(str.replace(/_/g, \"\"))\n  }\n\n  function stringToBigInt(str) {\n    if (typeof BigInt !== \"function\") {\n      return null\n    }\n\n    // `BigInt(value)` throws syntax error if the string contains numeric separators.\n    return BigInt(str.replace(/_/g, \"\"))\n  }\n\n  pp.readRadixNumber = function(radix) {\n    var start = this.pos;\n    this.pos += 2; // 0x\n    var val = this.readInt(radix);\n    if (val == null) { this.raise(this.start + 2, \"Expected number in radix \" + radix); }\n    if (this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110) {\n      val = stringToBigInt(this.input.slice(start, this.pos));\n      ++this.pos;\n    } else if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, \"Identifier directly after number\"); }\n    return this.finishToken(types$1.num, val)\n  };\n\n  // Read an integer, octal integer, or floating-point number.\n\n  pp.readNumber = function(startsWithDot) {\n    var start = this.pos;\n    if (!startsWithDot && this.readInt(10, undefined, true) === null) { this.raise(start, \"Invalid number\"); }\n    var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;\n    if (octal && this.strict) { this.raise(start, \"Invalid number\"); }\n    var next = this.input.charCodeAt(this.pos);\n    if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && next === 110) {\n      var val$1 = stringToBigInt(this.input.slice(start, this.pos));\n      ++this.pos;\n      if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, \"Identifier directly after number\"); }\n      return this.finishToken(types$1.num, val$1)\n    }\n    if (octal && /[89]/.test(this.input.slice(start, this.pos))) { octal = false; }\n    if (next === 46 && !octal) { // '.'\n      ++this.pos;\n      this.readInt(10);\n      next = this.input.charCodeAt(this.pos);\n    }\n    if ((next === 69 || next === 101) && !octal) { // 'eE'\n      next = this.input.charCodeAt(++this.pos);\n      if (next === 43 || next === 45) { ++this.pos; } // '+-'\n      if (this.readInt(10) === null) { this.raise(start, \"Invalid number\"); }\n    }\n    if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, \"Identifier directly after number\"); }\n\n    var val = stringToNumber(this.input.slice(start, this.pos), octal);\n    return this.finishToken(types$1.num, val)\n  };\n\n  // Read a string value, interpreting backslash-escapes.\n\n  pp.readCodePoint = function() {\n    var ch = this.input.charCodeAt(this.pos), code;\n\n    if (ch === 123) { // '{'\n      if (this.options.ecmaVersion < 6) { this.unexpected(); }\n      var codePos = ++this.pos;\n      code = this.readHexChar(this.input.indexOf(\"}\", this.pos) - this.pos);\n      ++this.pos;\n      if (code > 0x10FFFF) { this.invalidStringToken(codePos, \"Code point out of bounds\"); }\n    } else {\n      code = this.readHexChar(4);\n    }\n    return code\n  };\n\n  pp.readString = function(quote) {\n    var out = \"\", chunkStart = ++this.pos;\n    for (;;) {\n      if (this.pos >= this.input.length) { this.raise(this.start, \"Unterminated string constant\"); }\n      var ch = this.input.charCodeAt(this.pos);\n      if (ch === quote) { break }\n      if (ch === 92) { // '\\'\n        out += this.input.slice(chunkStart, this.pos);\n        out += this.readEscapedChar(false);\n        chunkStart = this.pos;\n      } else if (ch === 0x2028 || ch === 0x2029) {\n        if (this.options.ecmaVersion < 10) { this.raise(this.start, \"Unterminated string constant\"); }\n        ++this.pos;\n        if (this.options.locations) {\n          this.curLine++;\n          this.lineStart = this.pos;\n        }\n      } else {\n        if (isNewLine(ch)) { this.raise(this.start, \"Unterminated string constant\"); }\n        ++this.pos;\n      }\n    }\n    out += this.input.slice(chunkStart, this.pos++);\n    return this.finishToken(types$1.string, out)\n  };\n\n  // Reads template string tokens.\n\n  var INVALID_TEMPLATE_ESCAPE_ERROR = {};\n\n  pp.tryReadTemplateToken = function() {\n    this.inTemplateElement = true;\n    try {\n      this.readTmplToken();\n    } catch (err) {\n      if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {\n        this.readInvalidTemplateToken();\n      } else {\n        throw err\n      }\n    }\n\n    this.inTemplateElement = false;\n  };\n\n  pp.invalidStringToken = function(position, message) {\n    if (this.inTemplateElement && this.options.ecmaVersion >= 9) {\n      throw INVALID_TEMPLATE_ESCAPE_ERROR\n    } else {\n      this.raise(position, message);\n    }\n  };\n\n  pp.readTmplToken = function() {\n    var out = \"\", chunkStart = this.pos;\n    for (;;) {\n      if (this.pos >= this.input.length) { this.raise(this.start, \"Unterminated template\"); }\n      var ch = this.input.charCodeAt(this.pos);\n      if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) { // '`', '${'\n        if (this.pos === this.start && (this.type === types$1.template || this.type === types$1.invalidTemplate)) {\n          if (ch === 36) {\n            this.pos += 2;\n            return this.finishToken(types$1.dollarBraceL)\n          } else {\n            ++this.pos;\n            return this.finishToken(types$1.backQuote)\n          }\n        }\n        out += this.input.slice(chunkStart, this.pos);\n        return this.finishToken(types$1.template, out)\n      }\n      if (ch === 92) { // '\\'\n        out += this.input.slice(chunkStart, this.pos);\n        out += this.readEscapedChar(true);\n        chunkStart = this.pos;\n      } else if (isNewLine(ch)) {\n        out += this.input.slice(chunkStart, this.pos);\n        ++this.pos;\n        switch (ch) {\n        case 13:\n          if (this.input.charCodeAt(this.pos) === 10) { ++this.pos; }\n        case 10:\n          out += \"\\n\";\n          break\n        default:\n          out += String.fromCharCode(ch);\n          break\n        }\n        if (this.options.locations) {\n          ++this.curLine;\n          this.lineStart = this.pos;\n        }\n        chunkStart = this.pos;\n      } else {\n        ++this.pos;\n      }\n    }\n  };\n\n  // Reads a template token to search for the end, without validating any escape sequences\n  pp.readInvalidTemplateToken = function() {\n    for (; this.pos < this.input.length; this.pos++) {\n      switch (this.input[this.pos]) {\n      case \"\\\\\":\n        ++this.pos;\n        break\n\n      case \"$\":\n        if (this.input[this.pos + 1] !== \"{\") {\n          break\n        }\n\n      // falls through\n      case \"`\":\n        return this.finishToken(types$1.invalidTemplate, this.input.slice(this.start, this.pos))\n\n      // no default\n      }\n    }\n    this.raise(this.start, \"Unterminated template\");\n  };\n\n  // Used to read escaped characters\n\n  pp.readEscapedChar = function(inTemplate) {\n    var ch = this.input.charCodeAt(++this.pos);\n    ++this.pos;\n    switch (ch) {\n    case 110: return \"\\n\" // 'n' -> '\\n'\n    case 114: return \"\\r\" // 'r' -> '\\r'\n    case 120: return String.fromCharCode(this.readHexChar(2)) // 'x'\n    case 117: return codePointToString(this.readCodePoint()) // 'u'\n    case 116: return \"\\t\" // 't' -> '\\t'\n    case 98: return \"\\b\" // 'b' -> '\\b'\n    case 118: return \"\\u000b\" // 'v' -> '\\u000b'\n    case 102: return \"\\f\" // 'f' -> '\\f'\n    case 13: if (this.input.charCodeAt(this.pos) === 10) { ++this.pos; } // '\\r\\n'\n    case 10: // ' \\n'\n      if (this.options.locations) { this.lineStart = this.pos; ++this.curLine; }\n      return \"\"\n    case 56:\n    case 57:\n      if (this.strict) {\n        this.invalidStringToken(\n          this.pos - 1,\n          \"Invalid escape sequence\"\n        );\n      }\n      if (inTemplate) {\n        var codePos = this.pos - 1;\n\n        this.invalidStringToken(\n          codePos,\n          \"Invalid escape sequence in template string\"\n        );\n\n        return null\n      }\n    default:\n      if (ch >= 48 && ch <= 55) {\n        var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];\n        var octal = parseInt(octalStr, 8);\n        if (octal > 255) {\n          octalStr = octalStr.slice(0, -1);\n          octal = parseInt(octalStr, 8);\n        }\n        this.pos += octalStr.length - 1;\n        ch = this.input.charCodeAt(this.pos);\n        if ((octalStr !== \"0\" || ch === 56 || ch === 57) && (this.strict || inTemplate)) {\n          this.invalidStringToken(\n            this.pos - 1 - octalStr.length,\n            inTemplate\n              ? \"Octal literal in template string\"\n              : \"Octal literal in strict mode\"\n          );\n        }\n        return String.fromCharCode(octal)\n      }\n      if (isNewLine(ch)) {\n        // Unicode new line characters after \\ get removed from output in both\n        // template literals and strings\n        return \"\"\n      }\n      return String.fromCharCode(ch)\n    }\n  };\n\n  // Used to read character escape sequences ('\\x', '\\u', '\\U').\n\n  pp.readHexChar = function(len) {\n    var codePos = this.pos;\n    var n = this.readInt(16, len);\n    if (n === null) { this.invalidStringToken(codePos, \"Bad character escape sequence\"); }\n    return n\n  };\n\n  // Read an identifier, and return it as a string. Sets `this.containsEsc`\n  // to whether the word contained a '\\u' escape.\n  //\n  // Incrementally adds only escaped chars, adding other chunks as-is\n  // as a micro-optimization.\n\n  pp.readWord1 = function() {\n    this.containsEsc = false;\n    var word = \"\", first = true, chunkStart = this.pos;\n    var astral = this.options.ecmaVersion >= 6;\n    while (this.pos < this.input.length) {\n      var ch = this.fullCharCodeAtPos();\n      if (isIdentifierChar(ch, astral)) {\n        this.pos += ch <= 0xffff ? 1 : 2;\n      } else if (ch === 92) { // \"\\\"\n        this.containsEsc = true;\n        word += this.input.slice(chunkStart, this.pos);\n        var escStart = this.pos;\n        if (this.input.charCodeAt(++this.pos) !== 117) // \"u\"\n          { this.invalidStringToken(this.pos, \"Expecting Unicode escape sequence \\\\uXXXX\"); }\n        ++this.pos;\n        var esc = this.readCodePoint();\n        if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral))\n          { this.invalidStringToken(escStart, \"Invalid Unicode escape\"); }\n        word += codePointToString(esc);\n        chunkStart = this.pos;\n      } else {\n        break\n      }\n      first = false;\n    }\n    return word + this.input.slice(chunkStart, this.pos)\n  };\n\n  // Read an identifier or keyword token. Will check for reserved\n  // words when necessary.\n\n  pp.readWord = function() {\n    var word = this.readWord1();\n    var type = types$1.name;\n    if (this.keywords.test(word)) {\n      type = keywords[word];\n    }\n    return this.finishToken(type, word)\n  };\n\n  // Acorn is a tiny, fast JavaScript parser written in JavaScript.\n\n  var version = \"8.7.1\";\n\n  Parser.acorn = {\n    Parser: Parser,\n    version: version,\n    defaultOptions: defaultOptions,\n    Position: Position,\n    SourceLocation: SourceLocation,\n    getLineInfo: getLineInfo,\n    Node: Node,\n    TokenType: TokenType,\n    tokTypes: types$1,\n    keywordTypes: keywords,\n    TokContext: TokContext,\n    tokContexts: types,\n    isIdentifierChar: isIdentifierChar,\n    isIdentifierStart: isIdentifierStart,\n    Token: Token,\n    isNewLine: isNewLine,\n    lineBreak: lineBreak,\n    lineBreakG: lineBreakG,\n    nonASCIIwhitespace: nonASCIIwhitespace\n  };\n\n  // The main exported interface (under `self.acorn` when in the\n  // browser) is a `parse` function that takes a code string and\n  // returns an abstract syntax tree as specified by [Mozilla parser\n  // API][api].\n  //\n  // [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API\n\n  function parse(input, options) {\n    return Parser.parse(input, options)\n  }\n\n  // This function tries to parse a single expression at a given\n  // offset in a string. Useful for parsing mixed-language formats\n  // that embed JavaScript expressions.\n\n  function parseExpressionAt(input, pos, options) {\n    return Parser.parseExpressionAt(input, pos, options)\n  }\n\n  // Acorn is organized as a tokenizer and a recursive-descent parser.\n  // The `tokenizer` export provides an interface to the tokenizer.\n\n  function tokenizer(input, options) {\n    return Parser.tokenizer(input, options)\n  }\n\n  exports.Node = Node;\n  exports.Parser = Parser;\n  exports.Position = Position;\n  exports.SourceLocation = SourceLocation;\n  exports.TokContext = TokContext;\n  exports.Token = Token;\n  exports.TokenType = TokenType;\n  exports.defaultOptions = defaultOptions;\n  exports.getLineInfo = getLineInfo;\n  exports.isIdentifierChar = isIdentifierChar;\n  exports.isIdentifierStart = isIdentifierStart;\n  exports.isNewLine = isNewLine;\n  exports.keywordTypes = keywords;\n  exports.lineBreak = lineBreak;\n  exports.lineBreakG = lineBreakG;\n  exports.nonASCIIwhitespace = nonASCIIwhitespace;\n  exports.parse = parse;\n  exports.parseExpressionAt = parseExpressionAt;\n  exports.tokContexts = types;\n  exports.tokTypes = types$1;\n  exports.tokenizer = tokenizer;\n  exports.version = version;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n}));\n\n\n//# sourceURL=webpack://javascript/./node_modules/acorn/dist/acorn.js?");

/***/ }),

/***/ "./node_modules/ajv/lib/ajv.js":
/*!*************************************!*\
  !*** ./node_modules/ajv/lib/ajv.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* provided dependency */ var console = __webpack_require__(/*! ./node_modules/console-browserify/index.js */ \"./node_modules/console-browserify/index.js\");\n\n\nvar compileSchema = __webpack_require__(/*! ./compile */ \"./node_modules/ajv/lib/compile/index.js\")\n  , resolve = __webpack_require__(/*! ./compile/resolve */ \"./node_modules/ajv/lib/compile/resolve.js\")\n  , Cache = __webpack_require__(/*! ./cache */ \"./node_modules/ajv/lib/cache.js\")\n  , SchemaObject = __webpack_require__(/*! ./compile/schema_obj */ \"./node_modules/ajv/lib/compile/schema_obj.js\")\n  , stableStringify = __webpack_require__(/*! fast-json-stable-stringify */ \"./node_modules/fast-json-stable-stringify/index.js\")\n  , formats = __webpack_require__(/*! ./compile/formats */ \"./node_modules/ajv/lib/compile/formats.js\")\n  , rules = __webpack_require__(/*! ./compile/rules */ \"./node_modules/ajv/lib/compile/rules.js\")\n  , $dataMetaSchema = __webpack_require__(/*! ./data */ \"./node_modules/ajv/lib/data.js\")\n  , util = __webpack_require__(/*! ./compile/util */ \"./node_modules/ajv/lib/compile/util.js\");\n\nmodule.exports = Ajv;\n\nAjv.prototype.validate = validate;\nAjv.prototype.compile = compile;\nAjv.prototype.addSchema = addSchema;\nAjv.prototype.addMetaSchema = addMetaSchema;\nAjv.prototype.validateSchema = validateSchema;\nAjv.prototype.getSchema = getSchema;\nAjv.prototype.removeSchema = removeSchema;\nAjv.prototype.addFormat = addFormat;\nAjv.prototype.errorsText = errorsText;\n\nAjv.prototype._addSchema = _addSchema;\nAjv.prototype._compile = _compile;\n\nAjv.prototype.compileAsync = __webpack_require__(/*! ./compile/async */ \"./node_modules/ajv/lib/compile/async.js\");\nvar customKeyword = __webpack_require__(/*! ./keyword */ \"./node_modules/ajv/lib/keyword.js\");\nAjv.prototype.addKeyword = customKeyword.add;\nAjv.prototype.getKeyword = customKeyword.get;\nAjv.prototype.removeKeyword = customKeyword.remove;\nAjv.prototype.validateKeyword = customKeyword.validate;\n\nvar errorClasses = __webpack_require__(/*! ./compile/error_classes */ \"./node_modules/ajv/lib/compile/error_classes.js\");\nAjv.ValidationError = errorClasses.Validation;\nAjv.MissingRefError = errorClasses.MissingRef;\nAjv.$dataMetaSchema = $dataMetaSchema;\n\nvar META_SCHEMA_ID = 'http://json-schema.org/draft-07/schema';\n\nvar META_IGNORE_OPTIONS = [ 'removeAdditional', 'useDefaults', 'coerceTypes', 'strictDefaults' ];\nvar META_SUPPORT_DATA = ['/properties'];\n\n/**\n * Creates validator instance.\n * Usage: `Ajv(opts)`\n * @param {Object} opts optional options\n * @return {Object} ajv instance\n */\nfunction Ajv(opts) {\n  if (!(this instanceof Ajv)) return new Ajv(opts);\n  opts = this._opts = util.copy(opts) || {};\n  setLogger(this);\n  this._schemas = {};\n  this._refs = {};\n  this._fragments = {};\n  this._formats = formats(opts.format);\n\n  this._cache = opts.cache || new Cache;\n  this._loadingSchemas = {};\n  this._compilations = [];\n  this.RULES = rules();\n  this._getId = chooseGetId(opts);\n\n  opts.loopRequired = opts.loopRequired || Infinity;\n  if (opts.errorDataPath == 'property') opts._errorDataPathProperty = true;\n  if (opts.serialize === undefined) opts.serialize = stableStringify;\n  this._metaOpts = getMetaSchemaOptions(this);\n\n  if (opts.formats) addInitialFormats(this);\n  if (opts.keywords) addInitialKeywords(this);\n  addDefaultMetaSchema(this);\n  if (typeof opts.meta == 'object') this.addMetaSchema(opts.meta);\n  if (opts.nullable) this.addKeyword('nullable', {metaSchema: {type: 'boolean'}});\n  addInitialSchemas(this);\n}\n\n\n\n/**\n * Validate data using schema\n * Schema will be compiled and cached (using serialized JSON as key. [fast-json-stable-stringify](https://github.com/epoberezkin/fast-json-stable-stringify) is used to serialize.\n * @this   Ajv\n * @param  {String|Object} schemaKeyRef key, ref or schema object\n * @param  {Any} data to be validated\n * @return {Boolean} validation result. Errors from the last validation will be available in `ajv.errors` (and also in compiled schema: `schema.errors`).\n */\nfunction validate(schemaKeyRef, data) {\n  var v;\n  if (typeof schemaKeyRef == 'string') {\n    v = this.getSchema(schemaKeyRef);\n    if (!v) throw new Error('no schema with key or ref \"' + schemaKeyRef + '\"');\n  } else {\n    var schemaObj = this._addSchema(schemaKeyRef);\n    v = schemaObj.validate || this._compile(schemaObj);\n  }\n\n  var valid = v(data);\n  if (v.$async !== true) this.errors = v.errors;\n  return valid;\n}\n\n\n/**\n * Create validating function for passed schema.\n * @this   Ajv\n * @param  {Object} schema schema object\n * @param  {Boolean} _meta true if schema is a meta-schema. Used internally to compile meta schemas of custom keywords.\n * @return {Function} validating function\n */\nfunction compile(schema, _meta) {\n  var schemaObj = this._addSchema(schema, undefined, _meta);\n  return schemaObj.validate || this._compile(schemaObj);\n}\n\n\n/**\n * Adds schema to the instance.\n * @this   Ajv\n * @param {Object|Array} schema schema or array of schemas. If array is passed, `key` and other parameters will be ignored.\n * @param {String} key Optional schema key. Can be passed to `validate` method instead of schema object or id/ref. One schema per instance can have empty `id` and `key`.\n * @param {Boolean} _skipValidation true to skip schema validation. Used internally, option validateSchema should be used instead.\n * @param {Boolean} _meta true if schema is a meta-schema. Used internally, addMetaSchema should be used instead.\n * @return {Ajv} this for method chaining\n */\nfunction addSchema(schema, key, _skipValidation, _meta) {\n  if (Array.isArray(schema)){\n    for (var i=0; i<schema.length; i++) this.addSchema(schema[i], undefined, _skipValidation, _meta);\n    return this;\n  }\n  var id = this._getId(schema);\n  if (id !== undefined && typeof id != 'string')\n    throw new Error('schema id must be string');\n  key = resolve.normalizeId(key || id);\n  checkUnique(this, key);\n  this._schemas[key] = this._addSchema(schema, _skipValidation, _meta, true);\n  return this;\n}\n\n\n/**\n * Add schema that will be used to validate other schemas\n * options in META_IGNORE_OPTIONS are alway set to false\n * @this   Ajv\n * @param {Object} schema schema object\n * @param {String} key optional schema key\n * @param {Boolean} skipValidation true to skip schema validation, can be used to override validateSchema option for meta-schema\n * @return {Ajv} this for method chaining\n */\nfunction addMetaSchema(schema, key, skipValidation) {\n  this.addSchema(schema, key, skipValidation, true);\n  return this;\n}\n\n\n/**\n * Validate schema\n * @this   Ajv\n * @param {Object} schema schema to validate\n * @param {Boolean} throwOrLogError pass true to throw (or log) an error if invalid\n * @return {Boolean} true if schema is valid\n */\nfunction validateSchema(schema, throwOrLogError) {\n  var $schema = schema.$schema;\n  if ($schema !== undefined && typeof $schema != 'string')\n    throw new Error('$schema must be a string');\n  $schema = $schema || this._opts.defaultMeta || defaultMeta(this);\n  if (!$schema) {\n    this.logger.warn('meta-schema not available');\n    this.errors = null;\n    return true;\n  }\n  var valid = this.validate($schema, schema);\n  if (!valid && throwOrLogError) {\n    var message = 'schema is invalid: ' + this.errorsText();\n    if (this._opts.validateSchema == 'log') this.logger.error(message);\n    else throw new Error(message);\n  }\n  return valid;\n}\n\n\nfunction defaultMeta(self) {\n  var meta = self._opts.meta;\n  self._opts.defaultMeta = typeof meta == 'object'\n                            ? self._getId(meta) || meta\n                            : self.getSchema(META_SCHEMA_ID)\n                              ? META_SCHEMA_ID\n                              : undefined;\n  return self._opts.defaultMeta;\n}\n\n\n/**\n * Get compiled schema from the instance by `key` or `ref`.\n * @this   Ajv\n * @param  {String} keyRef `key` that was passed to `addSchema` or full schema reference (`schema.id` or resolved id).\n * @return {Function} schema validating function (with property `schema`).\n */\nfunction getSchema(keyRef) {\n  var schemaObj = _getSchemaObj(this, keyRef);\n  switch (typeof schemaObj) {\n    case 'object': return schemaObj.validate || this._compile(schemaObj);\n    case 'string': return this.getSchema(schemaObj);\n    case 'undefined': return _getSchemaFragment(this, keyRef);\n  }\n}\n\n\nfunction _getSchemaFragment(self, ref) {\n  var res = resolve.schema.call(self, { schema: {} }, ref);\n  if (res) {\n    var schema = res.schema\n      , root = res.root\n      , baseId = res.baseId;\n    var v = compileSchema.call(self, schema, root, undefined, baseId);\n    self._fragments[ref] = new SchemaObject({\n      ref: ref,\n      fragment: true,\n      schema: schema,\n      root: root,\n      baseId: baseId,\n      validate: v\n    });\n    return v;\n  }\n}\n\n\nfunction _getSchemaObj(self, keyRef) {\n  keyRef = resolve.normalizeId(keyRef);\n  return self._schemas[keyRef] || self._refs[keyRef] || self._fragments[keyRef];\n}\n\n\n/**\n * Remove cached schema(s).\n * If no parameter is passed all schemas but meta-schemas are removed.\n * If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.\n * Even if schema is referenced by other schemas it still can be removed as other schemas have local references.\n * @this   Ajv\n * @param  {String|Object|RegExp} schemaKeyRef key, ref, pattern to match key/ref or schema object\n * @return {Ajv} this for method chaining\n */\nfunction removeSchema(schemaKeyRef) {\n  if (schemaKeyRef instanceof RegExp) {\n    _removeAllSchemas(this, this._schemas, schemaKeyRef);\n    _removeAllSchemas(this, this._refs, schemaKeyRef);\n    return this;\n  }\n  switch (typeof schemaKeyRef) {\n    case 'undefined':\n      _removeAllSchemas(this, this._schemas);\n      _removeAllSchemas(this, this._refs);\n      this._cache.clear();\n      return this;\n    case 'string':\n      var schemaObj = _getSchemaObj(this, schemaKeyRef);\n      if (schemaObj) this._cache.del(schemaObj.cacheKey);\n      delete this._schemas[schemaKeyRef];\n      delete this._refs[schemaKeyRef];\n      return this;\n    case 'object':\n      var serialize = this._opts.serialize;\n      var cacheKey = serialize ? serialize(schemaKeyRef) : schemaKeyRef;\n      this._cache.del(cacheKey);\n      var id = this._getId(schemaKeyRef);\n      if (id) {\n        id = resolve.normalizeId(id);\n        delete this._schemas[id];\n        delete this._refs[id];\n      }\n  }\n  return this;\n}\n\n\nfunction _removeAllSchemas(self, schemas, regex) {\n  for (var keyRef in schemas) {\n    var schemaObj = schemas[keyRef];\n    if (!schemaObj.meta && (!regex || regex.test(keyRef))) {\n      self._cache.del(schemaObj.cacheKey);\n      delete schemas[keyRef];\n    }\n  }\n}\n\n\n/* @this   Ajv */\nfunction _addSchema(schema, skipValidation, meta, shouldAddSchema) {\n  if (typeof schema != 'object' && typeof schema != 'boolean')\n    throw new Error('schema should be object or boolean');\n  var serialize = this._opts.serialize;\n  var cacheKey = serialize ? serialize(schema) : schema;\n  var cached = this._cache.get(cacheKey);\n  if (cached) return cached;\n\n  shouldAddSchema = shouldAddSchema || this._opts.addUsedSchema !== false;\n\n  var id = resolve.normalizeId(this._getId(schema));\n  if (id && shouldAddSchema) checkUnique(this, id);\n\n  var willValidate = this._opts.validateSchema !== false && !skipValidation;\n  var recursiveMeta;\n  if (willValidate && !(recursiveMeta = id && id == resolve.normalizeId(schema.$schema)))\n    this.validateSchema(schema, true);\n\n  var localRefs = resolve.ids.call(this, schema);\n\n  var schemaObj = new SchemaObject({\n    id: id,\n    schema: schema,\n    localRefs: localRefs,\n    cacheKey: cacheKey,\n    meta: meta\n  });\n\n  if (id[0] != '#' && shouldAddSchema) this._refs[id] = schemaObj;\n  this._cache.put(cacheKey, schemaObj);\n\n  if (willValidate && recursiveMeta) this.validateSchema(schema, true);\n\n  return schemaObj;\n}\n\n\n/* @this   Ajv */\nfunction _compile(schemaObj, root) {\n  if (schemaObj.compiling) {\n    schemaObj.validate = callValidate;\n    callValidate.schema = schemaObj.schema;\n    callValidate.errors = null;\n    callValidate.root = root ? root : callValidate;\n    if (schemaObj.schema.$async === true)\n      callValidate.$async = true;\n    return callValidate;\n  }\n  schemaObj.compiling = true;\n\n  var currentOpts;\n  if (schemaObj.meta) {\n    currentOpts = this._opts;\n    this._opts = this._metaOpts;\n  }\n\n  var v;\n  try { v = compileSchema.call(this, schemaObj.schema, root, schemaObj.localRefs); }\n  catch(e) {\n    delete schemaObj.validate;\n    throw e;\n  }\n  finally {\n    schemaObj.compiling = false;\n    if (schemaObj.meta) this._opts = currentOpts;\n  }\n\n  schemaObj.validate = v;\n  schemaObj.refs = v.refs;\n  schemaObj.refVal = v.refVal;\n  schemaObj.root = v.root;\n  return v;\n\n\n  /* @this   {*} - custom context, see passContext option */\n  function callValidate() {\n    /* jshint validthis: true */\n    var _validate = schemaObj.validate;\n    var result = _validate.apply(this, arguments);\n    callValidate.errors = _validate.errors;\n    return result;\n  }\n}\n\n\nfunction chooseGetId(opts) {\n  switch (opts.schemaId) {\n    case 'auto': return _get$IdOrId;\n    case 'id': return _getId;\n    default: return _get$Id;\n  }\n}\n\n/* @this   Ajv */\nfunction _getId(schema) {\n  if (schema.$id) this.logger.warn('schema $id ignored', schema.$id);\n  return schema.id;\n}\n\n/* @this   Ajv */\nfunction _get$Id(schema) {\n  if (schema.id) this.logger.warn('schema id ignored', schema.id);\n  return schema.$id;\n}\n\n\nfunction _get$IdOrId(schema) {\n  if (schema.$id && schema.id && schema.$id != schema.id)\n    throw new Error('schema $id is different from id');\n  return schema.$id || schema.id;\n}\n\n\n/**\n * Convert array of error message objects to string\n * @this   Ajv\n * @param  {Array<Object>} errors optional array of validation errors, if not passed errors from the instance are used.\n * @param  {Object} options optional options with properties `separator` and `dataVar`.\n * @return {String} human readable string with all errors descriptions\n */\nfunction errorsText(errors, options) {\n  errors = errors || this.errors;\n  if (!errors) return 'No errors';\n  options = options || {};\n  var separator = options.separator === undefined ? ', ' : options.separator;\n  var dataVar = options.dataVar === undefined ? 'data' : options.dataVar;\n\n  var text = '';\n  for (var i=0; i<errors.length; i++) {\n    var e = errors[i];\n    if (e) text += dataVar + e.dataPath + ' ' + e.message + separator;\n  }\n  return text.slice(0, -separator.length);\n}\n\n\n/**\n * Add custom format\n * @this   Ajv\n * @param {String} name format name\n * @param {String|RegExp|Function} format string is converted to RegExp; function should return boolean (true when valid)\n * @return {Ajv} this for method chaining\n */\nfunction addFormat(name, format) {\n  if (typeof format == 'string') format = new RegExp(format);\n  this._formats[name] = format;\n  return this;\n}\n\n\nfunction addDefaultMetaSchema(self) {\n  var $dataSchema;\n  if (self._opts.$data) {\n    $dataSchema = __webpack_require__(/*! ./refs/data.json */ \"./node_modules/ajv/lib/refs/data.json\");\n    self.addMetaSchema($dataSchema, $dataSchema.$id, true);\n  }\n  if (self._opts.meta === false) return;\n  var metaSchema = __webpack_require__(/*! ./refs/json-schema-draft-07.json */ \"./node_modules/ajv/lib/refs/json-schema-draft-07.json\");\n  if (self._opts.$data) metaSchema = $dataMetaSchema(metaSchema, META_SUPPORT_DATA);\n  self.addMetaSchema(metaSchema, META_SCHEMA_ID, true);\n  self._refs['http://json-schema.org/schema'] = META_SCHEMA_ID;\n}\n\n\nfunction addInitialSchemas(self) {\n  var optsSchemas = self._opts.schemas;\n  if (!optsSchemas) return;\n  if (Array.isArray(optsSchemas)) self.addSchema(optsSchemas);\n  else for (var key in optsSchemas) self.addSchema(optsSchemas[key], key);\n}\n\n\nfunction addInitialFormats(self) {\n  for (var name in self._opts.formats) {\n    var format = self._opts.formats[name];\n    self.addFormat(name, format);\n  }\n}\n\n\nfunction addInitialKeywords(self) {\n  for (var name in self._opts.keywords) {\n    var keyword = self._opts.keywords[name];\n    self.addKeyword(name, keyword);\n  }\n}\n\n\nfunction checkUnique(self, id) {\n  if (self._schemas[id] || self._refs[id])\n    throw new Error('schema with key or id \"' + id + '\" already exists');\n}\n\n\nfunction getMetaSchemaOptions(self) {\n  var metaOpts = util.copy(self._opts);\n  for (var i=0; i<META_IGNORE_OPTIONS.length; i++)\n    delete metaOpts[META_IGNORE_OPTIONS[i]];\n  return metaOpts;\n}\n\n\nfunction setLogger(self) {\n  var logger = self._opts.logger;\n  if (logger === false) {\n    self.logger = {log: noop, warn: noop, error: noop};\n  } else {\n    if (logger === undefined) logger = console;\n    if (!(typeof logger == 'object' && logger.log && logger.warn && logger.error))\n      throw new Error('logger must implement log, warn and error methods');\n    self.logger = logger;\n  }\n}\n\n\nfunction noop() {}\n\n\n//# sourceURL=webpack://javascript/./node_modules/ajv/lib/ajv.js?");

/***/ }),

/***/ "./node_modules/ajv/lib/cache.js":
/*!***************************************!*\
  !*** ./node_modules/ajv/lib/cache.js ***!
  \***************************************/
/***/ ((module) => {

"use strict";
eval("\n\n\nvar Cache = module.exports = function Cache() {\n  this._cache = {};\n};\n\n\nCache.prototype.put = function Cache_put(key, value) {\n  this._cache[key] = value;\n};\n\n\nCache.prototype.get = function Cache_get(key) {\n  return this._cache[key];\n};\n\n\nCache.prototype.del = function Cache_del(key) {\n  delete this._cache[key];\n};\n\n\nCache.prototype.clear = function Cache_clear() {\n  this._cache = {};\n};\n\n\n//# sourceURL=webpack://javascript/./node_modules/ajv/lib/cache.js?");

/***/ }),

/***/ "./node_modules/ajv/lib/compile/async.js":
/*!***********************************************!*\
  !*** ./node_modules/ajv/lib/compile/async.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar MissingRefError = (__webpack_require__(/*! ./error_classes */ \"./node_modules/ajv/lib/compile/error_classes.js\").MissingRef);\n\nmodule.exports = compileAsync;\n\n\n/**\n * Creates validating function for passed schema with asynchronous loading of missing schemas.\n * `loadSchema` option should be a function that accepts schema uri and returns promise that resolves with the schema.\n * @this  Ajv\n * @param {Object}   schema schema object\n * @param {Boolean}  meta optional true to compile meta-schema; this parameter can be skipped\n * @param {Function} callback an optional node-style callback, it is called with 2 parameters: error (or null) and validating function.\n * @return {Promise} promise that resolves with a validating function.\n */\nfunction compileAsync(schema, meta, callback) {\n  /* eslint no-shadow: 0 */\n  /* global Promise */\n  /* jshint validthis: true */\n  var self = this;\n  if (typeof this._opts.loadSchema != 'function')\n    throw new Error('options.loadSchema should be a function');\n\n  if (typeof meta == 'function') {\n    callback = meta;\n    meta = undefined;\n  }\n\n  var p = loadMetaSchemaOf(schema).then(function () {\n    var schemaObj = self._addSchema(schema, undefined, meta);\n    return schemaObj.validate || _compileAsync(schemaObj);\n  });\n\n  if (callback) {\n    p.then(\n      function(v) { callback(null, v); },\n      callback\n    );\n  }\n\n  return p;\n\n\n  function loadMetaSchemaOf(sch) {\n    var $schema = sch.$schema;\n    return $schema && !self.getSchema($schema)\n            ? compileAsync.call(self, { $ref: $schema }, true)\n            : Promise.resolve();\n  }\n\n\n  function _compileAsync(schemaObj) {\n    try { return self._compile(schemaObj); }\n    catch(e) {\n      if (e instanceof MissingRefError) return loadMissingSchema(e);\n      throw e;\n    }\n\n\n    function loadMissingSchema(e) {\n      var ref = e.missingSchema;\n      if (added(ref)) throw new Error('Schema ' + ref + ' is loaded but ' + e.missingRef + ' cannot be resolved');\n\n      var schemaPromise = self._loadingSchemas[ref];\n      if (!schemaPromise) {\n        schemaPromise = self._loadingSchemas[ref] = self._opts.loadSchema(ref);\n        schemaPromise.then(removePromise, removePromise);\n      }\n\n      return schemaPromise.then(function (sch) {\n        if (!added(ref)) {\n          return loadMetaSchemaOf(sch).then(function () {\n            if (!added(ref)) self.addSchema(sch, ref, undefined, meta);\n          });\n        }\n      }).then(function() {\n        return _compileAsync(schemaObj);\n      });\n\n      function removePromise() {\n        delete self._loadingSchemas[ref];\n      }\n\n      function added(ref) {\n        return self._refs[ref] || self._schemas[ref];\n      }\n    }\n  }\n}\n\n\n//# sourceURL=webpack://javascript/./node_modules/ajv/lib/compile/async.js?");

/***/ }),

/***/ "./node_modules/ajv/lib/compile/error_classes.js":
/*!*******************************************************!*\
  !*** ./node_modules/ajv/lib/compile/error_classes.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar resolve = __webpack_require__(/*! ./resolve */ \"./node_modules/ajv/lib/compile/resolve.js\");\n\nmodule.exports = {\n  Validation: errorSubclass(ValidationError),\n  MissingRef: errorSubclass(MissingRefError)\n};\n\n\nfunction ValidationError(errors) {\n  this.message = 'validation failed';\n  this.errors = errors;\n  this.ajv = this.validation = true;\n}\n\n\nMissingRefError.message = function (baseId, ref) {\n  return 'can\\'t resolve reference ' + ref + ' from id ' + baseId;\n};\n\n\nfunction MissingRefError(baseId, ref, message) {\n  this.message = message || MissingRefError.message(baseId, ref);\n  this.missingRef = resolve.url(baseId, ref);\n  this.missingSchema = resolve.normalizeId(resolve.fullPath(this.missingRef));\n}\n\n\nfunction errorSubclass(Subclass) {\n  Subclass.prototype = Object.create(Error.prototype);\n  Subclass.prototype.constructor = Subclass;\n  return Subclass;\n}\n\n\n//# sourceURL=webpack://javascript/./node_modules/ajv/lib/compile/error_classes.js?");

/***/ }),

/***/ "./node_modules/ajv/lib/compile/formats.js":
/*!*************************************************!*\
  !*** ./node_modules/ajv/lib/compile/formats.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar util = __webpack_require__(/*! ./util */ \"./node_modules/ajv/lib/compile/util.js\");\n\nvar DATE = /^(\\d\\d\\d\\d)-(\\d\\d)-(\\d\\d)$/;\nvar DAYS = [0,31,28,31,30,31,30,31,31,30,31,30,31];\nvar TIME = /^(\\d\\d):(\\d\\d):(\\d\\d)(\\.\\d+)?(z|[+-]\\d\\d(?::?\\d\\d)?)?$/i;\nvar HOSTNAME = /^(?=.{1,253}\\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\\.?$/i;\nvar URI = /^(?:[a-z][a-z0-9+\\-.]*:)(?:\\/?\\/(?:(?:[a-z0-9\\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\\.[a-z0-9\\-._~!$&'()*+,;=:]+)\\]|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)|(?:[a-z0-9\\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\\d*)?(?:\\/(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\\/(?:(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\\?(?:[a-z0-9\\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;\nvar URIREF = /^(?:[a-z][a-z0-9+\\-.]*:)?(?:\\/?\\/(?:(?:[a-z0-9\\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\\.[a-z0-9\\-._~!$&'()*+,;=:]+)\\]|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)|(?:[a-z0-9\\-._~!$&'\"()*+,;=]|%[0-9a-f]{2})*)(?::\\d*)?(?:\\/(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})*)*|\\/(?:(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\\?(?:[a-z0-9\\-._~!$&'\"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\\-._~!$&'\"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;\n// uri-template: https://tools.ietf.org/html/rfc6570\nvar URITEMPLATE = /^(?:(?:[^\\x00-\\x20\"'<>%\\\\^`{|}]|%[0-9a-f]{2})|\\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\\*)?)*\\})*$/i;\n// For the source: https://gist.github.com/dperini/729294\n// For test cases: https://mathiasbynens.be/demo/url-regex\n// @todo Delete current URL in favour of the commented out URL rule when this issue is fixed https://github.com/eslint/eslint/issues/7983.\n// var URL = /^(?:(?:https?|ftp):\\/\\/)(?:\\S+(?::\\S*)?@)?(?:(?!10(?:\\.\\d{1,3}){3})(?!127(?:\\.\\d{1,3}){3})(?!169\\.254(?:\\.\\d{1,3}){2})(?!192\\.168(?:\\.\\d{1,3}){2})(?!172\\.(?:1[6-9]|2\\d|3[0-1])(?:\\.\\d{1,3}){2})(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u{00a1}-\\u{ffff}0-9]+-)*[a-z\\u{00a1}-\\u{ffff}0-9]+)(?:\\.(?:[a-z\\u{00a1}-\\u{ffff}0-9]+-)*[a-z\\u{00a1}-\\u{ffff}0-9]+)*(?:\\.(?:[a-z\\u{00a1}-\\u{ffff}]{2,})))(?::\\d{2,5})?(?:\\/[^\\s]*)?$/iu;\nvar URL = /^(?:(?:http[s\\u017F]?|ftp):\\/\\/)(?:(?:[\\0-\\x08\\x0E-\\x1F!-\\x9F\\xA1-\\u167F\\u1681-\\u1FFF\\u200B-\\u2027\\u202A-\\u202E\\u2030-\\u205E\\u2060-\\u2FFF\\u3001-\\uD7FF\\uE000-\\uFEFE\\uFF00-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])+(?::(?:[\\0-\\x08\\x0E-\\x1F!-\\x9F\\xA1-\\u167F\\u1681-\\u1FFF\\u200B-\\u2027\\u202A-\\u202E\\u2030-\\u205E\\u2060-\\u2FFF\\u3001-\\uD7FF\\uE000-\\uFEFE\\uFF00-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])*)?@)?(?:(?!10(?:\\.[0-9]{1,3}){3})(?!127(?:\\.[0-9]{1,3}){3})(?!169\\.254(?:\\.[0-9]{1,3}){2})(?!192\\.168(?:\\.[0-9]{1,3}){2})(?!172\\.(?:1[6-9]|2[0-9]|3[01])(?:\\.[0-9]{1,3}){2})(?:[1-9][0-9]?|1[0-9][0-9]|2[01][0-9]|22[0-3])(?:\\.(?:1?[0-9]{1,2}|2[0-4][0-9]|25[0-5])){2}(?:\\.(?:[1-9][0-9]?|1[0-9][0-9]|2[0-4][0-9]|25[0-4]))|(?:(?:(?:[0-9a-z\\xA1-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])+-)*(?:[0-9a-z\\xA1-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])+)(?:\\.(?:(?:[0-9a-z\\xA1-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])+-)*(?:[0-9a-z\\xA1-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])+)*(?:\\.(?:(?:[a-z\\xA1-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]){2,})))(?::[0-9]{2,5})?(?:\\/(?:[\\0-\\x08\\x0E-\\x1F!-\\x9F\\xA1-\\u167F\\u1681-\\u1FFF\\u200B-\\u2027\\u202A-\\u202E\\u2030-\\u205E\\u2060-\\u2FFF\\u3001-\\uD7FF\\uE000-\\uFEFE\\uFF00-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])*)?$/i;\nvar UUID = /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i;\nvar JSON_POINTER = /^(?:\\/(?:[^~/]|~0|~1)*)*$/;\nvar JSON_POINTER_URI_FRAGMENT = /^#(?:\\/(?:[a-z0-9_\\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i;\nvar RELATIVE_JSON_POINTER = /^(?:0|[1-9][0-9]*)(?:#|(?:\\/(?:[^~/]|~0|~1)*)*)$/;\n\n\nmodule.exports = formats;\n\nfunction formats(mode) {\n  mode = mode == 'full' ? 'full' : 'fast';\n  return util.copy(formats[mode]);\n}\n\n\nformats.fast = {\n  // date: http://tools.ietf.org/html/rfc3339#section-5.6\n  date: /^\\d\\d\\d\\d-[0-1]\\d-[0-3]\\d$/,\n  // date-time: http://tools.ietf.org/html/rfc3339#section-5.6\n  time: /^(?:[0-2]\\d:[0-5]\\d:[0-5]\\d|23:59:60)(?:\\.\\d+)?(?:z|[+-]\\d\\d(?::?\\d\\d)?)?$/i,\n  'date-time': /^\\d\\d\\d\\d-[0-1]\\d-[0-3]\\d[t\\s](?:[0-2]\\d:[0-5]\\d:[0-5]\\d|23:59:60)(?:\\.\\d+)?(?:z|[+-]\\d\\d(?::?\\d\\d)?)$/i,\n  // uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js\n  uri: /^(?:[a-z][a-z0-9+\\-.]*:)(?:\\/?\\/)?[^\\s]*$/i,\n  'uri-reference': /^(?:(?:[a-z][a-z0-9+\\-.]*:)?\\/?\\/)?(?:[^\\\\\\s#][^\\s#]*)?(?:#[^\\\\\\s]*)?$/i,\n  'uri-template': URITEMPLATE,\n  url: URL,\n  // email (sources from jsen validator):\n  // http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address#answer-8829363\n  // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address (search for 'willful violation')\n  email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i,\n  hostname: HOSTNAME,\n  // optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html\n  ipv4: /^(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)$/,\n  // optimized http://stackoverflow.com/questions/53497/regular-expression-that-matches-valid-ipv6-addresses\n  ipv6: /^\\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:)))(?:%.+)?\\s*$/i,\n  regex: regex,\n  // uuid: http://tools.ietf.org/html/rfc4122\n  uuid: UUID,\n  // JSON-pointer: https://tools.ietf.org/html/rfc6901\n  // uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A\n  'json-pointer': JSON_POINTER,\n  'json-pointer-uri-fragment': JSON_POINTER_URI_FRAGMENT,\n  // relative JSON-pointer: http://tools.ietf.org/html/draft-luff-relative-json-pointer-00\n  'relative-json-pointer': RELATIVE_JSON_POINTER\n};\n\n\nformats.full = {\n  date: date,\n  time: time,\n  'date-time': date_time,\n  uri: uri,\n  'uri-reference': URIREF,\n  'uri-template': URITEMPLATE,\n  url: URL,\n  email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,\n  hostname: HOSTNAME,\n  ipv4: /^(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)$/,\n  ipv6: /^\\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:)))(?:%.+)?\\s*$/i,\n  regex: regex,\n  uuid: UUID,\n  'json-pointer': JSON_POINTER,\n  'json-pointer-uri-fragment': JSON_POINTER_URI_FRAGMENT,\n  'relative-json-pointer': RELATIVE_JSON_POINTER\n};\n\n\nfunction isLeapYear(year) {\n  // https://tools.ietf.org/html/rfc3339#appendix-C\n  return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);\n}\n\n\nfunction date(str) {\n  // full-date from http://tools.ietf.org/html/rfc3339#section-5.6\n  var matches = str.match(DATE);\n  if (!matches) return false;\n\n  var year = +matches[1];\n  var month = +matches[2];\n  var day = +matches[3];\n\n  return month >= 1 && month <= 12 && day >= 1 &&\n          day <= (month == 2 && isLeapYear(year) ? 29 : DAYS[month]);\n}\n\n\nfunction time(str, full) {\n  var matches = str.match(TIME);\n  if (!matches) return false;\n\n  var hour = matches[1];\n  var minute = matches[2];\n  var second = matches[3];\n  var timeZone = matches[5];\n  return ((hour <= 23 && minute <= 59 && second <= 59) ||\n          (hour == 23 && minute == 59 && second == 60)) &&\n         (!full || timeZone);\n}\n\n\nvar DATE_TIME_SEPARATOR = /t|\\s/i;\nfunction date_time(str) {\n  // http://tools.ietf.org/html/rfc3339#section-5.6\n  var dateTime = str.split(DATE_TIME_SEPARATOR);\n  return dateTime.length == 2 && date(dateTime[0]) && time(dateTime[1], true);\n}\n\n\nvar NOT_URI_FRAGMENT = /\\/|:/;\nfunction uri(str) {\n  // http://jmrware.com/articles/2009/uri_regexp/URI_regex.html + optional protocol + required \".\"\n  return NOT_URI_FRAGMENT.test(str) && URI.test(str);\n}\n\n\nvar Z_ANCHOR = /[^\\\\]\\\\Z/;\nfunction regex(str) {\n  if (Z_ANCHOR.test(str)) return false;\n  try {\n    new RegExp(str);\n    return true;\n  } catch(e) {\n    return false;\n  }\n}\n\n\n//# sourceURL=webpack://javascript/./node_modules/ajv/lib/compile/formats.js?");

/***/ }),

/***/ "./node_modules/ajv/lib/compile/index.js":
/*!***********************************************!*\
  !*** ./node_modules/ajv/lib/compile/index.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar resolve = __webpack_require__(/*! ./resolve */ \"./node_modules/ajv/lib/compile/resolve.js\")\n  , util = __webpack_require__(/*! ./util */ \"./node_modules/ajv/lib/compile/util.js\")\n  , errorClasses = __webpack_require__(/*! ./error_classes */ \"./node_modules/ajv/lib/compile/error_classes.js\")\n  , stableStringify = __webpack_require__(/*! fast-json-stable-stringify */ \"./node_modules/fast-json-stable-stringify/index.js\");\n\nvar validateGenerator = __webpack_require__(/*! ../dotjs/validate */ \"./node_modules/ajv/lib/dotjs/validate.js\");\n\n/**\n * Functions below are used inside compiled validations function\n */\n\nvar ucs2length = util.ucs2length;\nvar equal = __webpack_require__(/*! fast-deep-equal */ \"./node_modules/fast-deep-equal/index.js\");\n\n// this error is thrown by async schemas to return validation errors via exception\nvar ValidationError = errorClasses.Validation;\n\nmodule.exports = compile;\n\n\n/**\n * Compiles schema to validation function\n * @this   Ajv\n * @param  {Object} schema schema object\n * @param  {Object} root object with information about the root schema for this schema\n * @param  {Object} localRefs the hash of local references inside the schema (created by resolve.id), used for inline resolution\n * @param  {String} baseId base ID for IDs in the schema\n * @return {Function} validation function\n */\nfunction compile(schema, root, localRefs, baseId) {\n  /* jshint validthis: true, evil: true */\n  /* eslint no-shadow: 0 */\n  var self = this\n    , opts = this._opts\n    , refVal = [ undefined ]\n    , refs = {}\n    , patterns = []\n    , patternsHash = {}\n    , defaults = []\n    , defaultsHash = {}\n    , customRules = [];\n\n  root = root || { schema: schema, refVal: refVal, refs: refs };\n\n  var c = checkCompiling.call(this, schema, root, baseId);\n  var compilation = this._compilations[c.index];\n  if (c.compiling) return (compilation.callValidate = callValidate);\n\n  var formats = this._formats;\n  var RULES = this.RULES;\n\n  try {\n    var v = localCompile(schema, root, localRefs, baseId);\n    compilation.validate = v;\n    var cv = compilation.callValidate;\n    if (cv) {\n      cv.schema = v.schema;\n      cv.errors = null;\n      cv.refs = v.refs;\n      cv.refVal = v.refVal;\n      cv.root = v.root;\n      cv.$async = v.$async;\n      if (opts.sourceCode) cv.source = v.source;\n    }\n    return v;\n  } finally {\n    endCompiling.call(this, schema, root, baseId);\n  }\n\n  /* @this   {*} - custom context, see passContext option */\n  function callValidate() {\n    /* jshint validthis: true */\n    var validate = compilation.validate;\n    var result = validate.apply(this, arguments);\n    callValidate.errors = validate.errors;\n    return result;\n  }\n\n  function localCompile(_schema, _root, localRefs, baseId) {\n    var isRoot = !_root || (_root && _root.schema == _schema);\n    if (_root.schema != root.schema)\n      return compile.call(self, _schema, _root, localRefs, baseId);\n\n    var $async = _schema.$async === true;\n\n    var sourceCode = validateGenerator({\n      isTop: true,\n      schema: _schema,\n      isRoot: isRoot,\n      baseId: baseId,\n      root: _root,\n      schemaPath: '',\n      errSchemaPath: '#',\n      errorPath: '\"\"',\n      MissingRefError: errorClasses.MissingRef,\n      RULES: RULES,\n      validate: validateGenerator,\n      util: util,\n      resolve: resolve,\n      resolveRef: resolveRef,\n      usePattern: usePattern,\n      useDefault: useDefault,\n      useCustomRule: useCustomRule,\n      opts: opts,\n      formats: formats,\n      logger: self.logger,\n      self: self\n    });\n\n    sourceCode = vars(refVal, refValCode) + vars(patterns, patternCode)\n                   + vars(defaults, defaultCode) + vars(customRules, customRuleCode)\n                   + sourceCode;\n\n    if (opts.processCode) sourceCode = opts.processCode(sourceCode, _schema);\n    // console.log('\\n\\n\\n *** \\n', JSON.stringify(sourceCode));\n    var validate;\n    try {\n      var makeValidate = new Function(\n        'self',\n        'RULES',\n        'formats',\n        'root',\n        'refVal',\n        'defaults',\n        'customRules',\n        'equal',\n        'ucs2length',\n        'ValidationError',\n        sourceCode\n      );\n\n      validate = makeValidate(\n        self,\n        RULES,\n        formats,\n        root,\n        refVal,\n        defaults,\n        customRules,\n        equal,\n        ucs2length,\n        ValidationError\n      );\n\n      refVal[0] = validate;\n    } catch(e) {\n      self.logger.error('Error compiling schema, function code:', sourceCode);\n      throw e;\n    }\n\n    validate.schema = _schema;\n    validate.errors = null;\n    validate.refs = refs;\n    validate.refVal = refVal;\n    validate.root = isRoot ? validate : _root;\n    if ($async) validate.$async = true;\n    if (opts.sourceCode === true) {\n      validate.source = {\n        code: sourceCode,\n        patterns: patterns,\n        defaults: defaults\n      };\n    }\n\n    return validate;\n  }\n\n  function resolveRef(baseId, ref, isRoot) {\n    ref = resolve.url(baseId, ref);\n    var refIndex = refs[ref];\n    var _refVal, refCode;\n    if (refIndex !== undefined) {\n      _refVal = refVal[refIndex];\n      refCode = 'refVal[' + refIndex + ']';\n      return resolvedRef(_refVal, refCode);\n    }\n    if (!isRoot && root.refs) {\n      var rootRefId = root.refs[ref];\n      if (rootRefId !== undefined) {\n        _refVal = root.refVal[rootRefId];\n        refCode = addLocalRef(ref, _refVal);\n        return resolvedRef(_refVal, refCode);\n      }\n    }\n\n    refCode = addLocalRef(ref);\n    var v = resolve.call(self, localCompile, root, ref);\n    if (v === undefined) {\n      var localSchema = localRefs && localRefs[ref];\n      if (localSchema) {\n        v = resolve.inlineRef(localSchema, opts.inlineRefs)\n            ? localSchema\n            : compile.call(self, localSchema, root, localRefs, baseId);\n      }\n    }\n\n    if (v === undefined) {\n      removeLocalRef(ref);\n    } else {\n      replaceLocalRef(ref, v);\n      return resolvedRef(v, refCode);\n    }\n  }\n\n  function addLocalRef(ref, v) {\n    var refId = refVal.length;\n    refVal[refId] = v;\n    refs[ref] = refId;\n    return 'refVal' + refId;\n  }\n\n  function removeLocalRef(ref) {\n    delete refs[ref];\n  }\n\n  function replaceLocalRef(ref, v) {\n    var refId = refs[ref];\n    refVal[refId] = v;\n  }\n\n  function resolvedRef(refVal, code) {\n    return typeof refVal == 'object' || typeof refVal == 'boolean'\n            ? { code: code, schema: refVal, inline: true }\n            : { code: code, $async: refVal && !!refVal.$async };\n  }\n\n  function usePattern(regexStr) {\n    var index = patternsHash[regexStr];\n    if (index === undefined) {\n      index = patternsHash[regexStr] = patterns.length;\n      patterns[index] = regexStr;\n    }\n    return 'pattern' + index;\n  }\n\n  function useDefault(value) {\n    switch (typeof value) {\n      case 'boolean':\n      case 'number':\n        return '' + value;\n      case 'string':\n        return util.toQuotedString(value);\n      case 'object':\n        if (value === null) return 'null';\n        var valueStr = stableStringify(value);\n        var index = defaultsHash[valueStr];\n        if (index === undefined) {\n          index = defaultsHash[valueStr] = defaults.length;\n          defaults[index] = value;\n        }\n        return 'default' + index;\n    }\n  }\n\n  function useCustomRule(rule, schema, parentSchema, it) {\n    if (self._opts.validateSchema !== false) {\n      var deps = rule.definition.dependencies;\n      if (deps && !deps.every(function(keyword) {\n        return Object.prototype.hasOwnProperty.call(parentSchema, keyword);\n      }))\n        throw new Error('parent schema must have all required keywords: ' + deps.join(','));\n\n      var validateSchema = rule.definition.validateSchema;\n      if (validateSchema) {\n        var valid = validateSchema(schema);\n        if (!valid) {\n          var message = 'keyword schema is invalid: ' + self.errorsText(validateSchema.errors);\n          if (self._opts.validateSchema == 'log') self.logger.error(message);\n          else throw new Error(message);\n        }\n      }\n    }\n\n    var compile = rule.definition.compile\n      , inline = rule.definition.inline\n      , macro = rule.definition.macro;\n\n    var validate;\n    if (compile) {\n      validate = compile.call(self, schema, parentSchema, it);\n    } else if (macro) {\n      validate = macro.call(self, schema, parentSchema, it);\n      if (opts.validateSchema !== false) self.validateSchema(validate, true);\n    } else if (inline) {\n      validate = inline.call(self, it, rule.keyword, schema, parentSchema);\n    } else {\n      validate = rule.definition.validate;\n      if (!validate) return;\n    }\n\n    if (validate === undefined)\n      throw new Error('custom keyword \"' + rule.keyword + '\"failed to compile');\n\n    var index = customRules.length;\n    customRules[index] = validate;\n\n    return {\n      code: 'customRule' + index,\n      validate: validate\n    };\n  }\n}\n\n\n/**\n * Checks if the schema is currently compiled\n * @this   Ajv\n * @param  {Object} schema schema to compile\n * @param  {Object} root root object\n * @param  {String} baseId base schema ID\n * @return {Object} object with properties \"index\" (compilation index) and \"compiling\" (boolean)\n */\nfunction checkCompiling(schema, root, baseId) {\n  /* jshint validthis: true */\n  var index = compIndex.call(this, schema, root, baseId);\n  if (index >= 0) return { index: index, compiling: true };\n  index = this._compilations.length;\n  this._compilations[index] = {\n    schema: schema,\n    root: root,\n    baseId: baseId\n  };\n  return { index: index, compiling: false };\n}\n\n\n/**\n * Removes the schema from the currently compiled list\n * @this   Ajv\n * @param  {Object} schema schema to compile\n * @param  {Object} root root object\n * @param  {String} baseId base schema ID\n */\nfunction endCompiling(schema, root, baseId) {\n  /* jshint validthis: true */\n  var i = compIndex.call(this, schema, root, baseId);\n  if (i >= 0) this._compilations.splice(i, 1);\n}\n\n\n/**\n * Index of schema compilation in the currently compiled list\n * @this   Ajv\n * @param  {Object} schema schema to compile\n * @param  {Object} root root object\n * @param  {String} baseId base schema ID\n * @return {Integer} compilation index\n */\nfunction compIndex(schema, root, baseId) {\n  /* jshint validthis: true */\n  for (var i=0; i<this._compilations.length; i++) {\n    var c = this._compilations[i];\n    if (c.schema == schema && c.root == root && c.baseId == baseId) return i;\n  }\n  return -1;\n}\n\n\nfunction patternCode(i, patterns) {\n  return 'var pattern' + i + ' = new RegExp(' + util.toQuotedString(patterns[i]) + ');';\n}\n\n\nfunction defaultCode(i) {\n  return 'var default' + i + ' = defaults[' + i + '];';\n}\n\n\nfunction refValCode(i, refVal) {\n  return refVal[i] === undefined ? '' : 'var refVal' + i + ' = refVal[' + i + '];';\n}\n\n\nfunction customRuleCode(i) {\n  return 'var customRule' + i + ' = customRules[' + i + '];';\n}\n\n\nfunction vars(arr, statement) {\n  if (!arr.length) return '';\n  var code = '';\n  for (var i=0; i<arr.length; i++)\n    code += statement(i, arr);\n  return code;\n}\n\n\n//# sourceURL=webpack://javascript/./node_modules/ajv/lib/compile/index.js?");

/***/ }),

/***/ "./node_modules/ajv/lib/compile/resolve.js":
/*!*************************************************!*\
  !*** ./node_modules/ajv/lib/compile/resolve.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar URI = __webpack_require__(/*! uri-js */ \"./node_modules/uri-js/dist/es5/uri.all.js\")\n  , equal = __webpack_require__(/*! fast-deep-equal */ \"./node_modules/fast-deep-equal/index.js\")\n  , util = __webpack_require__(/*! ./util */ \"./node_modules/ajv/lib/compile/util.js\")\n  , SchemaObject = __webpack_require__(/*! ./schema_obj */ \"./node_modules/ajv/lib/compile/schema_obj.js\")\n  , traverse = __webpack_require__(/*! json-schema-traverse */ \"./node_modules/json-schema-traverse/index.js\");\n\nmodule.exports = resolve;\n\nresolve.normalizeId = normalizeId;\nresolve.fullPath = getFullPath;\nresolve.url = resolveUrl;\nresolve.ids = resolveIds;\nresolve.inlineRef = inlineRef;\nresolve.schema = resolveSchema;\n\n/**\n * [resolve and compile the references ($ref)]\n * @this   Ajv\n * @param  {Function} compile reference to schema compilation funciton (localCompile)\n * @param  {Object} root object with information about the root schema for the current schema\n * @param  {String} ref reference to resolve\n * @return {Object|Function} schema object (if the schema can be inlined) or validation function\n */\nfunction resolve(compile, root, ref) {\n  /* jshint validthis: true */\n  var refVal = this._refs[ref];\n  if (typeof refVal == 'string') {\n    if (this._refs[refVal]) refVal = this._refs[refVal];\n    else return resolve.call(this, compile, root, refVal);\n  }\n\n  refVal = refVal || this._schemas[ref];\n  if (refVal instanceof SchemaObject) {\n    return inlineRef(refVal.schema, this._opts.inlineRefs)\n            ? refVal.schema\n            : refVal.validate || this._compile(refVal);\n  }\n\n  var res = resolveSchema.call(this, root, ref);\n  var schema, v, baseId;\n  if (res) {\n    schema = res.schema;\n    root = res.root;\n    baseId = res.baseId;\n  }\n\n  if (schema instanceof SchemaObject) {\n    v = schema.validate || compile.call(this, schema.schema, root, undefined, baseId);\n  } else if (schema !== undefined) {\n    v = inlineRef(schema, this._opts.inlineRefs)\n        ? schema\n        : compile.call(this, schema, root, undefined, baseId);\n  }\n\n  return v;\n}\n\n\n/**\n * Resolve schema, its root and baseId\n * @this Ajv\n * @param  {Object} root root object with properties schema, refVal, refs\n * @param  {String} ref  reference to resolve\n * @return {Object} object with properties schema, root, baseId\n */\nfunction resolveSchema(root, ref) {\n  /* jshint validthis: true */\n  var p = URI.parse(ref)\n    , refPath = _getFullPath(p)\n    , baseId = getFullPath(this._getId(root.schema));\n  if (Object.keys(root.schema).length === 0 || refPath !== baseId) {\n    var id = normalizeId(refPath);\n    var refVal = this._refs[id];\n    if (typeof refVal == 'string') {\n      return resolveRecursive.call(this, root, refVal, p);\n    } else if (refVal instanceof SchemaObject) {\n      if (!refVal.validate) this._compile(refVal);\n      root = refVal;\n    } else {\n      refVal = this._schemas[id];\n      if (refVal instanceof SchemaObject) {\n        if (!refVal.validate) this._compile(refVal);\n        if (id == normalizeId(ref))\n          return { schema: refVal, root: root, baseId: baseId };\n        root = refVal;\n      } else {\n        return;\n      }\n    }\n    if (!root.schema) return;\n    baseId = getFullPath(this._getId(root.schema));\n  }\n  return getJsonPointer.call(this, p, baseId, root.schema, root);\n}\n\n\n/* @this Ajv */\nfunction resolveRecursive(root, ref, parsedRef) {\n  /* jshint validthis: true */\n  var res = resolveSchema.call(this, root, ref);\n  if (res) {\n    var schema = res.schema;\n    var baseId = res.baseId;\n    root = res.root;\n    var id = this._getId(schema);\n    if (id) baseId = resolveUrl(baseId, id);\n    return getJsonPointer.call(this, parsedRef, baseId, schema, root);\n  }\n}\n\n\nvar PREVENT_SCOPE_CHANGE = util.toHash(['properties', 'patternProperties', 'enum', 'dependencies', 'definitions']);\n/* @this Ajv */\nfunction getJsonPointer(parsedRef, baseId, schema, root) {\n  /* jshint validthis: true */\n  parsedRef.fragment = parsedRef.fragment || '';\n  if (parsedRef.fragment.slice(0,1) != '/') return;\n  var parts = parsedRef.fragment.split('/');\n\n  for (var i = 1; i < parts.length; i++) {\n    var part = parts[i];\n    if (part) {\n      part = util.unescapeFragment(part);\n      schema = schema[part];\n      if (schema === undefined) break;\n      var id;\n      if (!PREVENT_SCOPE_CHANGE[part]) {\n        id = this._getId(schema);\n        if (id) baseId = resolveUrl(baseId, id);\n        if (schema.$ref) {\n          var $ref = resolveUrl(baseId, schema.$ref);\n          var res = resolveSchema.call(this, root, $ref);\n          if (res) {\n            schema = res.schema;\n            root = res.root;\n            baseId = res.baseId;\n          }\n        }\n      }\n    }\n  }\n  if (schema !== undefined && schema !== root.schema)\n    return { schema: schema, root: root, baseId: baseId };\n}\n\n\nvar SIMPLE_INLINED = util.toHash([\n  'type', 'format', 'pattern',\n  'maxLength', 'minLength',\n  'maxProperties', 'minProperties',\n  'maxItems', 'minItems',\n  'maximum', 'minimum',\n  'uniqueItems', 'multipleOf',\n  'required', 'enum'\n]);\nfunction inlineRef(schema, limit) {\n  if (limit === false) return false;\n  if (limit === undefined || limit === true) return checkNoRef(schema);\n  else if (limit) return countKeys(schema) <= limit;\n}\n\n\nfunction checkNoRef(schema) {\n  var item;\n  if (Array.isArray(schema)) {\n    for (var i=0; i<schema.length; i++) {\n      item = schema[i];\n      if (typeof item == 'object' && !checkNoRef(item)) return false;\n    }\n  } else {\n    for (var key in schema) {\n      if (key == '$ref') return false;\n      item = schema[key];\n      if (typeof item == 'object' && !checkNoRef(item)) return false;\n    }\n  }\n  return true;\n}\n\n\nfunction countKeys(schema) {\n  var count = 0, item;\n  if (Array.isArray(schema)) {\n    for (var i=0; i<schema.length; i++) {\n      item = schema[i];\n      if (typeof item == 'object') count += countKeys(item);\n      if (count == Infinity) return Infinity;\n    }\n  } else {\n    for (var key in schema) {\n      if (key == '$ref') return Infinity;\n      if (SIMPLE_INLINED[key]) {\n        count++;\n      } else {\n        item = schema[key];\n        if (typeof item == 'object') count += countKeys(item) + 1;\n        if (count == Infinity) return Infinity;\n      }\n    }\n  }\n  return count;\n}\n\n\nfunction getFullPath(id, normalize) {\n  if (normalize !== false) id = normalizeId(id);\n  var p = URI.parse(id);\n  return _getFullPath(p);\n}\n\n\nfunction _getFullPath(p) {\n  return URI.serialize(p).split('#')[0] + '#';\n}\n\n\nvar TRAILING_SLASH_HASH = /#\\/?$/;\nfunction normalizeId(id) {\n  return id ? id.replace(TRAILING_SLASH_HASH, '') : '';\n}\n\n\nfunction resolveUrl(baseId, id) {\n  id = normalizeId(id);\n  return URI.resolve(baseId, id);\n}\n\n\n/* @this Ajv */\nfunction resolveIds(schema) {\n  var schemaId = normalizeId(this._getId(schema));\n  var baseIds = {'': schemaId};\n  var fullPaths = {'': getFullPath(schemaId, false)};\n  var localRefs = {};\n  var self = this;\n\n  traverse(schema, {allKeys: true}, function(sch, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {\n    if (jsonPtr === '') return;\n    var id = self._getId(sch);\n    var baseId = baseIds[parentJsonPtr];\n    var fullPath = fullPaths[parentJsonPtr] + '/' + parentKeyword;\n    if (keyIndex !== undefined)\n      fullPath += '/' + (typeof keyIndex == 'number' ? keyIndex : util.escapeFragment(keyIndex));\n\n    if (typeof id == 'string') {\n      id = baseId = normalizeId(baseId ? URI.resolve(baseId, id) : id);\n\n      var refVal = self._refs[id];\n      if (typeof refVal == 'string') refVal = self._refs[refVal];\n      if (refVal && refVal.schema) {\n        if (!equal(sch, refVal.schema))\n          throw new Error('id \"' + id + '\" resolves to more than one schema');\n      } else if (id != normalizeId(fullPath)) {\n        if (id[0] == '#') {\n          if (localRefs[id] && !equal(sch, localRefs[id]))\n            throw new Error('id \"' + id + '\" resolves to more than one schema');\n          localRefs[id] = sch;\n        } else {\n          self._refs[id] = fullPath;\n        }\n      }\n    }\n    baseIds[jsonPtr] = baseId;\n    fullPaths[jsonPtr] = fullPath;\n  });\n\n  return localRefs;\n}\n\n\n//# sourceURL=webpack://javascript/./node_modules/ajv/lib/compile/resolve.js?");

/***/ }),

/***/ "./node_modules/ajv/lib/compile/rules.js":
/*!***********************************************!*\
  !*** ./node_modules/ajv/lib/compile/rules.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar ruleModules = __webpack_require__(/*! ../dotjs */ \"./node_modules/ajv/lib/dotjs/index.js\")\n  , toHash = (__webpack_require__(/*! ./util */ \"./node_modules/ajv/lib/compile/util.js\").toHash);\n\nmodule.exports = function rules() {\n  var RULES = [\n    { type: 'number',\n      rules: [ { 'maximum': ['exclusiveMaximum'] },\n               { 'minimum': ['exclusiveMinimum'] }, 'multipleOf', 'format'] },\n    { type: 'string',\n      rules: [ 'maxLength', 'minLength', 'pattern', 'format' ] },\n    { type: 'array',\n      rules: [ 'maxItems', 'minItems', 'items', 'contains', 'uniqueItems' ] },\n    { type: 'object',\n      rules: [ 'maxProperties', 'minProperties', 'required', 'dependencies', 'propertyNames',\n               { 'properties': ['additionalProperties', 'patternProperties'] } ] },\n    { rules: [ '$ref', 'const', 'enum', 'not', 'anyOf', 'oneOf', 'allOf', 'if' ] }\n  ];\n\n  var ALL = [ 'type', '$comment' ];\n  var KEYWORDS = [\n    '$schema', '$id', 'id', '$data', '$async', 'title',\n    'description', 'default', 'definitions',\n    'examples', 'readOnly', 'writeOnly',\n    'contentMediaType', 'contentEncoding',\n    'additionalItems', 'then', 'else'\n  ];\n  var TYPES = [ 'number', 'integer', 'string', 'array', 'object', 'boolean', 'null' ];\n  RULES.all = toHash(ALL);\n  RULES.types = toHash(TYPES);\n\n  RULES.forEach(function (group) {\n    group.rules = group.rules.map(function (keyword) {\n      var implKeywords;\n      if (typeof keyword == 'object') {\n        var key = Object.keys(keyword)[0];\n        implKeywords = keyword[key];\n        keyword = key;\n        implKeywords.forEach(function (k) {\n          ALL.push(k);\n          RULES.all[k] = true;\n        });\n      }\n      ALL.push(keyword);\n      var rule = RULES.all[keyword] = {\n        keyword: keyword,\n        code: ruleModules[keyword],\n        implements: implKeywords\n      };\n      return rule;\n    });\n\n    RULES.all.$comment = {\n      keyword: '$comment',\n      code: ruleModules.$comment\n    };\n\n    if (group.type) RULES.types[group.type] = group;\n  });\n\n  RULES.keywords = toHash(ALL.concat(KEYWORDS));\n  RULES.custom = {};\n\n  return RULES;\n};\n\n\n//# sourceURL=webpack://javascript/./node_modules/ajv/lib/compile/rules.js?");

/***/ }),

/***/ "./node_modules/ajv/lib/compile/schema_obj.js":
/*!****************************************************!*\
  !*** ./node_modules/ajv/lib/compile/schema_obj.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar util = __webpack_require__(/*! ./util */ \"./node_modules/ajv/lib/compile/util.js\");\n\nmodule.exports = SchemaObject;\n\nfunction SchemaObject(obj) {\n  util.copy(obj, this);\n}\n\n\n//# sourceURL=webpack://javascript/./node_modules/ajv/lib/compile/schema_obj.js?");

/***/ }),

/***/ "./node_modules/ajv/lib/compile/ucs2length.js":
/*!****************************************************!*\
  !*** ./node_modules/ajv/lib/compile/ucs2length.js ***!
  \****************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n// https://mathiasbynens.be/notes/javascript-encoding\n// https://github.com/bestiejs/punycode.js - punycode.ucs2.decode\nmodule.exports = function ucs2length(str) {\n  var length = 0\n    , len = str.length\n    , pos = 0\n    , value;\n  while (pos < len) {\n    length++;\n    value = str.charCodeAt(pos++);\n    if (value >= 0xD800 && value <= 0xDBFF && pos < len) {\n      // high surrogate, and there is a next character\n      value = str.charCodeAt(pos);\n      if ((value & 0xFC00) == 0xDC00) pos++; // low surrogate\n    }\n  }\n  return length;\n};\n\n\n//# sourceURL=webpack://javascript/./node_modules/ajv/lib/compile/ucs2length.js?");

/***/ }),

/***/ "./node_modules/ajv/lib/compile/util.js":
/*!**********************************************!*\
  !*** ./node_modules/ajv/lib/compile/util.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n\nmodule.exports = {\n  copy: copy,\n  checkDataType: checkDataType,\n  checkDataTypes: checkDataTypes,\n  coerceToTypes: coerceToTypes,\n  toHash: toHash,\n  getProperty: getProperty,\n  escapeQuotes: escapeQuotes,\n  equal: __webpack_require__(/*! fast-deep-equal */ \"./node_modules/fast-deep-equal/index.js\"),\n  ucs2length: __webpack_require__(/*! ./ucs2length */ \"./node_modules/ajv/lib/compile/ucs2length.js\"),\n  varOccurences: varOccurences,\n  varReplace: varReplace,\n  schemaHasRules: schemaHasRules,\n  schemaHasRulesExcept: schemaHasRulesExcept,\n  schemaUnknownRules: schemaUnknownRules,\n  toQuotedString: toQuotedString,\n  getPathExpr: getPathExpr,\n  getPath: getPath,\n  getData: getData,\n  unescapeFragment: unescapeFragment,\n  unescapeJsonPointer: unescapeJsonPointer,\n  escapeFragment: escapeFragment,\n  escapeJsonPointer: escapeJsonPointer\n};\n\n\nfunction copy(o, to) {\n  to = to || {};\n  for (var key in o) to[key] = o[key];\n  return to;\n}\n\n\nfunction checkDataType(dataType, data, strictNumbers, negate) {\n  var EQUAL = negate ? ' !== ' : ' === '\n    , AND = negate ? ' || ' : ' && '\n    , OK = negate ? '!' : ''\n    , NOT = negate ? '' : '!';\n  switch (dataType) {\n    case 'null': return data + EQUAL + 'null';\n    case 'array': return OK + 'Array.isArray(' + data + ')';\n    case 'object': return '(' + OK + data + AND +\n                          'typeof ' + data + EQUAL + '\"object\"' + AND +\n                          NOT + 'Array.isArray(' + data + '))';\n    case 'integer': return '(typeof ' + data + EQUAL + '\"number\"' + AND +\n                           NOT + '(' + data + ' % 1)' +\n                           AND + data + EQUAL + data +\n                           (strictNumbers ? (AND + OK + 'isFinite(' + data + ')') : '') + ')';\n    case 'number': return '(typeof ' + data + EQUAL + '\"' + dataType + '\"' +\n                          (strictNumbers ? (AND + OK + 'isFinite(' + data + ')') : '') + ')';\n    default: return 'typeof ' + data + EQUAL + '\"' + dataType + '\"';\n  }\n}\n\n\nfunction checkDataTypes(dataTypes, data, strictNumbers) {\n  switch (dataTypes.length) {\n    case 1: return checkDataType(dataTypes[0], data, strictNumbers, true);\n    default:\n      var code = '';\n      var types = toHash(dataTypes);\n      if (types.array && types.object) {\n        code = types.null ? '(': '(!' + data + ' || ';\n        code += 'typeof ' + data + ' !== \"object\")';\n        delete types.null;\n        delete types.array;\n        delete types.object;\n      }\n      if (types.number) delete types.integer;\n      for (var t in types)\n        code += (code ? ' && ' : '' ) + checkDataType(t, data, strictNumbers, true);\n\n      return code;\n  }\n}\n\n\nvar COERCE_TO_TYPES = toHash([ 'string', 'number', 'integer', 'boolean', 'null' ]);\nfunction coerceToTypes(optionCoerceTypes, dataTypes) {\n  if (Array.isArray(dataTypes)) {\n    var types = [];\n    for (var i=0; i<dataTypes.length; i++) {\n      var t = dataTypes[i];\n      if (COERCE_TO_TYPES[t]) types[types.length] = t;\n      else if (optionCoerceTypes === 'array' && t === 'array') types[types.length] = t;\n    }\n    if (types.length) return types;\n  } else if (COERCE_TO_TYPES[dataTypes]) {\n    return [dataTypes];\n  } else if (optionCoerceTypes === 'array' && dataTypes === 'array') {\n    return ['array'];\n  }\n}\n\n\nfunction toHash(arr) {\n  var hash = {};\n  for (var i=0; i<arr.length; i++) hash[arr[i]] = true;\n  return hash;\n}\n\n\nvar IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;\nvar SINGLE_QUOTE = /'|\\\\/g;\nfunction getProperty(key) {\n  return typeof key == 'number'\n          ? '[' + key + ']'\n          : IDENTIFIER.test(key)\n            ? '.' + key\n            : \"['\" + escapeQuotes(key) + \"']\";\n}\n\n\nfunction escapeQuotes(str) {\n  return str.replace(SINGLE_QUOTE, '\\\\$&')\n            .replace(/\\n/g, '\\\\n')\n            .replace(/\\r/g, '\\\\r')\n            .replace(/\\f/g, '\\\\f')\n            .replace(/\\t/g, '\\\\t');\n}\n\n\nfunction varOccurences(str, dataVar) {\n  dataVar += '[^0-9]';\n  var matches = str.match(new RegExp(dataVar, 'g'));\n  return matches ? matches.length : 0;\n}\n\n\nfunction varReplace(str, dataVar, expr) {\n  dataVar += '([^0-9])';\n  expr = expr.replace(/\\$/g, '$$$$');\n  return str.replace(new RegExp(dataVar, 'g'), expr + '$1');\n}\n\n\nfunction schemaHasRules(schema, rules) {\n  if (typeof schema == 'boolean') return !schema;\n  for (var key in schema) if (rules[key]) return true;\n}\n\n\nfunction schemaHasRulesExcept(schema, rules, exceptKeyword) {\n  if (typeof schema == 'boolean') return !schema && exceptKeyword != 'not';\n  for (var key in schema) if (key != exceptKeyword && rules[key]) return true;\n}\n\n\nfunction schemaUnknownRules(schema, rules) {\n  if (typeof schema == 'boolean') return;\n  for (var key in schema) if (!rules[key]) return key;\n}\n\n\nfunction toQuotedString(str) {\n  return '\\'' + escapeQuotes(str) + '\\'';\n}\n\n\nfunction getPathExpr(currentPath, expr, jsonPointers, isNumber) {\n  var path = jsonPointers // false by default\n              ? '\\'/\\' + ' + expr + (isNumber ? '' : '.replace(/~/g, \\'~0\\').replace(/\\\\//g, \\'~1\\')')\n              : (isNumber ? '\\'[\\' + ' + expr + ' + \\']\\'' : '\\'[\\\\\\'\\' + ' + expr + ' + \\'\\\\\\']\\'');\n  return joinPaths(currentPath, path);\n}\n\n\nfunction getPath(currentPath, prop, jsonPointers) {\n  var path = jsonPointers // false by default\n              ? toQuotedString('/' + escapeJsonPointer(prop))\n              : toQuotedString(getProperty(prop));\n  return joinPaths(currentPath, path);\n}\n\n\nvar JSON_POINTER = /^\\/(?:[^~]|~0|~1)*$/;\nvar RELATIVE_JSON_POINTER = /^([0-9]+)(#|\\/(?:[^~]|~0|~1)*)?$/;\nfunction getData($data, lvl, paths) {\n  var up, jsonPointer, data, matches;\n  if ($data === '') return 'rootData';\n  if ($data[0] == '/') {\n    if (!JSON_POINTER.test($data)) throw new Error('Invalid JSON-pointer: ' + $data);\n    jsonPointer = $data;\n    data = 'rootData';\n  } else {\n    matches = $data.match(RELATIVE_JSON_POINTER);\n    if (!matches) throw new Error('Invalid JSON-pointer: ' + $data);\n    up = +matches[1];\n    jsonPointer = matches[2];\n    if (jsonPointer == '#') {\n      if (up >= lvl) throw new Error('Cannot access property/index ' + up + ' levels up, current level is ' + lvl);\n      return paths[lvl - up];\n    }\n\n    if (up > lvl) throw new Error('Cannot access data ' + up + ' levels up, current level is ' + lvl);\n    data = 'data' + ((lvl - up) || '');\n    if (!jsonPointer) return data;\n  }\n\n  var expr = data;\n  var segments = jsonPointer.split('/');\n  for (var i=0; i<segments.length; i++) {\n    var segment = segments[i];\n    if (segment) {\n      data += getProperty(unescapeJsonPointer(segment));\n      expr += ' && ' + data;\n    }\n  }\n  return expr;\n}\n\n\nfunction joinPaths (a, b) {\n  if (a == '\"\"') return b;\n  return (a + ' + ' + b).replace(/([^\\\\])' \\+ '/g, '$1');\n}\n\n\nfunction unescapeFragment(str) {\n  return unescapeJsonPointer(decodeURIComponent(str));\n}\n\n\nfunction escapeFragment(str) {\n  return encodeURIComponent(escapeJsonPointer(str));\n}\n\n\nfunction escapeJsonPointer(str) {\n  return str.replace(/~/g, '~0').replace(/\\//g, '~1');\n}\n\n\nfunction unescapeJsonPointer(str) {\n  return str.replace(/~1/g, '/').replace(/~0/g, '~');\n}\n\n\n//# sourceURL=webpack://javascript/./node_modules/ajv/lib/compile/util.js?");

/***/ }),

/***/ "./node_modules/ajv/lib/data.js":
/*!**************************************!*\
  !*** ./node_modules/ajv/lib/data.js ***!
  \**************************************/
/***/ ((module) => {

"use strict";
eval("\n\nvar KEYWORDS = [\n  'multipleOf',\n  'maximum',\n  'exclusiveMaximum',\n  'minimum',\n  'exclusiveMinimum',\n  'maxLength',\n  'minLength',\n  'pattern',\n  'additionalItems',\n  'maxItems',\n  'minItems',\n  'uniqueItems',\n  'maxProperties',\n  'minProperties',\n  'required',\n  'additionalProperties',\n  'enum',\n  'format',\n  'const'\n];\n\nmodule.exports = function (metaSchema, keywordsJsonPointers) {\n  for (var i=0; i<keywordsJsonPointers.length; i++) {\n    metaSchema = JSON.parse(JSON.stringify(metaSchema));\n    var segments = keywordsJsonPointers[i].split('/');\n    var keywords = metaSchema;\n    var j;\n    for (j=1; j<segments.length; j++)\n      keywords = keywords[segments[j]];\n\n    for (j=0; j<KEYWORDS.length; j++) {\n      var key = KEYWORDS[j];\n      var schema = keywords[key];\n      if (schema) {\n        keywords[key] = {\n          anyOf: [\n            schema,\n            { $ref: 'https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#' }\n          ]\n        };\n      }\n    }\n  }\n\n  return metaSchema;\n};\n\n\n//# sourceURL=webpack://javascript/./node_modules/ajv/lib/data.js?");

/***/ }),

/***/ "./node_modules/ajv/lib/definition_schema.js":
/*!***************************************************!*\
  !*** ./node_modules/ajv/lib/definition_schema.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar metaSchema = __webpack_require__(/*! ./refs/json-schema-draft-07.json */ \"./node_modules/ajv/lib/refs/json-schema-draft-07.json\");\n\nmodule.exports = {\n  $id: 'https://github.com/ajv-validator/ajv/blob/master/lib/definition_schema.js',\n  definitions: {\n    simpleTypes: metaSchema.definitions.simpleTypes\n  },\n  type: 'object',\n  dependencies: {\n    schema: ['validate'],\n    $data: ['validate'],\n    statements: ['inline'],\n    valid: {not: {required: ['macro']}}\n  },\n  properties: {\n    type: metaSchema.properties.type,\n    schema: {type: 'boolean'},\n    statements: {type: 'boolean'},\n    dependencies: {\n      type: 'array',\n      items: {type: 'string'}\n    },\n    metaSchema: {type: 'object'},\n    modifying: {type: 'boolean'},\n    valid: {type: 'boolean'},\n    $data: {type: 'boolean'},\n    async: {type: 'boolean'},\n    errors: {\n      anyOf: [\n        {type: 'boolean'},\n        {const: 'full'}\n      ]\n    }\n  }\n};\n\n\n//# sourceURL=webpack://javascript/./node_modules/ajv/lib/definition_schema.js?");

/***/ }),

/***/ "./node_modules/ajv/lib/dotjs/_limit.js":
/*!**********************************************!*\
  !*** ./node_modules/ajv/lib/dotjs/_limit.js ***!
  \**********************************************/
/***/ ((module) => {

"use strict";
eval("\nmodule.exports = function generate__limit(it, $keyword, $ruleType) {\n  var out = ' ';\n  var $lvl = it.level;\n  var $dataLvl = it.dataLevel;\n  var $schema = it.schema[$keyword];\n  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);\n  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;\n  var $breakOnError = !it.opts.allErrors;\n  var $errorKeyword;\n  var $data = 'data' + ($dataLvl || '');\n  var $isData = it.opts.$data && $schema && $schema.$data,\n    $schemaValue;\n  if ($isData) {\n    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';\n    $schemaValue = 'schema' + $lvl;\n  } else {\n    $schemaValue = $schema;\n  }\n  var $isMax = $keyword == 'maximum',\n    $exclusiveKeyword = $isMax ? 'exclusiveMaximum' : 'exclusiveMinimum',\n    $schemaExcl = it.schema[$exclusiveKeyword],\n    $isDataExcl = it.opts.$data && $schemaExcl && $schemaExcl.$data,\n    $op = $isMax ? '<' : '>',\n    $notOp = $isMax ? '>' : '<',\n    $errorKeyword = undefined;\n  if (!($isData || typeof $schema == 'number' || $schema === undefined)) {\n    throw new Error($keyword + ' must be number');\n  }\n  if (!($isDataExcl || $schemaExcl === undefined || typeof $schemaExcl == 'number' || typeof $schemaExcl == 'boolean')) {\n    throw new Error($exclusiveKeyword + ' must be number or boolean');\n  }\n  if ($isDataExcl) {\n    var $schemaValueExcl = it.util.getData($schemaExcl.$data, $dataLvl, it.dataPathArr),\n      $exclusive = 'exclusive' + $lvl,\n      $exclType = 'exclType' + $lvl,\n      $exclIsNumber = 'exclIsNumber' + $lvl,\n      $opExpr = 'op' + $lvl,\n      $opStr = '\\' + ' + $opExpr + ' + \\'';\n    out += ' var schemaExcl' + ($lvl) + ' = ' + ($schemaValueExcl) + '; ';\n    $schemaValueExcl = 'schemaExcl' + $lvl;\n    out += ' var ' + ($exclusive) + '; var ' + ($exclType) + ' = typeof ' + ($schemaValueExcl) + '; if (' + ($exclType) + ' != \\'boolean\\' && ' + ($exclType) + ' != \\'undefined\\' && ' + ($exclType) + ' != \\'number\\') { ';\n    var $errorKeyword = $exclusiveKeyword;\n    var $$outStack = $$outStack || [];\n    $$outStack.push(out);\n    out = ''; /* istanbul ignore else */\n    if (it.createErrors !== false) {\n      out += ' { keyword: \\'' + ($errorKeyword || '_exclusiveLimit') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: {} ';\n      if (it.opts.messages !== false) {\n        out += ' , message: \\'' + ($exclusiveKeyword) + ' should be boolean\\' ';\n      }\n      if (it.opts.verbose) {\n        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n      }\n      out += ' } ';\n    } else {\n      out += ' {} ';\n    }\n    var __err = out;\n    out = $$outStack.pop();\n    if (!it.compositeRule && $breakOnError) {\n      /* istanbul ignore if */\n      if (it.async) {\n        out += ' throw new ValidationError([' + (__err) + ']); ';\n      } else {\n        out += ' validate.errors = [' + (__err) + ']; return false; ';\n      }\n    } else {\n      out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n    }\n    out += ' } else if ( ';\n    if ($isData) {\n      out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \\'number\\') || ';\n    }\n    out += ' ' + ($exclType) + ' == \\'number\\' ? ( (' + ($exclusive) + ' = ' + ($schemaValue) + ' === undefined || ' + ($schemaValueExcl) + ' ' + ($op) + '= ' + ($schemaValue) + ') ? ' + ($data) + ' ' + ($notOp) + '= ' + ($schemaValueExcl) + ' : ' + ($data) + ' ' + ($notOp) + ' ' + ($schemaValue) + ' ) : ( (' + ($exclusive) + ' = ' + ($schemaValueExcl) + ' === true) ? ' + ($data) + ' ' + ($notOp) + '= ' + ($schemaValue) + ' : ' + ($data) + ' ' + ($notOp) + ' ' + ($schemaValue) + ' ) || ' + ($data) + ' !== ' + ($data) + ') { var op' + ($lvl) + ' = ' + ($exclusive) + ' ? \\'' + ($op) + '\\' : \\'' + ($op) + '=\\'; ';\n    if ($schema === undefined) {\n      $errorKeyword = $exclusiveKeyword;\n      $errSchemaPath = it.errSchemaPath + '/' + $exclusiveKeyword;\n      $schemaValue = $schemaValueExcl;\n      $isData = $isDataExcl;\n    }\n  } else {\n    var $exclIsNumber = typeof $schemaExcl == 'number',\n      $opStr = $op;\n    if ($exclIsNumber && $isData) {\n      var $opExpr = '\\'' + $opStr + '\\'';\n      out += ' if ( ';\n      if ($isData) {\n        out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \\'number\\') || ';\n      }\n      out += ' ( ' + ($schemaValue) + ' === undefined || ' + ($schemaExcl) + ' ' + ($op) + '= ' + ($schemaValue) + ' ? ' + ($data) + ' ' + ($notOp) + '= ' + ($schemaExcl) + ' : ' + ($data) + ' ' + ($notOp) + ' ' + ($schemaValue) + ' ) || ' + ($data) + ' !== ' + ($data) + ') { ';\n    } else {\n      if ($exclIsNumber && $schema === undefined) {\n        $exclusive = true;\n        $errorKeyword = $exclusiveKeyword;\n        $errSchemaPath = it.errSchemaPath + '/' + $exclusiveKeyword;\n        $schemaValue = $schemaExcl;\n        $notOp += '=';\n      } else {\n        if ($exclIsNumber) $schemaValue = Math[$isMax ? 'min' : 'max']($schemaExcl, $schema);\n        if ($schemaExcl === ($exclIsNumber ? $schemaValue : true)) {\n          $exclusive = true;\n          $errorKeyword = $exclusiveKeyword;\n          $errSchemaPath = it.errSchemaPath + '/' + $exclusiveKeyword;\n          $notOp += '=';\n        } else {\n          $exclusive = false;\n          $opStr += '=';\n        }\n      }\n      var $opExpr = '\\'' + $opStr + '\\'';\n      out += ' if ( ';\n      if ($isData) {\n        out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \\'number\\') || ';\n      }\n      out += ' ' + ($data) + ' ' + ($notOp) + ' ' + ($schemaValue) + ' || ' + ($data) + ' !== ' + ($data) + ') { ';\n    }\n  }\n  $errorKeyword = $errorKeyword || $keyword;\n  var $$outStack = $$outStack || [];\n  $$outStack.push(out);\n  out = ''; /* istanbul ignore else */\n  if (it.createErrors !== false) {\n    out += ' { keyword: \\'' + ($errorKeyword || '_limit') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { comparison: ' + ($opExpr) + ', limit: ' + ($schemaValue) + ', exclusive: ' + ($exclusive) + ' } ';\n    if (it.opts.messages !== false) {\n      out += ' , message: \\'should be ' + ($opStr) + ' ';\n      if ($isData) {\n        out += '\\' + ' + ($schemaValue);\n      } else {\n        out += '' + ($schemaValue) + '\\'';\n      }\n    }\n    if (it.opts.verbose) {\n      out += ' , schema:  ';\n      if ($isData) {\n        out += 'validate.schema' + ($schemaPath);\n      } else {\n        out += '' + ($schema);\n      }\n      out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n    }\n    out += ' } ';\n  } else {\n    out += ' {} ';\n  }\n  var __err = out;\n  out = $$outStack.pop();\n  if (!it.compositeRule && $breakOnError) {\n    /* istanbul ignore if */\n    if (it.async) {\n      out += ' throw new ValidationError([' + (__err) + ']); ';\n    } else {\n      out += ' validate.errors = [' + (__err) + ']; return false; ';\n    }\n  } else {\n    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n  }\n  out += ' } ';\n  if ($breakOnError) {\n    out += ' else { ';\n  }\n  return out;\n}\n\n\n//# sourceURL=webpack://javascript/./node_modules/ajv/lib/dotjs/_limit.js?");

/***/ }),

/***/ "./node_modules/ajv/lib/dotjs/_limitItems.js":
/*!***************************************************!*\
  !*** ./node_modules/ajv/lib/dotjs/_limitItems.js ***!
  \***************************************************/
/***/ ((module) => {

"use strict";
eval("\nmodule.exports = function generate__limitItems(it, $keyword, $ruleType) {\n  var out = ' ';\n  var $lvl = it.level;\n  var $dataLvl = it.dataLevel;\n  var $schema = it.schema[$keyword];\n  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);\n  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;\n  var $breakOnError = !it.opts.allErrors;\n  var $errorKeyword;\n  var $data = 'data' + ($dataLvl || '');\n  var $isData = it.opts.$data && $schema && $schema.$data,\n    $schemaValue;\n  if ($isData) {\n    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';\n    $schemaValue = 'schema' + $lvl;\n  } else {\n    $schemaValue = $schema;\n  }\n  if (!($isData || typeof $schema == 'number')) {\n    throw new Error($keyword + ' must be number');\n  }\n  var $op = $keyword == 'maxItems' ? '>' : '<';\n  out += 'if ( ';\n  if ($isData) {\n    out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \\'number\\') || ';\n  }\n  out += ' ' + ($data) + '.length ' + ($op) + ' ' + ($schemaValue) + ') { ';\n  var $errorKeyword = $keyword;\n  var $$outStack = $$outStack || [];\n  $$outStack.push(out);\n  out = ''; /* istanbul ignore else */\n  if (it.createErrors !== false) {\n    out += ' { keyword: \\'' + ($errorKeyword || '_limitItems') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { limit: ' + ($schemaValue) + ' } ';\n    if (it.opts.messages !== false) {\n      out += ' , message: \\'should NOT have ';\n      if ($keyword == 'maxItems') {\n        out += 'more';\n      } else {\n        out += 'fewer';\n      }\n      out += ' than ';\n      if ($isData) {\n        out += '\\' + ' + ($schemaValue) + ' + \\'';\n      } else {\n        out += '' + ($schema);\n      }\n      out += ' items\\' ';\n    }\n    if (it.opts.verbose) {\n      out += ' , schema:  ';\n      if ($isData) {\n        out += 'validate.schema' + ($schemaPath);\n      } else {\n        out += '' + ($schema);\n      }\n      out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n    }\n    out += ' } ';\n  } else {\n    out += ' {} ';\n  }\n  var __err = out;\n  out = $$outStack.pop();\n  if (!it.compositeRule && $breakOnError) {\n    /* istanbul ignore if */\n    if (it.async) {\n      out += ' throw new ValidationError([' + (__err) + ']); ';\n    } else {\n      out += ' validate.errors = [' + (__err) + ']; return false; ';\n    }\n  } else {\n    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n  }\n  out += '} ';\n  if ($breakOnError) {\n    out += ' else { ';\n  }\n  return out;\n}\n\n\n//# sourceURL=webpack://javascript/./node_modules/ajv/lib/dotjs/_limitItems.js?");

/***/ }),

/***/ "./node_modules/ajv/lib/dotjs/_limitLength.js":
/*!****************************************************!*\
  !*** ./node_modules/ajv/lib/dotjs/_limitLength.js ***!
  \****************************************************/
/***/ ((module) => {

"use strict";
eval("\nmodule.exports = function generate__limitLength(it, $keyword, $ruleType) {\n  var out = ' ';\n  var $lvl = it.level;\n  var $dataLvl = it.dataLevel;\n  var $schema = it.schema[$keyword];\n  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);\n  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;\n  var $breakOnError = !it.opts.allErrors;\n  var $errorKeyword;\n  var $data = 'data' + ($dataLvl || '');\n  var $isData = it.opts.$data && $schema && $schema.$data,\n    $schemaValue;\n  if ($isData) {\n    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';\n    $schemaValue = 'schema' + $lvl;\n  } else {\n    $schemaValue = $schema;\n  }\n  if (!($isData || typeof $schema == 'number')) {\n    throw new Error($keyword + ' must be number');\n  }\n  var $op = $keyword == 'maxLength' ? '>' : '<';\n  out += 'if ( ';\n  if ($isData) {\n    out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \\'number\\') || ';\n  }\n  if (it.opts.unicode === false) {\n    out += ' ' + ($data) + '.length ';\n  } else {\n    out += ' ucs2length(' + ($data) + ') ';\n  }\n  out += ' ' + ($op) + ' ' + ($schemaValue) + ') { ';\n  var $errorKeyword = $keyword;\n  var $$outStack = $$outStack || [];\n  $$outStack.push(out);\n  out = ''; /* istanbul ignore else */\n  if (it.createErrors !== false) {\n    out += ' { keyword: \\'' + ($errorKeyword || '_limitLength') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { limit: ' + ($schemaValue) + ' } ';\n    if (it.opts.messages !== false) {\n      out += ' , message: \\'should NOT be ';\n      if ($keyword == 'maxLength') {\n        out += 'longer';\n      } else {\n        out += 'shorter';\n      }\n      out += ' than ';\n      if ($isData) {\n        out += '\\' + ' + ($schemaValue) + ' + \\'';\n      } else {\n        out += '' + ($schema);\n      }\n      out += ' characters\\' ';\n    }\n    if (it.opts.verbose) {\n      out += ' , schema:  ';\n      if ($isData) {\n        out += 'validate.schema' + ($schemaPath);\n      } else {\n        out += '' + ($schema);\n      }\n      out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n    }\n    out += ' } ';\n  } else {\n    out += ' {} ';\n  }\n  var __err = out;\n  out = $$outStack.pop();\n  if (!it.compositeRule && $breakOnError) {\n    /* istanbul ignore if */\n    if (it.async) {\n      out += ' throw new ValidationError([' + (__err) + ']); ';\n    } else {\n      out += ' validate.errors = [' + (__err) + ']; return false; ';\n    }\n  } else {\n    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n  }\n  out += '} ';\n  if ($breakOnError) {\n    out += ' else { ';\n  }\n  return out;\n}\n\n\n//# sourceURL=webpack://javascript/./node_modules/ajv/lib/dotjs/_limitLength.js?");

/***/ }),

/***/ "./node_modules/ajv/lib/dotjs/_limitProperties.js":
/*!********************************************************!*\
  !*** ./node_modules/ajv/lib/dotjs/_limitProperties.js ***!
  \********************************************************/
/***/ ((module) => {

"use strict";
eval("\nmodule.exports = function generate__limitProperties(it, $keyword, $ruleType) {\n  var out = ' ';\n  var $lvl = it.level;\n  var $dataLvl = it.dataLevel;\n  var $schema = it.schema[$keyword];\n  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);\n  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;\n  var $breakOnError = !it.opts.allErrors;\n  var $errorKeyword;\n  var $data = 'data' + ($dataLvl || '');\n  var $isData = it.opts.$data && $schema && $schema.$data,\n    $schemaValue;\n  if ($isData) {\n    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';\n    $schemaValue = 'schema' + $lvl;\n  } else {\n    $schemaValue = $schema;\n  }\n  if (!($isData || typeof $schema == 'number')) {\n    throw new Error($keyword + ' must be number');\n  }\n  var $op = $keyword == 'maxProperties' ? '>' : '<';\n  out += 'if ( ';\n  if ($isData) {\n    out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \\'number\\') || ';\n  }\n  out += ' Object.keys(' + ($data) + ').length ' + ($op) + ' ' + ($schemaValue) + ') { ';\n  var $errorKeyword = $keyword;\n  var $$outStack = $$outStack || [];\n  $$outStack.push(out);\n  out = ''; /* istanbul ignore else */\n  if (it.createErrors !== false) {\n    out += ' { keyword: \\'' + ($errorKeyword || '_limitProperties') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { limit: ' + ($schemaValue) + ' } ';\n    if (it.opts.messages !== false) {\n      out += ' , message: \\'should NOT have ';\n      if ($keyword == 'maxProperties') {\n        out += 'more';\n      } else {\n        out += 'fewer';\n      }\n      out += ' than ';\n      if ($isData) {\n        out += '\\' + ' + ($schemaValue) + ' + \\'';\n      } else {\n        out += '' + ($schema);\n      }\n      out += ' properties\\' ';\n    }\n    if (it.opts.verbose) {\n      out += ' , schema:  ';\n      if ($isData) {\n        out += 'validate.schema' + ($schemaPath);\n      } else {\n        out += '' + ($schema);\n      }\n      out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n    }\n    out += ' } ';\n  } else {\n    out += ' {} ';\n  }\n  var __err = out;\n  out = $$outStack.pop();\n  if (!it.compositeRule && $breakOnError) {\n    /* istanbul ignore if */\n    if (it.async) {\n      out += ' throw new ValidationError([' + (__err) + ']); ';\n    } else {\n      out += ' validate.errors = [' + (__err) + ']; return false; ';\n    }\n  } else {\n    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n  }\n  out += '} ';\n  if ($breakOnError) {\n    out += ' else { ';\n  }\n  return out;\n}\n\n\n//# sourceURL=webpack://javascript/./node_modules/ajv/lib/dotjs/_limitProperties.js?");

/***/ }),

/***/ "./node_modules/ajv/lib/dotjs/allOf.js":
/*!*********************************************!*\
  !*** ./node_modules/ajv/lib/dotjs/allOf.js ***!
  \*********************************************/
/***/ ((module) => {

"use strict";
eval("\nmodule.exports = function generate_allOf(it, $keyword, $ruleType) {\n  var out = ' ';\n  var $schema = it.schema[$keyword];\n  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);\n  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;\n  var $breakOnError = !it.opts.allErrors;\n  var $it = it.util.copy(it);\n  var $closingBraces = '';\n  $it.level++;\n  var $nextValid = 'valid' + $it.level;\n  var $currentBaseId = $it.baseId,\n    $allSchemasEmpty = true;\n  var arr1 = $schema;\n  if (arr1) {\n    var $sch, $i = -1,\n      l1 = arr1.length - 1;\n    while ($i < l1) {\n      $sch = arr1[$i += 1];\n      if ((it.opts.strictKeywords ? (typeof $sch == 'object' && Object.keys($sch).length > 0) || $sch === false : it.util.schemaHasRules($sch, it.RULES.all))) {\n        $allSchemasEmpty = false;\n        $it.schema = $sch;\n        $it.schemaPath = $schemaPath + '[' + $i + ']';\n        $it.errSchemaPath = $errSchemaPath + '/' + $i;\n        out += '  ' + (it.validate($it)) + ' ';\n        $it.baseId = $currentBaseId;\n        if ($breakOnError) {\n          out += ' if (' + ($nextValid) + ') { ';\n          $closingBraces += '}';\n        }\n      }\n    }\n  }\n  if ($breakOnError) {\n    if ($allSchemasEmpty) {\n      out += ' if (true) { ';\n    } else {\n      out += ' ' + ($closingBraces.slice(0, -1)) + ' ';\n    }\n  }\n  return out;\n}\n\n\n//# sourceURL=webpack://javascript/./node_modules/ajv/lib/dotjs/allOf.js?");

/***/ }),

/***/ "./node_modules/ajv/lib/dotjs/anyOf.js":
/*!*********************************************!*\
  !*** ./node_modules/ajv/lib/dotjs/anyOf.js ***!
  \*********************************************/
/***/ ((module) => {

"use strict";
eval("\nmodule.exports = function generate_anyOf(it, $keyword, $ruleType) {\n  var out = ' ';\n  var $lvl = it.level;\n  var $dataLvl = it.dataLevel;\n  var $schema = it.schema[$keyword];\n  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);\n  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;\n  var $breakOnError = !it.opts.allErrors;\n  var $data = 'data' + ($dataLvl || '');\n  var $valid = 'valid' + $lvl;\n  var $errs = 'errs__' + $lvl;\n  var $it = it.util.copy(it);\n  var $closingBraces = '';\n  $it.level++;\n  var $nextValid = 'valid' + $it.level;\n  var $noEmptySchema = $schema.every(function($sch) {\n    return (it.opts.strictKeywords ? (typeof $sch == 'object' && Object.keys($sch).length > 0) || $sch === false : it.util.schemaHasRules($sch, it.RULES.all));\n  });\n  if ($noEmptySchema) {\n    var $currentBaseId = $it.baseId;\n    out += ' var ' + ($errs) + ' = errors; var ' + ($valid) + ' = false;  ';\n    var $wasComposite = it.compositeRule;\n    it.compositeRule = $it.compositeRule = true;\n    var arr1 = $schema;\n    if (arr1) {\n      var $sch, $i = -1,\n        l1 = arr1.length - 1;\n      while ($i < l1) {\n        $sch = arr1[$i += 1];\n        $it.schema = $sch;\n        $it.schemaPath = $schemaPath + '[' + $i + ']';\n        $it.errSchemaPath = $errSchemaPath + '/' + $i;\n        out += '  ' + (it.validate($it)) + ' ';\n        $it.baseId = $currentBaseId;\n        out += ' ' + ($valid) + ' = ' + ($valid) + ' || ' + ($nextValid) + '; if (!' + ($valid) + ') { ';\n        $closingBraces += '}';\n      }\n    }\n    it.compositeRule = $it.compositeRule = $wasComposite;\n    out += ' ' + ($closingBraces) + ' if (!' + ($valid) + ') {   var err =   '; /* istanbul ignore else */\n    if (it.createErrors !== false) {\n      out += ' { keyword: \\'' + ('anyOf') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: {} ';\n      if (it.opts.messages !== false) {\n        out += ' , message: \\'should match some schema in anyOf\\' ';\n      }\n      if (it.opts.verbose) {\n        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n      }\n      out += ' } ';\n    } else {\n      out += ' {} ';\n    }\n    out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n    if (!it.compositeRule && $breakOnError) {\n      /* istanbul ignore if */\n      if (it.async) {\n        out += ' throw new ValidationError(vErrors); ';\n      } else {\n        out += ' validate.errors = vErrors; return false; ';\n      }\n    }\n    out += ' } else {  errors = ' + ($errs) + '; if (vErrors !== null) { if (' + ($errs) + ') vErrors.length = ' + ($errs) + '; else vErrors = null; } ';\n    if (it.opts.allErrors) {\n      out += ' } ';\n    }\n  } else {\n    if ($breakOnError) {\n      out += ' if (true) { ';\n    }\n  }\n  return out;\n}\n\n\n//# sourceURL=webpack://javascript/./node_modules/ajv/lib/dotjs/anyOf.js?");

/***/ }),

/***/ "./node_modules/ajv/lib/dotjs/comment.js":
/*!***********************************************!*\
  !*** ./node_modules/ajv/lib/dotjs/comment.js ***!
  \***********************************************/
/***/ ((module) => {

"use strict";
eval("\nmodule.exports = function generate_comment(it, $keyword, $ruleType) {\n  var out = ' ';\n  var $schema = it.schema[$keyword];\n  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;\n  var $breakOnError = !it.opts.allErrors;\n  var $comment = it.util.toQuotedString($schema);\n  if (it.opts.$comment === true) {\n    out += ' console.log(' + ($comment) + ');';\n  } else if (typeof it.opts.$comment == 'function') {\n    out += ' self._opts.$comment(' + ($comment) + ', ' + (it.util.toQuotedString($errSchemaPath)) + ', validate.root.schema);';\n  }\n  return out;\n}\n\n\n//# sourceURL=webpack://javascript/./node_modules/ajv/lib/dotjs/comment.js?");

/***/ }),

/***/ "./node_modules/ajv/lib/dotjs/const.js":
/*!*********************************************!*\
  !*** ./node_modules/ajv/lib/dotjs/const.js ***!
  \*********************************************/
/***/ ((module) => {

"use strict";
eval("\nmodule.exports = function generate_const(it, $keyword, $ruleType) {\n  var out = ' ';\n  var $lvl = it.level;\n  var $dataLvl = it.dataLevel;\n  var $schema = it.schema[$keyword];\n  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);\n  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;\n  var $breakOnError = !it.opts.allErrors;\n  var $data = 'data' + ($dataLvl || '');\n  var $valid = 'valid' + $lvl;\n  var $isData = it.opts.$data && $schema && $schema.$data,\n    $schemaValue;\n  if ($isData) {\n    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';\n    $schemaValue = 'schema' + $lvl;\n  } else {\n    $schemaValue = $schema;\n  }\n  if (!$isData) {\n    out += ' var schema' + ($lvl) + ' = validate.schema' + ($schemaPath) + ';';\n  }\n  out += 'var ' + ($valid) + ' = equal(' + ($data) + ', schema' + ($lvl) + '); if (!' + ($valid) + ') {   ';\n  var $$outStack = $$outStack || [];\n  $$outStack.push(out);\n  out = ''; /* istanbul ignore else */\n  if (it.createErrors !== false) {\n    out += ' { keyword: \\'' + ('const') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { allowedValue: schema' + ($lvl) + ' } ';\n    if (it.opts.messages !== false) {\n      out += ' , message: \\'should be equal to constant\\' ';\n    }\n    if (it.opts.verbose) {\n      out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n    }\n    out += ' } ';\n  } else {\n    out += ' {} ';\n  }\n  var __err = out;\n  out = $$outStack.pop();\n  if (!it.compositeRule && $breakOnError) {\n    /* istanbul ignore if */\n    if (it.async) {\n      out += ' throw new ValidationError([' + (__err) + ']); ';\n    } else {\n      out += ' validate.errors = [' + (__err) + ']; return false; ';\n    }\n  } else {\n    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n  }\n  out += ' }';\n  if ($breakOnError) {\n    out += ' else { ';\n  }\n  return out;\n}\n\n\n//# sourceURL=webpack://javascript/./node_modules/ajv/lib/dotjs/const.js?");

/***/ }),

/***/ "./node_modules/ajv/lib/dotjs/contains.js":
/*!************************************************!*\
  !*** ./node_modules/ajv/lib/dotjs/contains.js ***!
  \************************************************/
/***/ ((module) => {

"use strict";
eval("\nmodule.exports = function generate_contains(it, $keyword, $ruleType) {\n  var out = ' ';\n  var $lvl = it.level;\n  var $dataLvl = it.dataLevel;\n  var $schema = it.schema[$keyword];\n  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);\n  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;\n  var $breakOnError = !it.opts.allErrors;\n  var $data = 'data' + ($dataLvl || '');\n  var $valid = 'valid' + $lvl;\n  var $errs = 'errs__' + $lvl;\n  var $it = it.util.copy(it);\n  var $closingBraces = '';\n  $it.level++;\n  var $nextValid = 'valid' + $it.level;\n  var $idx = 'i' + $lvl,\n    $dataNxt = $it.dataLevel = it.dataLevel + 1,\n    $nextData = 'data' + $dataNxt,\n    $currentBaseId = it.baseId,\n    $nonEmptySchema = (it.opts.strictKeywords ? (typeof $schema == 'object' && Object.keys($schema).length > 0) || $schema === false : it.util.schemaHasRules($schema, it.RULES.all));\n  out += 'var ' + ($errs) + ' = errors;var ' + ($valid) + ';';\n  if ($nonEmptySchema) {\n    var $wasComposite = it.compositeRule;\n    it.compositeRule = $it.compositeRule = true;\n    $it.schema = $schema;\n    $it.schemaPath = $schemaPath;\n    $it.errSchemaPath = $errSchemaPath;\n    out += ' var ' + ($nextValid) + ' = false; for (var ' + ($idx) + ' = 0; ' + ($idx) + ' < ' + ($data) + '.length; ' + ($idx) + '++) { ';\n    $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);\n    var $passData = $data + '[' + $idx + ']';\n    $it.dataPathArr[$dataNxt] = $idx;\n    var $code = it.validate($it);\n    $it.baseId = $currentBaseId;\n    if (it.util.varOccurences($code, $nextData) < 2) {\n      out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';\n    } else {\n      out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';\n    }\n    out += ' if (' + ($nextValid) + ') break; }  ';\n    it.compositeRule = $it.compositeRule = $wasComposite;\n    out += ' ' + ($closingBraces) + ' if (!' + ($nextValid) + ') {';\n  } else {\n    out += ' if (' + ($data) + '.length == 0) {';\n  }\n  var $$outStack = $$outStack || [];\n  $$outStack.push(out);\n  out = ''; /* istanbul ignore else */\n  if (it.createErrors !== false) {\n    out += ' { keyword: \\'' + ('contains') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: {} ';\n    if (it.opts.messages !== false) {\n      out += ' , message: \\'should contain a valid item\\' ';\n    }\n    if (it.opts.verbose) {\n      out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n    }\n    out += ' } ';\n  } else {\n    out += ' {} ';\n  }\n  var __err = out;\n  out = $$outStack.pop();\n  if (!it.compositeRule && $breakOnError) {\n    /* istanbul ignore if */\n    if (it.async) {\n      out += ' throw new ValidationError([' + (__err) + ']); ';\n    } else {\n      out += ' validate.errors = [' + (__err) + ']; return false; ';\n    }\n  } else {\n    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n  }\n  out += ' } else { ';\n  if ($nonEmptySchema) {\n    out += '  errors = ' + ($errs) + '; if (vErrors !== null) { if (' + ($errs) + ') vErrors.length = ' + ($errs) + '; else vErrors = null; } ';\n  }\n  if (it.opts.allErrors) {\n    out += ' } ';\n  }\n  return out;\n}\n\n\n//# sourceURL=webpack://javascript/./node_modules/ajv/lib/dotjs/contains.js?");

/***/ }),

/***/ "./node_modules/ajv/lib/dotjs/custom.js":
/*!**********************************************!*\
  !*** ./node_modules/ajv/lib/dotjs/custom.js ***!
  \**********************************************/
/***/ ((module) => {

"use strict";
eval("\nmodule.exports = function generate_custom(it, $keyword, $ruleType) {\n  var out = ' ';\n  var $lvl = it.level;\n  var $dataLvl = it.dataLevel;\n  var $schema = it.schema[$keyword];\n  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);\n  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;\n  var $breakOnError = !it.opts.allErrors;\n  var $errorKeyword;\n  var $data = 'data' + ($dataLvl || '');\n  var $valid = 'valid' + $lvl;\n  var $errs = 'errs__' + $lvl;\n  var $isData = it.opts.$data && $schema && $schema.$data,\n    $schemaValue;\n  if ($isData) {\n    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';\n    $schemaValue = 'schema' + $lvl;\n  } else {\n    $schemaValue = $schema;\n  }\n  var $rule = this,\n    $definition = 'definition' + $lvl,\n    $rDef = $rule.definition,\n    $closingBraces = '';\n  var $compile, $inline, $macro, $ruleValidate, $validateCode;\n  if ($isData && $rDef.$data) {\n    $validateCode = 'keywordValidate' + $lvl;\n    var $validateSchema = $rDef.validateSchema;\n    out += ' var ' + ($definition) + ' = RULES.custom[\\'' + ($keyword) + '\\'].definition; var ' + ($validateCode) + ' = ' + ($definition) + '.validate;';\n  } else {\n    $ruleValidate = it.useCustomRule($rule, $schema, it.schema, it);\n    if (!$ruleValidate) return;\n    $schemaValue = 'validate.schema' + $schemaPath;\n    $validateCode = $ruleValidate.code;\n    $compile = $rDef.compile;\n    $inline = $rDef.inline;\n    $macro = $rDef.macro;\n  }\n  var $ruleErrs = $validateCode + '.errors',\n    $i = 'i' + $lvl,\n    $ruleErr = 'ruleErr' + $lvl,\n    $asyncKeyword = $rDef.async;\n  if ($asyncKeyword && !it.async) throw new Error('async keyword in sync schema');\n  if (!($inline || $macro)) {\n    out += '' + ($ruleErrs) + ' = null;';\n  }\n  out += 'var ' + ($errs) + ' = errors;var ' + ($valid) + ';';\n  if ($isData && $rDef.$data) {\n    $closingBraces += '}';\n    out += ' if (' + ($schemaValue) + ' === undefined) { ' + ($valid) + ' = true; } else { ';\n    if ($validateSchema) {\n      $closingBraces += '}';\n      out += ' ' + ($valid) + ' = ' + ($definition) + '.validateSchema(' + ($schemaValue) + '); if (' + ($valid) + ') { ';\n    }\n  }\n  if ($inline) {\n    if ($rDef.statements) {\n      out += ' ' + ($ruleValidate.validate) + ' ';\n    } else {\n      out += ' ' + ($valid) + ' = ' + ($ruleValidate.validate) + '; ';\n    }\n  } else if ($macro) {\n    var $it = it.util.copy(it);\n    var $closingBraces = '';\n    $it.level++;\n    var $nextValid = 'valid' + $it.level;\n    $it.schema = $ruleValidate.validate;\n    $it.schemaPath = '';\n    var $wasComposite = it.compositeRule;\n    it.compositeRule = $it.compositeRule = true;\n    var $code = it.validate($it).replace(/validate\\.schema/g, $validateCode);\n    it.compositeRule = $it.compositeRule = $wasComposite;\n    out += ' ' + ($code);\n  } else {\n    var $$outStack = $$outStack || [];\n    $$outStack.push(out);\n    out = '';\n    out += '  ' + ($validateCode) + '.call( ';\n    if (it.opts.passContext) {\n      out += 'this';\n    } else {\n      out += 'self';\n    }\n    if ($compile || $rDef.schema === false) {\n      out += ' , ' + ($data) + ' ';\n    } else {\n      out += ' , ' + ($schemaValue) + ' , ' + ($data) + ' , validate.schema' + (it.schemaPath) + ' ';\n    }\n    out += ' , (dataPath || \\'\\')';\n    if (it.errorPath != '\"\"') {\n      out += ' + ' + (it.errorPath);\n    }\n    var $parentData = $dataLvl ? 'data' + (($dataLvl - 1) || '') : 'parentData',\n      $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : 'parentDataProperty';\n    out += ' , ' + ($parentData) + ' , ' + ($parentDataProperty) + ' , rootData )  ';\n    var def_callRuleValidate = out;\n    out = $$outStack.pop();\n    if ($rDef.errors === false) {\n      out += ' ' + ($valid) + ' = ';\n      if ($asyncKeyword) {\n        out += 'await ';\n      }\n      out += '' + (def_callRuleValidate) + '; ';\n    } else {\n      if ($asyncKeyword) {\n        $ruleErrs = 'customErrors' + $lvl;\n        out += ' var ' + ($ruleErrs) + ' = null; try { ' + ($valid) + ' = await ' + (def_callRuleValidate) + '; } catch (e) { ' + ($valid) + ' = false; if (e instanceof ValidationError) ' + ($ruleErrs) + ' = e.errors; else throw e; } ';\n      } else {\n        out += ' ' + ($ruleErrs) + ' = null; ' + ($valid) + ' = ' + (def_callRuleValidate) + '; ';\n      }\n    }\n  }\n  if ($rDef.modifying) {\n    out += ' if (' + ($parentData) + ') ' + ($data) + ' = ' + ($parentData) + '[' + ($parentDataProperty) + '];';\n  }\n  out += '' + ($closingBraces);\n  if ($rDef.valid) {\n    if ($breakOnError) {\n      out += ' if (true) { ';\n    }\n  } else {\n    out += ' if ( ';\n    if ($rDef.valid === undefined) {\n      out += ' !';\n      if ($macro) {\n        out += '' + ($nextValid);\n      } else {\n        out += '' + ($valid);\n      }\n    } else {\n      out += ' ' + (!$rDef.valid) + ' ';\n    }\n    out += ') { ';\n    $errorKeyword = $rule.keyword;\n    var $$outStack = $$outStack || [];\n    $$outStack.push(out);\n    out = '';\n    var $$outStack = $$outStack || [];\n    $$outStack.push(out);\n    out = ''; /* istanbul ignore else */\n    if (it.createErrors !== false) {\n      out += ' { keyword: \\'' + ($errorKeyword || 'custom') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { keyword: \\'' + ($rule.keyword) + '\\' } ';\n      if (it.opts.messages !== false) {\n        out += ' , message: \\'should pass \"' + ($rule.keyword) + '\" keyword validation\\' ';\n      }\n      if (it.opts.verbose) {\n        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n      }\n      out += ' } ';\n    } else {\n      out += ' {} ';\n    }\n    var __err = out;\n    out = $$outStack.pop();\n    if (!it.compositeRule && $breakOnError) {\n      /* istanbul ignore if */\n      if (it.async) {\n        out += ' throw new ValidationError([' + (__err) + ']); ';\n      } else {\n        out += ' validate.errors = [' + (__err) + ']; return false; ';\n      }\n    } else {\n      out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n    }\n    var def_customError = out;\n    out = $$outStack.pop();\n    if ($inline) {\n      if ($rDef.errors) {\n        if ($rDef.errors != 'full') {\n          out += '  for (var ' + ($i) + '=' + ($errs) + '; ' + ($i) + '<errors; ' + ($i) + '++) { var ' + ($ruleErr) + ' = vErrors[' + ($i) + ']; if (' + ($ruleErr) + '.dataPath === undefined) ' + ($ruleErr) + '.dataPath = (dataPath || \\'\\') + ' + (it.errorPath) + '; if (' + ($ruleErr) + '.schemaPath === undefined) { ' + ($ruleErr) + '.schemaPath = \"' + ($errSchemaPath) + '\"; } ';\n          if (it.opts.verbose) {\n            out += ' ' + ($ruleErr) + '.schema = ' + ($schemaValue) + '; ' + ($ruleErr) + '.data = ' + ($data) + '; ';\n          }\n          out += ' } ';\n        }\n      } else {\n        if ($rDef.errors === false) {\n          out += ' ' + (def_customError) + ' ';\n        } else {\n          out += ' if (' + ($errs) + ' == errors) { ' + (def_customError) + ' } else {  for (var ' + ($i) + '=' + ($errs) + '; ' + ($i) + '<errors; ' + ($i) + '++) { var ' + ($ruleErr) + ' = vErrors[' + ($i) + ']; if (' + ($ruleErr) + '.dataPath === undefined) ' + ($ruleErr) + '.dataPath = (dataPath || \\'\\') + ' + (it.errorPath) + '; if (' + ($ruleErr) + '.schemaPath === undefined) { ' + ($ruleErr) + '.schemaPath = \"' + ($errSchemaPath) + '\"; } ';\n          if (it.opts.verbose) {\n            out += ' ' + ($ruleErr) + '.schema = ' + ($schemaValue) + '; ' + ($ruleErr) + '.data = ' + ($data) + '; ';\n          }\n          out += ' } } ';\n        }\n      }\n    } else if ($macro) {\n      out += '   var err =   '; /* istanbul ignore else */\n      if (it.createErrors !== false) {\n        out += ' { keyword: \\'' + ($errorKeyword || 'custom') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { keyword: \\'' + ($rule.keyword) + '\\' } ';\n        if (it.opts.messages !== false) {\n          out += ' , message: \\'should pass \"' + ($rule.keyword) + '\" keyword validation\\' ';\n        }\n        if (it.opts.verbose) {\n          out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n        }\n        out += ' } ';\n      } else {\n        out += ' {} ';\n      }\n      out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n      if (!it.compositeRule && $breakOnError) {\n        /* istanbul ignore if */\n        if (it.async) {\n          out += ' throw new ValidationError(vErrors); ';\n        } else {\n          out += ' validate.errors = vErrors; return false; ';\n        }\n      }\n    } else {\n      if ($rDef.errors === false) {\n        out += ' ' + (def_customError) + ' ';\n      } else {\n        out += ' if (Array.isArray(' + ($ruleErrs) + ')) { if (vErrors === null) vErrors = ' + ($ruleErrs) + '; else vErrors = vErrors.concat(' + ($ruleErrs) + '); errors = vErrors.length;  for (var ' + ($i) + '=' + ($errs) + '; ' + ($i) + '<errors; ' + ($i) + '++) { var ' + ($ruleErr) + ' = vErrors[' + ($i) + ']; if (' + ($ruleErr) + '.dataPath === undefined) ' + ($ruleErr) + '.dataPath = (dataPath || \\'\\') + ' + (it.errorPath) + ';  ' + ($ruleErr) + '.schemaPath = \"' + ($errSchemaPath) + '\";  ';\n        if (it.opts.verbose) {\n          out += ' ' + ($ruleErr) + '.schema = ' + ($schemaValue) + '; ' + ($ruleErr) + '.data = ' + ($data) + '; ';\n        }\n        out += ' } } else { ' + (def_customError) + ' } ';\n      }\n    }\n    out += ' } ';\n    if ($breakOnError) {\n      out += ' else { ';\n    }\n  }\n  return out;\n}\n\n\n//# sourceURL=webpack://javascript/./node_modules/ajv/lib/dotjs/custom.js?");

/***/ }),

/***/ "./node_modules/ajv/lib/dotjs/dependencies.js":
/*!****************************************************!*\
  !*** ./node_modules/ajv/lib/dotjs/dependencies.js ***!
  \****************************************************/
/***/ ((module) => {

"use strict";
eval("\nmodule.exports = function generate_dependencies(it, $keyword, $ruleType) {\n  var out = ' ';\n  var $lvl = it.level;\n  var $dataLvl = it.dataLevel;\n  var $schema = it.schema[$keyword];\n  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);\n  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;\n  var $breakOnError = !it.opts.allErrors;\n  var $data = 'data' + ($dataLvl || '');\n  var $errs = 'errs__' + $lvl;\n  var $it = it.util.copy(it);\n  var $closingBraces = '';\n  $it.level++;\n  var $nextValid = 'valid' + $it.level;\n  var $schemaDeps = {},\n    $propertyDeps = {},\n    $ownProperties = it.opts.ownProperties;\n  for ($property in $schema) {\n    if ($property == '__proto__') continue;\n    var $sch = $schema[$property];\n    var $deps = Array.isArray($sch) ? $propertyDeps : $schemaDeps;\n    $deps[$property] = $sch;\n  }\n  out += 'var ' + ($errs) + ' = errors;';\n  var $currentErrorPath = it.errorPath;\n  out += 'var missing' + ($lvl) + ';';\n  for (var $property in $propertyDeps) {\n    $deps = $propertyDeps[$property];\n    if ($deps.length) {\n      out += ' if ( ' + ($data) + (it.util.getProperty($property)) + ' !== undefined ';\n      if ($ownProperties) {\n        out += ' && Object.prototype.hasOwnProperty.call(' + ($data) + ', \\'' + (it.util.escapeQuotes($property)) + '\\') ';\n      }\n      if ($breakOnError) {\n        out += ' && ( ';\n        var arr1 = $deps;\n        if (arr1) {\n          var $propertyKey, $i = -1,\n            l1 = arr1.length - 1;\n          while ($i < l1) {\n            $propertyKey = arr1[$i += 1];\n            if ($i) {\n              out += ' || ';\n            }\n            var $prop = it.util.getProperty($propertyKey),\n              $useData = $data + $prop;\n            out += ' ( ( ' + ($useData) + ' === undefined ';\n            if ($ownProperties) {\n              out += ' || ! Object.prototype.hasOwnProperty.call(' + ($data) + ', \\'' + (it.util.escapeQuotes($propertyKey)) + '\\') ';\n            }\n            out += ') && (missing' + ($lvl) + ' = ' + (it.util.toQuotedString(it.opts.jsonPointers ? $propertyKey : $prop)) + ') ) ';\n          }\n        }\n        out += ')) {  ';\n        var $propertyPath = 'missing' + $lvl,\n          $missingProperty = '\\' + ' + $propertyPath + ' + \\'';\n        if (it.opts._errorDataPathProperty) {\n          it.errorPath = it.opts.jsonPointers ? it.util.getPathExpr($currentErrorPath, $propertyPath, true) : $currentErrorPath + ' + ' + $propertyPath;\n        }\n        var $$outStack = $$outStack || [];\n        $$outStack.push(out);\n        out = ''; /* istanbul ignore else */\n        if (it.createErrors !== false) {\n          out += ' { keyword: \\'' + ('dependencies') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { property: \\'' + (it.util.escapeQuotes($property)) + '\\', missingProperty: \\'' + ($missingProperty) + '\\', depsCount: ' + ($deps.length) + ', deps: \\'' + (it.util.escapeQuotes($deps.length == 1 ? $deps[0] : $deps.join(\", \"))) + '\\' } ';\n          if (it.opts.messages !== false) {\n            out += ' , message: \\'should have ';\n            if ($deps.length == 1) {\n              out += 'property ' + (it.util.escapeQuotes($deps[0]));\n            } else {\n              out += 'properties ' + (it.util.escapeQuotes($deps.join(\", \")));\n            }\n            out += ' when property ' + (it.util.escapeQuotes($property)) + ' is present\\' ';\n          }\n          if (it.opts.verbose) {\n            out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n          }\n          out += ' } ';\n        } else {\n          out += ' {} ';\n        }\n        var __err = out;\n        out = $$outStack.pop();\n        if (!it.compositeRule && $breakOnError) {\n          /* istanbul ignore if */\n          if (it.async) {\n            out += ' throw new ValidationError([' + (__err) + ']); ';\n          } else {\n            out += ' validate.errors = [' + (__err) + ']; return false; ';\n          }\n        } else {\n          out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n        }\n      } else {\n        out += ' ) { ';\n        var arr2 = $deps;\n        if (arr2) {\n          var $propertyKey, i2 = -1,\n            l2 = arr2.length - 1;\n          while (i2 < l2) {\n            $propertyKey = arr2[i2 += 1];\n            var $prop = it.util.getProperty($propertyKey),\n              $missingProperty = it.util.escapeQuotes($propertyKey),\n              $useData = $data + $prop;\n            if (it.opts._errorDataPathProperty) {\n              it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);\n            }\n            out += ' if ( ' + ($useData) + ' === undefined ';\n            if ($ownProperties) {\n              out += ' || ! Object.prototype.hasOwnProperty.call(' + ($data) + ', \\'' + (it.util.escapeQuotes($propertyKey)) + '\\') ';\n            }\n            out += ') {  var err =   '; /* istanbul ignore else */\n            if (it.createErrors !== false) {\n              out += ' { keyword: \\'' + ('dependencies') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { property: \\'' + (it.util.escapeQuotes($property)) + '\\', missingProperty: \\'' + ($missingProperty) + '\\', depsCount: ' + ($deps.length) + ', deps: \\'' + (it.util.escapeQuotes($deps.length == 1 ? $deps[0] : $deps.join(\", \"))) + '\\' } ';\n              if (it.opts.messages !== false) {\n                out += ' , message: \\'should have ';\n                if ($deps.length == 1) {\n                  out += 'property ' + (it.util.escapeQuotes($deps[0]));\n                } else {\n                  out += 'properties ' + (it.util.escapeQuotes($deps.join(\", \")));\n                }\n                out += ' when property ' + (it.util.escapeQuotes($property)) + ' is present\\' ';\n              }\n              if (it.opts.verbose) {\n                out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n              }\n              out += ' } ';\n            } else {\n              out += ' {} ';\n            }\n            out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } ';\n          }\n        }\n      }\n      out += ' }   ';\n      if ($breakOnError) {\n        $closingBraces += '}';\n        out += ' else { ';\n      }\n    }\n  }\n  it.errorPath = $currentErrorPath;\n  var $currentBaseId = $it.baseId;\n  for (var $property in $schemaDeps) {\n    var $sch = $schemaDeps[$property];\n    if ((it.opts.strictKeywords ? (typeof $sch == 'object' && Object.keys($sch).length > 0) || $sch === false : it.util.schemaHasRules($sch, it.RULES.all))) {\n      out += ' ' + ($nextValid) + ' = true; if ( ' + ($data) + (it.util.getProperty($property)) + ' !== undefined ';\n      if ($ownProperties) {\n        out += ' && Object.prototype.hasOwnProperty.call(' + ($data) + ', \\'' + (it.util.escapeQuotes($property)) + '\\') ';\n      }\n      out += ') { ';\n      $it.schema = $sch;\n      $it.schemaPath = $schemaPath + it.util.getProperty($property);\n      $it.errSchemaPath = $errSchemaPath + '/' + it.util.escapeFragment($property);\n      out += '  ' + (it.validate($it)) + ' ';\n      $it.baseId = $currentBaseId;\n      out += ' }  ';\n      if ($breakOnError) {\n        out += ' if (' + ($nextValid) + ') { ';\n        $closingBraces += '}';\n      }\n    }\n  }\n  if ($breakOnError) {\n    out += '   ' + ($closingBraces) + ' if (' + ($errs) + ' == errors) {';\n  }\n  return out;\n}\n\n\n//# sourceURL=webpack://javascript/./node_modules/ajv/lib/dotjs/dependencies.js?");

/***/ }),

/***/ "./node_modules/ajv/lib/dotjs/enum.js":
/*!********************************************!*\
  !*** ./node_modules/ajv/lib/dotjs/enum.js ***!
  \********************************************/
/***/ ((module) => {

"use strict";
eval("\nmodule.exports = function generate_enum(it, $keyword, $ruleType) {\n  var out = ' ';\n  var $lvl = it.level;\n  var $dataLvl = it.dataLevel;\n  var $schema = it.schema[$keyword];\n  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);\n  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;\n  var $breakOnError = !it.opts.allErrors;\n  var $data = 'data' + ($dataLvl || '');\n  var $valid = 'valid' + $lvl;\n  var $isData = it.opts.$data && $schema && $schema.$data,\n    $schemaValue;\n  if ($isData) {\n    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';\n    $schemaValue = 'schema' + $lvl;\n  } else {\n    $schemaValue = $schema;\n  }\n  var $i = 'i' + $lvl,\n    $vSchema = 'schema' + $lvl;\n  if (!$isData) {\n    out += ' var ' + ($vSchema) + ' = validate.schema' + ($schemaPath) + ';';\n  }\n  out += 'var ' + ($valid) + ';';\n  if ($isData) {\n    out += ' if (schema' + ($lvl) + ' === undefined) ' + ($valid) + ' = true; else if (!Array.isArray(schema' + ($lvl) + ')) ' + ($valid) + ' = false; else {';\n  }\n  out += '' + ($valid) + ' = false;for (var ' + ($i) + '=0; ' + ($i) + '<' + ($vSchema) + '.length; ' + ($i) + '++) if (equal(' + ($data) + ', ' + ($vSchema) + '[' + ($i) + '])) { ' + ($valid) + ' = true; break; }';\n  if ($isData) {\n    out += '  }  ';\n  }\n  out += ' if (!' + ($valid) + ') {   ';\n  var $$outStack = $$outStack || [];\n  $$outStack.push(out);\n  out = ''; /* istanbul ignore else */\n  if (it.createErrors !== false) {\n    out += ' { keyword: \\'' + ('enum') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { allowedValues: schema' + ($lvl) + ' } ';\n    if (it.opts.messages !== false) {\n      out += ' , message: \\'should be equal to one of the allowed values\\' ';\n    }\n    if (it.opts.verbose) {\n      out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n    }\n    out += ' } ';\n  } else {\n    out += ' {} ';\n  }\n  var __err = out;\n  out = $$outStack.pop();\n  if (!it.compositeRule && $breakOnError) {\n    /* istanbul ignore if */\n    if (it.async) {\n      out += ' throw new ValidationError([' + (__err) + ']); ';\n    } else {\n      out += ' validate.errors = [' + (__err) + ']; return false; ';\n    }\n  } else {\n    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n  }\n  out += ' }';\n  if ($breakOnError) {\n    out += ' else { ';\n  }\n  return out;\n}\n\n\n//# sourceURL=webpack://javascript/./node_modules/ajv/lib/dotjs/enum.js?");

/***/ }),

/***/ "./node_modules/ajv/lib/dotjs/format.js":
/*!**********************************************!*\
  !*** ./node_modules/ajv/lib/dotjs/format.js ***!
  \**********************************************/
/***/ ((module) => {

"use strict";
eval("\nmodule.exports = function generate_format(it, $keyword, $ruleType) {\n  var out = ' ';\n  var $lvl = it.level;\n  var $dataLvl = it.dataLevel;\n  var $schema = it.schema[$keyword];\n  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);\n  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;\n  var $breakOnError = !it.opts.allErrors;\n  var $data = 'data' + ($dataLvl || '');\n  if (it.opts.format === false) {\n    if ($breakOnError) {\n      out += ' if (true) { ';\n    }\n    return out;\n  }\n  var $isData = it.opts.$data && $schema && $schema.$data,\n    $schemaValue;\n  if ($isData) {\n    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';\n    $schemaValue = 'schema' + $lvl;\n  } else {\n    $schemaValue = $schema;\n  }\n  var $unknownFormats = it.opts.unknownFormats,\n    $allowUnknown = Array.isArray($unknownFormats);\n  if ($isData) {\n    var $format = 'format' + $lvl,\n      $isObject = 'isObject' + $lvl,\n      $formatType = 'formatType' + $lvl;\n    out += ' var ' + ($format) + ' = formats[' + ($schemaValue) + ']; var ' + ($isObject) + ' = typeof ' + ($format) + ' == \\'object\\' && !(' + ($format) + ' instanceof RegExp) && ' + ($format) + '.validate; var ' + ($formatType) + ' = ' + ($isObject) + ' && ' + ($format) + '.type || \\'string\\'; if (' + ($isObject) + ') { ';\n    if (it.async) {\n      out += ' var async' + ($lvl) + ' = ' + ($format) + '.async; ';\n    }\n    out += ' ' + ($format) + ' = ' + ($format) + '.validate; } if (  ';\n    if ($isData) {\n      out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \\'string\\') || ';\n    }\n    out += ' (';\n    if ($unknownFormats != 'ignore') {\n      out += ' (' + ($schemaValue) + ' && !' + ($format) + ' ';\n      if ($allowUnknown) {\n        out += ' && self._opts.unknownFormats.indexOf(' + ($schemaValue) + ') == -1 ';\n      }\n      out += ') || ';\n    }\n    out += ' (' + ($format) + ' && ' + ($formatType) + ' == \\'' + ($ruleType) + '\\' && !(typeof ' + ($format) + ' == \\'function\\' ? ';\n    if (it.async) {\n      out += ' (async' + ($lvl) + ' ? await ' + ($format) + '(' + ($data) + ') : ' + ($format) + '(' + ($data) + ')) ';\n    } else {\n      out += ' ' + ($format) + '(' + ($data) + ') ';\n    }\n    out += ' : ' + ($format) + '.test(' + ($data) + '))))) {';\n  } else {\n    var $format = it.formats[$schema];\n    if (!$format) {\n      if ($unknownFormats == 'ignore') {\n        it.logger.warn('unknown format \"' + $schema + '\" ignored in schema at path \"' + it.errSchemaPath + '\"');\n        if ($breakOnError) {\n          out += ' if (true) { ';\n        }\n        return out;\n      } else if ($allowUnknown && $unknownFormats.indexOf($schema) >= 0) {\n        if ($breakOnError) {\n          out += ' if (true) { ';\n        }\n        return out;\n      } else {\n        throw new Error('unknown format \"' + $schema + '\" is used in schema at path \"' + it.errSchemaPath + '\"');\n      }\n    }\n    var $isObject = typeof $format == 'object' && !($format instanceof RegExp) && $format.validate;\n    var $formatType = $isObject && $format.type || 'string';\n    if ($isObject) {\n      var $async = $format.async === true;\n      $format = $format.validate;\n    }\n    if ($formatType != $ruleType) {\n      if ($breakOnError) {\n        out += ' if (true) { ';\n      }\n      return out;\n    }\n    if ($async) {\n      if (!it.async) throw new Error('async format in sync schema');\n      var $formatRef = 'formats' + it.util.getProperty($schema) + '.validate';\n      out += ' if (!(await ' + ($formatRef) + '(' + ($data) + '))) { ';\n    } else {\n      out += ' if (! ';\n      var $formatRef = 'formats' + it.util.getProperty($schema);\n      if ($isObject) $formatRef += '.validate';\n      if (typeof $format == 'function') {\n        out += ' ' + ($formatRef) + '(' + ($data) + ') ';\n      } else {\n        out += ' ' + ($formatRef) + '.test(' + ($data) + ') ';\n      }\n      out += ') { ';\n    }\n  }\n  var $$outStack = $$outStack || [];\n  $$outStack.push(out);\n  out = ''; /* istanbul ignore else */\n  if (it.createErrors !== false) {\n    out += ' { keyword: \\'' + ('format') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { format:  ';\n    if ($isData) {\n      out += '' + ($schemaValue);\n    } else {\n      out += '' + (it.util.toQuotedString($schema));\n    }\n    out += '  } ';\n    if (it.opts.messages !== false) {\n      out += ' , message: \\'should match format \"';\n      if ($isData) {\n        out += '\\' + ' + ($schemaValue) + ' + \\'';\n      } else {\n        out += '' + (it.util.escapeQuotes($schema));\n      }\n      out += '\"\\' ';\n    }\n    if (it.opts.verbose) {\n      out += ' , schema:  ';\n      if ($isData) {\n        out += 'validate.schema' + ($schemaPath);\n      } else {\n        out += '' + (it.util.toQuotedString($schema));\n      }\n      out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n    }\n    out += ' } ';\n  } else {\n    out += ' {} ';\n  }\n  var __err = out;\n  out = $$outStack.pop();\n  if (!it.compositeRule && $breakOnError) {\n    /* istanbul ignore if */\n    if (it.async) {\n      out += ' throw new ValidationError([' + (__err) + ']); ';\n    } else {\n      out += ' validate.errors = [' + (__err) + ']; return false; ';\n    }\n  } else {\n    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n  }\n  out += ' } ';\n  if ($breakOnError) {\n    out += ' else { ';\n  }\n  return out;\n}\n\n\n//# sourceURL=webpack://javascript/./node_modules/ajv/lib/dotjs/format.js?");

/***/ }),

/***/ "./node_modules/ajv/lib/dotjs/if.js":
/*!******************************************!*\
  !*** ./node_modules/ajv/lib/dotjs/if.js ***!
  \******************************************/
/***/ ((module) => {

"use strict";
eval("\nmodule.exports = function generate_if(it, $keyword, $ruleType) {\n  var out = ' ';\n  var $lvl = it.level;\n  var $dataLvl = it.dataLevel;\n  var $schema = it.schema[$keyword];\n  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);\n  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;\n  var $breakOnError = !it.opts.allErrors;\n  var $data = 'data' + ($dataLvl || '');\n  var $valid = 'valid' + $lvl;\n  var $errs = 'errs__' + $lvl;\n  var $it = it.util.copy(it);\n  $it.level++;\n  var $nextValid = 'valid' + $it.level;\n  var $thenSch = it.schema['then'],\n    $elseSch = it.schema['else'],\n    $thenPresent = $thenSch !== undefined && (it.opts.strictKeywords ? (typeof $thenSch == 'object' && Object.keys($thenSch).length > 0) || $thenSch === false : it.util.schemaHasRules($thenSch, it.RULES.all)),\n    $elsePresent = $elseSch !== undefined && (it.opts.strictKeywords ? (typeof $elseSch == 'object' && Object.keys($elseSch).length > 0) || $elseSch === false : it.util.schemaHasRules($elseSch, it.RULES.all)),\n    $currentBaseId = $it.baseId;\n  if ($thenPresent || $elsePresent) {\n    var $ifClause;\n    $it.createErrors = false;\n    $it.schema = $schema;\n    $it.schemaPath = $schemaPath;\n    $it.errSchemaPath = $errSchemaPath;\n    out += ' var ' + ($errs) + ' = errors; var ' + ($valid) + ' = true;  ';\n    var $wasComposite = it.compositeRule;\n    it.compositeRule = $it.compositeRule = true;\n    out += '  ' + (it.validate($it)) + ' ';\n    $it.baseId = $currentBaseId;\n    $it.createErrors = true;\n    out += '  errors = ' + ($errs) + '; if (vErrors !== null) { if (' + ($errs) + ') vErrors.length = ' + ($errs) + '; else vErrors = null; }  ';\n    it.compositeRule = $it.compositeRule = $wasComposite;\n    if ($thenPresent) {\n      out += ' if (' + ($nextValid) + ') {  ';\n      $it.schema = it.schema['then'];\n      $it.schemaPath = it.schemaPath + '.then';\n      $it.errSchemaPath = it.errSchemaPath + '/then';\n      out += '  ' + (it.validate($it)) + ' ';\n      $it.baseId = $currentBaseId;\n      out += ' ' + ($valid) + ' = ' + ($nextValid) + '; ';\n      if ($thenPresent && $elsePresent) {\n        $ifClause = 'ifClause' + $lvl;\n        out += ' var ' + ($ifClause) + ' = \\'then\\'; ';\n      } else {\n        $ifClause = '\\'then\\'';\n      }\n      out += ' } ';\n      if ($elsePresent) {\n        out += ' else { ';\n      }\n    } else {\n      out += ' if (!' + ($nextValid) + ') { ';\n    }\n    if ($elsePresent) {\n      $it.schema = it.schema['else'];\n      $it.schemaPath = it.schemaPath + '.else';\n      $it.errSchemaPath = it.errSchemaPath + '/else';\n      out += '  ' + (it.validate($it)) + ' ';\n      $it.baseId = $currentBaseId;\n      out += ' ' + ($valid) + ' = ' + ($nextValid) + '; ';\n      if ($thenPresent && $elsePresent) {\n        $ifClause = 'ifClause' + $lvl;\n        out += ' var ' + ($ifClause) + ' = \\'else\\'; ';\n      } else {\n        $ifClause = '\\'else\\'';\n      }\n      out += ' } ';\n    }\n    out += ' if (!' + ($valid) + ') {   var err =   '; /* istanbul ignore else */\n    if (it.createErrors !== false) {\n      out += ' { keyword: \\'' + ('if') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { failingKeyword: ' + ($ifClause) + ' } ';\n      if (it.opts.messages !== false) {\n        out += ' , message: \\'should match \"\\' + ' + ($ifClause) + ' + \\'\" schema\\' ';\n      }\n      if (it.opts.verbose) {\n        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n      }\n      out += ' } ';\n    } else {\n      out += ' {} ';\n    }\n    out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n    if (!it.compositeRule && $breakOnError) {\n      /* istanbul ignore if */\n      if (it.async) {\n        out += ' throw new ValidationError(vErrors); ';\n      } else {\n        out += ' validate.errors = vErrors; return false; ';\n      }\n    }\n    out += ' }   ';\n    if ($breakOnError) {\n      out += ' else { ';\n    }\n  } else {\n    if ($breakOnError) {\n      out += ' if (true) { ';\n    }\n  }\n  return out;\n}\n\n\n//# sourceURL=webpack://javascript/./node_modules/ajv/lib/dotjs/if.js?");

/***/ }),

/***/ "./node_modules/ajv/lib/dotjs/index.js":
/*!*********************************************!*\
  !*** ./node_modules/ajv/lib/dotjs/index.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n//all requires must be explicit because browserify won't work with dynamic requires\nmodule.exports = {\n  '$ref': __webpack_require__(/*! ./ref */ \"./node_modules/ajv/lib/dotjs/ref.js\"),\n  allOf: __webpack_require__(/*! ./allOf */ \"./node_modules/ajv/lib/dotjs/allOf.js\"),\n  anyOf: __webpack_require__(/*! ./anyOf */ \"./node_modules/ajv/lib/dotjs/anyOf.js\"),\n  '$comment': __webpack_require__(/*! ./comment */ \"./node_modules/ajv/lib/dotjs/comment.js\"),\n  const: __webpack_require__(/*! ./const */ \"./node_modules/ajv/lib/dotjs/const.js\"),\n  contains: __webpack_require__(/*! ./contains */ \"./node_modules/ajv/lib/dotjs/contains.js\"),\n  dependencies: __webpack_require__(/*! ./dependencies */ \"./node_modules/ajv/lib/dotjs/dependencies.js\"),\n  'enum': __webpack_require__(/*! ./enum */ \"./node_modules/ajv/lib/dotjs/enum.js\"),\n  format: __webpack_require__(/*! ./format */ \"./node_modules/ajv/lib/dotjs/format.js\"),\n  'if': __webpack_require__(/*! ./if */ \"./node_modules/ajv/lib/dotjs/if.js\"),\n  items: __webpack_require__(/*! ./items */ \"./node_modules/ajv/lib/dotjs/items.js\"),\n  maximum: __webpack_require__(/*! ./_limit */ \"./node_modules/ajv/lib/dotjs/_limit.js\"),\n  minimum: __webpack_require__(/*! ./_limit */ \"./node_modules/ajv/lib/dotjs/_limit.js\"),\n  maxItems: __webpack_require__(/*! ./_limitItems */ \"./node_modules/ajv/lib/dotjs/_limitItems.js\"),\n  minItems: __webpack_require__(/*! ./_limitItems */ \"./node_modules/ajv/lib/dotjs/_limitItems.js\"),\n  maxLength: __webpack_require__(/*! ./_limitLength */ \"./node_modules/ajv/lib/dotjs/_limitLength.js\"),\n  minLength: __webpack_require__(/*! ./_limitLength */ \"./node_modules/ajv/lib/dotjs/_limitLength.js\"),\n  maxProperties: __webpack_require__(/*! ./_limitProperties */ \"./node_modules/ajv/lib/dotjs/_limitProperties.js\"),\n  minProperties: __webpack_require__(/*! ./_limitProperties */ \"./node_modules/ajv/lib/dotjs/_limitProperties.js\"),\n  multipleOf: __webpack_require__(/*! ./multipleOf */ \"./node_modules/ajv/lib/dotjs/multipleOf.js\"),\n  not: __webpack_require__(/*! ./not */ \"./node_modules/ajv/lib/dotjs/not.js\"),\n  oneOf: __webpack_require__(/*! ./oneOf */ \"./node_modules/ajv/lib/dotjs/oneOf.js\"),\n  pattern: __webpack_require__(/*! ./pattern */ \"./node_modules/ajv/lib/dotjs/pattern.js\"),\n  properties: __webpack_require__(/*! ./properties */ \"./node_modules/ajv/lib/dotjs/properties.js\"),\n  propertyNames: __webpack_require__(/*! ./propertyNames */ \"./node_modules/ajv/lib/dotjs/propertyNames.js\"),\n  required: __webpack_require__(/*! ./required */ \"./node_modules/ajv/lib/dotjs/required.js\"),\n  uniqueItems: __webpack_require__(/*! ./uniqueItems */ \"./node_modules/ajv/lib/dotjs/uniqueItems.js\"),\n  validate: __webpack_require__(/*! ./validate */ \"./node_modules/ajv/lib/dotjs/validate.js\")\n};\n\n\n//# sourceURL=webpack://javascript/./node_modules/ajv/lib/dotjs/index.js?");

/***/ }),

/***/ "./node_modules/ajv/lib/dotjs/items.js":
/*!*********************************************!*\
  !*** ./node_modules/ajv/lib/dotjs/items.js ***!
  \*********************************************/
/***/ ((module) => {

"use strict";
eval("\nmodule.exports = function generate_items(it, $keyword, $ruleType) {\n  var out = ' ';\n  var $lvl = it.level;\n  var $dataLvl = it.dataLevel;\n  var $schema = it.schema[$keyword];\n  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);\n  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;\n  var $breakOnError = !it.opts.allErrors;\n  var $data = 'data' + ($dataLvl || '');\n  var $valid = 'valid' + $lvl;\n  var $errs = 'errs__' + $lvl;\n  var $it = it.util.copy(it);\n  var $closingBraces = '';\n  $it.level++;\n  var $nextValid = 'valid' + $it.level;\n  var $idx = 'i' + $lvl,\n    $dataNxt = $it.dataLevel = it.dataLevel + 1,\n    $nextData = 'data' + $dataNxt,\n    $currentBaseId = it.baseId;\n  out += 'var ' + ($errs) + ' = errors;var ' + ($valid) + ';';\n  if (Array.isArray($schema)) {\n    var $additionalItems = it.schema.additionalItems;\n    if ($additionalItems === false) {\n      out += ' ' + ($valid) + ' = ' + ($data) + '.length <= ' + ($schema.length) + '; ';\n      var $currErrSchemaPath = $errSchemaPath;\n      $errSchemaPath = it.errSchemaPath + '/additionalItems';\n      out += '  if (!' + ($valid) + ') {   ';\n      var $$outStack = $$outStack || [];\n      $$outStack.push(out);\n      out = ''; /* istanbul ignore else */\n      if (it.createErrors !== false) {\n        out += ' { keyword: \\'' + ('additionalItems') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { limit: ' + ($schema.length) + ' } ';\n        if (it.opts.messages !== false) {\n          out += ' , message: \\'should NOT have more than ' + ($schema.length) + ' items\\' ';\n        }\n        if (it.opts.verbose) {\n          out += ' , schema: false , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n        }\n        out += ' } ';\n      } else {\n        out += ' {} ';\n      }\n      var __err = out;\n      out = $$outStack.pop();\n      if (!it.compositeRule && $breakOnError) {\n        /* istanbul ignore if */\n        if (it.async) {\n          out += ' throw new ValidationError([' + (__err) + ']); ';\n        } else {\n          out += ' validate.errors = [' + (__err) + ']; return false; ';\n        }\n      } else {\n        out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n      }\n      out += ' } ';\n      $errSchemaPath = $currErrSchemaPath;\n      if ($breakOnError) {\n        $closingBraces += '}';\n        out += ' else { ';\n      }\n    }\n    var arr1 = $schema;\n    if (arr1) {\n      var $sch, $i = -1,\n        l1 = arr1.length - 1;\n      while ($i < l1) {\n        $sch = arr1[$i += 1];\n        if ((it.opts.strictKeywords ? (typeof $sch == 'object' && Object.keys($sch).length > 0) || $sch === false : it.util.schemaHasRules($sch, it.RULES.all))) {\n          out += ' ' + ($nextValid) + ' = true; if (' + ($data) + '.length > ' + ($i) + ') { ';\n          var $passData = $data + '[' + $i + ']';\n          $it.schema = $sch;\n          $it.schemaPath = $schemaPath + '[' + $i + ']';\n          $it.errSchemaPath = $errSchemaPath + '/' + $i;\n          $it.errorPath = it.util.getPathExpr(it.errorPath, $i, it.opts.jsonPointers, true);\n          $it.dataPathArr[$dataNxt] = $i;\n          var $code = it.validate($it);\n          $it.baseId = $currentBaseId;\n          if (it.util.varOccurences($code, $nextData) < 2) {\n            out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';\n          } else {\n            out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';\n          }\n          out += ' }  ';\n          if ($breakOnError) {\n            out += ' if (' + ($nextValid) + ') { ';\n            $closingBraces += '}';\n          }\n        }\n      }\n    }\n    if (typeof $additionalItems == 'object' && (it.opts.strictKeywords ? (typeof $additionalItems == 'object' && Object.keys($additionalItems).length > 0) || $additionalItems === false : it.util.schemaHasRules($additionalItems, it.RULES.all))) {\n      $it.schema = $additionalItems;\n      $it.schemaPath = it.schemaPath + '.additionalItems';\n      $it.errSchemaPath = it.errSchemaPath + '/additionalItems';\n      out += ' ' + ($nextValid) + ' = true; if (' + ($data) + '.length > ' + ($schema.length) + ') {  for (var ' + ($idx) + ' = ' + ($schema.length) + '; ' + ($idx) + ' < ' + ($data) + '.length; ' + ($idx) + '++) { ';\n      $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);\n      var $passData = $data + '[' + $idx + ']';\n      $it.dataPathArr[$dataNxt] = $idx;\n      var $code = it.validate($it);\n      $it.baseId = $currentBaseId;\n      if (it.util.varOccurences($code, $nextData) < 2) {\n        out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';\n      } else {\n        out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';\n      }\n      if ($breakOnError) {\n        out += ' if (!' + ($nextValid) + ') break; ';\n      }\n      out += ' } }  ';\n      if ($breakOnError) {\n        out += ' if (' + ($nextValid) + ') { ';\n        $closingBraces += '}';\n      }\n    }\n  } else if ((it.opts.strictKeywords ? (typeof $schema == 'object' && Object.keys($schema).length > 0) || $schema === false : it.util.schemaHasRules($schema, it.RULES.all))) {\n    $it.schema = $schema;\n    $it.schemaPath = $schemaPath;\n    $it.errSchemaPath = $errSchemaPath;\n    out += '  for (var ' + ($idx) + ' = ' + (0) + '; ' + ($idx) + ' < ' + ($data) + '.length; ' + ($idx) + '++) { ';\n    $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);\n    var $passData = $data + '[' + $idx + ']';\n    $it.dataPathArr[$dataNxt] = $idx;\n    var $code = it.validate($it);\n    $it.baseId = $currentBaseId;\n    if (it.util.varOccurences($code, $nextData) < 2) {\n      out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';\n    } else {\n      out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';\n    }\n    if ($breakOnError) {\n      out += ' if (!' + ($nextValid) + ') break; ';\n    }\n    out += ' }';\n  }\n  if ($breakOnError) {\n    out += ' ' + ($closingBraces) + ' if (' + ($errs) + ' == errors) {';\n  }\n  return out;\n}\n\n\n//# sourceURL=webpack://javascript/./node_modules/ajv/lib/dotjs/items.js?");

/***/ }),

/***/ "./node_modules/ajv/lib/dotjs/multipleOf.js":
/*!**************************************************!*\
  !*** ./node_modules/ajv/lib/dotjs/multipleOf.js ***!
  \**************************************************/
/***/ ((module) => {

"use strict";
eval("\nmodule.exports = function generate_multipleOf(it, $keyword, $ruleType) {\n  var out = ' ';\n  var $lvl = it.level;\n  var $dataLvl = it.dataLevel;\n  var $schema = it.schema[$keyword];\n  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);\n  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;\n  var $breakOnError = !it.opts.allErrors;\n  var $data = 'data' + ($dataLvl || '');\n  var $isData = it.opts.$data && $schema && $schema.$data,\n    $schemaValue;\n  if ($isData) {\n    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';\n    $schemaValue = 'schema' + $lvl;\n  } else {\n    $schemaValue = $schema;\n  }\n  if (!($isData || typeof $schema == 'number')) {\n    throw new Error($keyword + ' must be number');\n  }\n  out += 'var division' + ($lvl) + ';if (';\n  if ($isData) {\n    out += ' ' + ($schemaValue) + ' !== undefined && ( typeof ' + ($schemaValue) + ' != \\'number\\' || ';\n  }\n  out += ' (division' + ($lvl) + ' = ' + ($data) + ' / ' + ($schemaValue) + ', ';\n  if (it.opts.multipleOfPrecision) {\n    out += ' Math.abs(Math.round(division' + ($lvl) + ') - division' + ($lvl) + ') > 1e-' + (it.opts.multipleOfPrecision) + ' ';\n  } else {\n    out += ' division' + ($lvl) + ' !== parseInt(division' + ($lvl) + ') ';\n  }\n  out += ' ) ';\n  if ($isData) {\n    out += '  )  ';\n  }\n  out += ' ) {   ';\n  var $$outStack = $$outStack || [];\n  $$outStack.push(out);\n  out = ''; /* istanbul ignore else */\n  if (it.createErrors !== false) {\n    out += ' { keyword: \\'' + ('multipleOf') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { multipleOf: ' + ($schemaValue) + ' } ';\n    if (it.opts.messages !== false) {\n      out += ' , message: \\'should be multiple of ';\n      if ($isData) {\n        out += '\\' + ' + ($schemaValue);\n      } else {\n        out += '' + ($schemaValue) + '\\'';\n      }\n    }\n    if (it.opts.verbose) {\n      out += ' , schema:  ';\n      if ($isData) {\n        out += 'validate.schema' + ($schemaPath);\n      } else {\n        out += '' + ($schema);\n      }\n      out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n    }\n    out += ' } ';\n  } else {\n    out += ' {} ';\n  }\n  var __err = out;\n  out = $$outStack.pop();\n  if (!it.compositeRule && $breakOnError) {\n    /* istanbul ignore if */\n    if (it.async) {\n      out += ' throw new ValidationError([' + (__err) + ']); ';\n    } else {\n      out += ' validate.errors = [' + (__err) + ']; return false; ';\n    }\n  } else {\n    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n  }\n  out += '} ';\n  if ($breakOnError) {\n    out += ' else { ';\n  }\n  return out;\n}\n\n\n//# sourceURL=webpack://javascript/./node_modules/ajv/lib/dotjs/multipleOf.js?");

/***/ }),

/***/ "./node_modules/ajv/lib/dotjs/not.js":
/*!*******************************************!*\
  !*** ./node_modules/ajv/lib/dotjs/not.js ***!
  \*******************************************/
/***/ ((module) => {

"use strict";
eval("\nmodule.exports = function generate_not(it, $keyword, $ruleType) {\n  var out = ' ';\n  var $lvl = it.level;\n  var $dataLvl = it.dataLevel;\n  var $schema = it.schema[$keyword];\n  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);\n  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;\n  var $breakOnError = !it.opts.allErrors;\n  var $data = 'data' + ($dataLvl || '');\n  var $errs = 'errs__' + $lvl;\n  var $it = it.util.copy(it);\n  $it.level++;\n  var $nextValid = 'valid' + $it.level;\n  if ((it.opts.strictKeywords ? (typeof $schema == 'object' && Object.keys($schema).length > 0) || $schema === false : it.util.schemaHasRules($schema, it.RULES.all))) {\n    $it.schema = $schema;\n    $it.schemaPath = $schemaPath;\n    $it.errSchemaPath = $errSchemaPath;\n    out += ' var ' + ($errs) + ' = errors;  ';\n    var $wasComposite = it.compositeRule;\n    it.compositeRule = $it.compositeRule = true;\n    $it.createErrors = false;\n    var $allErrorsOption;\n    if ($it.opts.allErrors) {\n      $allErrorsOption = $it.opts.allErrors;\n      $it.opts.allErrors = false;\n    }\n    out += ' ' + (it.validate($it)) + ' ';\n    $it.createErrors = true;\n    if ($allErrorsOption) $it.opts.allErrors = $allErrorsOption;\n    it.compositeRule = $it.compositeRule = $wasComposite;\n    out += ' if (' + ($nextValid) + ') {   ';\n    var $$outStack = $$outStack || [];\n    $$outStack.push(out);\n    out = ''; /* istanbul ignore else */\n    if (it.createErrors !== false) {\n      out += ' { keyword: \\'' + ('not') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: {} ';\n      if (it.opts.messages !== false) {\n        out += ' , message: \\'should NOT be valid\\' ';\n      }\n      if (it.opts.verbose) {\n        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n      }\n      out += ' } ';\n    } else {\n      out += ' {} ';\n    }\n    var __err = out;\n    out = $$outStack.pop();\n    if (!it.compositeRule && $breakOnError) {\n      /* istanbul ignore if */\n      if (it.async) {\n        out += ' throw new ValidationError([' + (__err) + ']); ';\n      } else {\n        out += ' validate.errors = [' + (__err) + ']; return false; ';\n      }\n    } else {\n      out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n    }\n    out += ' } else {  errors = ' + ($errs) + '; if (vErrors !== null) { if (' + ($errs) + ') vErrors.length = ' + ($errs) + '; else vErrors = null; } ';\n    if (it.opts.allErrors) {\n      out += ' } ';\n    }\n  } else {\n    out += '  var err =   '; /* istanbul ignore else */\n    if (it.createErrors !== false) {\n      out += ' { keyword: \\'' + ('not') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: {} ';\n      if (it.opts.messages !== false) {\n        out += ' , message: \\'should NOT be valid\\' ';\n      }\n      if (it.opts.verbose) {\n        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n      }\n      out += ' } ';\n    } else {\n      out += ' {} ';\n    }\n    out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n    if ($breakOnError) {\n      out += ' if (false) { ';\n    }\n  }\n  return out;\n}\n\n\n//# sourceURL=webpack://javascript/./node_modules/ajv/lib/dotjs/not.js?");

/***/ }),

/***/ "./node_modules/ajv/lib/dotjs/oneOf.js":
/*!*********************************************!*\
  !*** ./node_modules/ajv/lib/dotjs/oneOf.js ***!
  \*********************************************/
/***/ ((module) => {

"use strict";
eval("\nmodule.exports = function generate_oneOf(it, $keyword, $ruleType) {\n  var out = ' ';\n  var $lvl = it.level;\n  var $dataLvl = it.dataLevel;\n  var $schema = it.schema[$keyword];\n  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);\n  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;\n  var $breakOnError = !it.opts.allErrors;\n  var $data = 'data' + ($dataLvl || '');\n  var $valid = 'valid' + $lvl;\n  var $errs = 'errs__' + $lvl;\n  var $it = it.util.copy(it);\n  var $closingBraces = '';\n  $it.level++;\n  var $nextValid = 'valid' + $it.level;\n  var $currentBaseId = $it.baseId,\n    $prevValid = 'prevValid' + $lvl,\n    $passingSchemas = 'passingSchemas' + $lvl;\n  out += 'var ' + ($errs) + ' = errors , ' + ($prevValid) + ' = false , ' + ($valid) + ' = false , ' + ($passingSchemas) + ' = null; ';\n  var $wasComposite = it.compositeRule;\n  it.compositeRule = $it.compositeRule = true;\n  var arr1 = $schema;\n  if (arr1) {\n    var $sch, $i = -1,\n      l1 = arr1.length - 1;\n    while ($i < l1) {\n      $sch = arr1[$i += 1];\n      if ((it.opts.strictKeywords ? (typeof $sch == 'object' && Object.keys($sch).length > 0) || $sch === false : it.util.schemaHasRules($sch, it.RULES.all))) {\n        $it.schema = $sch;\n        $it.schemaPath = $schemaPath + '[' + $i + ']';\n        $it.errSchemaPath = $errSchemaPath + '/' + $i;\n        out += '  ' + (it.validate($it)) + ' ';\n        $it.baseId = $currentBaseId;\n      } else {\n        out += ' var ' + ($nextValid) + ' = true; ';\n      }\n      if ($i) {\n        out += ' if (' + ($nextValid) + ' && ' + ($prevValid) + ') { ' + ($valid) + ' = false; ' + ($passingSchemas) + ' = [' + ($passingSchemas) + ', ' + ($i) + ']; } else { ';\n        $closingBraces += '}';\n      }\n      out += ' if (' + ($nextValid) + ') { ' + ($valid) + ' = ' + ($prevValid) + ' = true; ' + ($passingSchemas) + ' = ' + ($i) + '; }';\n    }\n  }\n  it.compositeRule = $it.compositeRule = $wasComposite;\n  out += '' + ($closingBraces) + 'if (!' + ($valid) + ') {   var err =   '; /* istanbul ignore else */\n  if (it.createErrors !== false) {\n    out += ' { keyword: \\'' + ('oneOf') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { passingSchemas: ' + ($passingSchemas) + ' } ';\n    if (it.opts.messages !== false) {\n      out += ' , message: \\'should match exactly one schema in oneOf\\' ';\n    }\n    if (it.opts.verbose) {\n      out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n    }\n    out += ' } ';\n  } else {\n    out += ' {} ';\n  }\n  out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n  if (!it.compositeRule && $breakOnError) {\n    /* istanbul ignore if */\n    if (it.async) {\n      out += ' throw new ValidationError(vErrors); ';\n    } else {\n      out += ' validate.errors = vErrors; return false; ';\n    }\n  }\n  out += '} else {  errors = ' + ($errs) + '; if (vErrors !== null) { if (' + ($errs) + ') vErrors.length = ' + ($errs) + '; else vErrors = null; }';\n  if (it.opts.allErrors) {\n    out += ' } ';\n  }\n  return out;\n}\n\n\n//# sourceURL=webpack://javascript/./node_modules/ajv/lib/dotjs/oneOf.js?");

/***/ }),

/***/ "./node_modules/ajv/lib/dotjs/pattern.js":
/*!***********************************************!*\
  !*** ./node_modules/ajv/lib/dotjs/pattern.js ***!
  \***********************************************/
/***/ ((module) => {

"use strict";
eval("\nmodule.exports = function generate_pattern(it, $keyword, $ruleType) {\n  var out = ' ';\n  var $lvl = it.level;\n  var $dataLvl = it.dataLevel;\n  var $schema = it.schema[$keyword];\n  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);\n  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;\n  var $breakOnError = !it.opts.allErrors;\n  var $data = 'data' + ($dataLvl || '');\n  var $isData = it.opts.$data && $schema && $schema.$data,\n    $schemaValue;\n  if ($isData) {\n    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';\n    $schemaValue = 'schema' + $lvl;\n  } else {\n    $schemaValue = $schema;\n  }\n  var $regexp = $isData ? '(new RegExp(' + $schemaValue + '))' : it.usePattern($schema);\n  out += 'if ( ';\n  if ($isData) {\n    out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \\'string\\') || ';\n  }\n  out += ' !' + ($regexp) + '.test(' + ($data) + ') ) {   ';\n  var $$outStack = $$outStack || [];\n  $$outStack.push(out);\n  out = ''; /* istanbul ignore else */\n  if (it.createErrors !== false) {\n    out += ' { keyword: \\'' + ('pattern') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { pattern:  ';\n    if ($isData) {\n      out += '' + ($schemaValue);\n    } else {\n      out += '' + (it.util.toQuotedString($schema));\n    }\n    out += '  } ';\n    if (it.opts.messages !== false) {\n      out += ' , message: \\'should match pattern \"';\n      if ($isData) {\n        out += '\\' + ' + ($schemaValue) + ' + \\'';\n      } else {\n        out += '' + (it.util.escapeQuotes($schema));\n      }\n      out += '\"\\' ';\n    }\n    if (it.opts.verbose) {\n      out += ' , schema:  ';\n      if ($isData) {\n        out += 'validate.schema' + ($schemaPath);\n      } else {\n        out += '' + (it.util.toQuotedString($schema));\n      }\n      out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n    }\n    out += ' } ';\n  } else {\n    out += ' {} ';\n  }\n  var __err = out;\n  out = $$outStack.pop();\n  if (!it.compositeRule && $breakOnError) {\n    /* istanbul ignore if */\n    if (it.async) {\n      out += ' throw new ValidationError([' + (__err) + ']); ';\n    } else {\n      out += ' validate.errors = [' + (__err) + ']; return false; ';\n    }\n  } else {\n    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n  }\n  out += '} ';\n  if ($breakOnError) {\n    out += ' else { ';\n  }\n  return out;\n}\n\n\n//# sourceURL=webpack://javascript/./node_modules/ajv/lib/dotjs/pattern.js?");

/***/ }),

/***/ "./node_modules/ajv/lib/dotjs/properties.js":
/*!**************************************************!*\
  !*** ./node_modules/ajv/lib/dotjs/properties.js ***!
  \**************************************************/
/***/ ((module) => {

"use strict";
eval("\nmodule.exports = function generate_properties(it, $keyword, $ruleType) {\n  var out = ' ';\n  var $lvl = it.level;\n  var $dataLvl = it.dataLevel;\n  var $schema = it.schema[$keyword];\n  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);\n  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;\n  var $breakOnError = !it.opts.allErrors;\n  var $data = 'data' + ($dataLvl || '');\n  var $errs = 'errs__' + $lvl;\n  var $it = it.util.copy(it);\n  var $closingBraces = '';\n  $it.level++;\n  var $nextValid = 'valid' + $it.level;\n  var $key = 'key' + $lvl,\n    $idx = 'idx' + $lvl,\n    $dataNxt = $it.dataLevel = it.dataLevel + 1,\n    $nextData = 'data' + $dataNxt,\n    $dataProperties = 'dataProperties' + $lvl;\n  var $schemaKeys = Object.keys($schema || {}).filter(notProto),\n    $pProperties = it.schema.patternProperties || {},\n    $pPropertyKeys = Object.keys($pProperties).filter(notProto),\n    $aProperties = it.schema.additionalProperties,\n    $someProperties = $schemaKeys.length || $pPropertyKeys.length,\n    $noAdditional = $aProperties === false,\n    $additionalIsSchema = typeof $aProperties == 'object' && Object.keys($aProperties).length,\n    $removeAdditional = it.opts.removeAdditional,\n    $checkAdditional = $noAdditional || $additionalIsSchema || $removeAdditional,\n    $ownProperties = it.opts.ownProperties,\n    $currentBaseId = it.baseId;\n  var $required = it.schema.required;\n  if ($required && !(it.opts.$data && $required.$data) && $required.length < it.opts.loopRequired) {\n    var $requiredHash = it.util.toHash($required);\n  }\n\n  function notProto(p) {\n    return p !== '__proto__';\n  }\n  out += 'var ' + ($errs) + ' = errors;var ' + ($nextValid) + ' = true;';\n  if ($ownProperties) {\n    out += ' var ' + ($dataProperties) + ' = undefined;';\n  }\n  if ($checkAdditional) {\n    if ($ownProperties) {\n      out += ' ' + ($dataProperties) + ' = ' + ($dataProperties) + ' || Object.keys(' + ($data) + '); for (var ' + ($idx) + '=0; ' + ($idx) + '<' + ($dataProperties) + '.length; ' + ($idx) + '++) { var ' + ($key) + ' = ' + ($dataProperties) + '[' + ($idx) + ']; ';\n    } else {\n      out += ' for (var ' + ($key) + ' in ' + ($data) + ') { ';\n    }\n    if ($someProperties) {\n      out += ' var isAdditional' + ($lvl) + ' = !(false ';\n      if ($schemaKeys.length) {\n        if ($schemaKeys.length > 8) {\n          out += ' || validate.schema' + ($schemaPath) + '.hasOwnProperty(' + ($key) + ') ';\n        } else {\n          var arr1 = $schemaKeys;\n          if (arr1) {\n            var $propertyKey, i1 = -1,\n              l1 = arr1.length - 1;\n            while (i1 < l1) {\n              $propertyKey = arr1[i1 += 1];\n              out += ' || ' + ($key) + ' == ' + (it.util.toQuotedString($propertyKey)) + ' ';\n            }\n          }\n        }\n      }\n      if ($pPropertyKeys.length) {\n        var arr2 = $pPropertyKeys;\n        if (arr2) {\n          var $pProperty, $i = -1,\n            l2 = arr2.length - 1;\n          while ($i < l2) {\n            $pProperty = arr2[$i += 1];\n            out += ' || ' + (it.usePattern($pProperty)) + '.test(' + ($key) + ') ';\n          }\n        }\n      }\n      out += ' ); if (isAdditional' + ($lvl) + ') { ';\n    }\n    if ($removeAdditional == 'all') {\n      out += ' delete ' + ($data) + '[' + ($key) + ']; ';\n    } else {\n      var $currentErrorPath = it.errorPath;\n      var $additionalProperty = '\\' + ' + $key + ' + \\'';\n      if (it.opts._errorDataPathProperty) {\n        it.errorPath = it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);\n      }\n      if ($noAdditional) {\n        if ($removeAdditional) {\n          out += ' delete ' + ($data) + '[' + ($key) + ']; ';\n        } else {\n          out += ' ' + ($nextValid) + ' = false; ';\n          var $currErrSchemaPath = $errSchemaPath;\n          $errSchemaPath = it.errSchemaPath + '/additionalProperties';\n          var $$outStack = $$outStack || [];\n          $$outStack.push(out);\n          out = ''; /* istanbul ignore else */\n          if (it.createErrors !== false) {\n            out += ' { keyword: \\'' + ('additionalProperties') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { additionalProperty: \\'' + ($additionalProperty) + '\\' } ';\n            if (it.opts.messages !== false) {\n              out += ' , message: \\'';\n              if (it.opts._errorDataPathProperty) {\n                out += 'is an invalid additional property';\n              } else {\n                out += 'should NOT have additional properties';\n              }\n              out += '\\' ';\n            }\n            if (it.opts.verbose) {\n              out += ' , schema: false , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n            }\n            out += ' } ';\n          } else {\n            out += ' {} ';\n          }\n          var __err = out;\n          out = $$outStack.pop();\n          if (!it.compositeRule && $breakOnError) {\n            /* istanbul ignore if */\n            if (it.async) {\n              out += ' throw new ValidationError([' + (__err) + ']); ';\n            } else {\n              out += ' validate.errors = [' + (__err) + ']; return false; ';\n            }\n          } else {\n            out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n          }\n          $errSchemaPath = $currErrSchemaPath;\n          if ($breakOnError) {\n            out += ' break; ';\n          }\n        }\n      } else if ($additionalIsSchema) {\n        if ($removeAdditional == 'failing') {\n          out += ' var ' + ($errs) + ' = errors;  ';\n          var $wasComposite = it.compositeRule;\n          it.compositeRule = $it.compositeRule = true;\n          $it.schema = $aProperties;\n          $it.schemaPath = it.schemaPath + '.additionalProperties';\n          $it.errSchemaPath = it.errSchemaPath + '/additionalProperties';\n          $it.errorPath = it.opts._errorDataPathProperty ? it.errorPath : it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);\n          var $passData = $data + '[' + $key + ']';\n          $it.dataPathArr[$dataNxt] = $key;\n          var $code = it.validate($it);\n          $it.baseId = $currentBaseId;\n          if (it.util.varOccurences($code, $nextData) < 2) {\n            out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';\n          } else {\n            out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';\n          }\n          out += ' if (!' + ($nextValid) + ') { errors = ' + ($errs) + '; if (validate.errors !== null) { if (errors) validate.errors.length = errors; else validate.errors = null; } delete ' + ($data) + '[' + ($key) + ']; }  ';\n          it.compositeRule = $it.compositeRule = $wasComposite;\n        } else {\n          $it.schema = $aProperties;\n          $it.schemaPath = it.schemaPath + '.additionalProperties';\n          $it.errSchemaPath = it.errSchemaPath + '/additionalProperties';\n          $it.errorPath = it.opts._errorDataPathProperty ? it.errorPath : it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);\n          var $passData = $data + '[' + $key + ']';\n          $it.dataPathArr[$dataNxt] = $key;\n          var $code = it.validate($it);\n          $it.baseId = $currentBaseId;\n          if (it.util.varOccurences($code, $nextData) < 2) {\n            out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';\n          } else {\n            out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';\n          }\n          if ($breakOnError) {\n            out += ' if (!' + ($nextValid) + ') break; ';\n          }\n        }\n      }\n      it.errorPath = $currentErrorPath;\n    }\n    if ($someProperties) {\n      out += ' } ';\n    }\n    out += ' }  ';\n    if ($breakOnError) {\n      out += ' if (' + ($nextValid) + ') { ';\n      $closingBraces += '}';\n    }\n  }\n  var $useDefaults = it.opts.useDefaults && !it.compositeRule;\n  if ($schemaKeys.length) {\n    var arr3 = $schemaKeys;\n    if (arr3) {\n      var $propertyKey, i3 = -1,\n        l3 = arr3.length - 1;\n      while (i3 < l3) {\n        $propertyKey = arr3[i3 += 1];\n        var $sch = $schema[$propertyKey];\n        if ((it.opts.strictKeywords ? (typeof $sch == 'object' && Object.keys($sch).length > 0) || $sch === false : it.util.schemaHasRules($sch, it.RULES.all))) {\n          var $prop = it.util.getProperty($propertyKey),\n            $passData = $data + $prop,\n            $hasDefault = $useDefaults && $sch.default !== undefined;\n          $it.schema = $sch;\n          $it.schemaPath = $schemaPath + $prop;\n          $it.errSchemaPath = $errSchemaPath + '/' + it.util.escapeFragment($propertyKey);\n          $it.errorPath = it.util.getPath(it.errorPath, $propertyKey, it.opts.jsonPointers);\n          $it.dataPathArr[$dataNxt] = it.util.toQuotedString($propertyKey);\n          var $code = it.validate($it);\n          $it.baseId = $currentBaseId;\n          if (it.util.varOccurences($code, $nextData) < 2) {\n            $code = it.util.varReplace($code, $nextData, $passData);\n            var $useData = $passData;\n          } else {\n            var $useData = $nextData;\n            out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ';\n          }\n          if ($hasDefault) {\n            out += ' ' + ($code) + ' ';\n          } else {\n            if ($requiredHash && $requiredHash[$propertyKey]) {\n              out += ' if ( ' + ($useData) + ' === undefined ';\n              if ($ownProperties) {\n                out += ' || ! Object.prototype.hasOwnProperty.call(' + ($data) + ', \\'' + (it.util.escapeQuotes($propertyKey)) + '\\') ';\n              }\n              out += ') { ' + ($nextValid) + ' = false; ';\n              var $currentErrorPath = it.errorPath,\n                $currErrSchemaPath = $errSchemaPath,\n                $missingProperty = it.util.escapeQuotes($propertyKey);\n              if (it.opts._errorDataPathProperty) {\n                it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);\n              }\n              $errSchemaPath = it.errSchemaPath + '/required';\n              var $$outStack = $$outStack || [];\n              $$outStack.push(out);\n              out = ''; /* istanbul ignore else */\n              if (it.createErrors !== false) {\n                out += ' { keyword: \\'' + ('required') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { missingProperty: \\'' + ($missingProperty) + '\\' } ';\n                if (it.opts.messages !== false) {\n                  out += ' , message: \\'';\n                  if (it.opts._errorDataPathProperty) {\n                    out += 'is a required property';\n                  } else {\n                    out += 'should have required property \\\\\\'' + ($missingProperty) + '\\\\\\'';\n                  }\n                  out += '\\' ';\n                }\n                if (it.opts.verbose) {\n                  out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n                }\n                out += ' } ';\n              } else {\n                out += ' {} ';\n              }\n              var __err = out;\n              out = $$outStack.pop();\n              if (!it.compositeRule && $breakOnError) {\n                /* istanbul ignore if */\n                if (it.async) {\n                  out += ' throw new ValidationError([' + (__err) + ']); ';\n                } else {\n                  out += ' validate.errors = [' + (__err) + ']; return false; ';\n                }\n              } else {\n                out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n              }\n              $errSchemaPath = $currErrSchemaPath;\n              it.errorPath = $currentErrorPath;\n              out += ' } else { ';\n            } else {\n              if ($breakOnError) {\n                out += ' if ( ' + ($useData) + ' === undefined ';\n                if ($ownProperties) {\n                  out += ' || ! Object.prototype.hasOwnProperty.call(' + ($data) + ', \\'' + (it.util.escapeQuotes($propertyKey)) + '\\') ';\n                }\n                out += ') { ' + ($nextValid) + ' = true; } else { ';\n              } else {\n                out += ' if (' + ($useData) + ' !== undefined ';\n                if ($ownProperties) {\n                  out += ' &&   Object.prototype.hasOwnProperty.call(' + ($data) + ', \\'' + (it.util.escapeQuotes($propertyKey)) + '\\') ';\n                }\n                out += ' ) { ';\n              }\n            }\n            out += ' ' + ($code) + ' } ';\n          }\n        }\n        if ($breakOnError) {\n          out += ' if (' + ($nextValid) + ') { ';\n          $closingBraces += '}';\n        }\n      }\n    }\n  }\n  if ($pPropertyKeys.length) {\n    var arr4 = $pPropertyKeys;\n    if (arr4) {\n      var $pProperty, i4 = -1,\n        l4 = arr4.length - 1;\n      while (i4 < l4) {\n        $pProperty = arr4[i4 += 1];\n        var $sch = $pProperties[$pProperty];\n        if ((it.opts.strictKeywords ? (typeof $sch == 'object' && Object.keys($sch).length > 0) || $sch === false : it.util.schemaHasRules($sch, it.RULES.all))) {\n          $it.schema = $sch;\n          $it.schemaPath = it.schemaPath + '.patternProperties' + it.util.getProperty($pProperty);\n          $it.errSchemaPath = it.errSchemaPath + '/patternProperties/' + it.util.escapeFragment($pProperty);\n          if ($ownProperties) {\n            out += ' ' + ($dataProperties) + ' = ' + ($dataProperties) + ' || Object.keys(' + ($data) + '); for (var ' + ($idx) + '=0; ' + ($idx) + '<' + ($dataProperties) + '.length; ' + ($idx) + '++) { var ' + ($key) + ' = ' + ($dataProperties) + '[' + ($idx) + ']; ';\n          } else {\n            out += ' for (var ' + ($key) + ' in ' + ($data) + ') { ';\n          }\n          out += ' if (' + (it.usePattern($pProperty)) + '.test(' + ($key) + ')) { ';\n          $it.errorPath = it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);\n          var $passData = $data + '[' + $key + ']';\n          $it.dataPathArr[$dataNxt] = $key;\n          var $code = it.validate($it);\n          $it.baseId = $currentBaseId;\n          if (it.util.varOccurences($code, $nextData) < 2) {\n            out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';\n          } else {\n            out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';\n          }\n          if ($breakOnError) {\n            out += ' if (!' + ($nextValid) + ') break; ';\n          }\n          out += ' } ';\n          if ($breakOnError) {\n            out += ' else ' + ($nextValid) + ' = true; ';\n          }\n          out += ' }  ';\n          if ($breakOnError) {\n            out += ' if (' + ($nextValid) + ') { ';\n            $closingBraces += '}';\n          }\n        }\n      }\n    }\n  }\n  if ($breakOnError) {\n    out += ' ' + ($closingBraces) + ' if (' + ($errs) + ' == errors) {';\n  }\n  return out;\n}\n\n\n//# sourceURL=webpack://javascript/./node_modules/ajv/lib/dotjs/properties.js?");

/***/ }),

/***/ "./node_modules/ajv/lib/dotjs/propertyNames.js":
/*!*****************************************************!*\
  !*** ./node_modules/ajv/lib/dotjs/propertyNames.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";
eval("\nmodule.exports = function generate_propertyNames(it, $keyword, $ruleType) {\n  var out = ' ';\n  var $lvl = it.level;\n  var $dataLvl = it.dataLevel;\n  var $schema = it.schema[$keyword];\n  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);\n  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;\n  var $breakOnError = !it.opts.allErrors;\n  var $data = 'data' + ($dataLvl || '');\n  var $errs = 'errs__' + $lvl;\n  var $it = it.util.copy(it);\n  var $closingBraces = '';\n  $it.level++;\n  var $nextValid = 'valid' + $it.level;\n  out += 'var ' + ($errs) + ' = errors;';\n  if ((it.opts.strictKeywords ? (typeof $schema == 'object' && Object.keys($schema).length > 0) || $schema === false : it.util.schemaHasRules($schema, it.RULES.all))) {\n    $it.schema = $schema;\n    $it.schemaPath = $schemaPath;\n    $it.errSchemaPath = $errSchemaPath;\n    var $key = 'key' + $lvl,\n      $idx = 'idx' + $lvl,\n      $i = 'i' + $lvl,\n      $invalidName = '\\' + ' + $key + ' + \\'',\n      $dataNxt = $it.dataLevel = it.dataLevel + 1,\n      $nextData = 'data' + $dataNxt,\n      $dataProperties = 'dataProperties' + $lvl,\n      $ownProperties = it.opts.ownProperties,\n      $currentBaseId = it.baseId;\n    if ($ownProperties) {\n      out += ' var ' + ($dataProperties) + ' = undefined; ';\n    }\n    if ($ownProperties) {\n      out += ' ' + ($dataProperties) + ' = ' + ($dataProperties) + ' || Object.keys(' + ($data) + '); for (var ' + ($idx) + '=0; ' + ($idx) + '<' + ($dataProperties) + '.length; ' + ($idx) + '++) { var ' + ($key) + ' = ' + ($dataProperties) + '[' + ($idx) + ']; ';\n    } else {\n      out += ' for (var ' + ($key) + ' in ' + ($data) + ') { ';\n    }\n    out += ' var startErrs' + ($lvl) + ' = errors; ';\n    var $passData = $key;\n    var $wasComposite = it.compositeRule;\n    it.compositeRule = $it.compositeRule = true;\n    var $code = it.validate($it);\n    $it.baseId = $currentBaseId;\n    if (it.util.varOccurences($code, $nextData) < 2) {\n      out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';\n    } else {\n      out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';\n    }\n    it.compositeRule = $it.compositeRule = $wasComposite;\n    out += ' if (!' + ($nextValid) + ') { for (var ' + ($i) + '=startErrs' + ($lvl) + '; ' + ($i) + '<errors; ' + ($i) + '++) { vErrors[' + ($i) + '].propertyName = ' + ($key) + '; }   var err =   '; /* istanbul ignore else */\n    if (it.createErrors !== false) {\n      out += ' { keyword: \\'' + ('propertyNames') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { propertyName: \\'' + ($invalidName) + '\\' } ';\n      if (it.opts.messages !== false) {\n        out += ' , message: \\'property name \\\\\\'' + ($invalidName) + '\\\\\\' is invalid\\' ';\n      }\n      if (it.opts.verbose) {\n        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n      }\n      out += ' } ';\n    } else {\n      out += ' {} ';\n    }\n    out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n    if (!it.compositeRule && $breakOnError) {\n      /* istanbul ignore if */\n      if (it.async) {\n        out += ' throw new ValidationError(vErrors); ';\n      } else {\n        out += ' validate.errors = vErrors; return false; ';\n      }\n    }\n    if ($breakOnError) {\n      out += ' break; ';\n    }\n    out += ' } }';\n  }\n  if ($breakOnError) {\n    out += ' ' + ($closingBraces) + ' if (' + ($errs) + ' == errors) {';\n  }\n  return out;\n}\n\n\n//# sourceURL=webpack://javascript/./node_modules/ajv/lib/dotjs/propertyNames.js?");

/***/ }),

/***/ "./node_modules/ajv/lib/dotjs/ref.js":
/*!*******************************************!*\
  !*** ./node_modules/ajv/lib/dotjs/ref.js ***!
  \*******************************************/
/***/ ((module) => {

"use strict";
eval("\nmodule.exports = function generate_ref(it, $keyword, $ruleType) {\n  var out = ' ';\n  var $lvl = it.level;\n  var $dataLvl = it.dataLevel;\n  var $schema = it.schema[$keyword];\n  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;\n  var $breakOnError = !it.opts.allErrors;\n  var $data = 'data' + ($dataLvl || '');\n  var $valid = 'valid' + $lvl;\n  var $async, $refCode;\n  if ($schema == '#' || $schema == '#/') {\n    if (it.isRoot) {\n      $async = it.async;\n      $refCode = 'validate';\n    } else {\n      $async = it.root.schema.$async === true;\n      $refCode = 'root.refVal[0]';\n    }\n  } else {\n    var $refVal = it.resolveRef(it.baseId, $schema, it.isRoot);\n    if ($refVal === undefined) {\n      var $message = it.MissingRefError.message(it.baseId, $schema);\n      if (it.opts.missingRefs == 'fail') {\n        it.logger.error($message);\n        var $$outStack = $$outStack || [];\n        $$outStack.push(out);\n        out = ''; /* istanbul ignore else */\n        if (it.createErrors !== false) {\n          out += ' { keyword: \\'' + ('$ref') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { ref: \\'' + (it.util.escapeQuotes($schema)) + '\\' } ';\n          if (it.opts.messages !== false) {\n            out += ' , message: \\'can\\\\\\'t resolve reference ' + (it.util.escapeQuotes($schema)) + '\\' ';\n          }\n          if (it.opts.verbose) {\n            out += ' , schema: ' + (it.util.toQuotedString($schema)) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n          }\n          out += ' } ';\n        } else {\n          out += ' {} ';\n        }\n        var __err = out;\n        out = $$outStack.pop();\n        if (!it.compositeRule && $breakOnError) {\n          /* istanbul ignore if */\n          if (it.async) {\n            out += ' throw new ValidationError([' + (__err) + ']); ';\n          } else {\n            out += ' validate.errors = [' + (__err) + ']; return false; ';\n          }\n        } else {\n          out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n        }\n        if ($breakOnError) {\n          out += ' if (false) { ';\n        }\n      } else if (it.opts.missingRefs == 'ignore') {\n        it.logger.warn($message);\n        if ($breakOnError) {\n          out += ' if (true) { ';\n        }\n      } else {\n        throw new it.MissingRefError(it.baseId, $schema, $message);\n      }\n    } else if ($refVal.inline) {\n      var $it = it.util.copy(it);\n      $it.level++;\n      var $nextValid = 'valid' + $it.level;\n      $it.schema = $refVal.schema;\n      $it.schemaPath = '';\n      $it.errSchemaPath = $schema;\n      var $code = it.validate($it).replace(/validate\\.schema/g, $refVal.code);\n      out += ' ' + ($code) + ' ';\n      if ($breakOnError) {\n        out += ' if (' + ($nextValid) + ') { ';\n      }\n    } else {\n      $async = $refVal.$async === true || (it.async && $refVal.$async !== false);\n      $refCode = $refVal.code;\n    }\n  }\n  if ($refCode) {\n    var $$outStack = $$outStack || [];\n    $$outStack.push(out);\n    out = '';\n    if (it.opts.passContext) {\n      out += ' ' + ($refCode) + '.call(this, ';\n    } else {\n      out += ' ' + ($refCode) + '( ';\n    }\n    out += ' ' + ($data) + ', (dataPath || \\'\\')';\n    if (it.errorPath != '\"\"') {\n      out += ' + ' + (it.errorPath);\n    }\n    var $parentData = $dataLvl ? 'data' + (($dataLvl - 1) || '') : 'parentData',\n      $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : 'parentDataProperty';\n    out += ' , ' + ($parentData) + ' , ' + ($parentDataProperty) + ', rootData)  ';\n    var __callValidate = out;\n    out = $$outStack.pop();\n    if ($async) {\n      if (!it.async) throw new Error('async schema referenced by sync schema');\n      if ($breakOnError) {\n        out += ' var ' + ($valid) + '; ';\n      }\n      out += ' try { await ' + (__callValidate) + '; ';\n      if ($breakOnError) {\n        out += ' ' + ($valid) + ' = true; ';\n      }\n      out += ' } catch (e) { if (!(e instanceof ValidationError)) throw e; if (vErrors === null) vErrors = e.errors; else vErrors = vErrors.concat(e.errors); errors = vErrors.length; ';\n      if ($breakOnError) {\n        out += ' ' + ($valid) + ' = false; ';\n      }\n      out += ' } ';\n      if ($breakOnError) {\n        out += ' if (' + ($valid) + ') { ';\n      }\n    } else {\n      out += ' if (!' + (__callValidate) + ') { if (vErrors === null) vErrors = ' + ($refCode) + '.errors; else vErrors = vErrors.concat(' + ($refCode) + '.errors); errors = vErrors.length; } ';\n      if ($breakOnError) {\n        out += ' else { ';\n      }\n    }\n  }\n  return out;\n}\n\n\n//# sourceURL=webpack://javascript/./node_modules/ajv/lib/dotjs/ref.js?");

/***/ }),

/***/ "./node_modules/ajv/lib/dotjs/required.js":
/*!************************************************!*\
  !*** ./node_modules/ajv/lib/dotjs/required.js ***!
  \************************************************/
/***/ ((module) => {

"use strict";
eval("\nmodule.exports = function generate_required(it, $keyword, $ruleType) {\n  var out = ' ';\n  var $lvl = it.level;\n  var $dataLvl = it.dataLevel;\n  var $schema = it.schema[$keyword];\n  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);\n  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;\n  var $breakOnError = !it.opts.allErrors;\n  var $data = 'data' + ($dataLvl || '');\n  var $valid = 'valid' + $lvl;\n  var $isData = it.opts.$data && $schema && $schema.$data,\n    $schemaValue;\n  if ($isData) {\n    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';\n    $schemaValue = 'schema' + $lvl;\n  } else {\n    $schemaValue = $schema;\n  }\n  var $vSchema = 'schema' + $lvl;\n  if (!$isData) {\n    if ($schema.length < it.opts.loopRequired && it.schema.properties && Object.keys(it.schema.properties).length) {\n      var $required = [];\n      var arr1 = $schema;\n      if (arr1) {\n        var $property, i1 = -1,\n          l1 = arr1.length - 1;\n        while (i1 < l1) {\n          $property = arr1[i1 += 1];\n          var $propertySch = it.schema.properties[$property];\n          if (!($propertySch && (it.opts.strictKeywords ? (typeof $propertySch == 'object' && Object.keys($propertySch).length > 0) || $propertySch === false : it.util.schemaHasRules($propertySch, it.RULES.all)))) {\n            $required[$required.length] = $property;\n          }\n        }\n      }\n    } else {\n      var $required = $schema;\n    }\n  }\n  if ($isData || $required.length) {\n    var $currentErrorPath = it.errorPath,\n      $loopRequired = $isData || $required.length >= it.opts.loopRequired,\n      $ownProperties = it.opts.ownProperties;\n    if ($breakOnError) {\n      out += ' var missing' + ($lvl) + '; ';\n      if ($loopRequired) {\n        if (!$isData) {\n          out += ' var ' + ($vSchema) + ' = validate.schema' + ($schemaPath) + '; ';\n        }\n        var $i = 'i' + $lvl,\n          $propertyPath = 'schema' + $lvl + '[' + $i + ']',\n          $missingProperty = '\\' + ' + $propertyPath + ' + \\'';\n        if (it.opts._errorDataPathProperty) {\n          it.errorPath = it.util.getPathExpr($currentErrorPath, $propertyPath, it.opts.jsonPointers);\n        }\n        out += ' var ' + ($valid) + ' = true; ';\n        if ($isData) {\n          out += ' if (schema' + ($lvl) + ' === undefined) ' + ($valid) + ' = true; else if (!Array.isArray(schema' + ($lvl) + ')) ' + ($valid) + ' = false; else {';\n        }\n        out += ' for (var ' + ($i) + ' = 0; ' + ($i) + ' < ' + ($vSchema) + '.length; ' + ($i) + '++) { ' + ($valid) + ' = ' + ($data) + '[' + ($vSchema) + '[' + ($i) + ']] !== undefined ';\n        if ($ownProperties) {\n          out += ' &&   Object.prototype.hasOwnProperty.call(' + ($data) + ', ' + ($vSchema) + '[' + ($i) + ']) ';\n        }\n        out += '; if (!' + ($valid) + ') break; } ';\n        if ($isData) {\n          out += '  }  ';\n        }\n        out += '  if (!' + ($valid) + ') {   ';\n        var $$outStack = $$outStack || [];\n        $$outStack.push(out);\n        out = ''; /* istanbul ignore else */\n        if (it.createErrors !== false) {\n          out += ' { keyword: \\'' + ('required') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { missingProperty: \\'' + ($missingProperty) + '\\' } ';\n          if (it.opts.messages !== false) {\n            out += ' , message: \\'';\n            if (it.opts._errorDataPathProperty) {\n              out += 'is a required property';\n            } else {\n              out += 'should have required property \\\\\\'' + ($missingProperty) + '\\\\\\'';\n            }\n            out += '\\' ';\n          }\n          if (it.opts.verbose) {\n            out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n          }\n          out += ' } ';\n        } else {\n          out += ' {} ';\n        }\n        var __err = out;\n        out = $$outStack.pop();\n        if (!it.compositeRule && $breakOnError) {\n          /* istanbul ignore if */\n          if (it.async) {\n            out += ' throw new ValidationError([' + (__err) + ']); ';\n          } else {\n            out += ' validate.errors = [' + (__err) + ']; return false; ';\n          }\n        } else {\n          out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n        }\n        out += ' } else { ';\n      } else {\n        out += ' if ( ';\n        var arr2 = $required;\n        if (arr2) {\n          var $propertyKey, $i = -1,\n            l2 = arr2.length - 1;\n          while ($i < l2) {\n            $propertyKey = arr2[$i += 1];\n            if ($i) {\n              out += ' || ';\n            }\n            var $prop = it.util.getProperty($propertyKey),\n              $useData = $data + $prop;\n            out += ' ( ( ' + ($useData) + ' === undefined ';\n            if ($ownProperties) {\n              out += ' || ! Object.prototype.hasOwnProperty.call(' + ($data) + ', \\'' + (it.util.escapeQuotes($propertyKey)) + '\\') ';\n            }\n            out += ') && (missing' + ($lvl) + ' = ' + (it.util.toQuotedString(it.opts.jsonPointers ? $propertyKey : $prop)) + ') ) ';\n          }\n        }\n        out += ') {  ';\n        var $propertyPath = 'missing' + $lvl,\n          $missingProperty = '\\' + ' + $propertyPath + ' + \\'';\n        if (it.opts._errorDataPathProperty) {\n          it.errorPath = it.opts.jsonPointers ? it.util.getPathExpr($currentErrorPath, $propertyPath, true) : $currentErrorPath + ' + ' + $propertyPath;\n        }\n        var $$outStack = $$outStack || [];\n        $$outStack.push(out);\n        out = ''; /* istanbul ignore else */\n        if (it.createErrors !== false) {\n          out += ' { keyword: \\'' + ('required') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { missingProperty: \\'' + ($missingProperty) + '\\' } ';\n          if (it.opts.messages !== false) {\n            out += ' , message: \\'';\n            if (it.opts._errorDataPathProperty) {\n              out += 'is a required property';\n            } else {\n              out += 'should have required property \\\\\\'' + ($missingProperty) + '\\\\\\'';\n            }\n            out += '\\' ';\n          }\n          if (it.opts.verbose) {\n            out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n          }\n          out += ' } ';\n        } else {\n          out += ' {} ';\n        }\n        var __err = out;\n        out = $$outStack.pop();\n        if (!it.compositeRule && $breakOnError) {\n          /* istanbul ignore if */\n          if (it.async) {\n            out += ' throw new ValidationError([' + (__err) + ']); ';\n          } else {\n            out += ' validate.errors = [' + (__err) + ']; return false; ';\n          }\n        } else {\n          out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n        }\n        out += ' } else { ';\n      }\n    } else {\n      if ($loopRequired) {\n        if (!$isData) {\n          out += ' var ' + ($vSchema) + ' = validate.schema' + ($schemaPath) + '; ';\n        }\n        var $i = 'i' + $lvl,\n          $propertyPath = 'schema' + $lvl + '[' + $i + ']',\n          $missingProperty = '\\' + ' + $propertyPath + ' + \\'';\n        if (it.opts._errorDataPathProperty) {\n          it.errorPath = it.util.getPathExpr($currentErrorPath, $propertyPath, it.opts.jsonPointers);\n        }\n        if ($isData) {\n          out += ' if (' + ($vSchema) + ' && !Array.isArray(' + ($vSchema) + ')) {  var err =   '; /* istanbul ignore else */\n          if (it.createErrors !== false) {\n            out += ' { keyword: \\'' + ('required') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { missingProperty: \\'' + ($missingProperty) + '\\' } ';\n            if (it.opts.messages !== false) {\n              out += ' , message: \\'';\n              if (it.opts._errorDataPathProperty) {\n                out += 'is a required property';\n              } else {\n                out += 'should have required property \\\\\\'' + ($missingProperty) + '\\\\\\'';\n              }\n              out += '\\' ';\n            }\n            if (it.opts.verbose) {\n              out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n            }\n            out += ' } ';\n          } else {\n            out += ' {} ';\n          }\n          out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } else if (' + ($vSchema) + ' !== undefined) { ';\n        }\n        out += ' for (var ' + ($i) + ' = 0; ' + ($i) + ' < ' + ($vSchema) + '.length; ' + ($i) + '++) { if (' + ($data) + '[' + ($vSchema) + '[' + ($i) + ']] === undefined ';\n        if ($ownProperties) {\n          out += ' || ! Object.prototype.hasOwnProperty.call(' + ($data) + ', ' + ($vSchema) + '[' + ($i) + ']) ';\n        }\n        out += ') {  var err =   '; /* istanbul ignore else */\n        if (it.createErrors !== false) {\n          out += ' { keyword: \\'' + ('required') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { missingProperty: \\'' + ($missingProperty) + '\\' } ';\n          if (it.opts.messages !== false) {\n            out += ' , message: \\'';\n            if (it.opts._errorDataPathProperty) {\n              out += 'is a required property';\n            } else {\n              out += 'should have required property \\\\\\'' + ($missingProperty) + '\\\\\\'';\n            }\n            out += '\\' ';\n          }\n          if (it.opts.verbose) {\n            out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n          }\n          out += ' } ';\n        } else {\n          out += ' {} ';\n        }\n        out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } } ';\n        if ($isData) {\n          out += '  }  ';\n        }\n      } else {\n        var arr3 = $required;\n        if (arr3) {\n          var $propertyKey, i3 = -1,\n            l3 = arr3.length - 1;\n          while (i3 < l3) {\n            $propertyKey = arr3[i3 += 1];\n            var $prop = it.util.getProperty($propertyKey),\n              $missingProperty = it.util.escapeQuotes($propertyKey),\n              $useData = $data + $prop;\n            if (it.opts._errorDataPathProperty) {\n              it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);\n            }\n            out += ' if ( ' + ($useData) + ' === undefined ';\n            if ($ownProperties) {\n              out += ' || ! Object.prototype.hasOwnProperty.call(' + ($data) + ', \\'' + (it.util.escapeQuotes($propertyKey)) + '\\') ';\n            }\n            out += ') {  var err =   '; /* istanbul ignore else */\n            if (it.createErrors !== false) {\n              out += ' { keyword: \\'' + ('required') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { missingProperty: \\'' + ($missingProperty) + '\\' } ';\n              if (it.opts.messages !== false) {\n                out += ' , message: \\'';\n                if (it.opts._errorDataPathProperty) {\n                  out += 'is a required property';\n                } else {\n                  out += 'should have required property \\\\\\'' + ($missingProperty) + '\\\\\\'';\n                }\n                out += '\\' ';\n              }\n              if (it.opts.verbose) {\n                out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n              }\n              out += ' } ';\n            } else {\n              out += ' {} ';\n            }\n            out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } ';\n          }\n        }\n      }\n    }\n    it.errorPath = $currentErrorPath;\n  } else if ($breakOnError) {\n    out += ' if (true) {';\n  }\n  return out;\n}\n\n\n//# sourceURL=webpack://javascript/./node_modules/ajv/lib/dotjs/required.js?");

/***/ }),

/***/ "./node_modules/ajv/lib/dotjs/uniqueItems.js":
/*!***************************************************!*\
  !*** ./node_modules/ajv/lib/dotjs/uniqueItems.js ***!
  \***************************************************/
/***/ ((module) => {

"use strict";
eval("\nmodule.exports = function generate_uniqueItems(it, $keyword, $ruleType) {\n  var out = ' ';\n  var $lvl = it.level;\n  var $dataLvl = it.dataLevel;\n  var $schema = it.schema[$keyword];\n  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);\n  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;\n  var $breakOnError = !it.opts.allErrors;\n  var $data = 'data' + ($dataLvl || '');\n  var $valid = 'valid' + $lvl;\n  var $isData = it.opts.$data && $schema && $schema.$data,\n    $schemaValue;\n  if ($isData) {\n    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';\n    $schemaValue = 'schema' + $lvl;\n  } else {\n    $schemaValue = $schema;\n  }\n  if (($schema || $isData) && it.opts.uniqueItems !== false) {\n    if ($isData) {\n      out += ' var ' + ($valid) + '; if (' + ($schemaValue) + ' === false || ' + ($schemaValue) + ' === undefined) ' + ($valid) + ' = true; else if (typeof ' + ($schemaValue) + ' != \\'boolean\\') ' + ($valid) + ' = false; else { ';\n    }\n    out += ' var i = ' + ($data) + '.length , ' + ($valid) + ' = true , j; if (i > 1) { ';\n    var $itemType = it.schema.items && it.schema.items.type,\n      $typeIsArray = Array.isArray($itemType);\n    if (!$itemType || $itemType == 'object' || $itemType == 'array' || ($typeIsArray && ($itemType.indexOf('object') >= 0 || $itemType.indexOf('array') >= 0))) {\n      out += ' outer: for (;i--;) { for (j = i; j--;) { if (equal(' + ($data) + '[i], ' + ($data) + '[j])) { ' + ($valid) + ' = false; break outer; } } } ';\n    } else {\n      out += ' var itemIndices = {}, item; for (;i--;) { var item = ' + ($data) + '[i]; ';\n      var $method = 'checkDataType' + ($typeIsArray ? 's' : '');\n      out += ' if (' + (it.util[$method]($itemType, 'item', it.opts.strictNumbers, true)) + ') continue; ';\n      if ($typeIsArray) {\n        out += ' if (typeof item == \\'string\\') item = \\'\"\\' + item; ';\n      }\n      out += ' if (typeof itemIndices[item] == \\'number\\') { ' + ($valid) + ' = false; j = itemIndices[item]; break; } itemIndices[item] = i; } ';\n    }\n    out += ' } ';\n    if ($isData) {\n      out += '  }  ';\n    }\n    out += ' if (!' + ($valid) + ') {   ';\n    var $$outStack = $$outStack || [];\n    $$outStack.push(out);\n    out = ''; /* istanbul ignore else */\n    if (it.createErrors !== false) {\n      out += ' { keyword: \\'' + ('uniqueItems') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { i: i, j: j } ';\n      if (it.opts.messages !== false) {\n        out += ' , message: \\'should NOT have duplicate items (items ## \\' + j + \\' and \\' + i + \\' are identical)\\' ';\n      }\n      if (it.opts.verbose) {\n        out += ' , schema:  ';\n        if ($isData) {\n          out += 'validate.schema' + ($schemaPath);\n        } else {\n          out += '' + ($schema);\n        }\n        out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n      }\n      out += ' } ';\n    } else {\n      out += ' {} ';\n    }\n    var __err = out;\n    out = $$outStack.pop();\n    if (!it.compositeRule && $breakOnError) {\n      /* istanbul ignore if */\n      if (it.async) {\n        out += ' throw new ValidationError([' + (__err) + ']); ';\n      } else {\n        out += ' validate.errors = [' + (__err) + ']; return false; ';\n      }\n    } else {\n      out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n    }\n    out += ' } ';\n    if ($breakOnError) {\n      out += ' else { ';\n    }\n  } else {\n    if ($breakOnError) {\n      out += ' if (true) { ';\n    }\n  }\n  return out;\n}\n\n\n//# sourceURL=webpack://javascript/./node_modules/ajv/lib/dotjs/uniqueItems.js?");

/***/ }),

/***/ "./node_modules/ajv/lib/dotjs/validate.js":
/*!************************************************!*\
  !*** ./node_modules/ajv/lib/dotjs/validate.js ***!
  \************************************************/
/***/ ((module) => {

"use strict";
eval("\nmodule.exports = function generate_validate(it, $keyword, $ruleType) {\n  var out = '';\n  var $async = it.schema.$async === true,\n    $refKeywords = it.util.schemaHasRulesExcept(it.schema, it.RULES.all, '$ref'),\n    $id = it.self._getId(it.schema);\n  if (it.opts.strictKeywords) {\n    var $unknownKwd = it.util.schemaUnknownRules(it.schema, it.RULES.keywords);\n    if ($unknownKwd) {\n      var $keywordsMsg = 'unknown keyword: ' + $unknownKwd;\n      if (it.opts.strictKeywords === 'log') it.logger.warn($keywordsMsg);\n      else throw new Error($keywordsMsg);\n    }\n  }\n  if (it.isTop) {\n    out += ' var validate = ';\n    if ($async) {\n      it.async = true;\n      out += 'async ';\n    }\n    out += 'function(data, dataPath, parentData, parentDataProperty, rootData) { \\'use strict\\'; ';\n    if ($id && (it.opts.sourceCode || it.opts.processCode)) {\n      out += ' ' + ('/\\*# sourceURL=' + $id + ' */') + ' ';\n    }\n  }\n  if (typeof it.schema == 'boolean' || !($refKeywords || it.schema.$ref)) {\n    var $keyword = 'false schema';\n    var $lvl = it.level;\n    var $dataLvl = it.dataLevel;\n    var $schema = it.schema[$keyword];\n    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);\n    var $errSchemaPath = it.errSchemaPath + '/' + $keyword;\n    var $breakOnError = !it.opts.allErrors;\n    var $errorKeyword;\n    var $data = 'data' + ($dataLvl || '');\n    var $valid = 'valid' + $lvl;\n    if (it.schema === false) {\n      if (it.isTop) {\n        $breakOnError = true;\n      } else {\n        out += ' var ' + ($valid) + ' = false; ';\n      }\n      var $$outStack = $$outStack || [];\n      $$outStack.push(out);\n      out = ''; /* istanbul ignore else */\n      if (it.createErrors !== false) {\n        out += ' { keyword: \\'' + ($errorKeyword || 'false schema') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: {} ';\n        if (it.opts.messages !== false) {\n          out += ' , message: \\'boolean schema is false\\' ';\n        }\n        if (it.opts.verbose) {\n          out += ' , schema: false , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n        }\n        out += ' } ';\n      } else {\n        out += ' {} ';\n      }\n      var __err = out;\n      out = $$outStack.pop();\n      if (!it.compositeRule && $breakOnError) {\n        /* istanbul ignore if */\n        if (it.async) {\n          out += ' throw new ValidationError([' + (__err) + ']); ';\n        } else {\n          out += ' validate.errors = [' + (__err) + ']; return false; ';\n        }\n      } else {\n        out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n      }\n    } else {\n      if (it.isTop) {\n        if ($async) {\n          out += ' return data; ';\n        } else {\n          out += ' validate.errors = null; return true; ';\n        }\n      } else {\n        out += ' var ' + ($valid) + ' = true; ';\n      }\n    }\n    if (it.isTop) {\n      out += ' }; return validate; ';\n    }\n    return out;\n  }\n  if (it.isTop) {\n    var $top = it.isTop,\n      $lvl = it.level = 0,\n      $dataLvl = it.dataLevel = 0,\n      $data = 'data';\n    it.rootId = it.resolve.fullPath(it.self._getId(it.root.schema));\n    it.baseId = it.baseId || it.rootId;\n    delete it.isTop;\n    it.dataPathArr = [\"\"];\n    if (it.schema.default !== undefined && it.opts.useDefaults && it.opts.strictDefaults) {\n      var $defaultMsg = 'default is ignored in the schema root';\n      if (it.opts.strictDefaults === 'log') it.logger.warn($defaultMsg);\n      else throw new Error($defaultMsg);\n    }\n    out += ' var vErrors = null; ';\n    out += ' var errors = 0;     ';\n    out += ' if (rootData === undefined) rootData = data; ';\n  } else {\n    var $lvl = it.level,\n      $dataLvl = it.dataLevel,\n      $data = 'data' + ($dataLvl || '');\n    if ($id) it.baseId = it.resolve.url(it.baseId, $id);\n    if ($async && !it.async) throw new Error('async schema in sync schema');\n    out += ' var errs_' + ($lvl) + ' = errors;';\n  }\n  var $valid = 'valid' + $lvl,\n    $breakOnError = !it.opts.allErrors,\n    $closingBraces1 = '',\n    $closingBraces2 = '';\n  var $errorKeyword;\n  var $typeSchema = it.schema.type,\n    $typeIsArray = Array.isArray($typeSchema);\n  if ($typeSchema && it.opts.nullable && it.schema.nullable === true) {\n    if ($typeIsArray) {\n      if ($typeSchema.indexOf('null') == -1) $typeSchema = $typeSchema.concat('null');\n    } else if ($typeSchema != 'null') {\n      $typeSchema = [$typeSchema, 'null'];\n      $typeIsArray = true;\n    }\n  }\n  if ($typeIsArray && $typeSchema.length == 1) {\n    $typeSchema = $typeSchema[0];\n    $typeIsArray = false;\n  }\n  if (it.schema.$ref && $refKeywords) {\n    if (it.opts.extendRefs == 'fail') {\n      throw new Error('$ref: validation keywords used in schema at path \"' + it.errSchemaPath + '\" (see option extendRefs)');\n    } else if (it.opts.extendRefs !== true) {\n      $refKeywords = false;\n      it.logger.warn('$ref: keywords ignored in schema at path \"' + it.errSchemaPath + '\"');\n    }\n  }\n  if (it.schema.$comment && it.opts.$comment) {\n    out += ' ' + (it.RULES.all.$comment.code(it, '$comment'));\n  }\n  if ($typeSchema) {\n    if (it.opts.coerceTypes) {\n      var $coerceToTypes = it.util.coerceToTypes(it.opts.coerceTypes, $typeSchema);\n    }\n    var $rulesGroup = it.RULES.types[$typeSchema];\n    if ($coerceToTypes || $typeIsArray || $rulesGroup === true || ($rulesGroup && !$shouldUseGroup($rulesGroup))) {\n      var $schemaPath = it.schemaPath + '.type',\n        $errSchemaPath = it.errSchemaPath + '/type';\n      var $schemaPath = it.schemaPath + '.type',\n        $errSchemaPath = it.errSchemaPath + '/type',\n        $method = $typeIsArray ? 'checkDataTypes' : 'checkDataType';\n      out += ' if (' + (it.util[$method]($typeSchema, $data, it.opts.strictNumbers, true)) + ') { ';\n      if ($coerceToTypes) {\n        var $dataType = 'dataType' + $lvl,\n          $coerced = 'coerced' + $lvl;\n        out += ' var ' + ($dataType) + ' = typeof ' + ($data) + '; var ' + ($coerced) + ' = undefined; ';\n        if (it.opts.coerceTypes == 'array') {\n          out += ' if (' + ($dataType) + ' == \\'object\\' && Array.isArray(' + ($data) + ') && ' + ($data) + '.length == 1) { ' + ($data) + ' = ' + ($data) + '[0]; ' + ($dataType) + ' = typeof ' + ($data) + '; if (' + (it.util.checkDataType(it.schema.type, $data, it.opts.strictNumbers)) + ') ' + ($coerced) + ' = ' + ($data) + '; } ';\n        }\n        out += ' if (' + ($coerced) + ' !== undefined) ; ';\n        var arr1 = $coerceToTypes;\n        if (arr1) {\n          var $type, $i = -1,\n            l1 = arr1.length - 1;\n          while ($i < l1) {\n            $type = arr1[$i += 1];\n            if ($type == 'string') {\n              out += ' else if (' + ($dataType) + ' == \\'number\\' || ' + ($dataType) + ' == \\'boolean\\') ' + ($coerced) + ' = \\'\\' + ' + ($data) + '; else if (' + ($data) + ' === null) ' + ($coerced) + ' = \\'\\'; ';\n            } else if ($type == 'number' || $type == 'integer') {\n              out += ' else if (' + ($dataType) + ' == \\'boolean\\' || ' + ($data) + ' === null || (' + ($dataType) + ' == \\'string\\' && ' + ($data) + ' && ' + ($data) + ' == +' + ($data) + ' ';\n              if ($type == 'integer') {\n                out += ' && !(' + ($data) + ' % 1)';\n              }\n              out += ')) ' + ($coerced) + ' = +' + ($data) + '; ';\n            } else if ($type == 'boolean') {\n              out += ' else if (' + ($data) + ' === \\'false\\' || ' + ($data) + ' === 0 || ' + ($data) + ' === null) ' + ($coerced) + ' = false; else if (' + ($data) + ' === \\'true\\' || ' + ($data) + ' === 1) ' + ($coerced) + ' = true; ';\n            } else if ($type == 'null') {\n              out += ' else if (' + ($data) + ' === \\'\\' || ' + ($data) + ' === 0 || ' + ($data) + ' === false) ' + ($coerced) + ' = null; ';\n            } else if (it.opts.coerceTypes == 'array' && $type == 'array') {\n              out += ' else if (' + ($dataType) + ' == \\'string\\' || ' + ($dataType) + ' == \\'number\\' || ' + ($dataType) + ' == \\'boolean\\' || ' + ($data) + ' == null) ' + ($coerced) + ' = [' + ($data) + ']; ';\n            }\n          }\n        }\n        out += ' else {   ';\n        var $$outStack = $$outStack || [];\n        $$outStack.push(out);\n        out = ''; /* istanbul ignore else */\n        if (it.createErrors !== false) {\n          out += ' { keyword: \\'' + ($errorKeyword || 'type') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { type: \\'';\n          if ($typeIsArray) {\n            out += '' + ($typeSchema.join(\",\"));\n          } else {\n            out += '' + ($typeSchema);\n          }\n          out += '\\' } ';\n          if (it.opts.messages !== false) {\n            out += ' , message: \\'should be ';\n            if ($typeIsArray) {\n              out += '' + ($typeSchema.join(\",\"));\n            } else {\n              out += '' + ($typeSchema);\n            }\n            out += '\\' ';\n          }\n          if (it.opts.verbose) {\n            out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n          }\n          out += ' } ';\n        } else {\n          out += ' {} ';\n        }\n        var __err = out;\n        out = $$outStack.pop();\n        if (!it.compositeRule && $breakOnError) {\n          /* istanbul ignore if */\n          if (it.async) {\n            out += ' throw new ValidationError([' + (__err) + ']); ';\n          } else {\n            out += ' validate.errors = [' + (__err) + ']; return false; ';\n          }\n        } else {\n          out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n        }\n        out += ' } if (' + ($coerced) + ' !== undefined) {  ';\n        var $parentData = $dataLvl ? 'data' + (($dataLvl - 1) || '') : 'parentData',\n          $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : 'parentDataProperty';\n        out += ' ' + ($data) + ' = ' + ($coerced) + '; ';\n        if (!$dataLvl) {\n          out += 'if (' + ($parentData) + ' !== undefined)';\n        }\n        out += ' ' + ($parentData) + '[' + ($parentDataProperty) + '] = ' + ($coerced) + '; } ';\n      } else {\n        var $$outStack = $$outStack || [];\n        $$outStack.push(out);\n        out = ''; /* istanbul ignore else */\n        if (it.createErrors !== false) {\n          out += ' { keyword: \\'' + ($errorKeyword || 'type') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { type: \\'';\n          if ($typeIsArray) {\n            out += '' + ($typeSchema.join(\",\"));\n          } else {\n            out += '' + ($typeSchema);\n          }\n          out += '\\' } ';\n          if (it.opts.messages !== false) {\n            out += ' , message: \\'should be ';\n            if ($typeIsArray) {\n              out += '' + ($typeSchema.join(\",\"));\n            } else {\n              out += '' + ($typeSchema);\n            }\n            out += '\\' ';\n          }\n          if (it.opts.verbose) {\n            out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n          }\n          out += ' } ';\n        } else {\n          out += ' {} ';\n        }\n        var __err = out;\n        out = $$outStack.pop();\n        if (!it.compositeRule && $breakOnError) {\n          /* istanbul ignore if */\n          if (it.async) {\n            out += ' throw new ValidationError([' + (__err) + ']); ';\n          } else {\n            out += ' validate.errors = [' + (__err) + ']; return false; ';\n          }\n        } else {\n          out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n        }\n      }\n      out += ' } ';\n    }\n  }\n  if (it.schema.$ref && !$refKeywords) {\n    out += ' ' + (it.RULES.all.$ref.code(it, '$ref')) + ' ';\n    if ($breakOnError) {\n      out += ' } if (errors === ';\n      if ($top) {\n        out += '0';\n      } else {\n        out += 'errs_' + ($lvl);\n      }\n      out += ') { ';\n      $closingBraces2 += '}';\n    }\n  } else {\n    var arr2 = it.RULES;\n    if (arr2) {\n      var $rulesGroup, i2 = -1,\n        l2 = arr2.length - 1;\n      while (i2 < l2) {\n        $rulesGroup = arr2[i2 += 1];\n        if ($shouldUseGroup($rulesGroup)) {\n          if ($rulesGroup.type) {\n            out += ' if (' + (it.util.checkDataType($rulesGroup.type, $data, it.opts.strictNumbers)) + ') { ';\n          }\n          if (it.opts.useDefaults) {\n            if ($rulesGroup.type == 'object' && it.schema.properties) {\n              var $schema = it.schema.properties,\n                $schemaKeys = Object.keys($schema);\n              var arr3 = $schemaKeys;\n              if (arr3) {\n                var $propertyKey, i3 = -1,\n                  l3 = arr3.length - 1;\n                while (i3 < l3) {\n                  $propertyKey = arr3[i3 += 1];\n                  var $sch = $schema[$propertyKey];\n                  if ($sch.default !== undefined) {\n                    var $passData = $data + it.util.getProperty($propertyKey);\n                    if (it.compositeRule) {\n                      if (it.opts.strictDefaults) {\n                        var $defaultMsg = 'default is ignored for: ' + $passData;\n                        if (it.opts.strictDefaults === 'log') it.logger.warn($defaultMsg);\n                        else throw new Error($defaultMsg);\n                      }\n                    } else {\n                      out += ' if (' + ($passData) + ' === undefined ';\n                      if (it.opts.useDefaults == 'empty') {\n                        out += ' || ' + ($passData) + ' === null || ' + ($passData) + ' === \\'\\' ';\n                      }\n                      out += ' ) ' + ($passData) + ' = ';\n                      if (it.opts.useDefaults == 'shared') {\n                        out += ' ' + (it.useDefault($sch.default)) + ' ';\n                      } else {\n                        out += ' ' + (JSON.stringify($sch.default)) + ' ';\n                      }\n                      out += '; ';\n                    }\n                  }\n                }\n              }\n            } else if ($rulesGroup.type == 'array' && Array.isArray(it.schema.items)) {\n              var arr4 = it.schema.items;\n              if (arr4) {\n                var $sch, $i = -1,\n                  l4 = arr4.length - 1;\n                while ($i < l4) {\n                  $sch = arr4[$i += 1];\n                  if ($sch.default !== undefined) {\n                    var $passData = $data + '[' + $i + ']';\n                    if (it.compositeRule) {\n                      if (it.opts.strictDefaults) {\n                        var $defaultMsg = 'default is ignored for: ' + $passData;\n                        if (it.opts.strictDefaults === 'log') it.logger.warn($defaultMsg);\n                        else throw new Error($defaultMsg);\n                      }\n                    } else {\n                      out += ' if (' + ($passData) + ' === undefined ';\n                      if (it.opts.useDefaults == 'empty') {\n                        out += ' || ' + ($passData) + ' === null || ' + ($passData) + ' === \\'\\' ';\n                      }\n                      out += ' ) ' + ($passData) + ' = ';\n                      if (it.opts.useDefaults == 'shared') {\n                        out += ' ' + (it.useDefault($sch.default)) + ' ';\n                      } else {\n                        out += ' ' + (JSON.stringify($sch.default)) + ' ';\n                      }\n                      out += '; ';\n                    }\n                  }\n                }\n              }\n            }\n          }\n          var arr5 = $rulesGroup.rules;\n          if (arr5) {\n            var $rule, i5 = -1,\n              l5 = arr5.length - 1;\n            while (i5 < l5) {\n              $rule = arr5[i5 += 1];\n              if ($shouldUseRule($rule)) {\n                var $code = $rule.code(it, $rule.keyword, $rulesGroup.type);\n                if ($code) {\n                  out += ' ' + ($code) + ' ';\n                  if ($breakOnError) {\n                    $closingBraces1 += '}';\n                  }\n                }\n              }\n            }\n          }\n          if ($breakOnError) {\n            out += ' ' + ($closingBraces1) + ' ';\n            $closingBraces1 = '';\n          }\n          if ($rulesGroup.type) {\n            out += ' } ';\n            if ($typeSchema && $typeSchema === $rulesGroup.type && !$coerceToTypes) {\n              out += ' else { ';\n              var $schemaPath = it.schemaPath + '.type',\n                $errSchemaPath = it.errSchemaPath + '/type';\n              var $$outStack = $$outStack || [];\n              $$outStack.push(out);\n              out = ''; /* istanbul ignore else */\n              if (it.createErrors !== false) {\n                out += ' { keyword: \\'' + ($errorKeyword || 'type') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { type: \\'';\n                if ($typeIsArray) {\n                  out += '' + ($typeSchema.join(\",\"));\n                } else {\n                  out += '' + ($typeSchema);\n                }\n                out += '\\' } ';\n                if (it.opts.messages !== false) {\n                  out += ' , message: \\'should be ';\n                  if ($typeIsArray) {\n                    out += '' + ($typeSchema.join(\",\"));\n                  } else {\n                    out += '' + ($typeSchema);\n                  }\n                  out += '\\' ';\n                }\n                if (it.opts.verbose) {\n                  out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n                }\n                out += ' } ';\n              } else {\n                out += ' {} ';\n              }\n              var __err = out;\n              out = $$outStack.pop();\n              if (!it.compositeRule && $breakOnError) {\n                /* istanbul ignore if */\n                if (it.async) {\n                  out += ' throw new ValidationError([' + (__err) + ']); ';\n                } else {\n                  out += ' validate.errors = [' + (__err) + ']; return false; ';\n                }\n              } else {\n                out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n              }\n              out += ' } ';\n            }\n          }\n          if ($breakOnError) {\n            out += ' if (errors === ';\n            if ($top) {\n              out += '0';\n            } else {\n              out += 'errs_' + ($lvl);\n            }\n            out += ') { ';\n            $closingBraces2 += '}';\n          }\n        }\n      }\n    }\n  }\n  if ($breakOnError) {\n    out += ' ' + ($closingBraces2) + ' ';\n  }\n  if ($top) {\n    if ($async) {\n      out += ' if (errors === 0) return data;           ';\n      out += ' else throw new ValidationError(vErrors); ';\n    } else {\n      out += ' validate.errors = vErrors; ';\n      out += ' return errors === 0;       ';\n    }\n    out += ' }; return validate;';\n  } else {\n    out += ' var ' + ($valid) + ' = errors === errs_' + ($lvl) + ';';\n  }\n\n  function $shouldUseGroup($rulesGroup) {\n    var rules = $rulesGroup.rules;\n    for (var i = 0; i < rules.length; i++)\n      if ($shouldUseRule(rules[i])) return true;\n  }\n\n  function $shouldUseRule($rule) {\n    return it.schema[$rule.keyword] !== undefined || ($rule.implements && $ruleImplementsSomeKeyword($rule));\n  }\n\n  function $ruleImplementsSomeKeyword($rule) {\n    var impl = $rule.implements;\n    for (var i = 0; i < impl.length; i++)\n      if (it.schema[impl[i]] !== undefined) return true;\n  }\n  return out;\n}\n\n\n//# sourceURL=webpack://javascript/./node_modules/ajv/lib/dotjs/validate.js?");

/***/ }),

/***/ "./node_modules/ajv/lib/keyword.js":
/*!*****************************************!*\
  !*** ./node_modules/ajv/lib/keyword.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar IDENTIFIER = /^[a-z_$][a-z0-9_$-]*$/i;\nvar customRuleCode = __webpack_require__(/*! ./dotjs/custom */ \"./node_modules/ajv/lib/dotjs/custom.js\");\nvar definitionSchema = __webpack_require__(/*! ./definition_schema */ \"./node_modules/ajv/lib/definition_schema.js\");\n\nmodule.exports = {\n  add: addKeyword,\n  get: getKeyword,\n  remove: removeKeyword,\n  validate: validateKeyword\n};\n\n\n/**\n * Define custom keyword\n * @this  Ajv\n * @param {String} keyword custom keyword, should be unique (including different from all standard, custom and macro keywords).\n * @param {Object} definition keyword definition object with properties `type` (type(s) which the keyword applies to), `validate` or `compile`.\n * @return {Ajv} this for method chaining\n */\nfunction addKeyword(keyword, definition) {\n  /* jshint validthis: true */\n  /* eslint no-shadow: 0 */\n  var RULES = this.RULES;\n  if (RULES.keywords[keyword])\n    throw new Error('Keyword ' + keyword + ' is already defined');\n\n  if (!IDENTIFIER.test(keyword))\n    throw new Error('Keyword ' + keyword + ' is not a valid identifier');\n\n  if (definition) {\n    this.validateKeyword(definition, true);\n\n    var dataType = definition.type;\n    if (Array.isArray(dataType)) {\n      for (var i=0; i<dataType.length; i++)\n        _addRule(keyword, dataType[i], definition);\n    } else {\n      _addRule(keyword, dataType, definition);\n    }\n\n    var metaSchema = definition.metaSchema;\n    if (metaSchema) {\n      if (definition.$data && this._opts.$data) {\n        metaSchema = {\n          anyOf: [\n            metaSchema,\n            { '$ref': 'https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#' }\n          ]\n        };\n      }\n      definition.validateSchema = this.compile(metaSchema, true);\n    }\n  }\n\n  RULES.keywords[keyword] = RULES.all[keyword] = true;\n\n\n  function _addRule(keyword, dataType, definition) {\n    var ruleGroup;\n    for (var i=0; i<RULES.length; i++) {\n      var rg = RULES[i];\n      if (rg.type == dataType) {\n        ruleGroup = rg;\n        break;\n      }\n    }\n\n    if (!ruleGroup) {\n      ruleGroup = { type: dataType, rules: [] };\n      RULES.push(ruleGroup);\n    }\n\n    var rule = {\n      keyword: keyword,\n      definition: definition,\n      custom: true,\n      code: customRuleCode,\n      implements: definition.implements\n    };\n    ruleGroup.rules.push(rule);\n    RULES.custom[keyword] = rule;\n  }\n\n  return this;\n}\n\n\n/**\n * Get keyword\n * @this  Ajv\n * @param {String} keyword pre-defined or custom keyword.\n * @return {Object|Boolean} custom keyword definition, `true` if it is a predefined keyword, `false` otherwise.\n */\nfunction getKeyword(keyword) {\n  /* jshint validthis: true */\n  var rule = this.RULES.custom[keyword];\n  return rule ? rule.definition : this.RULES.keywords[keyword] || false;\n}\n\n\n/**\n * Remove keyword\n * @this  Ajv\n * @param {String} keyword pre-defined or custom keyword.\n * @return {Ajv} this for method chaining\n */\nfunction removeKeyword(keyword) {\n  /* jshint validthis: true */\n  var RULES = this.RULES;\n  delete RULES.keywords[keyword];\n  delete RULES.all[keyword];\n  delete RULES.custom[keyword];\n  for (var i=0; i<RULES.length; i++) {\n    var rules = RULES[i].rules;\n    for (var j=0; j<rules.length; j++) {\n      if (rules[j].keyword == keyword) {\n        rules.splice(j, 1);\n        break;\n      }\n    }\n  }\n  return this;\n}\n\n\n/**\n * Validate keyword definition\n * @this  Ajv\n * @param {Object} definition keyword definition object.\n * @param {Boolean} throwError true to throw exception if definition is invalid\n * @return {boolean} validation result\n */\nfunction validateKeyword(definition, throwError) {\n  validateKeyword.errors = null;\n  var v = this._validateKeyword = this._validateKeyword\n                                  || this.compile(definitionSchema, true);\n\n  if (v(definition)) return true;\n  validateKeyword.errors = v.errors;\n  if (throwError)\n    throw new Error('custom keyword definition is invalid: '  + this.errorsText(v.errors));\n  else\n    return false;\n}\n\n\n//# sourceURL=webpack://javascript/./node_modules/ajv/lib/keyword.js?");

/***/ }),

/***/ "./node_modules/assert/build/assert.js":
/*!*********************************************!*\
  !*** ./node_modules/assert/build/assert.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* provided dependency */ var process = __webpack_require__(/*! ./node_modules/process/browser.js */ \"./node_modules/process/browser.js\");\n/* provided dependency */ var console = __webpack_require__(/*! ./node_modules/console-browserify/index.js */ \"./node_modules/console-browserify/index.js\");\n// Currently in sync with Node.js lib/assert.js\n// https://github.com/nodejs/node/commit/2a51ae424a513ec9a6aa3466baa0cc1d55dd4f3b\n// Originally from narwhal.js (http://narwhaljs.org)\n// Copyright (c) 2009 Thomas Robinson <280north.com>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the 'Software'), to\n// deal in the Software without restriction, including without limitation the\n// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n// sell copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar _require = __webpack_require__(/*! ./internal/errors */ \"./node_modules/assert/build/internal/errors.js\"),\n    _require$codes = _require.codes,\n    ERR_AMBIGUOUS_ARGUMENT = _require$codes.ERR_AMBIGUOUS_ARGUMENT,\n    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,\n    ERR_INVALID_ARG_VALUE = _require$codes.ERR_INVALID_ARG_VALUE,\n    ERR_INVALID_RETURN_VALUE = _require$codes.ERR_INVALID_RETURN_VALUE,\n    ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;\n\nvar AssertionError = __webpack_require__(/*! ./internal/assert/assertion_error */ \"./node_modules/assert/build/internal/assert/assertion_error.js\");\n\nvar _require2 = __webpack_require__(/*! util/ */ \"./node_modules/util/util.js\"),\n    inspect = _require2.inspect;\n\nvar _require$types = (__webpack_require__(/*! util/ */ \"./node_modules/util/util.js\").types),\n    isPromise = _require$types.isPromise,\n    isRegExp = _require$types.isRegExp;\n\nvar objectAssign = Object.assign ? Object.assign : (__webpack_require__(/*! es6-object-assign */ \"./node_modules/es6-object-assign/index.js\").assign);\nvar objectIs = Object.is ? Object.is : __webpack_require__(/*! object-is */ \"./node_modules/object-is/index.js\");\nvar errorCache = new Map();\nvar isDeepEqual;\nvar isDeepStrictEqual;\nvar parseExpressionAt;\nvar findNodeAround;\nvar decoder;\n\nfunction lazyLoadComparison() {\n  var comparison = __webpack_require__(/*! ./internal/util/comparisons */ \"./node_modules/assert/build/internal/util/comparisons.js\");\n\n  isDeepEqual = comparison.isDeepEqual;\n  isDeepStrictEqual = comparison.isDeepStrictEqual;\n} // Escape control characters but not \\n and \\t to keep the line breaks and\n// indentation intact.\n// eslint-disable-next-line no-control-regex\n\n\nvar escapeSequencesRegExp = /[\\x00-\\x08\\x0b\\x0c\\x0e-\\x1f]/g;\nvar meta = [\"\\\\u0000\", \"\\\\u0001\", \"\\\\u0002\", \"\\\\u0003\", \"\\\\u0004\", \"\\\\u0005\", \"\\\\u0006\", \"\\\\u0007\", '\\\\b', '', '', \"\\\\u000b\", '\\\\f', '', \"\\\\u000e\", \"\\\\u000f\", \"\\\\u0010\", \"\\\\u0011\", \"\\\\u0012\", \"\\\\u0013\", \"\\\\u0014\", \"\\\\u0015\", \"\\\\u0016\", \"\\\\u0017\", \"\\\\u0018\", \"\\\\u0019\", \"\\\\u001a\", \"\\\\u001b\", \"\\\\u001c\", \"\\\\u001d\", \"\\\\u001e\", \"\\\\u001f\"];\n\nvar escapeFn = function escapeFn(str) {\n  return meta[str.charCodeAt(0)];\n};\n\nvar warned = false; // The assert module provides functions that throw\n// AssertionError's when particular conditions are not met. The\n// assert module must conform to the following interface.\n\nvar assert = module.exports = ok;\nvar NO_EXCEPTION_SENTINEL = {}; // All of the following functions must throw an AssertionError\n// when a corresponding condition is not met, with a message that\n// may be undefined if not provided. All assertion methods provide\n// both the actual and expected values to the assertion error for\n// display purposes.\n\nfunction innerFail(obj) {\n  if (obj.message instanceof Error) throw obj.message;\n  throw new AssertionError(obj);\n}\n\nfunction fail(actual, expected, message, operator, stackStartFn) {\n  var argsLen = arguments.length;\n  var internalMessage;\n\n  if (argsLen === 0) {\n    internalMessage = 'Failed';\n  } else if (argsLen === 1) {\n    message = actual;\n    actual = undefined;\n  } else {\n    if (warned === false) {\n      warned = true;\n      var warn = process.emitWarning ? process.emitWarning : console.warn.bind(console);\n      warn('assert.fail() with more than one argument is deprecated. ' + 'Please use assert.strictEqual() instead or only pass a message.', 'DeprecationWarning', 'DEP0094');\n    }\n\n    if (argsLen === 2) operator = '!=';\n  }\n\n  if (message instanceof Error) throw message;\n  var errArgs = {\n    actual: actual,\n    expected: expected,\n    operator: operator === undefined ? 'fail' : operator,\n    stackStartFn: stackStartFn || fail\n  };\n\n  if (message !== undefined) {\n    errArgs.message = message;\n  }\n\n  var err = new AssertionError(errArgs);\n\n  if (internalMessage) {\n    err.message = internalMessage;\n    err.generatedMessage = true;\n  }\n\n  throw err;\n}\n\nassert.fail = fail; // The AssertionError is defined in internal/error.\n\nassert.AssertionError = AssertionError;\n\nfunction innerOk(fn, argLen, value, message) {\n  if (!value) {\n    var generatedMessage = false;\n\n    if (argLen === 0) {\n      generatedMessage = true;\n      message = 'No value argument passed to `assert.ok()`';\n    } else if (message instanceof Error) {\n      throw message;\n    }\n\n    var err = new AssertionError({\n      actual: value,\n      expected: true,\n      message: message,\n      operator: '==',\n      stackStartFn: fn\n    });\n    err.generatedMessage = generatedMessage;\n    throw err;\n  }\n} // Pure assertion tests whether a value is truthy, as determined\n// by !!value.\n\n\nfunction ok() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  innerOk.apply(void 0, [ok, args.length].concat(args));\n}\n\nassert.ok = ok; // The equality assertion tests shallow, coercive equality with ==.\n\n/* eslint-disable no-restricted-properties */\n\nassert.equal = function equal(actual, expected, message) {\n  if (arguments.length < 2) {\n    throw new ERR_MISSING_ARGS('actual', 'expected');\n  } // eslint-disable-next-line eqeqeq\n\n\n  if (actual != expected) {\n    innerFail({\n      actual: actual,\n      expected: expected,\n      message: message,\n      operator: '==',\n      stackStartFn: equal\n    });\n  }\n}; // The non-equality assertion tests for whether two objects are not\n// equal with !=.\n\n\nassert.notEqual = function notEqual(actual, expected, message) {\n  if (arguments.length < 2) {\n    throw new ERR_MISSING_ARGS('actual', 'expected');\n  } // eslint-disable-next-line eqeqeq\n\n\n  if (actual == expected) {\n    innerFail({\n      actual: actual,\n      expected: expected,\n      message: message,\n      operator: '!=',\n      stackStartFn: notEqual\n    });\n  }\n}; // The equivalence assertion tests a deep equality relation.\n\n\nassert.deepEqual = function deepEqual(actual, expected, message) {\n  if (arguments.length < 2) {\n    throw new ERR_MISSING_ARGS('actual', 'expected');\n  }\n\n  if (isDeepEqual === undefined) lazyLoadComparison();\n\n  if (!isDeepEqual(actual, expected)) {\n    innerFail({\n      actual: actual,\n      expected: expected,\n      message: message,\n      operator: 'deepEqual',\n      stackStartFn: deepEqual\n    });\n  }\n}; // The non-equivalence assertion tests for any deep inequality.\n\n\nassert.notDeepEqual = function notDeepEqual(actual, expected, message) {\n  if (arguments.length < 2) {\n    throw new ERR_MISSING_ARGS('actual', 'expected');\n  }\n\n  if (isDeepEqual === undefined) lazyLoadComparison();\n\n  if (isDeepEqual(actual, expected)) {\n    innerFail({\n      actual: actual,\n      expected: expected,\n      message: message,\n      operator: 'notDeepEqual',\n      stackStartFn: notDeepEqual\n    });\n  }\n};\n/* eslint-enable */\n\n\nassert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {\n  if (arguments.length < 2) {\n    throw new ERR_MISSING_ARGS('actual', 'expected');\n  }\n\n  if (isDeepEqual === undefined) lazyLoadComparison();\n\n  if (!isDeepStrictEqual(actual, expected)) {\n    innerFail({\n      actual: actual,\n      expected: expected,\n      message: message,\n      operator: 'deepStrictEqual',\n      stackStartFn: deepStrictEqual\n    });\n  }\n};\n\nassert.notDeepStrictEqual = notDeepStrictEqual;\n\nfunction notDeepStrictEqual(actual, expected, message) {\n  if (arguments.length < 2) {\n    throw new ERR_MISSING_ARGS('actual', 'expected');\n  }\n\n  if (isDeepEqual === undefined) lazyLoadComparison();\n\n  if (isDeepStrictEqual(actual, expected)) {\n    innerFail({\n      actual: actual,\n      expected: expected,\n      message: message,\n      operator: 'notDeepStrictEqual',\n      stackStartFn: notDeepStrictEqual\n    });\n  }\n}\n\nassert.strictEqual = function strictEqual(actual, expected, message) {\n  if (arguments.length < 2) {\n    throw new ERR_MISSING_ARGS('actual', 'expected');\n  }\n\n  if (!objectIs(actual, expected)) {\n    innerFail({\n      actual: actual,\n      expected: expected,\n      message: message,\n      operator: 'strictEqual',\n      stackStartFn: strictEqual\n    });\n  }\n};\n\nassert.notStrictEqual = function notStrictEqual(actual, expected, message) {\n  if (arguments.length < 2) {\n    throw new ERR_MISSING_ARGS('actual', 'expected');\n  }\n\n  if (objectIs(actual, expected)) {\n    innerFail({\n      actual: actual,\n      expected: expected,\n      message: message,\n      operator: 'notStrictEqual',\n      stackStartFn: notStrictEqual\n    });\n  }\n};\n\nvar Comparison = function Comparison(obj, keys, actual) {\n  var _this = this;\n\n  _classCallCheck(this, Comparison);\n\n  keys.forEach(function (key) {\n    if (key in obj) {\n      if (actual !== undefined && typeof actual[key] === 'string' && isRegExp(obj[key]) && obj[key].test(actual[key])) {\n        _this[key] = actual[key];\n      } else {\n        _this[key] = obj[key];\n      }\n    }\n  });\n};\n\nfunction compareExceptionKey(actual, expected, key, message, keys, fn) {\n  if (!(key in actual) || !isDeepStrictEqual(actual[key], expected[key])) {\n    if (!message) {\n      // Create placeholder objects to create a nice output.\n      var a = new Comparison(actual, keys);\n      var b = new Comparison(expected, keys, actual);\n      var err = new AssertionError({\n        actual: a,\n        expected: b,\n        operator: 'deepStrictEqual',\n        stackStartFn: fn\n      });\n      err.actual = actual;\n      err.expected = expected;\n      err.operator = fn.name;\n      throw err;\n    }\n\n    innerFail({\n      actual: actual,\n      expected: expected,\n      message: message,\n      operator: fn.name,\n      stackStartFn: fn\n    });\n  }\n}\n\nfunction expectedException(actual, expected, msg, fn) {\n  if (typeof expected !== 'function') {\n    if (isRegExp(expected)) return expected.test(actual); // assert.doesNotThrow does not accept objects.\n\n    if (arguments.length === 2) {\n      throw new ERR_INVALID_ARG_TYPE('expected', ['Function', 'RegExp'], expected);\n    } // Handle primitives properly.\n\n\n    if (_typeof(actual) !== 'object' || actual === null) {\n      var err = new AssertionError({\n        actual: actual,\n        expected: expected,\n        message: msg,\n        operator: 'deepStrictEqual',\n        stackStartFn: fn\n      });\n      err.operator = fn.name;\n      throw err;\n    }\n\n    var keys = Object.keys(expected); // Special handle errors to make sure the name and the message are compared\n    // as well.\n\n    if (expected instanceof Error) {\n      keys.push('name', 'message');\n    } else if (keys.length === 0) {\n      throw new ERR_INVALID_ARG_VALUE('error', expected, 'may not be an empty object');\n    }\n\n    if (isDeepEqual === undefined) lazyLoadComparison();\n    keys.forEach(function (key) {\n      if (typeof actual[key] === 'string' && isRegExp(expected[key]) && expected[key].test(actual[key])) {\n        return;\n      }\n\n      compareExceptionKey(actual, expected, key, msg, keys, fn);\n    });\n    return true;\n  } // Guard instanceof against arrow functions as they don't have a prototype.\n\n\n  if (expected.prototype !== undefined && actual instanceof expected) {\n    return true;\n  }\n\n  if (Error.isPrototypeOf(expected)) {\n    return false;\n  }\n\n  return expected.call({}, actual) === true;\n}\n\nfunction getActual(fn) {\n  if (typeof fn !== 'function') {\n    throw new ERR_INVALID_ARG_TYPE('fn', 'Function', fn);\n  }\n\n  try {\n    fn();\n  } catch (e) {\n    return e;\n  }\n\n  return NO_EXCEPTION_SENTINEL;\n}\n\nfunction checkIsPromise(obj) {\n  // Accept native ES6 promises and promises that are implemented in a similar\n  // way. Do not accept thenables that use a function as `obj` and that have no\n  // `catch` handler.\n  // TODO: thenables are checked up until they have the correct methods,\n  // but according to documentation, the `then` method should receive\n  // the `fulfill` and `reject` arguments as well or it may be never resolved.\n  return isPromise(obj) || obj !== null && _typeof(obj) === 'object' && typeof obj.then === 'function' && typeof obj.catch === 'function';\n}\n\nfunction waitForActual(promiseFn) {\n  return Promise.resolve().then(function () {\n    var resultPromise;\n\n    if (typeof promiseFn === 'function') {\n      // Return a rejected promise if `promiseFn` throws synchronously.\n      resultPromise = promiseFn(); // Fail in case no promise is returned.\n\n      if (!checkIsPromise(resultPromise)) {\n        throw new ERR_INVALID_RETURN_VALUE('instance of Promise', 'promiseFn', resultPromise);\n      }\n    } else if (checkIsPromise(promiseFn)) {\n      resultPromise = promiseFn;\n    } else {\n      throw new ERR_INVALID_ARG_TYPE('promiseFn', ['Function', 'Promise'], promiseFn);\n    }\n\n    return Promise.resolve().then(function () {\n      return resultPromise;\n    }).then(function () {\n      return NO_EXCEPTION_SENTINEL;\n    }).catch(function (e) {\n      return e;\n    });\n  });\n}\n\nfunction expectsError(stackStartFn, actual, error, message) {\n  if (typeof error === 'string') {\n    if (arguments.length === 4) {\n      throw new ERR_INVALID_ARG_TYPE('error', ['Object', 'Error', 'Function', 'RegExp'], error);\n    }\n\n    if (_typeof(actual) === 'object' && actual !== null) {\n      if (actual.message === error) {\n        throw new ERR_AMBIGUOUS_ARGUMENT('error/message', \"The error message \\\"\".concat(actual.message, \"\\\" is identical to the message.\"));\n      }\n    } else if (actual === error) {\n      throw new ERR_AMBIGUOUS_ARGUMENT('error/message', \"The error \\\"\".concat(actual, \"\\\" is identical to the message.\"));\n    }\n\n    message = error;\n    error = undefined;\n  } else if (error != null && _typeof(error) !== 'object' && typeof error !== 'function') {\n    throw new ERR_INVALID_ARG_TYPE('error', ['Object', 'Error', 'Function', 'RegExp'], error);\n  }\n\n  if (actual === NO_EXCEPTION_SENTINEL) {\n    var details = '';\n\n    if (error && error.name) {\n      details += \" (\".concat(error.name, \")\");\n    }\n\n    details += message ? \": \".concat(message) : '.';\n    var fnType = stackStartFn.name === 'rejects' ? 'rejection' : 'exception';\n    innerFail({\n      actual: undefined,\n      expected: error,\n      operator: stackStartFn.name,\n      message: \"Missing expected \".concat(fnType).concat(details),\n      stackStartFn: stackStartFn\n    });\n  }\n\n  if (error && !expectedException(actual, error, message, stackStartFn)) {\n    throw actual;\n  }\n}\n\nfunction expectsNoError(stackStartFn, actual, error, message) {\n  if (actual === NO_EXCEPTION_SENTINEL) return;\n\n  if (typeof error === 'string') {\n    message = error;\n    error = undefined;\n  }\n\n  if (!error || expectedException(actual, error)) {\n    var details = message ? \": \".concat(message) : '.';\n    var fnType = stackStartFn.name === 'doesNotReject' ? 'rejection' : 'exception';\n    innerFail({\n      actual: actual,\n      expected: error,\n      operator: stackStartFn.name,\n      message: \"Got unwanted \".concat(fnType).concat(details, \"\\n\") + \"Actual message: \\\"\".concat(actual && actual.message, \"\\\"\"),\n      stackStartFn: stackStartFn\n    });\n  }\n\n  throw actual;\n}\n\nassert.throws = function throws(promiseFn) {\n  for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n    args[_key2 - 1] = arguments[_key2];\n  }\n\n  expectsError.apply(void 0, [throws, getActual(promiseFn)].concat(args));\n};\n\nassert.rejects = function rejects(promiseFn) {\n  for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n    args[_key3 - 1] = arguments[_key3];\n  }\n\n  return waitForActual(promiseFn).then(function (result) {\n    return expectsError.apply(void 0, [rejects, result].concat(args));\n  });\n};\n\nassert.doesNotThrow = function doesNotThrow(fn) {\n  for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n    args[_key4 - 1] = arguments[_key4];\n  }\n\n  expectsNoError.apply(void 0, [doesNotThrow, getActual(fn)].concat(args));\n};\n\nassert.doesNotReject = function doesNotReject(fn) {\n  for (var _len5 = arguments.length, args = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {\n    args[_key5 - 1] = arguments[_key5];\n  }\n\n  return waitForActual(fn).then(function (result) {\n    return expectsNoError.apply(void 0, [doesNotReject, result].concat(args));\n  });\n};\n\nassert.ifError = function ifError(err) {\n  if (err !== null && err !== undefined) {\n    var message = 'ifError got unwanted exception: ';\n\n    if (_typeof(err) === 'object' && typeof err.message === 'string') {\n      if (err.message.length === 0 && err.constructor) {\n        message += err.constructor.name;\n      } else {\n        message += err.message;\n      }\n    } else {\n      message += inspect(err);\n    }\n\n    var newErr = new AssertionError({\n      actual: err,\n      expected: null,\n      operator: 'ifError',\n      message: message,\n      stackStartFn: ifError\n    }); // Make sure we actually have a stack trace!\n\n    var origStack = err.stack;\n\n    if (typeof origStack === 'string') {\n      // This will remove any duplicated frames from the error frames taken\n      // from within `ifError` and add the original error frames to the newly\n      // created ones.\n      var tmp2 = origStack.split('\\n');\n      tmp2.shift(); // Filter all frames existing in err.stack.\n\n      var tmp1 = newErr.stack.split('\\n');\n\n      for (var i = 0; i < tmp2.length; i++) {\n        // Find the first occurrence of the frame.\n        var pos = tmp1.indexOf(tmp2[i]);\n\n        if (pos !== -1) {\n          // Only keep new frames.\n          tmp1 = tmp1.slice(0, pos);\n          break;\n        }\n      }\n\n      newErr.stack = \"\".concat(tmp1.join('\\n'), \"\\n\").concat(tmp2.join('\\n'));\n    }\n\n    throw newErr;\n  }\n}; // Expose a strict only variant of assert\n\n\nfunction strict() {\n  for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n    args[_key6] = arguments[_key6];\n  }\n\n  innerOk.apply(void 0, [strict, args.length].concat(args));\n}\n\nassert.strict = objectAssign(strict, assert, {\n  equal: assert.strictEqual,\n  deepEqual: assert.deepStrictEqual,\n  notEqual: assert.notStrictEqual,\n  notDeepEqual: assert.notDeepStrictEqual\n});\nassert.strict.strict = assert.strict;\n\n//# sourceURL=webpack://javascript/./node_modules/assert/build/assert.js?");

/***/ }),

/***/ "./node_modules/assert/build/internal/assert/assertion_error.js":
/*!**********************************************************************!*\
  !*** ./node_modules/assert/build/internal/assert/assertion_error.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* provided dependency */ var process = __webpack_require__(/*! ./node_modules/process/browser.js */ \"./node_modules/process/browser.js\");\n// Currently in sync with Node.js lib/internal/assert/assertion_error.js\n// https://github.com/nodejs/node/commit/0817840f775032169ddd70c85ac059f18ffcc81c\n\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _wrapNativeSuper(Class) { var _cache = typeof Map === \"function\" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== \"function\") { throw new TypeError(\"Super expression must either be null or a function\"); } if (typeof _cache !== \"undefined\") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }\n\nfunction isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _construct(Parent, args, Class) { if (isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }\n\nfunction _isNativeFunction(fn) { return Function.toString.call(fn).indexOf(\"[native code]\") !== -1; }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nvar _require = __webpack_require__(/*! util/ */ \"./node_modules/util/util.js\"),\n    inspect = _require.inspect;\n\nvar _require2 = __webpack_require__(/*! ../errors */ \"./node_modules/assert/build/internal/errors.js\"),\n    ERR_INVALID_ARG_TYPE = _require2.codes.ERR_INVALID_ARG_TYPE; // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith\n\n\nfunction endsWith(str, search, this_len) {\n  if (this_len === undefined || this_len > str.length) {\n    this_len = str.length;\n  }\n\n  return str.substring(this_len - search.length, this_len) === search;\n} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/repeat\n\n\nfunction repeat(str, count) {\n  count = Math.floor(count);\n  if (str.length == 0 || count == 0) return '';\n  var maxCount = str.length * count;\n  count = Math.floor(Math.log(count) / Math.log(2));\n\n  while (count) {\n    str += str;\n    count--;\n  }\n\n  str += str.substring(0, maxCount - str.length);\n  return str;\n}\n\nvar blue = '';\nvar green = '';\nvar red = '';\nvar white = '';\nvar kReadableOperator = {\n  deepStrictEqual: 'Expected values to be strictly deep-equal:',\n  strictEqual: 'Expected values to be strictly equal:',\n  strictEqualObject: 'Expected \"actual\" to be reference-equal to \"expected\":',\n  deepEqual: 'Expected values to be loosely deep-equal:',\n  equal: 'Expected values to be loosely equal:',\n  notDeepStrictEqual: 'Expected \"actual\" not to be strictly deep-equal to:',\n  notStrictEqual: 'Expected \"actual\" to be strictly unequal to:',\n  notStrictEqualObject: 'Expected \"actual\" not to be reference-equal to \"expected\":',\n  notDeepEqual: 'Expected \"actual\" not to be loosely deep-equal to:',\n  notEqual: 'Expected \"actual\" to be loosely unequal to:',\n  notIdentical: 'Values identical but not reference-equal:'\n}; // Comparing short primitives should just show === / !== instead of using the\n// diff.\n\nvar kMaxShortLength = 10;\n\nfunction copyError(source) {\n  var keys = Object.keys(source);\n  var target = Object.create(Object.getPrototypeOf(source));\n  keys.forEach(function (key) {\n    target[key] = source[key];\n  });\n  Object.defineProperty(target, 'message', {\n    value: source.message\n  });\n  return target;\n}\n\nfunction inspectValue(val) {\n  // The util.inspect default values could be changed. This makes sure the\n  // error messages contain the necessary information nevertheless.\n  return inspect(val, {\n    compact: false,\n    customInspect: false,\n    depth: 1000,\n    maxArrayLength: Infinity,\n    // Assert compares only enumerable properties (with a few exceptions).\n    showHidden: false,\n    // Having a long line as error is better than wrapping the line for\n    // comparison for now.\n    // TODO(BridgeAR): `breakLength` should be limited as soon as soon as we\n    // have meta information about the inspected properties (i.e., know where\n    // in what line the property starts and ends).\n    breakLength: Infinity,\n    // Assert does not detect proxies currently.\n    showProxy: false,\n    sorted: true,\n    // Inspect getters as we also check them when comparing entries.\n    getters: true\n  });\n}\n\nfunction createErrDiff(actual, expected, operator) {\n  var other = '';\n  var res = '';\n  var lastPos = 0;\n  var end = '';\n  var skipped = false;\n  var actualInspected = inspectValue(actual);\n  var actualLines = actualInspected.split('\\n');\n  var expectedLines = inspectValue(expected).split('\\n');\n  var i = 0;\n  var indicator = ''; // In case both values are objects explicitly mark them as not reference equal\n  // for the `strictEqual` operator.\n\n  if (operator === 'strictEqual' && _typeof(actual) === 'object' && _typeof(expected) === 'object' && actual !== null && expected !== null) {\n    operator = 'strictEqualObject';\n  } // If \"actual\" and \"expected\" fit on a single line and they are not strictly\n  // equal, check further special handling.\n\n\n  if (actualLines.length === 1 && expectedLines.length === 1 && actualLines[0] !== expectedLines[0]) {\n    var inputLength = actualLines[0].length + expectedLines[0].length; // If the character length of \"actual\" and \"expected\" together is less than\n    // kMaxShortLength and if neither is an object and at least one of them is\n    // not `zero`, use the strict equal comparison to visualize the output.\n\n    if (inputLength <= kMaxShortLength) {\n      if ((_typeof(actual) !== 'object' || actual === null) && (_typeof(expected) !== 'object' || expected === null) && (actual !== 0 || expected !== 0)) {\n        // -0 === +0\n        return \"\".concat(kReadableOperator[operator], \"\\n\\n\") + \"\".concat(actualLines[0], \" !== \").concat(expectedLines[0], \"\\n\");\n      }\n    } else if (operator !== 'strictEqualObject') {\n      // If the stderr is a tty and the input length is lower than the current\n      // columns per line, add a mismatch indicator below the output. If it is\n      // not a tty, use a default value of 80 characters.\n      var maxLength = process.stderr && process.stderr.isTTY ? process.stderr.columns : 80;\n\n      if (inputLength < maxLength) {\n        while (actualLines[0][i] === expectedLines[0][i]) {\n          i++;\n        } // Ignore the first characters.\n\n\n        if (i > 2) {\n          // Add position indicator for the first mismatch in case it is a\n          // single line and the input length is less than the column length.\n          indicator = \"\\n  \".concat(repeat(' ', i), \"^\");\n          i = 0;\n        }\n      }\n    }\n  } // Remove all ending lines that match (this optimizes the output for\n  // readability by reducing the number of total changed lines).\n\n\n  var a = actualLines[actualLines.length - 1];\n  var b = expectedLines[expectedLines.length - 1];\n\n  while (a === b) {\n    if (i++ < 2) {\n      end = \"\\n  \".concat(a).concat(end);\n    } else {\n      other = a;\n    }\n\n    actualLines.pop();\n    expectedLines.pop();\n    if (actualLines.length === 0 || expectedLines.length === 0) break;\n    a = actualLines[actualLines.length - 1];\n    b = expectedLines[expectedLines.length - 1];\n  }\n\n  var maxLines = Math.max(actualLines.length, expectedLines.length); // Strict equal with identical objects that are not identical by reference.\n  // E.g., assert.deepStrictEqual({ a: Symbol() }, { a: Symbol() })\n\n  if (maxLines === 0) {\n    // We have to get the result again. The lines were all removed before.\n    var _actualLines = actualInspected.split('\\n'); // Only remove lines in case it makes sense to collapse those.\n    // TODO: Accept env to always show the full error.\n\n\n    if (_actualLines.length > 30) {\n      _actualLines[26] = \"\".concat(blue, \"...\").concat(white);\n\n      while (_actualLines.length > 27) {\n        _actualLines.pop();\n      }\n    }\n\n    return \"\".concat(kReadableOperator.notIdentical, \"\\n\\n\").concat(_actualLines.join('\\n'), \"\\n\");\n  }\n\n  if (i > 3) {\n    end = \"\\n\".concat(blue, \"...\").concat(white).concat(end);\n    skipped = true;\n  }\n\n  if (other !== '') {\n    end = \"\\n  \".concat(other).concat(end);\n    other = '';\n  }\n\n  var printedLines = 0;\n  var msg = kReadableOperator[operator] + \"\\n\".concat(green, \"+ actual\").concat(white, \" \").concat(red, \"- expected\").concat(white);\n  var skippedMsg = \" \".concat(blue, \"...\").concat(white, \" Lines skipped\");\n\n  for (i = 0; i < maxLines; i++) {\n    // Only extra expected lines exist\n    var cur = i - lastPos;\n\n    if (actualLines.length < i + 1) {\n      // If the last diverging line is more than one line above and the\n      // current line is at least line three, add some of the former lines and\n      // also add dots to indicate skipped entries.\n      if (cur > 1 && i > 2) {\n        if (cur > 4) {\n          res += \"\\n\".concat(blue, \"...\").concat(white);\n          skipped = true;\n        } else if (cur > 3) {\n          res += \"\\n  \".concat(expectedLines[i - 2]);\n          printedLines++;\n        }\n\n        res += \"\\n  \".concat(expectedLines[i - 1]);\n        printedLines++;\n      } // Mark the current line as the last diverging one.\n\n\n      lastPos = i; // Add the expected line to the cache.\n\n      other += \"\\n\".concat(red, \"-\").concat(white, \" \").concat(expectedLines[i]);\n      printedLines++; // Only extra actual lines exist\n    } else if (expectedLines.length < i + 1) {\n      // If the last diverging line is more than one line above and the\n      // current line is at least line three, add some of the former lines and\n      // also add dots to indicate skipped entries.\n      if (cur > 1 && i > 2) {\n        if (cur > 4) {\n          res += \"\\n\".concat(blue, \"...\").concat(white);\n          skipped = true;\n        } else if (cur > 3) {\n          res += \"\\n  \".concat(actualLines[i - 2]);\n          printedLines++;\n        }\n\n        res += \"\\n  \".concat(actualLines[i - 1]);\n        printedLines++;\n      } // Mark the current line as the last diverging one.\n\n\n      lastPos = i; // Add the actual line to the result.\n\n      res += \"\\n\".concat(green, \"+\").concat(white, \" \").concat(actualLines[i]);\n      printedLines++; // Lines diverge\n    } else {\n      var expectedLine = expectedLines[i];\n      var actualLine = actualLines[i]; // If the lines diverge, specifically check for lines that only diverge by\n      // a trailing comma. In that case it is actually identical and we should\n      // mark it as such.\n\n      var divergingLines = actualLine !== expectedLine && (!endsWith(actualLine, ',') || actualLine.slice(0, -1) !== expectedLine); // If the expected line has a trailing comma but is otherwise identical,\n      // add a comma at the end of the actual line. Otherwise the output could\n      // look weird as in:\n      //\n      //   [\n      //     1         // No comma at the end!\n      // +   2\n      //   ]\n      //\n\n      if (divergingLines && endsWith(expectedLine, ',') && expectedLine.slice(0, -1) === actualLine) {\n        divergingLines = false;\n        actualLine += ',';\n      }\n\n      if (divergingLines) {\n        // If the last diverging line is more than one line above and the\n        // current line is at least line three, add some of the former lines and\n        // also add dots to indicate skipped entries.\n        if (cur > 1 && i > 2) {\n          if (cur > 4) {\n            res += \"\\n\".concat(blue, \"...\").concat(white);\n            skipped = true;\n          } else if (cur > 3) {\n            res += \"\\n  \".concat(actualLines[i - 2]);\n            printedLines++;\n          }\n\n          res += \"\\n  \".concat(actualLines[i - 1]);\n          printedLines++;\n        } // Mark the current line as the last diverging one.\n\n\n        lastPos = i; // Add the actual line to the result and cache the expected diverging\n        // line so consecutive diverging lines show up as +++--- and not +-+-+-.\n\n        res += \"\\n\".concat(green, \"+\").concat(white, \" \").concat(actualLine);\n        other += \"\\n\".concat(red, \"-\").concat(white, \" \").concat(expectedLine);\n        printedLines += 2; // Lines are identical\n      } else {\n        // Add all cached information to the result before adding other things\n        // and reset the cache.\n        res += other;\n        other = ''; // If the last diverging line is exactly one line above or if it is the\n        // very first line, add the line to the result.\n\n        if (cur === 1 || i === 0) {\n          res += \"\\n  \".concat(actualLine);\n          printedLines++;\n        }\n      }\n    } // Inspected object to big (Show ~20 rows max)\n\n\n    if (printedLines > 20 && i < maxLines - 2) {\n      return \"\".concat(msg).concat(skippedMsg, \"\\n\").concat(res, \"\\n\").concat(blue, \"...\").concat(white).concat(other, \"\\n\") + \"\".concat(blue, \"...\").concat(white);\n    }\n  }\n\n  return \"\".concat(msg).concat(skipped ? skippedMsg : '', \"\\n\").concat(res).concat(other).concat(end).concat(indicator);\n}\n\nvar AssertionError =\n/*#__PURE__*/\nfunction (_Error) {\n  _inherits(AssertionError, _Error);\n\n  function AssertionError(options) {\n    var _this;\n\n    _classCallCheck(this, AssertionError);\n\n    if (_typeof(options) !== 'object' || options === null) {\n      throw new ERR_INVALID_ARG_TYPE('options', 'Object', options);\n    }\n\n    var message = options.message,\n        operator = options.operator,\n        stackStartFn = options.stackStartFn;\n    var actual = options.actual,\n        expected = options.expected;\n    var limit = Error.stackTraceLimit;\n    Error.stackTraceLimit = 0;\n\n    if (message != null) {\n      _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError).call(this, String(message)));\n    } else {\n      if (process.stderr && process.stderr.isTTY) {\n        // Reset on each call to make sure we handle dynamically set environment\n        // variables correct.\n        if (process.stderr && process.stderr.getColorDepth && process.stderr.getColorDepth() !== 1) {\n          blue = \"\\x1B[34m\";\n          green = \"\\x1B[32m\";\n          white = \"\\x1B[39m\";\n          red = \"\\x1B[31m\";\n        } else {\n          blue = '';\n          green = '';\n          white = '';\n          red = '';\n        }\n      } // Prevent the error stack from being visible by duplicating the error\n      // in a very close way to the original in case both sides are actually\n      // instances of Error.\n\n\n      if (_typeof(actual) === 'object' && actual !== null && _typeof(expected) === 'object' && expected !== null && 'stack' in actual && actual instanceof Error && 'stack' in expected && expected instanceof Error) {\n        actual = copyError(actual);\n        expected = copyError(expected);\n      }\n\n      if (operator === 'deepStrictEqual' || operator === 'strictEqual') {\n        _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError).call(this, createErrDiff(actual, expected, operator)));\n      } else if (operator === 'notDeepStrictEqual' || operator === 'notStrictEqual') {\n        // In case the objects are equal but the operator requires unequal, show\n        // the first object and say A equals B\n        var base = kReadableOperator[operator];\n        var res = inspectValue(actual).split('\\n'); // In case \"actual\" is an object, it should not be reference equal.\n\n        if (operator === 'notStrictEqual' && _typeof(actual) === 'object' && actual !== null) {\n          base = kReadableOperator.notStrictEqualObject;\n        } // Only remove lines in case it makes sense to collapse those.\n        // TODO: Accept env to always show the full error.\n\n\n        if (res.length > 30) {\n          res[26] = \"\".concat(blue, \"...\").concat(white);\n\n          while (res.length > 27) {\n            res.pop();\n          }\n        } // Only print a single input.\n\n\n        if (res.length === 1) {\n          _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError).call(this, \"\".concat(base, \" \").concat(res[0])));\n        } else {\n          _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError).call(this, \"\".concat(base, \"\\n\\n\").concat(res.join('\\n'), \"\\n\")));\n        }\n      } else {\n        var _res = inspectValue(actual);\n\n        var other = '';\n        var knownOperators = kReadableOperator[operator];\n\n        if (operator === 'notDeepEqual' || operator === 'notEqual') {\n          _res = \"\".concat(kReadableOperator[operator], \"\\n\\n\").concat(_res);\n\n          if (_res.length > 1024) {\n            _res = \"\".concat(_res.slice(0, 1021), \"...\");\n          }\n        } else {\n          other = \"\".concat(inspectValue(expected));\n\n          if (_res.length > 512) {\n            _res = \"\".concat(_res.slice(0, 509), \"...\");\n          }\n\n          if (other.length > 512) {\n            other = \"\".concat(other.slice(0, 509), \"...\");\n          }\n\n          if (operator === 'deepEqual' || operator === 'equal') {\n            _res = \"\".concat(knownOperators, \"\\n\\n\").concat(_res, \"\\n\\nshould equal\\n\\n\");\n          } else {\n            other = \" \".concat(operator, \" \").concat(other);\n          }\n        }\n\n        _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError).call(this, \"\".concat(_res).concat(other)));\n      }\n    }\n\n    Error.stackTraceLimit = limit;\n    _this.generatedMessage = !message;\n    Object.defineProperty(_assertThisInitialized(_this), 'name', {\n      value: 'AssertionError [ERR_ASSERTION]',\n      enumerable: false,\n      writable: true,\n      configurable: true\n    });\n    _this.code = 'ERR_ASSERTION';\n    _this.actual = actual;\n    _this.expected = expected;\n    _this.operator = operator;\n\n    if (Error.captureStackTrace) {\n      // eslint-disable-next-line no-restricted-syntax\n      Error.captureStackTrace(_assertThisInitialized(_this), stackStartFn);\n    } // Create error message including the error code in the name.\n\n\n    _this.stack; // Reset the name.\n\n    _this.name = 'AssertionError';\n    return _possibleConstructorReturn(_this);\n  }\n\n  _createClass(AssertionError, [{\n    key: \"toString\",\n    value: function toString() {\n      return \"\".concat(this.name, \" [\").concat(this.code, \"]: \").concat(this.message);\n    }\n  }, {\n    key: inspect.custom,\n    value: function value(recurseTimes, ctx) {\n      // This limits the `actual` and `expected` property default inspection to\n      // the minimum depth. Otherwise those values would be too verbose compared\n      // to the actual error message which contains a combined view of these two\n      // input values.\n      return inspect(this, _objectSpread({}, ctx, {\n        customInspect: false,\n        depth: 0\n      }));\n    }\n  }]);\n\n  return AssertionError;\n}(_wrapNativeSuper(Error));\n\nmodule.exports = AssertionError;\n\n//# sourceURL=webpack://javascript/./node_modules/assert/build/internal/assert/assertion_error.js?");

/***/ }),

/***/ "./node_modules/assert/build/internal/errors.js":
/*!******************************************************!*\
  !*** ./node_modules/assert/build/internal/errors.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Currently in sync with Node.js lib/internal/errors.js\n// https://github.com/nodejs/node/commit/3b044962c48fe313905877a96b5d0894a5404f6f\n\n/* eslint node-core/documented-errors: \"error\" */\n\n/* eslint node-core/alphabetize-errors: \"error\" */\n\n/* eslint node-core/prefer-util-format-errors: \"error\" */\n // The whole point behind this internal module is to allow Node.js to no\n// longer be forced to treat every error message change as a semver-major\n// change. The NodeError classes here all expose a `code` property whose\n// value statically and permanently identifies the error. While the error\n// message may change, the code should not.\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nvar codes = {}; // Lazy loaded\n\nvar assert;\nvar util;\n\nfunction createErrorType(code, message, Base) {\n  if (!Base) {\n    Base = Error;\n  }\n\n  function getMessage(arg1, arg2, arg3) {\n    if (typeof message === 'string') {\n      return message;\n    } else {\n      return message(arg1, arg2, arg3);\n    }\n  }\n\n  var NodeError =\n  /*#__PURE__*/\n  function (_Base) {\n    _inherits(NodeError, _Base);\n\n    function NodeError(arg1, arg2, arg3) {\n      var _this;\n\n      _classCallCheck(this, NodeError);\n\n      _this = _possibleConstructorReturn(this, _getPrototypeOf(NodeError).call(this, getMessage(arg1, arg2, arg3)));\n      _this.code = code;\n      return _this;\n    }\n\n    return NodeError;\n  }(Base);\n\n  codes[code] = NodeError;\n} // https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js\n\n\nfunction oneOf(expected, thing) {\n  if (Array.isArray(expected)) {\n    var len = expected.length;\n    expected = expected.map(function (i) {\n      return String(i);\n    });\n\n    if (len > 2) {\n      return \"one of \".concat(thing, \" \").concat(expected.slice(0, len - 1).join(', '), \", or \") + expected[len - 1];\n    } else if (len === 2) {\n      return \"one of \".concat(thing, \" \").concat(expected[0], \" or \").concat(expected[1]);\n    } else {\n      return \"of \".concat(thing, \" \").concat(expected[0]);\n    }\n  } else {\n    return \"of \".concat(thing, \" \").concat(String(expected));\n  }\n} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith\n\n\nfunction startsWith(str, search, pos) {\n  return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;\n} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith\n\n\nfunction endsWith(str, search, this_len) {\n  if (this_len === undefined || this_len > str.length) {\n    this_len = str.length;\n  }\n\n  return str.substring(this_len - search.length, this_len) === search;\n} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes\n\n\nfunction includes(str, search, start) {\n  if (typeof start !== 'number') {\n    start = 0;\n  }\n\n  if (start + search.length > str.length) {\n    return false;\n  } else {\n    return str.indexOf(search, start) !== -1;\n  }\n}\n\ncreateErrorType('ERR_AMBIGUOUS_ARGUMENT', 'The \"%s\" argument is ambiguous. %s', TypeError);\ncreateErrorType('ERR_INVALID_ARG_TYPE', function (name, expected, actual) {\n  if (assert === undefined) assert = __webpack_require__(/*! ../assert */ \"./node_modules/assert/build/assert.js\");\n  assert(typeof name === 'string', \"'name' must be a string\"); // determiner: 'must be' or 'must not be'\n\n  var determiner;\n\n  if (typeof expected === 'string' && startsWith(expected, 'not ')) {\n    determiner = 'must not be';\n    expected = expected.replace(/^not /, '');\n  } else {\n    determiner = 'must be';\n  }\n\n  var msg;\n\n  if (endsWith(name, ' argument')) {\n    // For cases like 'first argument'\n    msg = \"The \".concat(name, \" \").concat(determiner, \" \").concat(oneOf(expected, 'type'));\n  } else {\n    var type = includes(name, '.') ? 'property' : 'argument';\n    msg = \"The \\\"\".concat(name, \"\\\" \").concat(type, \" \").concat(determiner, \" \").concat(oneOf(expected, 'type'));\n  } // TODO(BridgeAR): Improve the output by showing `null` and similar.\n\n\n  msg += \". Received type \".concat(_typeof(actual));\n  return msg;\n}, TypeError);\ncreateErrorType('ERR_INVALID_ARG_VALUE', function (name, value) {\n  var reason = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'is invalid';\n  if (util === undefined) util = __webpack_require__(/*! util/ */ \"./node_modules/util/util.js\");\n  var inspected = util.inspect(value);\n\n  if (inspected.length > 128) {\n    inspected = \"\".concat(inspected.slice(0, 128), \"...\");\n  }\n\n  return \"The argument '\".concat(name, \"' \").concat(reason, \". Received \").concat(inspected);\n}, TypeError, RangeError);\ncreateErrorType('ERR_INVALID_RETURN_VALUE', function (input, name, value) {\n  var type;\n\n  if (value && value.constructor && value.constructor.name) {\n    type = \"instance of \".concat(value.constructor.name);\n  } else {\n    type = \"type \".concat(_typeof(value));\n  }\n\n  return \"Expected \".concat(input, \" to be returned from the \\\"\").concat(name, \"\\\"\") + \" function but got \".concat(type, \".\");\n}, TypeError);\ncreateErrorType('ERR_MISSING_ARGS', function () {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  if (assert === undefined) assert = __webpack_require__(/*! ../assert */ \"./node_modules/assert/build/assert.js\");\n  assert(args.length > 0, 'At least one arg needs to be specified');\n  var msg = 'The ';\n  var len = args.length;\n  args = args.map(function (a) {\n    return \"\\\"\".concat(a, \"\\\"\");\n  });\n\n  switch (len) {\n    case 1:\n      msg += \"\".concat(args[0], \" argument\");\n      break;\n\n    case 2:\n      msg += \"\".concat(args[0], \" and \").concat(args[1], \" arguments\");\n      break;\n\n    default:\n      msg += args.slice(0, len - 1).join(', ');\n      msg += \", and \".concat(args[len - 1], \" arguments\");\n      break;\n  }\n\n  return \"\".concat(msg, \" must be specified\");\n}, TypeError);\nmodule.exports.codes = codes;\n\n//# sourceURL=webpack://javascript/./node_modules/assert/build/internal/errors.js?");

/***/ }),

/***/ "./node_modules/assert/build/internal/util/comparisons.js":
/*!****************************************************************!*\
  !*** ./node_modules/assert/build/internal/util/comparisons.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Currently in sync with Node.js lib/internal/util/comparisons.js\n// https://github.com/nodejs/node/commit/112cc7c27551254aa2b17098fb774867f05ed0d9\n\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); }\n\nfunction _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nvar regexFlagsSupported = /a/g.flags !== undefined;\n\nvar arrayFromSet = function arrayFromSet(set) {\n  var array = [];\n  set.forEach(function (value) {\n    return array.push(value);\n  });\n  return array;\n};\n\nvar arrayFromMap = function arrayFromMap(map) {\n  var array = [];\n  map.forEach(function (value, key) {\n    return array.push([key, value]);\n  });\n  return array;\n};\n\nvar objectIs = Object.is ? Object.is : __webpack_require__(/*! object-is */ \"./node_modules/object-is/index.js\");\nvar objectGetOwnPropertySymbols = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols : function () {\n  return [];\n};\nvar numberIsNaN = Number.isNaN ? Number.isNaN : __webpack_require__(/*! is-nan */ \"./node_modules/is-nan/index.js\");\n\nfunction uncurryThis(f) {\n  return f.call.bind(f);\n}\n\nvar hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);\nvar propertyIsEnumerable = uncurryThis(Object.prototype.propertyIsEnumerable);\nvar objectToString = uncurryThis(Object.prototype.toString);\n\nvar _require$types = (__webpack_require__(/*! util/ */ \"./node_modules/util/util.js\").types),\n    isAnyArrayBuffer = _require$types.isAnyArrayBuffer,\n    isArrayBufferView = _require$types.isArrayBufferView,\n    isDate = _require$types.isDate,\n    isMap = _require$types.isMap,\n    isRegExp = _require$types.isRegExp,\n    isSet = _require$types.isSet,\n    isNativeError = _require$types.isNativeError,\n    isBoxedPrimitive = _require$types.isBoxedPrimitive,\n    isNumberObject = _require$types.isNumberObject,\n    isStringObject = _require$types.isStringObject,\n    isBooleanObject = _require$types.isBooleanObject,\n    isBigIntObject = _require$types.isBigIntObject,\n    isSymbolObject = _require$types.isSymbolObject,\n    isFloat32Array = _require$types.isFloat32Array,\n    isFloat64Array = _require$types.isFloat64Array;\n\nfunction isNonIndex(key) {\n  if (key.length === 0 || key.length > 10) return true;\n\n  for (var i = 0; i < key.length; i++) {\n    var code = key.charCodeAt(i);\n    if (code < 48 || code > 57) return true;\n  } // The maximum size for an array is 2 ** 32 -1.\n\n\n  return key.length === 10 && key >= Math.pow(2, 32);\n}\n\nfunction getOwnNonIndexProperties(value) {\n  return Object.keys(value).filter(isNonIndex).concat(objectGetOwnPropertySymbols(value).filter(Object.prototype.propertyIsEnumerable.bind(value)));\n} // Taken from https://github.com/feross/buffer/blob/680e9e5e488f22aac27599a57dc844a6315928dd/index.js\n// original notice:\n\n/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n\n\nfunction compare(a, b) {\n  if (a === b) {\n    return 0;\n  }\n\n  var x = a.length;\n  var y = b.length;\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i];\n      y = b[i];\n      break;\n    }\n  }\n\n  if (x < y) {\n    return -1;\n  }\n\n  if (y < x) {\n    return 1;\n  }\n\n  return 0;\n}\n\nvar ONLY_ENUMERABLE = undefined;\nvar kStrict = true;\nvar kLoose = false;\nvar kNoIterator = 0;\nvar kIsArray = 1;\nvar kIsSet = 2;\nvar kIsMap = 3; // Check if they have the same source and flags\n\nfunction areSimilarRegExps(a, b) {\n  return regexFlagsSupported ? a.source === b.source && a.flags === b.flags : RegExp.prototype.toString.call(a) === RegExp.prototype.toString.call(b);\n}\n\nfunction areSimilarFloatArrays(a, b) {\n  if (a.byteLength !== b.byteLength) {\n    return false;\n  }\n\n  for (var offset = 0; offset < a.byteLength; offset++) {\n    if (a[offset] !== b[offset]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction areSimilarTypedArrays(a, b) {\n  if (a.byteLength !== b.byteLength) {\n    return false;\n  }\n\n  return compare(new Uint8Array(a.buffer, a.byteOffset, a.byteLength), new Uint8Array(b.buffer, b.byteOffset, b.byteLength)) === 0;\n}\n\nfunction areEqualArrayBuffers(buf1, buf2) {\n  return buf1.byteLength === buf2.byteLength && compare(new Uint8Array(buf1), new Uint8Array(buf2)) === 0;\n}\n\nfunction isEqualBoxedPrimitive(val1, val2) {\n  if (isNumberObject(val1)) {\n    return isNumberObject(val2) && objectIs(Number.prototype.valueOf.call(val1), Number.prototype.valueOf.call(val2));\n  }\n\n  if (isStringObject(val1)) {\n    return isStringObject(val2) && String.prototype.valueOf.call(val1) === String.prototype.valueOf.call(val2);\n  }\n\n  if (isBooleanObject(val1)) {\n    return isBooleanObject(val2) && Boolean.prototype.valueOf.call(val1) === Boolean.prototype.valueOf.call(val2);\n  }\n\n  if (isBigIntObject(val1)) {\n    return isBigIntObject(val2) && BigInt.prototype.valueOf.call(val1) === BigInt.prototype.valueOf.call(val2);\n  }\n\n  return isSymbolObject(val2) && Symbol.prototype.valueOf.call(val1) === Symbol.prototype.valueOf.call(val2);\n} // Notes: Type tags are historical [[Class]] properties that can be set by\n// FunctionTemplate::SetClassName() in C++ or Symbol.toStringTag in JS\n// and retrieved using Object.prototype.toString.call(obj) in JS\n// See https://tc39.github.io/ecma262/#sec-object.prototype.tostring\n// for a list of tags pre-defined in the spec.\n// There are some unspecified tags in the wild too (e.g. typed array tags).\n// Since tags can be altered, they only serve fast failures\n//\n// Typed arrays and buffers are checked by comparing the content in their\n// underlying ArrayBuffer. This optimization requires that it's\n// reasonable to interpret their underlying memory in the same way,\n// which is checked by comparing their type tags.\n// (e.g. a Uint8Array and a Uint16Array with the same memory content\n// could still be different because they will be interpreted differently).\n//\n// For strict comparison, objects should have\n// a) The same built-in type tags\n// b) The same prototypes.\n\n\nfunction innerDeepEqual(val1, val2, strict, memos) {\n  // All identical values are equivalent, as determined by ===.\n  if (val1 === val2) {\n    if (val1 !== 0) return true;\n    return strict ? objectIs(val1, val2) : true;\n  } // Check more closely if val1 and val2 are equal.\n\n\n  if (strict) {\n    if (_typeof(val1) !== 'object') {\n      return typeof val1 === 'number' && numberIsNaN(val1) && numberIsNaN(val2);\n    }\n\n    if (_typeof(val2) !== 'object' || val1 === null || val2 === null) {\n      return false;\n    }\n\n    if (Object.getPrototypeOf(val1) !== Object.getPrototypeOf(val2)) {\n      return false;\n    }\n  } else {\n    if (val1 === null || _typeof(val1) !== 'object') {\n      if (val2 === null || _typeof(val2) !== 'object') {\n        // eslint-disable-next-line eqeqeq\n        return val1 == val2;\n      }\n\n      return false;\n    }\n\n    if (val2 === null || _typeof(val2) !== 'object') {\n      return false;\n    }\n  }\n\n  var val1Tag = objectToString(val1);\n  var val2Tag = objectToString(val2);\n\n  if (val1Tag !== val2Tag) {\n    return false;\n  }\n\n  if (Array.isArray(val1)) {\n    // Check for sparse arrays and general fast path\n    if (val1.length !== val2.length) {\n      return false;\n    }\n\n    var keys1 = getOwnNonIndexProperties(val1, ONLY_ENUMERABLE);\n    var keys2 = getOwnNonIndexProperties(val2, ONLY_ENUMERABLE);\n\n    if (keys1.length !== keys2.length) {\n      return false;\n    }\n\n    return keyCheck(val1, val2, strict, memos, kIsArray, keys1);\n  } // [browserify] This triggers on certain types in IE (Map/Set) so we don't\n  // wan't to early return out of the rest of the checks. However we can check\n  // if the second value is one of these values and the first isn't.\n\n\n  if (val1Tag === '[object Object]') {\n    // return keyCheck(val1, val2, strict, memos, kNoIterator);\n    if (!isMap(val1) && isMap(val2) || !isSet(val1) && isSet(val2)) {\n      return false;\n    }\n  }\n\n  if (isDate(val1)) {\n    if (!isDate(val2) || Date.prototype.getTime.call(val1) !== Date.prototype.getTime.call(val2)) {\n      return false;\n    }\n  } else if (isRegExp(val1)) {\n    if (!isRegExp(val2) || !areSimilarRegExps(val1, val2)) {\n      return false;\n    }\n  } else if (isNativeError(val1) || val1 instanceof Error) {\n    // Do not compare the stack as it might differ even though the error itself\n    // is otherwise identical.\n    if (val1.message !== val2.message || val1.name !== val2.name) {\n      return false;\n    }\n  } else if (isArrayBufferView(val1)) {\n    if (!strict && (isFloat32Array(val1) || isFloat64Array(val1))) {\n      if (!areSimilarFloatArrays(val1, val2)) {\n        return false;\n      }\n    } else if (!areSimilarTypedArrays(val1, val2)) {\n      return false;\n    } // Buffer.compare returns true, so val1.length === val2.length. If they both\n    // only contain numeric keys, we don't need to exam further than checking\n    // the symbols.\n\n\n    var _keys = getOwnNonIndexProperties(val1, ONLY_ENUMERABLE);\n\n    var _keys2 = getOwnNonIndexProperties(val2, ONLY_ENUMERABLE);\n\n    if (_keys.length !== _keys2.length) {\n      return false;\n    }\n\n    return keyCheck(val1, val2, strict, memos, kNoIterator, _keys);\n  } else if (isSet(val1)) {\n    if (!isSet(val2) || val1.size !== val2.size) {\n      return false;\n    }\n\n    return keyCheck(val1, val2, strict, memos, kIsSet);\n  } else if (isMap(val1)) {\n    if (!isMap(val2) || val1.size !== val2.size) {\n      return false;\n    }\n\n    return keyCheck(val1, val2, strict, memos, kIsMap);\n  } else if (isAnyArrayBuffer(val1)) {\n    if (!areEqualArrayBuffers(val1, val2)) {\n      return false;\n    }\n  } else if (isBoxedPrimitive(val1) && !isEqualBoxedPrimitive(val1, val2)) {\n    return false;\n  }\n\n  return keyCheck(val1, val2, strict, memos, kNoIterator);\n}\n\nfunction getEnumerables(val, keys) {\n  return keys.filter(function (k) {\n    return propertyIsEnumerable(val, k);\n  });\n}\n\nfunction keyCheck(val1, val2, strict, memos, iterationType, aKeys) {\n  // For all remaining Object pairs, including Array, objects and Maps,\n  // equivalence is determined by having:\n  // a) The same number of owned enumerable properties\n  // b) The same set of keys/indexes (although not necessarily the same order)\n  // c) Equivalent values for every corresponding key/index\n  // d) For Sets and Maps, equal contents\n  // Note: this accounts for both named and indexed properties on Arrays.\n  if (arguments.length === 5) {\n    aKeys = Object.keys(val1);\n    var bKeys = Object.keys(val2); // The pair must have the same number of owned properties.\n\n    if (aKeys.length !== bKeys.length) {\n      return false;\n    }\n  } // Cheap key test\n\n\n  var i = 0;\n\n  for (; i < aKeys.length; i++) {\n    if (!hasOwnProperty(val2, aKeys[i])) {\n      return false;\n    }\n  }\n\n  if (strict && arguments.length === 5) {\n    var symbolKeysA = objectGetOwnPropertySymbols(val1);\n\n    if (symbolKeysA.length !== 0) {\n      var count = 0;\n\n      for (i = 0; i < symbolKeysA.length; i++) {\n        var key = symbolKeysA[i];\n\n        if (propertyIsEnumerable(val1, key)) {\n          if (!propertyIsEnumerable(val2, key)) {\n            return false;\n          }\n\n          aKeys.push(key);\n          count++;\n        } else if (propertyIsEnumerable(val2, key)) {\n          return false;\n        }\n      }\n\n      var symbolKeysB = objectGetOwnPropertySymbols(val2);\n\n      if (symbolKeysA.length !== symbolKeysB.length && getEnumerables(val2, symbolKeysB).length !== count) {\n        return false;\n      }\n    } else {\n      var _symbolKeysB = objectGetOwnPropertySymbols(val2);\n\n      if (_symbolKeysB.length !== 0 && getEnumerables(val2, _symbolKeysB).length !== 0) {\n        return false;\n      }\n    }\n  }\n\n  if (aKeys.length === 0 && (iterationType === kNoIterator || iterationType === kIsArray && val1.length === 0 || val1.size === 0)) {\n    return true;\n  } // Use memos to handle cycles.\n\n\n  if (memos === undefined) {\n    memos = {\n      val1: new Map(),\n      val2: new Map(),\n      position: 0\n    };\n  } else {\n    // We prevent up to two map.has(x) calls by directly retrieving the value\n    // and checking for undefined. The map can only contain numbers, so it is\n    // safe to check for undefined only.\n    var val2MemoA = memos.val1.get(val1);\n\n    if (val2MemoA !== undefined) {\n      var val2MemoB = memos.val2.get(val2);\n\n      if (val2MemoB !== undefined) {\n        return val2MemoA === val2MemoB;\n      }\n    }\n\n    memos.position++;\n  }\n\n  memos.val1.set(val1, memos.position);\n  memos.val2.set(val2, memos.position);\n  var areEq = objEquiv(val1, val2, strict, aKeys, memos, iterationType);\n  memos.val1.delete(val1);\n  memos.val2.delete(val2);\n  return areEq;\n}\n\nfunction setHasEqualElement(set, val1, strict, memo) {\n  // Go looking.\n  var setValues = arrayFromSet(set);\n\n  for (var i = 0; i < setValues.length; i++) {\n    var val2 = setValues[i];\n\n    if (innerDeepEqual(val1, val2, strict, memo)) {\n      // Remove the matching element to make sure we do not check that again.\n      set.delete(val2);\n      return true;\n    }\n  }\n\n  return false;\n} // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness#Loose_equality_using\n// Sadly it is not possible to detect corresponding values properly in case the\n// type is a string, number, bigint or boolean. The reason is that those values\n// can match lots of different string values (e.g., 1n == '+00001').\n\n\nfunction findLooseMatchingPrimitives(prim) {\n  switch (_typeof(prim)) {\n    case 'undefined':\n      return null;\n\n    case 'object':\n      // Only pass in null as object!\n      return undefined;\n\n    case 'symbol':\n      return false;\n\n    case 'string':\n      prim = +prim;\n    // Loose equal entries exist only if the string is possible to convert to\n    // a regular number and not NaN.\n    // Fall through\n\n    case 'number':\n      if (numberIsNaN(prim)) {\n        return false;\n      }\n\n  }\n\n  return true;\n}\n\nfunction setMightHaveLoosePrim(a, b, prim) {\n  var altValue = findLooseMatchingPrimitives(prim);\n  if (altValue != null) return altValue;\n  return b.has(altValue) && !a.has(altValue);\n}\n\nfunction mapMightHaveLoosePrim(a, b, prim, item, memo) {\n  var altValue = findLooseMatchingPrimitives(prim);\n\n  if (altValue != null) {\n    return altValue;\n  }\n\n  var curB = b.get(altValue);\n\n  if (curB === undefined && !b.has(altValue) || !innerDeepEqual(item, curB, false, memo)) {\n    return false;\n  }\n\n  return !a.has(altValue) && innerDeepEqual(item, curB, false, memo);\n}\n\nfunction setEquiv(a, b, strict, memo) {\n  // This is a lazily initiated Set of entries which have to be compared\n  // pairwise.\n  var set = null;\n  var aValues = arrayFromSet(a);\n\n  for (var i = 0; i < aValues.length; i++) {\n    var val = aValues[i]; // Note: Checking for the objects first improves the performance for object\n    // heavy sets but it is a minor slow down for primitives. As they are fast\n    // to check this improves the worst case scenario instead.\n\n    if (_typeof(val) === 'object' && val !== null) {\n      if (set === null) {\n        set = new Set();\n      } // If the specified value doesn't exist in the second set its an not null\n      // object (or non strict only: a not matching primitive) we'll need to go\n      // hunting for something thats deep-(strict-)equal to it. To make this\n      // O(n log n) complexity we have to copy these values in a new set first.\n\n\n      set.add(val);\n    } else if (!b.has(val)) {\n      if (strict) return false; // Fast path to detect missing string, symbol, undefined and null values.\n\n      if (!setMightHaveLoosePrim(a, b, val)) {\n        return false;\n      }\n\n      if (set === null) {\n        set = new Set();\n      }\n\n      set.add(val);\n    }\n  }\n\n  if (set !== null) {\n    var bValues = arrayFromSet(b);\n\n    for (var _i = 0; _i < bValues.length; _i++) {\n      var _val = bValues[_i]; // We have to check if a primitive value is already\n      // matching and only if it's not, go hunting for it.\n\n      if (_typeof(_val) === 'object' && _val !== null) {\n        if (!setHasEqualElement(set, _val, strict, memo)) return false;\n      } else if (!strict && !a.has(_val) && !setHasEqualElement(set, _val, strict, memo)) {\n        return false;\n      }\n    }\n\n    return set.size === 0;\n  }\n\n  return true;\n}\n\nfunction mapHasEqualEntry(set, map, key1, item1, strict, memo) {\n  // To be able to handle cases like:\n  //   Map([[{}, 'a'], [{}, 'b']]) vs Map([[{}, 'b'], [{}, 'a']])\n  // ... we need to consider *all* matching keys, not just the first we find.\n  var setValues = arrayFromSet(set);\n\n  for (var i = 0; i < setValues.length; i++) {\n    var key2 = setValues[i];\n\n    if (innerDeepEqual(key1, key2, strict, memo) && innerDeepEqual(item1, map.get(key2), strict, memo)) {\n      set.delete(key2);\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction mapEquiv(a, b, strict, memo) {\n  var set = null;\n  var aEntries = arrayFromMap(a);\n\n  for (var i = 0; i < aEntries.length; i++) {\n    var _aEntries$i = _slicedToArray(aEntries[i], 2),\n        key = _aEntries$i[0],\n        item1 = _aEntries$i[1];\n\n    if (_typeof(key) === 'object' && key !== null) {\n      if (set === null) {\n        set = new Set();\n      }\n\n      set.add(key);\n    } else {\n      // By directly retrieving the value we prevent another b.has(key) check in\n      // almost all possible cases.\n      var item2 = b.get(key);\n\n      if (item2 === undefined && !b.has(key) || !innerDeepEqual(item1, item2, strict, memo)) {\n        if (strict) return false; // Fast path to detect missing string, symbol, undefined and null\n        // keys.\n\n        if (!mapMightHaveLoosePrim(a, b, key, item1, memo)) return false;\n\n        if (set === null) {\n          set = new Set();\n        }\n\n        set.add(key);\n      }\n    }\n  }\n\n  if (set !== null) {\n    var bEntries = arrayFromMap(b);\n\n    for (var _i2 = 0; _i2 < bEntries.length; _i2++) {\n      var _bEntries$_i = _slicedToArray(bEntries[_i2], 2),\n          key = _bEntries$_i[0],\n          item = _bEntries$_i[1];\n\n      if (_typeof(key) === 'object' && key !== null) {\n        if (!mapHasEqualEntry(set, a, key, item, strict, memo)) return false;\n      } else if (!strict && (!a.has(key) || !innerDeepEqual(a.get(key), item, false, memo)) && !mapHasEqualEntry(set, a, key, item, false, memo)) {\n        return false;\n      }\n    }\n\n    return set.size === 0;\n  }\n\n  return true;\n}\n\nfunction objEquiv(a, b, strict, keys, memos, iterationType) {\n  // Sets and maps don't have their entries accessible via normal object\n  // properties.\n  var i = 0;\n\n  if (iterationType === kIsSet) {\n    if (!setEquiv(a, b, strict, memos)) {\n      return false;\n    }\n  } else if (iterationType === kIsMap) {\n    if (!mapEquiv(a, b, strict, memos)) {\n      return false;\n    }\n  } else if (iterationType === kIsArray) {\n    for (; i < a.length; i++) {\n      if (hasOwnProperty(a, i)) {\n        if (!hasOwnProperty(b, i) || !innerDeepEqual(a[i], b[i], strict, memos)) {\n          return false;\n        }\n      } else if (hasOwnProperty(b, i)) {\n        return false;\n      } else {\n        // Array is sparse.\n        var keysA = Object.keys(a);\n\n        for (; i < keysA.length; i++) {\n          var key = keysA[i];\n\n          if (!hasOwnProperty(b, key) || !innerDeepEqual(a[key], b[key], strict, memos)) {\n            return false;\n          }\n        }\n\n        if (keysA.length !== Object.keys(b).length) {\n          return false;\n        }\n\n        return true;\n      }\n    }\n  } // The pair must have equivalent values for every corresponding key.\n  // Possibly expensive deep test:\n\n\n  for (i = 0; i < keys.length; i++) {\n    var _key = keys[i];\n\n    if (!innerDeepEqual(a[_key], b[_key], strict, memos)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction isDeepEqual(val1, val2) {\n  return innerDeepEqual(val1, val2, kLoose);\n}\n\nfunction isDeepStrictEqual(val1, val2) {\n  return innerDeepEqual(val1, val2, kStrict);\n}\n\nmodule.exports = {\n  isDeepEqual: isDeepEqual,\n  isDeepStrictEqual: isDeepStrictEqual\n};\n\n//# sourceURL=webpack://javascript/./node_modules/assert/build/internal/util/comparisons.js?");

/***/ }),

/***/ "./src/eslint.js":
/*!***********************!*\
  !*** ./src/eslint.js ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var eslint4b__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! eslint4b */ \"./node_modules/eslint4b/dist/index.js\");\n/* harmony import */ var eslint4b__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(eslint4b__WEBPACK_IMPORTED_MODULE_0__);\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n// Copied the versions from here: https://github.com/node-red/nrlint/blob/master/package.json#L50\n\nvar linter = new (eslint4b__WEBPACK_IMPORTED_MODULE_0___default())();\nlinter.defineRule(\"no-es6-funcs\", {\n  meta: {\n    docs: {\n      recommended: false\n    }\n  },\n  create: function create(context) {\n    return {\n      CallExpression: function CallExpression(node) {\n        if (!node.callee || !node.callee.property) {\n          return;\n        }\n\n        var functionName = node.callee.property.name;\n        var es6ArrayFunctions = [\"find\", \"findIndex\", \"copyWithin\", \"values\", \"fill\"];\n        var es6StringFunctions = [\"startsWith\", \"endsWith\", \"includes\", \"repeat\"];\n        var es6Functions = [].concat(es6ArrayFunctions, es6StringFunctions);\n\n        if (es6Functions.indexOf(functionName) > -1) {\n          context.report({\n            node: node.callee.property,\n            message: \"ES6 methods not allowed: \" + functionName\n          });\n        }\n      }\n    };\n  }\n});\n\nvar lint = function lint(code) {\n  var rules = linter.getRules(); // Set reccomended rules\n\n  var ruleConfig = _toConsumableArray(rules.entries()).reduce(function (result, _ref) {\n    var _ref2 = _slicedToArray(_ref, 2),\n        ruleId = _ref2[0],\n        rule = _ref2[1];\n\n    if (rule.meta.docs.recommended) {\n      result[ruleId] = 2;\n    }\n\n    return result;\n  }, {});\n\n  var messages = linter.verify(code, {\n    parserOptions: {\n      ecmaVersion: 5\n    },\n    rules: _objectSpread(_objectSpread({}, ruleConfig), {}, {\n      \"no-undef\": 0,\n      unusedVar: 0,\n      \"no-es6-funcs\": 2\n    })\n  });\n  return messages;\n};\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (lint);\n\n//# sourceURL=webpack://javascript/./src/eslint.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var codeflask__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! codeflask */ \"./node_modules/codeflask/build/codeflask.module.js\");\n/* harmony import */ var _eslint__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./eslint */ \"./src/eslint.js\");\n/* provided dependency */ var console = __webpack_require__(/*! ./node_modules/console-browserify/index.js */ \"./node_modules/console-browserify/index.js\");\n\n\nvar code = \"var msg = \\\"Hello World\\\"\\nconsole.log(msg)\";\nvar editorElem = document.getElementById('editor');\nvar flask = new codeflask__WEBPACK_IMPORTED_MODULE_0__[\"default\"](editorElem, {\n  language: \"js\",\n  lineNumbers: true\n});\nflask.updateCode(code);\nflask.onUpdate(function (code) {\n  var messages = (0,_eslint__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(code);\n  console.log(messages);\n  document.getElementById(\"lint-errors\").innerHTML = \"<pre>\".concat(JSON.stringify(messages), \"</pre>\");\n});\n\n//# sourceURL=webpack://javascript/./src/index.js?");

/***/ }),

/***/ "./node_modules/call-bind/callBound.js":
/*!*********************************************!*\
  !*** ./node_modules/call-bind/callBound.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar GetIntrinsic = __webpack_require__(/*! get-intrinsic */ \"./node_modules/get-intrinsic/index.js\");\n\nvar callBind = __webpack_require__(/*! ./ */ \"./node_modules/call-bind/index.js\");\n\nvar $indexOf = callBind(GetIntrinsic('String.prototype.indexOf'));\n\nmodule.exports = function callBoundIntrinsic(name, allowMissing) {\n\tvar intrinsic = GetIntrinsic(name, !!allowMissing);\n\tif (typeof intrinsic === 'function' && $indexOf(name, '.prototype.') > -1) {\n\t\treturn callBind(intrinsic);\n\t}\n\treturn intrinsic;\n};\n\n\n//# sourceURL=webpack://javascript/./node_modules/call-bind/callBound.js?");

/***/ }),

/***/ "./node_modules/call-bind/index.js":
/*!*****************************************!*\
  !*** ./node_modules/call-bind/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar bind = __webpack_require__(/*! function-bind */ \"./node_modules/function-bind/index.js\");\nvar GetIntrinsic = __webpack_require__(/*! get-intrinsic */ \"./node_modules/get-intrinsic/index.js\");\n\nvar $apply = GetIntrinsic('%Function.prototype.apply%');\nvar $call = GetIntrinsic('%Function.prototype.call%');\nvar $reflectApply = GetIntrinsic('%Reflect.apply%', true) || bind.call($call, $apply);\n\nvar $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%', true);\nvar $defineProperty = GetIntrinsic('%Object.defineProperty%', true);\nvar $max = GetIntrinsic('%Math.max%');\n\nif ($defineProperty) {\n\ttry {\n\t\t$defineProperty({}, 'a', { value: 1 });\n\t} catch (e) {\n\t\t// IE 8 has a broken defineProperty\n\t\t$defineProperty = null;\n\t}\n}\n\nmodule.exports = function callBind(originalFunction) {\n\tvar func = $reflectApply(bind, $call, arguments);\n\tif ($gOPD && $defineProperty) {\n\t\tvar desc = $gOPD(func, 'length');\n\t\tif (desc.configurable) {\n\t\t\t// original length, plus the receiver, minus any additional arguments (after the receiver)\n\t\t\t$defineProperty(\n\t\t\t\tfunc,\n\t\t\t\t'length',\n\t\t\t\t{ value: 1 + $max(0, originalFunction.length - (arguments.length - 1)) }\n\t\t\t);\n\t\t}\n\t}\n\treturn func;\n};\n\nvar applyBind = function applyBind() {\n\treturn $reflectApply(bind, $apply, arguments);\n};\n\nif ($defineProperty) {\n\t$defineProperty(module.exports, 'apply', { value: applyBind });\n} else {\n\tmodule.exports.apply = applyBind;\n}\n\n\n//# sourceURL=webpack://javascript/./node_modules/call-bind/index.js?");

/***/ }),

/***/ "./node_modules/codeflask/build/codeflask.module.js":
/*!**********************************************************!*\
  !*** ./node_modules/codeflask/build/codeflask.module.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nvar BACKGROUND_COLOR=\"#fff\",LINE_HEIGHT=\"20px\",FONT_SIZE=\"13px\",defaultCssTheme=\"\\n.codeflask {\\n  background: \"+BACKGROUND_COLOR+\";\\n  color: #4f559c;\\n}\\n\\n.codeflask .token.punctuation {\\n  color: #4a4a4a;\\n}\\n\\n.codeflask .token.keyword {\\n  color: #8500ff;\\n}\\n\\n.codeflask .token.operator {\\n  color: #ff5598;\\n}\\n\\n.codeflask .token.string {\\n  color: #41ad8f;\\n}\\n\\n.codeflask .token.comment {\\n  color: #9badb7;\\n}\\n\\n.codeflask .token.function {\\n  color: #8500ff;\\n}\\n\\n.codeflask .token.boolean {\\n  color: #8500ff;\\n}\\n\\n.codeflask .token.number {\\n  color: #8500ff;\\n}\\n\\n.codeflask .token.selector {\\n  color: #8500ff;\\n}\\n\\n.codeflask .token.property {\\n  color: #8500ff;\\n}\\n\\n.codeflask .token.tag {\\n  color: #8500ff;\\n}\\n\\n.codeflask .token.attr-value {\\n  color: #8500ff;\\n}\\n\";function cssSupports(e,t){return\"undefined\"!=typeof CSS?CSS.supports(e,t):\"undefined\"!=typeof document&&toCamelCase(e)in document.body.style}function toCamelCase(e){return(e=e.split(\"-\").filter(function(e){return!!e}).map(function(e){return e[0].toUpperCase()+e.substr(1)}).join(\"\"))[0].toLowerCase()+e.substr(1)}var FONT_FAMILY='\"SFMono-Regular\", Consolas, \"Liberation Mono\", Menlo, Courier, monospace',COLOR=cssSupports(\"caret-color\",\"#000\")?BACKGROUND_COLOR:\"#ccc\",LINE_NUMBER_WIDTH=\"40px\",editorCss=\"\\n  .codeflask {\\n    position: absolute;\\n    width: 100%;\\n    height: 100%;\\n    overflow: hidden;\\n  }\\n\\n  .codeflask, .codeflask * {\\n    box-sizing: border-box;\\n  }\\n\\n  .codeflask__pre {\\n    pointer-events: none;\\n    z-index: 3;\\n    overflow: hidden;\\n  }\\n\\n  .codeflask__textarea {\\n    background: none;\\n    border: none;\\n    color: \"+COLOR+\";\\n    z-index: 1;\\n    resize: none;\\n    font-family: \"+FONT_FAMILY+\";\\n    -webkit-appearance: pre;\\n    caret-color: #111;\\n    z-index: 2;\\n    width: 100%;\\n    height: 100%;\\n  }\\n\\n  .codeflask--has-line-numbers .codeflask__textarea {\\n    width: calc(100% - \"+LINE_NUMBER_WIDTH+\");\\n  }\\n\\n  .codeflask__code {\\n    display: block;\\n    font-family: \"+FONT_FAMILY+\";\\n    overflow: hidden;\\n  }\\n\\n  .codeflask__flatten {\\n    padding: 10px;\\n    font-size: \"+FONT_SIZE+\";\\n    line-height: \"+LINE_HEIGHT+\";\\n    white-space: pre;\\n    position: absolute;\\n    top: 0;\\n    left: 0;\\n    overflow: auto;\\n    margin: 0 !important;\\n    outline: none;\\n    text-align: left;\\n  }\\n\\n  .codeflask--has-line-numbers .codeflask__flatten {\\n    width: calc(100% - \"+LINE_NUMBER_WIDTH+\");\\n    left: \"+LINE_NUMBER_WIDTH+\";\\n  }\\n\\n  .codeflask__line-highlight {\\n    position: absolute;\\n    top: 10px;\\n    left: 0;\\n    width: 100%;\\n    height: \"+LINE_HEIGHT+\";\\n    background: rgba(0,0,0,0.1);\\n    z-index: 1;\\n  }\\n\\n  .codeflask__lines {\\n    padding: 10px 4px;\\n    font-size: 12px;\\n    line-height: \"+LINE_HEIGHT+\";\\n    font-family: 'Cousine', monospace;\\n    position: absolute;\\n    left: 0;\\n    top: 0;\\n    width: \"+LINE_NUMBER_WIDTH+\";\\n    height: 100%;\\n    text-align: right;\\n    color: #999;\\n    z-index: 2;\\n  }\\n\\n  .codeflask__lines__line {\\n    display: block;\\n  }\\n\\n  .codeflask.codeflask--has-line-numbers {\\n    padding-left: \"+LINE_NUMBER_WIDTH+\";\\n  }\\n\\n  .codeflask.codeflask--has-line-numbers:before {\\n    content: '';\\n    position: absolute;\\n    left: 0;\\n    top: 0;\\n    width: \"+LINE_NUMBER_WIDTH+\";\\n    height: 100%;\\n    background: #eee;\\n    z-index: 1;\\n  }\\n\";function injectCss(e,t,n){var a=t||\"codeflask-style\",s=n||document.head;if(!e)return!1;if(document.getElementById(a))return!0;var o=document.createElement(\"style\");return o.innerHTML=e,o.id=a,s.appendChild(o),!0}var entityMap={\"&\":\"&amp;\",\"<\":\"&lt;\",\">\":\"&gt;\",'\"':\"&quot;\",\"'\":\"&#39;\",\"/\":\"&#x2F;\",\"`\":\"&#x60;\",\"=\":\"&#x3D;\"};function escapeHtml(e){return String(e).replace(/[&<>\"'`=/]/g,function(e){return entityMap[e]})}var commonjsGlobal=\"undefined\"!=typeof globalThis?globalThis:\"undefined\"!=typeof window?window:\"undefined\"!=typeof __webpack_require__.g?__webpack_require__.g:\"undefined\"!=typeof self?self:{};function createCommonjsModule(e,t){return e(t={exports:{}},t.exports),t.exports}var prism=createCommonjsModule(function(e){var t=function(e){var t=/\\blang(?:uage)?-([\\w-]+)\\b/i,n=0,a={manual:e.Prism&&e.Prism.manual,disableWorkerMessageHandler:e.Prism&&e.Prism.disableWorkerMessageHandler,util:{encode:function(e){return e instanceof s?new s(e.type,a.util.encode(e.content),e.alias):Array.isArray(e)?e.map(a.util.encode):e.replace(/&/g,\"&amp;\").replace(/</g,\"&lt;\").replace(/\\u00a0/g,\" \")},type:function(e){return Object.prototype.toString.call(e).slice(8,-1)},objId:function(e){return e.__id||Object.defineProperty(e,\"__id\",{value:++n}),e.__id},clone:function e(t,n){var s,o,i=a.util.type(t);switch(n=n||{},i){case\"Object\":if(o=a.util.objId(t),n[o])return n[o];for(var r in s={},n[o]=s,t)t.hasOwnProperty(r)&&(s[r]=e(t[r],n));return s;case\"Array\":return o=a.util.objId(t),n[o]?n[o]:(s=[],n[o]=s,t.forEach(function(t,a){s[a]=e(t,n)}),s);default:return t}}},languages:{extend:function(e,t){var n=a.util.clone(a.languages[e]);for(var s in t)n[s]=t[s];return n},insertBefore:function(e,t,n,s){var o=(s=s||a.languages)[e],i={};for(var r in o)if(o.hasOwnProperty(r)){if(r==t)for(var l in n)n.hasOwnProperty(l)&&(i[l]=n[l]);n.hasOwnProperty(r)||(i[r]=o[r])}var c=s[e];return s[e]=i,a.languages.DFS(a.languages,function(t,n){n===c&&t!=e&&(this[t]=i)}),i},DFS:function e(t,n,s,o){o=o||{};var i=a.util.objId;for(var r in t)if(t.hasOwnProperty(r)){n.call(t,r,t[r],s||r);var l=t[r],c=a.util.type(l);\"Object\"!==c||o[i(l)]?\"Array\"!==c||o[i(l)]||(o[i(l)]=!0,e(l,n,r,o)):(o[i(l)]=!0,e(l,n,null,o))}}},plugins:{},highlightAll:function(e,t){a.highlightAllUnder(document,e,t)},highlightAllUnder:function(e,t,n){var s={callback:n,selector:'code[class*=\"language-\"], [class*=\"language-\"] code, code[class*=\"lang-\"], [class*=\"lang-\"] code'};a.hooks.run(\"before-highlightall\",s);for(var o,i=s.elements||e.querySelectorAll(s.selector),r=0;o=i[r++];)a.highlightElement(o,!0===t,s.callback)},highlightElement:function(n,s,o){for(var i,r,l=n;l&&!t.test(l.className);)l=l.parentNode;l&&(i=(l.className.match(t)||[,\"\"])[1].toLowerCase(),r=a.languages[i]),n.className=n.className.replace(t,\"\").replace(/\\s+/g,\" \")+\" language-\"+i,n.parentNode&&(l=n.parentNode,/pre/i.test(l.nodeName)&&(l.className=l.className.replace(t,\"\").replace(/\\s+/g,\" \")+\" language-\"+i));var c={element:n,language:i,grammar:r,code:n.textContent},d=function(e){c.highlightedCode=e,a.hooks.run(\"before-insert\",c),c.element.innerHTML=c.highlightedCode,a.hooks.run(\"after-highlight\",c),a.hooks.run(\"complete\",c),o&&o.call(c.element)};if(a.hooks.run(\"before-sanity-check\",c),c.code)if(a.hooks.run(\"before-highlight\",c),c.grammar)if(s&&e.Worker){var u=new Worker(a.filename);u.onmessage=function(e){d(e.data)},u.postMessage(JSON.stringify({language:c.language,code:c.code,immediateClose:!0}))}else d(a.highlight(c.code,c.grammar,c.language));else d(a.util.encode(c.code));else a.hooks.run(\"complete\",c)},highlight:function(e,t,n){var o={code:e,grammar:t,language:n};return a.hooks.run(\"before-tokenize\",o),o.tokens=a.tokenize(o.code,o.grammar),a.hooks.run(\"after-tokenize\",o),s.stringify(a.util.encode(o.tokens),o.language)},matchGrammar:function(e,t,n,o,i,r,l){for(var c in n)if(n.hasOwnProperty(c)&&n[c]){if(c==l)return;var d=n[c];d=\"Array\"===a.util.type(d)?d:[d];for(var u=0;u<d.length;++u){var p=d[u],h=p.inside,g=!!p.lookbehind,f=!!p.greedy,m=0,b=p.alias;if(f&&!p.pattern.global){var k=p.pattern.toString().match(/[imuy]*$/)[0];p.pattern=RegExp(p.pattern.source,k+\"g\")}p=p.pattern||p;for(var y=o,C=i;y<t.length;C+=t[y].length,++y){var F=t[y];if(t.length>e.length)return;if(!(F instanceof s)){if(f&&y!=t.length-1){if(p.lastIndex=C,!(T=p.exec(e)))break;for(var v=T.index+(g?T[1].length:0),x=T.index+T[0].length,w=y,A=C,_=t.length;w<_&&(A<x||!t[w].type&&!t[w-1].greedy);++w)v>=(A+=t[w].length)&&(++y,C=A);if(t[y]instanceof s)continue;E=w-y,F=e.slice(C,A),T.index-=C}else{p.lastIndex=0;var T=p.exec(F),E=1}if(T){g&&(m=T[1]?T[1].length:0);x=(v=T.index+m)+(T=T[0].slice(m)).length;var L=F.slice(0,v),N=F.slice(x),S=[y,E];L&&(++y,C+=L.length,S.push(L));var I=new s(c,h?a.tokenize(T,h):T,b,T,f);if(S.push(I),N&&S.push(N),Array.prototype.splice.apply(t,S),1!=E&&a.matchGrammar(e,t,n,y,C,!0,c),r)break}else if(r)break}}}}},tokenize:function(e,t){var n=[e],s=t.rest;if(s){for(var o in s)t[o]=s[o];delete t.rest}return a.matchGrammar(e,n,t,0,0,!1),n},hooks:{all:{},add:function(e,t){var n=a.hooks.all;n[e]=n[e]||[],n[e].push(t)},run:function(e,t){var n=a.hooks.all[e];if(n&&n.length)for(var s,o=0;s=n[o++];)s(t)}},Token:s};function s(e,t,n,a,s){this.type=e,this.content=t,this.alias=n,this.length=0|(a||\"\").length,this.greedy=!!s}if(e.Prism=a,s.stringify=function(e,t,n){if(\"string\"==typeof e)return e;if(Array.isArray(e))return e.map(function(n){return s.stringify(n,t,e)}).join(\"\");var o={type:e.type,content:s.stringify(e.content,t,n),tag:\"span\",classes:[\"token\",e.type],attributes:{},language:t,parent:n};if(e.alias){var i=Array.isArray(e.alias)?e.alias:[e.alias];Array.prototype.push.apply(o.classes,i)}a.hooks.run(\"wrap\",o);var r=Object.keys(o.attributes).map(function(e){return e+'=\"'+(o.attributes[e]||\"\").replace(/\"/g,\"&quot;\")+'\"'}).join(\" \");return\"<\"+o.tag+' class=\"'+o.classes.join(\" \")+'\"'+(r?\" \"+r:\"\")+\">\"+o.content+\"</\"+o.tag+\">\"},!e.document)return e.addEventListener?(a.disableWorkerMessageHandler||e.addEventListener(\"message\",function(t){var n=JSON.parse(t.data),s=n.language,o=n.code,i=n.immediateClose;e.postMessage(a.highlight(o,a.languages[s],s)),i&&e.close()},!1),a):a;var o=document.currentScript||[].slice.call(document.getElementsByTagName(\"script\")).pop();return o&&(a.filename=o.src,a.manual||o.hasAttribute(\"data-manual\")||(\"loading\"!==document.readyState?window.requestAnimationFrame?window.requestAnimationFrame(a.highlightAll):window.setTimeout(a.highlightAll,16):document.addEventListener(\"DOMContentLoaded\",a.highlightAll))),a}(\"undefined\"!=typeof window?window:\"undefined\"!=typeof WorkerGlobalScope&&self instanceof WorkerGlobalScope?self:{});e.exports&&(e.exports=t),void 0!==commonjsGlobal&&(commonjsGlobal.Prism=t),t.languages.markup={comment:/<!--[\\s\\S]*?-->/,prolog:/<\\?[\\s\\S]+?\\?>/,doctype:/<!DOCTYPE[\\s\\S]+?>/i,cdata:/<!\\[CDATA\\[[\\s\\S]*?]]>/i,tag:{pattern:/<\\/?(?!\\d)[^\\s>\\/=$<%]+(?:\\s(?:\\s*[^\\s>\\/=]+(?:\\s*=\\s*(?:\"[^\"]*\"|'[^']*'|[^\\s'\">=]+(?=[\\s>]))|(?=[\\s/>])))+)?\\s*\\/?>/i,greedy:!0,inside:{tag:{pattern:/^<\\/?[^\\s>\\/]+/i,inside:{punctuation:/^<\\/?/,namespace:/^[^\\s>\\/:]+:/}},\"attr-value\":{pattern:/=\\s*(?:\"[^\"]*\"|'[^']*'|[^\\s'\">=]+)/i,inside:{punctuation:[/^=/,{pattern:/^(\\s*)[\"']|[\"']$/,lookbehind:!0}]}},punctuation:/\\/?>/,\"attr-name\":{pattern:/[^\\s>\\/]+/,inside:{namespace:/^[^\\s>\\/:]+:/}}}},entity:/&#?[\\da-z]{1,8};/i},t.languages.markup.tag.inside[\"attr-value\"].inside.entity=t.languages.markup.entity,t.hooks.add(\"wrap\",function(e){\"entity\"===e.type&&(e.attributes.title=e.content.replace(/&amp;/,\"&\"))}),Object.defineProperty(t.languages.markup.tag,\"addInlined\",{value:function(e,n){var a={};a[\"language-\"+n]={pattern:/(^<!\\[CDATA\\[)[\\s\\S]+?(?=\\]\\]>$)/i,lookbehind:!0,inside:t.languages[n]},a.cdata=/^<!\\[CDATA\\[|\\]\\]>$/i;var s={\"included-cdata\":{pattern:/<!\\[CDATA\\[[\\s\\S]*?\\]\\]>/i,inside:a}};s[\"language-\"+n]={pattern:/[\\s\\S]+/,inside:t.languages[n]};var o={};o[e]={pattern:RegExp(/(<__[\\s\\S]*?>)(?:<!\\[CDATA\\[[\\s\\S]*?\\]\\]>\\s*|[\\s\\S])*?(?=<\\/__>)/.source.replace(/__/g,e),\"i\"),lookbehind:!0,greedy:!0,inside:s},t.languages.insertBefore(\"markup\",\"cdata\",o)}}),t.languages.xml=t.languages.extend(\"markup\",{}),t.languages.html=t.languages.markup,t.languages.mathml=t.languages.markup,t.languages.svg=t.languages.markup,function(e){var t=/(\"|')(?:\\\\(?:\\r\\n|[\\s\\S])|(?!\\1)[^\\\\\\r\\n])*\\1/;e.languages.css={comment:/\\/\\*[\\s\\S]*?\\*\\//,atrule:{pattern:/@[\\w-]+?[\\s\\S]*?(?:;|(?=\\s*\\{))/i,inside:{rule:/@[\\w-]+/}},url:RegExp(\"url\\\\((?:\"+t.source+\"|.*?)\\\\)\",\"i\"),selector:RegExp(\"[^{}\\\\s](?:[^{};\\\"']|\"+t.source+\")*?(?=\\\\s*\\\\{)\"),string:{pattern:t,greedy:!0},property:/[-_a-z\\xA0-\\uFFFF][-\\w\\xA0-\\uFFFF]*(?=\\s*:)/i,important:/!important\\b/i,function:/[-a-z0-9]+(?=\\()/i,punctuation:/[(){};:,]/},e.languages.css.atrule.inside.rest=e.languages.css;var n=e.languages.markup;n&&(n.tag.addInlined(\"style\",\"css\"),e.languages.insertBefore(\"inside\",\"attr-value\",{\"style-attr\":{pattern:/\\s*style=(\"|')(?:\\\\[\\s\\S]|(?!\\1)[^\\\\])*\\1/i,inside:{\"attr-name\":{pattern:/^\\s*style/i,inside:n.tag.inside},punctuation:/^\\s*=\\s*['\"]|['\"]\\s*$/,\"attr-value\":{pattern:/.+/i,inside:e.languages.css}},alias:\"language-css\"}},n.tag))}(t),t.languages.clike={comment:[{pattern:/(^|[^\\\\])\\/\\*[\\s\\S]*?(?:\\*\\/|$)/,lookbehind:!0},{pattern:/(^|[^\\\\:])\\/\\/.*/,lookbehind:!0,greedy:!0}],string:{pattern:/([\"'])(?:\\\\(?:\\r\\n|[\\s\\S])|(?!\\1)[^\\\\\\r\\n])*\\1/,greedy:!0},\"class-name\":{pattern:/((?:\\b(?:class|interface|extends|implements|trait|instanceof|new)\\s+)|(?:catch\\s+\\())[\\w.\\\\]+/i,lookbehind:!0,inside:{punctuation:/[.\\\\]/}},keyword:/\\b(?:if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\\b/,boolean:/\\b(?:true|false)\\b/,function:/\\w+(?=\\()/,number:/\\b0x[\\da-f]+\\b|(?:\\b\\d+\\.?\\d*|\\B\\.\\d+)(?:e[+-]?\\d+)?/i,operator:/--?|\\+\\+?|!=?=?|<=?|>=?|==?=?|&&?|\\|\\|?|\\?|\\*|\\/|~|\\^|%/,punctuation:/[{}[\\];(),.:]/},t.languages.javascript=t.languages.extend(\"clike\",{\"class-name\":[t.languages.clike[\"class-name\"],{pattern:/(^|[^$\\w\\xA0-\\uFFFF])[_$A-Z\\xA0-\\uFFFF][$\\w\\xA0-\\uFFFF]*(?=\\.(?:prototype|constructor))/,lookbehind:!0}],keyword:[{pattern:/((?:^|})\\s*)(?:catch|finally)\\b/,lookbehind:!0},{pattern:/(^|[^.])\\b(?:as|async(?=\\s*(?:function\\b|\\(|[$\\w\\xA0-\\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\\b/,lookbehind:!0}],number:/\\b(?:(?:0[xX][\\dA-Fa-f]+|0[bB][01]+|0[oO][0-7]+)n?|\\d+n|NaN|Infinity)\\b|(?:\\b\\d+\\.?\\d*|\\B\\.\\d+)(?:[Ee][+-]?\\d+)?/,function:/[_$a-zA-Z\\xA0-\\uFFFF][$\\w\\xA0-\\uFFFF]*(?=\\s*(?:\\.\\s*(?:apply|bind|call)\\s*)?\\()/,operator:/-[-=]?|\\+[+=]?|!=?=?|<<?=?|>>?>?=?|=(?:==?|>)?|&[&=]?|\\|[|=]?|\\*\\*?=?|\\/=?|~|\\^=?|%=?|\\?|\\.{3}/}),t.languages.javascript[\"class-name\"][0].pattern=/(\\b(?:class|interface|extends|implements|instanceof|new)\\s+)[\\w.\\\\]+/,t.languages.insertBefore(\"javascript\",\"keyword\",{regex:{pattern:/((?:^|[^$\\w\\xA0-\\uFFFF.\"'\\])\\s])\\s*)\\/(\\[(?:[^\\]\\\\\\r\\n]|\\\\.)*]|\\\\.|[^/\\\\\\[\\r\\n])+\\/[gimyu]{0,5}(?=\\s*($|[\\r\\n,.;})\\]]))/,lookbehind:!0,greedy:!0},\"function-variable\":{pattern:/[_$a-zA-Z\\xA0-\\uFFFF][$\\w\\xA0-\\uFFFF]*(?=\\s*[=:]\\s*(?:async\\s*)?(?:\\bfunction\\b|(?:\\((?:[^()]|\\([^()]*\\))*\\)|[_$a-zA-Z\\xA0-\\uFFFF][$\\w\\xA0-\\uFFFF]*)\\s*=>))/,alias:\"function\"},parameter:[{pattern:/(function(?:\\s+[_$A-Za-z\\xA0-\\uFFFF][$\\w\\xA0-\\uFFFF]*)?\\s*\\(\\s*)(?!\\s)(?:[^()]|\\([^()]*\\))+?(?=\\s*\\))/,lookbehind:!0,inside:t.languages.javascript},{pattern:/[_$a-z\\xA0-\\uFFFF][$\\w\\xA0-\\uFFFF]*(?=\\s*=>)/i,inside:t.languages.javascript},{pattern:/(\\(\\s*)(?!\\s)(?:[^()]|\\([^()]*\\))+?(?=\\s*\\)\\s*=>)/,lookbehind:!0,inside:t.languages.javascript},{pattern:/((?:\\b|\\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\\w\\xA0-\\uFFFF]))(?:[_$A-Za-z\\xA0-\\uFFFF][$\\w\\xA0-\\uFFFF]*\\s*)\\(\\s*)(?!\\s)(?:[^()]|\\([^()]*\\))+?(?=\\s*\\)\\s*\\{)/,lookbehind:!0,inside:t.languages.javascript}],constant:/\\b[A-Z](?:[A-Z_]|\\dx?)*\\b/}),t.languages.insertBefore(\"javascript\",\"string\",{\"template-string\":{pattern:/`(?:\\\\[\\s\\S]|\\${[^}]+}|[^\\\\`])*`/,greedy:!0,inside:{interpolation:{pattern:/\\${[^}]+}/,inside:{\"interpolation-punctuation\":{pattern:/^\\${|}$/,alias:\"punctuation\"},rest:t.languages.javascript}},string:/[\\s\\S]+/}}}),t.languages.markup&&t.languages.markup.tag.addInlined(\"script\",\"javascript\"),t.languages.js=t.languages.javascript,\"undefined\"!=typeof self&&self.Prism&&self.document&&document.querySelector&&(self.Prism.fileHighlight=function(e){e=e||document;var n={js:\"javascript\",py:\"python\",rb:\"ruby\",ps1:\"powershell\",psm1:\"powershell\",sh:\"bash\",bat:\"batch\",h:\"c\",tex:\"latex\"};Array.prototype.slice.call(e.querySelectorAll(\"pre[data-src]\")).forEach(function(e){if(!e.hasAttribute(\"data-src-loaded\")){for(var a,s=e.getAttribute(\"data-src\"),o=e,i=/\\blang(?:uage)?-([\\w-]+)\\b/i;o&&!i.test(o.className);)o=o.parentNode;if(o&&(a=(e.className.match(i)||[,\"\"])[1]),!a){var r=(s.match(/\\.(\\w+)$/)||[,\"\"])[1];a=n[r]||r}var l=document.createElement(\"code\");l.className=\"language-\"+a,e.textContent=\"\",l.textContent=\"Loading\",e.appendChild(l);var c=new XMLHttpRequest;c.open(\"GET\",s,!0),c.onreadystatechange=function(){4==c.readyState&&(c.status<400&&c.responseText?(l.textContent=c.responseText,t.highlightElement(l),e.setAttribute(\"data-src-loaded\",\"\")):c.status>=400?l.textContent=\" Error \"+c.status+\" while fetching file: \"+c.statusText:l.textContent=\" Error: File does not exist or is empty\")},c.send(null)}}),t.plugins.toolbar&&t.plugins.toolbar.registerButton(\"download-file\",function(e){var t=e.element.parentNode;if(t&&/pre/i.test(t.nodeName)&&t.hasAttribute(\"data-src\")&&t.hasAttribute(\"data-download-link\")){var n=t.getAttribute(\"data-src\"),a=document.createElement(\"a\");return a.textContent=t.getAttribute(\"data-download-link-label\")||\"Download\",a.setAttribute(\"download\",\"\"),a.href=n,a}})},document.addEventListener(\"DOMContentLoaded\",function(){self.Prism.fileHighlight()}))}),CodeFlask=function(e,t){if(!e)throw Error(\"CodeFlask expects a parameter which is Element or a String selector\");if(!t)throw Error(\"CodeFlask expects an object containing options as second parameter\");if(e.nodeType)this.editorRoot=e;else{var n=document.querySelector(e);n&&(this.editorRoot=n)}this.opts=t,this.startEditor()};CodeFlask.prototype.startEditor=function(){if(!injectCss(editorCss,null,this.opts.styleParent))throw Error(\"Failed to inject CodeFlask CSS.\");this.createWrapper(),this.createTextarea(),this.createPre(),this.createCode(),this.runOptions(),this.listenTextarea(),this.populateDefault(),this.updateCode(this.code)},CodeFlask.prototype.createWrapper=function(){this.code=this.editorRoot.innerHTML,this.editorRoot.innerHTML=\"\",this.elWrapper=this.createElement(\"div\",this.editorRoot),this.elWrapper.classList.add(\"codeflask\")},CodeFlask.prototype.createTextarea=function(){this.elTextarea=this.createElement(\"textarea\",this.elWrapper),this.elTextarea.classList.add(\"codeflask__textarea\",\"codeflask__flatten\")},CodeFlask.prototype.createPre=function(){this.elPre=this.createElement(\"pre\",this.elWrapper),this.elPre.classList.add(\"codeflask__pre\",\"codeflask__flatten\")},CodeFlask.prototype.createCode=function(){this.elCode=this.createElement(\"code\",this.elPre),this.elCode.classList.add(\"codeflask__code\",\"language-\"+(this.opts.language||\"html\"))},CodeFlask.prototype.createLineNumbers=function(){this.elLineNumbers=this.createElement(\"div\",this.elWrapper),this.elLineNumbers.classList.add(\"codeflask__lines\"),this.setLineNumber()},CodeFlask.prototype.createElement=function(e,t){var n=document.createElement(e);return t.appendChild(n),n},CodeFlask.prototype.runOptions=function(){this.opts.rtl=this.opts.rtl||!1,this.opts.tabSize=this.opts.tabSize||2,this.opts.enableAutocorrect=this.opts.enableAutocorrect||!1,this.opts.lineNumbers=this.opts.lineNumbers||!1,this.opts.defaultTheme=!1!==this.opts.defaultTheme,this.opts.areaId=this.opts.areaId||null,this.opts.ariaLabelledby=this.opts.ariaLabelledby||null,this.opts.readonly=this.opts.readonly||null,\"boolean\"!=typeof this.opts.handleTabs&&(this.opts.handleTabs=!0),\"boolean\"!=typeof this.opts.handleSelfClosingCharacters&&(this.opts.handleSelfClosingCharacters=!0),\"boolean\"!=typeof this.opts.handleNewLineIndentation&&(this.opts.handleNewLineIndentation=!0),!0===this.opts.rtl&&(this.elTextarea.setAttribute(\"dir\",\"rtl\"),this.elPre.setAttribute(\"dir\",\"rtl\")),!1===this.opts.enableAutocorrect&&(this.elTextarea.setAttribute(\"spellcheck\",\"false\"),this.elTextarea.setAttribute(\"autocapitalize\",\"off\"),this.elTextarea.setAttribute(\"autocomplete\",\"off\"),this.elTextarea.setAttribute(\"autocorrect\",\"off\")),this.opts.lineNumbers&&(this.elWrapper.classList.add(\"codeflask--has-line-numbers\"),this.createLineNumbers()),this.opts.defaultTheme&&injectCss(defaultCssTheme,\"theme-default\",this.opts.styleParent),this.opts.areaId&&this.elTextarea.setAttribute(\"id\",this.opts.areaId),this.opts.ariaLabelledby&&this.elTextarea.setAttribute(\"aria-labelledby\",this.opts.ariaLabelledby),this.opts.readonly&&this.enableReadonlyMode()},CodeFlask.prototype.updateLineNumbersCount=function(){for(var e=\"\",t=1;t<=this.lineNumber;t++)e=e+'<span class=\"codeflask__lines__line\">'+t+\"</span>\";this.elLineNumbers.innerHTML=e},CodeFlask.prototype.listenTextarea=function(){var e=this;this.elTextarea.addEventListener(\"input\",function(t){e.code=t.target.value,e.elCode.innerHTML=escapeHtml(t.target.value),e.highlight(),setTimeout(function(){e.runUpdate(),e.setLineNumber()},1)}),this.elTextarea.addEventListener(\"keydown\",function(t){e.handleTabs(t),e.handleSelfClosingCharacters(t),e.handleNewLineIndentation(t)}),this.elTextarea.addEventListener(\"scroll\",function(t){e.elPre.style.transform=\"translate3d(-\"+t.target.scrollLeft+\"px, -\"+t.target.scrollTop+\"px, 0)\",e.elLineNumbers&&(e.elLineNumbers.style.transform=\"translate3d(0, -\"+t.target.scrollTop+\"px, 0)\")})},CodeFlask.prototype.handleTabs=function(e){if(this.opts.handleTabs){if(9!==e.keyCode)return;e.preventDefault();var t=this.elTextarea,n=t.selectionDirection,a=t.selectionStart,s=t.selectionEnd,o=t.value,i=o.substr(0,a),r=o.substring(a,s),l=o.substring(s),c=\" \".repeat(this.opts.tabSize);if(a!==s&&r.length>=c.length){var d=a-i.split(\"\\n\").pop().length,u=c.length,p=c.length;if(e.shiftKey)o.substr(d,c.length)===c?(u=-u,d>a?(r=r.substring(0,d)+r.substring(d+c.length),p=0):d===a?(u=0,p=0,r=r.substring(c.length)):(p=-p,i=i.substring(0,d)+i.substring(d+c.length))):(u=0,p=0),r=r.replace(new RegExp(\"\\n\"+c.split(\"\").join(\"\\\\\"),\"g\"),\"\\n\");else i=i.substr(0,d)+c+i.substring(d,a),r=r.replace(/\\n/g,\"\\n\"+c);t.value=i+r+l,t.selectionStart=a+u,t.selectionEnd=a+r.length+p,t.selectionDirection=n}else t.value=i+c+l,t.selectionStart=a+c.length,t.selectionEnd=a+c.length;var h=t.value;this.updateCode(h),this.elTextarea.selectionEnd=s+this.opts.tabSize}},CodeFlask.prototype.handleSelfClosingCharacters=function(e){if(this.opts.handleSelfClosingCharacters){var t=e.key;if([\"(\",\"[\",\"{\",\"<\",\"'\",'\"'].includes(t)||[\")\",\"]\",\"}\",\">\",\"'\",'\"'].includes(t))switch(t){case\"(\":case\")\":this.closeCharacter(t);break;case\"[\":case\"]\":this.closeCharacter(t);break;case\"{\":case\"}\":this.closeCharacter(t);break;case\"<\":case\">\":case\"'\":case'\"':this.closeCharacter(t)}}},CodeFlask.prototype.setLineNumber=function(){this.lineNumber=this.code.split(\"\\n\").length,this.opts.lineNumbers&&this.updateLineNumbersCount()},CodeFlask.prototype.handleNewLineIndentation=function(e){if(this.opts.handleNewLineIndentation&&13===e.keyCode){e.preventDefault();var t=this.elTextarea,n=t.selectionStart,a=t.selectionEnd,s=t.value,o=s.substr(0,n),i=s.substring(a),r=s.lastIndexOf(\"\\n\",n-1),l=r+s.slice(r+1).search(/[^ ]|$/),c=l>r?l-r:0,d=o+\"\\n\"+\" \".repeat(c)+i;t.value=d,t.selectionStart=n+c+1,t.selectionEnd=n+c+1,this.updateCode(t.value)}},CodeFlask.prototype.closeCharacter=function(e){var t=this.elTextarea.selectionStart,n=this.elTextarea.selectionEnd;if(this.skipCloseChar(e)){var a=this.code.substr(n,1)===e,s=a?n+1:n,o=!a&&[\"'\",'\"'].includes(e)?e:\"\",i=\"\"+this.code.substring(0,t)+o+this.code.substring(s);this.updateCode(i),this.elTextarea.selectionEnd=++this.elTextarea.selectionStart}else{var r=e;switch(e){case\"(\":r=String.fromCharCode(e.charCodeAt()+1);break;case\"<\":case\"{\":case\"[\":r=String.fromCharCode(e.charCodeAt()+2)}var l=this.code.substring(t,n),c=\"\"+this.code.substring(0,t)+l+r+this.code.substring(n);this.updateCode(c)}this.elTextarea.selectionEnd=t},CodeFlask.prototype.skipCloseChar=function(e){var t=this.elTextarea.selectionStart,n=this.elTextarea.selectionEnd,a=Math.abs(n-t)>0;return[\")\",\"}\",\"]\",\">\"].includes(e)||[\"'\",'\"'].includes(e)&&!a},CodeFlask.prototype.updateCode=function(e){this.code=e,this.elTextarea.value=e,this.elCode.innerHTML=escapeHtml(e),this.highlight(),this.setLineNumber(),setTimeout(this.runUpdate.bind(this),1)},CodeFlask.prototype.updateLanguage=function(e){var t=this.opts.language;this.elCode.classList.remove(\"language-\"+t),this.elCode.classList.add(\"language-\"+e),this.opts.language=e,this.highlight()},CodeFlask.prototype.addLanguage=function(e,t){prism.languages[e]=t},CodeFlask.prototype.populateDefault=function(){this.updateCode(this.code)},CodeFlask.prototype.highlight=function(){prism.highlightElement(this.elCode,!1)},CodeFlask.prototype.onUpdate=function(e){if(e&&\"[object Function]\"!=={}.toString.call(e))throw Error(\"CodeFlask expects callback of type Function\");this.updateCallBack=e},CodeFlask.prototype.getCode=function(){return this.code},CodeFlask.prototype.runUpdate=function(){this.updateCallBack&&this.updateCallBack(this.code)},CodeFlask.prototype.enableReadonlyMode=function(){this.elTextarea.setAttribute(\"readonly\",!0)},CodeFlask.prototype.disableReadonlyMode=function(){this.elTextarea.removeAttribute(\"readonly\")};/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CodeFlask);\n\n\n//# sourceURL=webpack://javascript/./node_modules/codeflask/build/codeflask.module.js?");

/***/ }),

/***/ "./node_modules/console-browserify/index.js":
/*!**************************************************!*\
  !*** ./node_modules/console-browserify/index.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*global window, global*/\nvar util = __webpack_require__(/*! util */ \"./node_modules/util/util.js\")\nvar assert = __webpack_require__(/*! assert */ \"./node_modules/assert/build/assert.js\")\nfunction now() { return new Date().getTime() }\n\nvar slice = Array.prototype.slice\nvar console\nvar times = {}\n\nif (typeof __webpack_require__.g !== \"undefined\" && __webpack_require__.g.console) {\n    console = __webpack_require__.g.console\n} else if (typeof window !== \"undefined\" && window.console) {\n    console = window.console\n} else {\n    console = {}\n}\n\nvar functions = [\n    [log, \"log\"],\n    [info, \"info\"],\n    [warn, \"warn\"],\n    [error, \"error\"],\n    [time, \"time\"],\n    [timeEnd, \"timeEnd\"],\n    [trace, \"trace\"],\n    [dir, \"dir\"],\n    [consoleAssert, \"assert\"]\n]\n\nfor (var i = 0; i < functions.length; i++) {\n    var tuple = functions[i]\n    var f = tuple[0]\n    var name = tuple[1]\n\n    if (!console[name]) {\n        console[name] = f\n    }\n}\n\nmodule.exports = console\n\nfunction log() {}\n\nfunction info() {\n    console.log.apply(console, arguments)\n}\n\nfunction warn() {\n    console.log.apply(console, arguments)\n}\n\nfunction error() {\n    console.warn.apply(console, arguments)\n}\n\nfunction time(label) {\n    times[label] = now()\n}\n\nfunction timeEnd(label) {\n    var time = times[label]\n    if (!time) {\n        throw new Error(\"No such label: \" + label)\n    }\n\n    delete times[label]\n    var duration = now() - time\n    console.log(label + \": \" + duration + \"ms\")\n}\n\nfunction trace() {\n    var err = new Error()\n    err.name = \"Trace\"\n    err.message = util.format.apply(null, arguments)\n    console.error(err.stack)\n}\n\nfunction dir(object) {\n    console.log(util.inspect(object) + \"\\n\")\n}\n\nfunction consoleAssert(expression) {\n    if (!expression) {\n        var arr = slice.call(arguments, 1)\n        assert.ok(false, util.format.apply(null, arr))\n    }\n}\n\n\n//# sourceURL=webpack://javascript/./node_modules/console-browserify/index.js?");

/***/ }),

/***/ "./node_modules/define-properties/index.js":
/*!*************************************************!*\
  !*** ./node_modules/define-properties/index.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar keys = __webpack_require__(/*! object-keys */ \"./node_modules/object-keys/index.js\");\nvar hasSymbols = typeof Symbol === 'function' && typeof Symbol('foo') === 'symbol';\n\nvar toStr = Object.prototype.toString;\nvar concat = Array.prototype.concat;\nvar origDefineProperty = Object.defineProperty;\n\nvar isFunction = function (fn) {\n\treturn typeof fn === 'function' && toStr.call(fn) === '[object Function]';\n};\n\nvar hasPropertyDescriptors = __webpack_require__(/*! has-property-descriptors */ \"./node_modules/has-property-descriptors/index.js\")();\n\nvar supportsDescriptors = origDefineProperty && hasPropertyDescriptors;\n\nvar defineProperty = function (object, name, value, predicate) {\n\tif (name in object && (!isFunction(predicate) || !predicate())) {\n\t\treturn;\n\t}\n\tif (supportsDescriptors) {\n\t\torigDefineProperty(object, name, {\n\t\t\tconfigurable: true,\n\t\t\tenumerable: false,\n\t\t\tvalue: value,\n\t\t\twritable: true\n\t\t});\n\t} else {\n\t\tobject[name] = value; // eslint-disable-line no-param-reassign\n\t}\n};\n\nvar defineProperties = function (object, map) {\n\tvar predicates = arguments.length > 2 ? arguments[2] : {};\n\tvar props = keys(map);\n\tif (hasSymbols) {\n\t\tprops = concat.call(props, Object.getOwnPropertySymbols(map));\n\t}\n\tfor (var i = 0; i < props.length; i += 1) {\n\t\tdefineProperty(object, props[i], map[props[i]], predicates[props[i]]);\n\t}\n};\n\ndefineProperties.supportsDescriptors = !!supportsDescriptors;\n\nmodule.exports = defineProperties;\n\n\n//# sourceURL=webpack://javascript/./node_modules/define-properties/index.js?");

/***/ }),

/***/ "./node_modules/doctrine/lib/doctrine.js":
/*!***********************************************!*\
  !*** ./node_modules/doctrine/lib/doctrine.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/*\n * @fileoverview Main Doctrine object\n * @author Yusuke Suzuki <utatane.tea@gmail.com>\n * @author Dan Tao <daniel.tao@gmail.com>\n * @author Andrew Eisenberg <andrew@eisenberg.as>\n */\n\n(function () {\n    'use strict';\n\n    var typed,\n        utility,\n        jsdoc,\n        esutils,\n        hasOwnProperty;\n\n    esutils = __webpack_require__(/*! esutils */ \"./node_modules/esutils/lib/utils.js\");\n    typed = __webpack_require__(/*! ./typed */ \"./node_modules/doctrine/lib/typed.js\");\n    utility = __webpack_require__(/*! ./utility */ \"./node_modules/doctrine/lib/utility.js\");\n\n    function sliceSource(source, index, last) {\n        return source.slice(index, last);\n    }\n\n    hasOwnProperty = (function () {\n        var func = Object.prototype.hasOwnProperty;\n        return function hasOwnProperty(obj, name) {\n            return func.call(obj, name);\n        };\n    }());\n    function shallowCopy(obj) {\n        var ret = {}, key;\n        for (key in obj) {\n            if (obj.hasOwnProperty(key)) {\n                ret[key] = obj[key];\n            }\n        }\n        return ret;\n    }\n\n    function isASCIIAlphanumeric(ch) {\n        return (ch >= 0x61  /* 'a' */ && ch <= 0x7A  /* 'z' */) ||\n            (ch >= 0x41  /* 'A' */ && ch <= 0x5A  /* 'Z' */) ||\n            (ch >= 0x30  /* '0' */ && ch <= 0x39  /* '9' */);\n    }\n\n    function isParamTitle(title) {\n        return title === 'param' || title === 'argument' || title === 'arg';\n    }\n\n    function isReturnTitle(title) {\n        return title === 'return' || title === 'returns';\n    }\n\n    function isProperty(title) {\n        return title === 'property' || title === 'prop';\n    }\n\n    function isNameParameterRequired(title) {\n        return isParamTitle(title) || isProperty(title) ||\n            title === 'alias' || title === 'this' || title === 'mixes' || title === 'requires';\n    }\n\n    function isAllowedName(title) {\n        return isNameParameterRequired(title) || title === 'const' || title === 'constant';\n    }\n\n    function isAllowedNested(title) {\n        return isProperty(title) || isParamTitle(title);\n    }\n\n    function isAllowedOptional(title) {\n        return isProperty(title) || isParamTitle(title);\n    }\n\n    function isTypeParameterRequired(title) {\n        return isParamTitle(title) || isReturnTitle(title) ||\n            title === 'define' || title === 'enum' ||\n            title === 'implements' || title === 'this' ||\n            title === 'type' || title === 'typedef' || isProperty(title);\n    }\n\n    // Consider deprecation instead using 'isTypeParameterRequired' and 'Rules' declaration to pick when a type is optional/required\n    // This would require changes to 'parseType'\n    function isAllowedType(title) {\n        return isTypeParameterRequired(title) || title === 'throws' || title === 'const' || title === 'constant' ||\n            title === 'namespace' || title === 'member' || title === 'var' || title === 'module' ||\n            title === 'constructor' || title === 'class' || title === 'extends' || title === 'augments' ||\n            title === 'public' || title === 'private' || title === 'protected';\n    }\n\n    // A regex character class that contains all whitespace except linebreak characters (\\r, \\n, \\u2028, \\u2029)\n    var WHITESPACE = '[ \\\\f\\\\t\\\\v\\\\u00a0\\\\u1680\\\\u180e\\\\u2000-\\\\u200a\\\\u202f\\\\u205f\\\\u3000\\\\ufeff]';\n\n    var STAR_MATCHER = '(' + WHITESPACE + '*(?:\\\\*' + WHITESPACE + '?)?)(.+|[\\r\\n\\u2028\\u2029])';\n\n    function unwrapComment(doc) {\n        // JSDoc comment is following form\n        //   /**\n        //    * .......\n        //    */\n\n        return doc.\n            // remove /**\n            replace(/^\\/\\*\\*?/, '').\n            // remove */\n            replace(/\\*\\/$/, '').\n            // remove ' * ' at the beginning of a line\n            replace(new RegExp(STAR_MATCHER, 'g'), '$2').\n            // remove trailing whitespace\n            replace(/\\s*$/, '');\n    }\n\n    /**\n     * Converts an index in an \"unwrapped\" JSDoc comment to the corresponding index in the original \"wrapped\" version\n     * @param {string} originalSource The original wrapped comment\n     * @param {number} unwrappedIndex The index of a character in the unwrapped string\n     * @returns {number} The index of the corresponding character in the original wrapped string\n     */\n    function convertUnwrappedCommentIndex(originalSource, unwrappedIndex) {\n        var replacedSource = originalSource.replace(/^\\/\\*\\*?/, '');\n        var numSkippedChars = 0;\n        var matcher = new RegExp(STAR_MATCHER, 'g');\n        var match;\n\n        while ((match = matcher.exec(replacedSource))) {\n            numSkippedChars += match[1].length;\n\n            if (match.index + match[0].length > unwrappedIndex + numSkippedChars) {\n                return unwrappedIndex + numSkippedChars + originalSource.length - replacedSource.length;\n            }\n        }\n\n        return originalSource.replace(/\\*\\/$/, '').replace(/\\s*$/, '').length;\n    }\n\n    // JSDoc Tag Parser\n\n    (function (exports) {\n        var Rules,\n            index,\n            lineNumber,\n            length,\n            source,\n            originalSource,\n            recoverable,\n            sloppy,\n            strict;\n\n        function advance() {\n            var ch = source.charCodeAt(index);\n            index += 1;\n            if (esutils.code.isLineTerminator(ch) && !(ch === 0x0D  /* '\\r' */ && source.charCodeAt(index) === 0x0A  /* '\\n' */)) {\n                lineNumber += 1;\n            }\n            return String.fromCharCode(ch);\n        }\n\n        function scanTitle() {\n            var title = '';\n            // waste '@'\n            advance();\n\n            while (index < length && isASCIIAlphanumeric(source.charCodeAt(index))) {\n                title += advance();\n            }\n\n            return title;\n        }\n\n        function seekContent() {\n            var ch, waiting, last = index;\n\n            waiting = false;\n            while (last < length) {\n                ch = source.charCodeAt(last);\n                if (esutils.code.isLineTerminator(ch) && !(ch === 0x0D  /* '\\r' */ && source.charCodeAt(last + 1) === 0x0A  /* '\\n' */)) {\n                    waiting = true;\n                } else if (waiting) {\n                    if (ch === 0x40  /* '@' */) {\n                        break;\n                    }\n                    if (!esutils.code.isWhiteSpace(ch)) {\n                        waiting = false;\n                    }\n                }\n                last += 1;\n            }\n            return last;\n        }\n\n        // type expression may have nest brace, such as,\n        // { { ok: string } }\n        //\n        // therefore, scanning type expression with balancing braces.\n        function parseType(title, last, addRange) {\n            var ch, brace, type, startIndex, direct = false;\n\n\n            // search '{'\n            while (index < last) {\n                ch = source.charCodeAt(index);\n                if (esutils.code.isWhiteSpace(ch)) {\n                    advance();\n                } else if (ch === 0x7B  /* '{' */) {\n                    advance();\n                    break;\n                } else {\n                    // this is direct pattern\n                    direct = true;\n                    break;\n                }\n            }\n\n\n            if (direct) {\n                return null;\n            }\n\n            // type expression { is found\n            brace = 1;\n            type = '';\n            while (index < last) {\n                ch = source.charCodeAt(index);\n                if (esutils.code.isLineTerminator(ch)) {\n                    advance();\n                } else {\n                    if (ch === 0x7D  /* '}' */) {\n                        brace -= 1;\n                        if (brace === 0) {\n                            advance();\n                            break;\n                        }\n                    } else if (ch === 0x7B  /* '{' */) {\n                        brace += 1;\n                    }\n                    if (type === '') {\n                        startIndex = index;\n                    }\n                    type += advance();\n                }\n            }\n\n            if (brace !== 0) {\n                // braces is not balanced\n                return utility.throwError('Braces are not balanced');\n            }\n\n            if (isAllowedOptional(title)) {\n                return typed.parseParamType(type, {startIndex: convertIndex(startIndex), range: addRange});\n            }\n\n            return typed.parseType(type, {startIndex: convertIndex(startIndex), range: addRange});\n        }\n\n        function scanIdentifier(last) {\n            var identifier;\n            if (!esutils.code.isIdentifierStartES5(source.charCodeAt(index)) && !source[index].match(/[0-9]/)) {\n                return null;\n            }\n            identifier = advance();\n            while (index < last && esutils.code.isIdentifierPartES5(source.charCodeAt(index))) {\n                identifier += advance();\n            }\n            return identifier;\n        }\n\n        function skipWhiteSpace(last) {\n            while (index < last && (esutils.code.isWhiteSpace(source.charCodeAt(index)) || esutils.code.isLineTerminator(source.charCodeAt(index)))) {\n                advance();\n            }\n        }\n\n        function parseName(last, allowBrackets, allowNestedParams) {\n            var name = '',\n                useBrackets,\n                insideString;\n\n\n            skipWhiteSpace(last);\n\n            if (index >= last) {\n                return null;\n            }\n\n            if (source.charCodeAt(index) === 0x5B  /* '[' */) {\n                if (allowBrackets) {\n                    useBrackets = true;\n                    name = advance();\n                } else {\n                    return null;\n                }\n            }\n\n            name += scanIdentifier(last);\n\n            if (allowNestedParams) {\n                if (source.charCodeAt(index) === 0x3A /* ':' */ && (\n                        name === 'module' ||\n                        name === 'external' ||\n                        name === 'event')) {\n                    name += advance();\n                    name += scanIdentifier(last);\n\n                }\n                if(source.charCodeAt(index) === 0x5B  /* '[' */ && source.charCodeAt(index + 1) === 0x5D  /* ']' */){\n                    name += advance();\n                    name += advance();\n                }\n                while (source.charCodeAt(index) === 0x2E  /* '.' */ ||\n                        source.charCodeAt(index) === 0x2F  /* '/' */ ||\n                        source.charCodeAt(index) === 0x23  /* '#' */ ||\n                        source.charCodeAt(index) === 0x2D  /* '-' */ ||\n                        source.charCodeAt(index) === 0x7E  /* '~' */) {\n                    name += advance();\n                    name += scanIdentifier(last);\n                }\n            }\n\n            if (useBrackets) {\n                skipWhiteSpace(last);\n                // do we have a default value for this?\n                if (source.charCodeAt(index) === 0x3D  /* '=' */) {\n                    // consume the '='' symbol\n                    name += advance();\n                    skipWhiteSpace(last);\n\n                    var ch;\n                    var bracketDepth = 1;\n\n                    // scan in the default value\n                    while (index < last) {\n                        ch = source.charCodeAt(index);\n\n                        if (esutils.code.isWhiteSpace(ch)) {\n                            if (!insideString) {\n                                skipWhiteSpace(last);\n                                ch = source.charCodeAt(index);\n                            }\n                        }\n\n                        if (ch === 0x27 /* ''' */) {\n                            if (!insideString) {\n                                insideString = '\\'';\n                            } else {\n                                if (insideString === '\\'') {\n                                    insideString = '';\n                                }\n                            }\n                        }\n\n                        if (ch === 0x22 /* '\"' */) {\n                            if (!insideString) {\n                                insideString = '\"';\n                            } else {\n                                if (insideString === '\"') {\n                                    insideString = '';\n                                }\n                            }\n                        }\n\n                        if (ch === 0x5B /* '[' */) {\n                            bracketDepth++;\n                        } else if (ch === 0x5D  /* ']' */ &&\n                            --bracketDepth === 0) {\n                            break;\n                        }\n\n                        name += advance();\n                    }\n                }\n\n                skipWhiteSpace(last);\n\n                if (index >= last || source.charCodeAt(index) !== 0x5D  /* ']' */) {\n                    // we never found a closing ']'\n                    return null;\n                }\n\n                // collect the last ']'\n                name += advance();\n            }\n\n            return name;\n        }\n\n        function skipToTag() {\n            while (index < length && source.charCodeAt(index) !== 0x40  /* '@' */) {\n                advance();\n            }\n            if (index >= length) {\n                return false;\n            }\n            utility.assert(source.charCodeAt(index) === 0x40  /* '@' */);\n            return true;\n        }\n\n        function convertIndex(rangeIndex) {\n            if (source === originalSource) {\n                return rangeIndex;\n            }\n            return convertUnwrappedCommentIndex(originalSource, rangeIndex);\n        }\n\n        function TagParser(options, title) {\n            this._options = options;\n            this._title = title.toLowerCase();\n            this._tag = {\n                title: title,\n                description: null\n            };\n            if (this._options.lineNumbers) {\n                this._tag.lineNumber = lineNumber;\n            }\n            this._first = index - title.length - 1;\n            this._last = 0;\n            // space to save special information for title parsers.\n            this._extra = { };\n        }\n\n        // addError(err, ...)\n        TagParser.prototype.addError = function addError(errorText) {\n            var args = Array.prototype.slice.call(arguments, 1),\n                msg = errorText.replace(\n                    /%(\\d)/g,\n                    function (whole, index) {\n                        utility.assert(index < args.length, 'Message reference must be in range');\n                        return args[index];\n                    }\n                );\n\n            if (!this._tag.errors) {\n                this._tag.errors = [];\n            }\n            if (strict) {\n                utility.throwError(msg);\n            }\n            this._tag.errors.push(msg);\n            return recoverable;\n        };\n\n        TagParser.prototype.parseType = function () {\n            // type required titles\n            if (isTypeParameterRequired(this._title)) {\n                try {\n                    this._tag.type = parseType(this._title, this._last, this._options.range);\n                    if (!this._tag.type) {\n                        if (!isParamTitle(this._title) && !isReturnTitle(this._title)) {\n                            if (!this.addError('Missing or invalid tag type')) {\n                                return false;\n                            }\n                        }\n                    }\n                } catch (error) {\n                    this._tag.type = null;\n                    if (!this.addError(error.message)) {\n                        return false;\n                    }\n                }\n            } else if (isAllowedType(this._title)) {\n                // optional types\n                try {\n                    this._tag.type = parseType(this._title, this._last, this._options.range);\n                } catch (e) {\n                    //For optional types, lets drop the thrown error when we hit the end of the file\n                }\n            }\n            return true;\n        };\n\n        TagParser.prototype._parseNamePath = function (optional) {\n            var name;\n            name = parseName(this._last, sloppy && isAllowedOptional(this._title), true);\n            if (!name) {\n                if (!optional) {\n                    if (!this.addError('Missing or invalid tag name')) {\n                        return false;\n                    }\n                }\n            }\n            this._tag.name = name;\n            return true;\n        };\n\n        TagParser.prototype.parseNamePath = function () {\n            return this._parseNamePath(false);\n        };\n\n        TagParser.prototype.parseNamePathOptional = function () {\n            return this._parseNamePath(true);\n        };\n\n\n        TagParser.prototype.parseName = function () {\n            var assign, name;\n\n            // param, property requires name\n            if (isAllowedName(this._title)) {\n                this._tag.name = parseName(this._last, sloppy && isAllowedOptional(this._title), isAllowedNested(this._title));\n                if (!this._tag.name) {\n                    if (!isNameParameterRequired(this._title)) {\n                        return true;\n                    }\n\n                    // it's possible the name has already been parsed but interpreted as a type\n                    // it's also possible this is a sloppy declaration, in which case it will be\n                    // fixed at the end\n                    if (isParamTitle(this._title) && this._tag.type && this._tag.type.name) {\n                        this._extra.name = this._tag.type;\n                        this._tag.name = this._tag.type.name;\n                        this._tag.type = null;\n                    } else {\n                        if (!this.addError('Missing or invalid tag name')) {\n                            return false;\n                        }\n                    }\n                } else {\n                    name = this._tag.name;\n                    if (name.charAt(0) === '[' && name.charAt(name.length - 1) === ']') {\n                        // extract the default value if there is one\n                        // example: @param {string} [somebody=John Doe] description\n                        assign = name.substring(1, name.length - 1).split('=');\n                        if (assign.length > 1) {\n                            this._tag['default'] = assign.slice(1).join('=');\n                        }\n                        this._tag.name = assign[0];\n\n                        // convert to an optional type\n                        if (this._tag.type && this._tag.type.type !== 'OptionalType') {\n                            this._tag.type = {\n                                type: 'OptionalType',\n                                expression: this._tag.type\n                            };\n                        }\n                    }\n                }\n            }\n\n\n            return true;\n        };\n\n        TagParser.prototype.parseDescription = function parseDescription() {\n            var description = sliceSource(source, index, this._last).trim();\n            if (description) {\n                if ((/^-\\s+/).test(description)) {\n                    description = description.substring(2);\n                }\n                this._tag.description = description;\n            }\n            return true;\n        };\n\n        TagParser.prototype.parseCaption = function parseDescription() {\n            var description = sliceSource(source, index, this._last).trim();\n            var captionStartTag = '<caption>';\n            var captionEndTag = '</caption>';\n            var captionStart = description.indexOf(captionStartTag);\n            var captionEnd = description.indexOf(captionEndTag);\n            if (captionStart >= 0 && captionEnd >= 0) {\n                this._tag.caption = description.substring(\n                    captionStart + captionStartTag.length, captionEnd).trim();\n                this._tag.description = description.substring(captionEnd + captionEndTag.length).trim();\n            } else {\n                this._tag.description = description;\n            }\n            return true;\n        };\n\n        TagParser.prototype.parseKind = function parseKind() {\n            var kind, kinds;\n            kinds = {\n                'class': true,\n                'constant': true,\n                'event': true,\n                'external': true,\n                'file': true,\n                'function': true,\n                'member': true,\n                'mixin': true,\n                'module': true,\n                'namespace': true,\n                'typedef': true\n            };\n            kind = sliceSource(source, index, this._last).trim();\n            this._tag.kind = kind;\n            if (!hasOwnProperty(kinds, kind)) {\n                if (!this.addError('Invalid kind name \\'%0\\'', kind)) {\n                    return false;\n                }\n            }\n            return true;\n        };\n\n        TagParser.prototype.parseAccess = function parseAccess() {\n            var access;\n            access = sliceSource(source, index, this._last).trim();\n            this._tag.access = access;\n            if (access !== 'private' && access !== 'protected' && access !== 'public') {\n                if (!this.addError('Invalid access name \\'%0\\'', access)) {\n                    return false;\n                }\n            }\n            return true;\n        };\n\n        TagParser.prototype.parseThis = function parseThis() {\n            // this name may be a name expression (e.g. {foo.bar}),\n            // an union (e.g. {foo.bar|foo.baz}) or a name path (e.g. foo.bar)\n            var value = sliceSource(source, index, this._last).trim();\n            if (value && value.charAt(0) === '{') {\n                var gotType = this.parseType();\n                if (gotType && this._tag.type.type === 'NameExpression' || this._tag.type.type === 'UnionType') {\n                    this._tag.name = this._tag.type.name;\n                    return true;\n                } else {\n                    return this.addError('Invalid name for this');\n                }\n            } else {\n                return this.parseNamePath();\n            }\n        };\n\n        TagParser.prototype.parseVariation = function parseVariation() {\n            var variation, text;\n            text = sliceSource(source, index, this._last).trim();\n            variation = parseFloat(text, 10);\n            this._tag.variation = variation;\n            if (isNaN(variation)) {\n                if (!this.addError('Invalid variation \\'%0\\'', text)) {\n                    return false;\n                }\n            }\n            return true;\n        };\n\n        TagParser.prototype.ensureEnd = function () {\n            var shouldBeEmpty = sliceSource(source, index, this._last).trim();\n            if (shouldBeEmpty) {\n                if (!this.addError('Unknown content \\'%0\\'', shouldBeEmpty)) {\n                    return false;\n                }\n            }\n            return true;\n        };\n\n        TagParser.prototype.epilogue = function epilogue() {\n            var description;\n\n            description = this._tag.description;\n            // un-fix potentially sloppy declaration\n            if (isAllowedOptional(this._title) && !this._tag.type && description && description.charAt(0) === '[') {\n                this._tag.type = this._extra.name;\n                if (!this._tag.name) {\n                    this._tag.name = undefined;\n                }\n\n                if (!sloppy) {\n                    if (!this.addError('Missing or invalid tag name')) {\n                        return false;\n                    }\n                }\n            }\n\n            return true;\n        };\n\n        Rules = {\n            // http://usejsdoc.org/tags-access.html\n            'access': ['parseAccess'],\n            // http://usejsdoc.org/tags-alias.html\n            'alias': ['parseNamePath', 'ensureEnd'],\n            // http://usejsdoc.org/tags-augments.html\n            'augments': ['parseType', 'parseNamePathOptional', 'ensureEnd'],\n            // http://usejsdoc.org/tags-constructor.html\n            'constructor': ['parseType', 'parseNamePathOptional', 'ensureEnd'],\n            // Synonym: http://usejsdoc.org/tags-constructor.html\n            'class': ['parseType', 'parseNamePathOptional', 'ensureEnd'],\n            // Synonym: http://usejsdoc.org/tags-extends.html\n            'extends': ['parseType', 'parseNamePathOptional', 'ensureEnd'],\n            // http://usejsdoc.org/tags-example.html\n            'example': ['parseCaption'],\n            // http://usejsdoc.org/tags-deprecated.html\n            'deprecated': ['parseDescription'],\n            // http://usejsdoc.org/tags-global.html\n            'global': ['ensureEnd'],\n            // http://usejsdoc.org/tags-inner.html\n            'inner': ['ensureEnd'],\n            // http://usejsdoc.org/tags-instance.html\n            'instance': ['ensureEnd'],\n            // http://usejsdoc.org/tags-kind.html\n            'kind': ['parseKind'],\n            // http://usejsdoc.org/tags-mixes.html\n            'mixes': ['parseNamePath', 'ensureEnd'],\n            // http://usejsdoc.org/tags-mixin.html\n            'mixin': ['parseNamePathOptional', 'ensureEnd'],\n            // http://usejsdoc.org/tags-member.html\n            'member': ['parseType', 'parseNamePathOptional', 'ensureEnd'],\n            // http://usejsdoc.org/tags-method.html\n            'method': ['parseNamePathOptional', 'ensureEnd'],\n            // http://usejsdoc.org/tags-module.html\n            'module': ['parseType', 'parseNamePathOptional', 'ensureEnd'],\n            // Synonym: http://usejsdoc.org/tags-method.html\n            'func': ['parseNamePathOptional', 'ensureEnd'],\n            // Synonym: http://usejsdoc.org/tags-method.html\n            'function': ['parseNamePathOptional', 'ensureEnd'],\n            // Synonym: http://usejsdoc.org/tags-member.html\n            'var': ['parseType', 'parseNamePathOptional', 'ensureEnd'],\n            // http://usejsdoc.org/tags-name.html\n            'name': ['parseNamePath', 'ensureEnd'],\n            // http://usejsdoc.org/tags-namespace.html\n            'namespace': ['parseType', 'parseNamePathOptional', 'ensureEnd'],\n            // http://usejsdoc.org/tags-private.html\n            'private': ['parseType', 'parseDescription'],\n            // http://usejsdoc.org/tags-protected.html\n            'protected': ['parseType', 'parseDescription'],\n            // http://usejsdoc.org/tags-public.html\n            'public': ['parseType', 'parseDescription'],\n            // http://usejsdoc.org/tags-readonly.html\n            'readonly': ['ensureEnd'],\n            // http://usejsdoc.org/tags-requires.html\n            'requires': ['parseNamePath', 'ensureEnd'],\n            // http://usejsdoc.org/tags-since.html\n            'since': ['parseDescription'],\n            // http://usejsdoc.org/tags-static.html\n            'static': ['ensureEnd'],\n            // http://usejsdoc.org/tags-summary.html\n            'summary': ['parseDescription'],\n            // http://usejsdoc.org/tags-this.html\n            'this': ['parseThis', 'ensureEnd'],\n            // http://usejsdoc.org/tags-todo.html\n            'todo': ['parseDescription'],\n            // http://usejsdoc.org/tags-typedef.html\n            'typedef': ['parseType', 'parseNamePathOptional'],\n            // http://usejsdoc.org/tags-variation.html\n            'variation': ['parseVariation'],\n            // http://usejsdoc.org/tags-version.html\n            'version': ['parseDescription']\n        };\n\n        TagParser.prototype.parse = function parse() {\n            var i, iz, sequences, method;\n\n\n            // empty title\n            if (!this._title) {\n                if (!this.addError('Missing or invalid title')) {\n                    return null;\n                }\n            }\n\n            // Seek to content last index.\n            this._last = seekContent(this._title);\n\n            if (this._options.range) {\n                this._tag.range = [this._first, source.slice(0, this._last).replace(/\\s*$/, '').length].map(convertIndex);\n            }\n\n            if (hasOwnProperty(Rules, this._title)) {\n                sequences = Rules[this._title];\n            } else {\n                // default sequences\n                sequences = ['parseType', 'parseName', 'parseDescription', 'epilogue'];\n            }\n\n            for (i = 0, iz = sequences.length; i < iz; ++i) {\n                method = sequences[i];\n                if (!this[method]()) {\n                    return null;\n                }\n            }\n\n            return this._tag;\n        };\n\n        function parseTag(options) {\n            var title, parser, tag;\n\n            // skip to tag\n            if (!skipToTag()) {\n                return null;\n            }\n\n            // scan title\n            title = scanTitle();\n\n            // construct tag parser\n            parser = new TagParser(options, title);\n            tag = parser.parse();\n\n            // Seek global index to end of this tag.\n            while (index < parser._last) {\n                advance();\n            }\n\n            return tag;\n        }\n\n        //\n        // Parse JSDoc\n        //\n\n        function scanJSDocDescription(preserveWhitespace) {\n            var description = '', ch, atAllowed;\n\n            atAllowed = true;\n            while (index < length) {\n                ch = source.charCodeAt(index);\n\n                if (atAllowed && ch === 0x40  /* '@' */) {\n                    break;\n                }\n\n                if (esutils.code.isLineTerminator(ch)) {\n                    atAllowed = true;\n                } else if (atAllowed && !esutils.code.isWhiteSpace(ch)) {\n                    atAllowed = false;\n                }\n\n                description += advance();\n            }\n\n            return preserveWhitespace ? description : description.trim();\n        }\n\n        function parse(comment, options) {\n            var tags = [], tag, description, interestingTags, i, iz;\n\n            if (options === undefined) {\n                options = {};\n            }\n\n            if (typeof options.unwrap === 'boolean' && options.unwrap) {\n                source = unwrapComment(comment);\n            } else {\n                source = comment;\n            }\n\n            originalSource = comment;\n\n            // array of relevant tags\n            if (options.tags) {\n                if (Array.isArray(options.tags)) {\n                    interestingTags = { };\n                    for (i = 0, iz = options.tags.length; i < iz; i++) {\n                        if (typeof options.tags[i] === 'string') {\n                            interestingTags[options.tags[i]] = true;\n                        } else {\n                            utility.throwError('Invalid \"tags\" parameter: ' + options.tags);\n                        }\n                    }\n                } else {\n                    utility.throwError('Invalid \"tags\" parameter: ' + options.tags);\n                }\n            }\n\n            length = source.length;\n            index = 0;\n            lineNumber = 0;\n            recoverable = options.recoverable;\n            sloppy = options.sloppy;\n            strict = options.strict;\n\n            description = scanJSDocDescription(options.preserveWhitespace);\n\n            while (true) {\n                tag = parseTag(options);\n                if (!tag) {\n                    break;\n                }\n                if (!interestingTags || interestingTags.hasOwnProperty(tag.title)) {\n                    tags.push(tag);\n                }\n            }\n\n            return {\n                description: description,\n                tags: tags\n            };\n        }\n        exports.parse = parse;\n    }(jsdoc = {}));\n\n    exports.version = utility.VERSION;\n    exports.parse = jsdoc.parse;\n    exports.parseType = typed.parseType;\n    exports.parseParamType = typed.parseParamType;\n    exports.unwrapComment = unwrapComment;\n    exports.Syntax = shallowCopy(typed.Syntax);\n    exports.Error = utility.DoctrineError;\n    exports.type = {\n        Syntax: exports.Syntax,\n        parseType: typed.parseType,\n        parseParamType: typed.parseParamType,\n        stringify: typed.stringify\n    };\n}());\n/* vim: set sw=4 ts=4 et tw=80 : */\n\n\n//# sourceURL=webpack://javascript/./node_modules/doctrine/lib/doctrine.js?");

/***/ }),

/***/ "./node_modules/doctrine/lib/typed.js":
/*!********************************************!*\
  !*** ./node_modules/doctrine/lib/typed.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/*\n * @fileoverview Type expression parser.\n * @author Yusuke Suzuki <utatane.tea@gmail.com>\n * @author Dan Tao <daniel.tao@gmail.com>\n * @author Andrew Eisenberg <andrew@eisenberg.as>\n */\n\n// \"typed\", the Type Expression Parser for doctrine.\n\n(function () {\n    'use strict';\n\n    var Syntax,\n        Token,\n        source,\n        length,\n        index,\n        previous,\n        token,\n        value,\n        esutils,\n        utility,\n        rangeOffset,\n        addRange;\n\n    esutils = __webpack_require__(/*! esutils */ \"./node_modules/esutils/lib/utils.js\");\n    utility = __webpack_require__(/*! ./utility */ \"./node_modules/doctrine/lib/utility.js\");\n\n    Syntax = {\n        NullableLiteral: 'NullableLiteral',\n        AllLiteral: 'AllLiteral',\n        NullLiteral: 'NullLiteral',\n        UndefinedLiteral: 'UndefinedLiteral',\n        VoidLiteral: 'VoidLiteral',\n        UnionType: 'UnionType',\n        ArrayType: 'ArrayType',\n        RecordType: 'RecordType',\n        FieldType: 'FieldType',\n        FunctionType: 'FunctionType',\n        ParameterType: 'ParameterType',\n        RestType: 'RestType',\n        NonNullableType: 'NonNullableType',\n        OptionalType: 'OptionalType',\n        NullableType: 'NullableType',\n        NameExpression: 'NameExpression',\n        TypeApplication: 'TypeApplication',\n        StringLiteralType: 'StringLiteralType',\n        NumericLiteralType: 'NumericLiteralType',\n        BooleanLiteralType: 'BooleanLiteralType'\n    };\n\n    Token = {\n        ILLEGAL: 0,    // ILLEGAL\n        DOT_LT: 1,     // .<\n        REST: 2,       // ...\n        LT: 3,         // <\n        GT: 4,         // >\n        LPAREN: 5,     // (\n        RPAREN: 6,     // )\n        LBRACE: 7,     // {\n        RBRACE: 8,     // }\n        LBRACK: 9,    // [\n        RBRACK: 10,    // ]\n        COMMA: 11,     // ,\n        COLON: 12,     // :\n        STAR: 13,      // *\n        PIPE: 14,      // |\n        QUESTION: 15,  // ?\n        BANG: 16,      // !\n        EQUAL: 17,     // =\n        NAME: 18,      // name token\n        STRING: 19,    // string\n        NUMBER: 20,    // number\n        EOF: 21\n    };\n\n    function isTypeName(ch) {\n        return '><(){}[],:*|?!='.indexOf(String.fromCharCode(ch)) === -1 && !esutils.code.isWhiteSpace(ch) && !esutils.code.isLineTerminator(ch);\n    }\n\n    function Context(previous, index, token, value) {\n        this._previous = previous;\n        this._index = index;\n        this._token = token;\n        this._value = value;\n    }\n\n    Context.prototype.restore = function () {\n        previous = this._previous;\n        index = this._index;\n        token = this._token;\n        value = this._value;\n    };\n\n    Context.save = function () {\n        return new Context(previous, index, token, value);\n    };\n\n    function maybeAddRange(node, range) {\n        if (addRange) {\n            node.range = [range[0] + rangeOffset, range[1] + rangeOffset];\n        }\n        return node;\n    }\n\n    function advance() {\n        var ch = source.charAt(index);\n        index += 1;\n        return ch;\n    }\n\n    function scanHexEscape(prefix) {\n        var i, len, ch, code = 0;\n\n        len = (prefix === 'u') ? 4 : 2;\n        for (i = 0; i < len; ++i) {\n            if (index < length && esutils.code.isHexDigit(source.charCodeAt(index))) {\n                ch = advance();\n                code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());\n            } else {\n                return '';\n            }\n        }\n        return String.fromCharCode(code);\n    }\n\n    function scanString() {\n        var str = '', quote, ch, code, unescaped, restore; //TODO review removal octal = false\n        quote = source.charAt(index);\n        ++index;\n\n        while (index < length) {\n            ch = advance();\n\n            if (ch === quote) {\n                quote = '';\n                break;\n            } else if (ch === '\\\\') {\n                ch = advance();\n                if (!esutils.code.isLineTerminator(ch.charCodeAt(0))) {\n                    switch (ch) {\n                    case 'n':\n                        str += '\\n';\n                        break;\n                    case 'r':\n                        str += '\\r';\n                        break;\n                    case 't':\n                        str += '\\t';\n                        break;\n                    case 'u':\n                    case 'x':\n                        restore = index;\n                        unescaped = scanHexEscape(ch);\n                        if (unescaped) {\n                            str += unescaped;\n                        } else {\n                            index = restore;\n                            str += ch;\n                        }\n                        break;\n                    case 'b':\n                        str += '\\b';\n                        break;\n                    case 'f':\n                        str += '\\f';\n                        break;\n                    case 'v':\n                        str += '\\v';\n                        break;\n\n                    default:\n                        if (esutils.code.isOctalDigit(ch.charCodeAt(0))) {\n                            code = '01234567'.indexOf(ch);\n\n                            // \\0 is not octal escape sequence\n                            // Deprecating unused code. TODO review removal\n                            //if (code !== 0) {\n                            //    octal = true;\n                            //}\n\n                            if (index < length && esutils.code.isOctalDigit(source.charCodeAt(index))) {\n                                //TODO Review Removal octal = true;\n                                code = code * 8 + '01234567'.indexOf(advance());\n\n                                // 3 digits are only allowed when string starts\n                                // with 0, 1, 2, 3\n                                if ('0123'.indexOf(ch) >= 0 &&\n                                        index < length &&\n                                        esutils.code.isOctalDigit(source.charCodeAt(index))) {\n                                    code = code * 8 + '01234567'.indexOf(advance());\n                                }\n                            }\n                            str += String.fromCharCode(code);\n                        } else {\n                            str += ch;\n                        }\n                        break;\n                    }\n                } else {\n                    if (ch ===  '\\r' && source.charCodeAt(index) === 0x0A  /* '\\n' */) {\n                        ++index;\n                    }\n                }\n            } else if (esutils.code.isLineTerminator(ch.charCodeAt(0))) {\n                break;\n            } else {\n                str += ch;\n            }\n        }\n\n        if (quote !== '') {\n            utility.throwError('unexpected quote');\n        }\n\n        value = str;\n        return Token.STRING;\n    }\n\n    function scanNumber() {\n        var number, ch;\n\n        number = '';\n        ch = source.charCodeAt(index);\n\n        if (ch !== 0x2E  /* '.' */) {\n            number = advance();\n            ch = source.charCodeAt(index);\n\n            if (number === '0') {\n                if (ch === 0x78  /* 'x' */ || ch === 0x58  /* 'X' */) {\n                    number += advance();\n                    while (index < length) {\n                        ch = source.charCodeAt(index);\n                        if (!esutils.code.isHexDigit(ch)) {\n                            break;\n                        }\n                        number += advance();\n                    }\n\n                    if (number.length <= 2) {\n                        // only 0x\n                        utility.throwError('unexpected token');\n                    }\n\n                    if (index < length) {\n                        ch = source.charCodeAt(index);\n                        if (esutils.code.isIdentifierStartES5(ch)) {\n                            utility.throwError('unexpected token');\n                        }\n                    }\n                    value = parseInt(number, 16);\n                    return Token.NUMBER;\n                }\n\n                if (esutils.code.isOctalDigit(ch)) {\n                    number += advance();\n                    while (index < length) {\n                        ch = source.charCodeAt(index);\n                        if (!esutils.code.isOctalDigit(ch)) {\n                            break;\n                        }\n                        number += advance();\n                    }\n\n                    if (index < length) {\n                        ch = source.charCodeAt(index);\n                        if (esutils.code.isIdentifierStartES5(ch) || esutils.code.isDecimalDigit(ch)) {\n                            utility.throwError('unexpected token');\n                        }\n                    }\n                    value = parseInt(number, 8);\n                    return Token.NUMBER;\n                }\n\n                if (esutils.code.isDecimalDigit(ch)) {\n                    utility.throwError('unexpected token');\n                }\n            }\n\n            while (index < length) {\n                ch = source.charCodeAt(index);\n                if (!esutils.code.isDecimalDigit(ch)) {\n                    break;\n                }\n                number += advance();\n            }\n        }\n\n        if (ch === 0x2E  /* '.' */) {\n            number += advance();\n            while (index < length) {\n                ch = source.charCodeAt(index);\n                if (!esutils.code.isDecimalDigit(ch)) {\n                    break;\n                }\n                number += advance();\n            }\n        }\n\n        if (ch === 0x65  /* 'e' */ || ch === 0x45  /* 'E' */) {\n            number += advance();\n\n            ch = source.charCodeAt(index);\n            if (ch === 0x2B  /* '+' */ || ch === 0x2D  /* '-' */) {\n                number += advance();\n            }\n\n            ch = source.charCodeAt(index);\n            if (esutils.code.isDecimalDigit(ch)) {\n                number += advance();\n                while (index < length) {\n                    ch = source.charCodeAt(index);\n                    if (!esutils.code.isDecimalDigit(ch)) {\n                        break;\n                    }\n                    number += advance();\n                }\n            } else {\n                utility.throwError('unexpected token');\n            }\n        }\n\n        if (index < length) {\n            ch = source.charCodeAt(index);\n            if (esutils.code.isIdentifierStartES5(ch)) {\n                utility.throwError('unexpected token');\n            }\n        }\n\n        value = parseFloat(number);\n        return Token.NUMBER;\n    }\n\n\n    function scanTypeName() {\n        var ch, ch2;\n\n        value = advance();\n        while (index < length && isTypeName(source.charCodeAt(index))) {\n            ch = source.charCodeAt(index);\n            if (ch === 0x2E  /* '.' */) {\n                if ((index + 1) >= length) {\n                    return Token.ILLEGAL;\n                }\n                ch2 = source.charCodeAt(index + 1);\n                if (ch2 === 0x3C  /* '<' */) {\n                    break;\n                }\n            }\n            value += advance();\n        }\n        return Token.NAME;\n    }\n\n    function next() {\n        var ch;\n\n        previous = index;\n\n        while (index < length && esutils.code.isWhiteSpace(source.charCodeAt(index))) {\n            advance();\n        }\n        if (index >= length) {\n            token = Token.EOF;\n            return token;\n        }\n\n        ch = source.charCodeAt(index);\n        switch (ch) {\n        case 0x27:  /* ''' */\n        case 0x22:  /* '\"' */\n            token = scanString();\n            return token;\n\n        case 0x3A:  /* ':' */\n            advance();\n            token = Token.COLON;\n            return token;\n\n        case 0x2C:  /* ',' */\n            advance();\n            token = Token.COMMA;\n            return token;\n\n        case 0x28:  /* '(' */\n            advance();\n            token = Token.LPAREN;\n            return token;\n\n        case 0x29:  /* ')' */\n            advance();\n            token = Token.RPAREN;\n            return token;\n\n        case 0x5B:  /* '[' */\n            advance();\n            token = Token.LBRACK;\n            return token;\n\n        case 0x5D:  /* ']' */\n            advance();\n            token = Token.RBRACK;\n            return token;\n\n        case 0x7B:  /* '{' */\n            advance();\n            token = Token.LBRACE;\n            return token;\n\n        case 0x7D:  /* '}' */\n            advance();\n            token = Token.RBRACE;\n            return token;\n\n        case 0x2E:  /* '.' */\n            if (index + 1 < length) {\n                ch = source.charCodeAt(index + 1);\n                if (ch === 0x3C  /* '<' */) {\n                    advance();  // '.'\n                    advance();  // '<'\n                    token = Token.DOT_LT;\n                    return token;\n                }\n\n                if (ch === 0x2E  /* '.' */ && index + 2 < length && source.charCodeAt(index + 2) === 0x2E  /* '.' */) {\n                    advance();  // '.'\n                    advance();  // '.'\n                    advance();  // '.'\n                    token = Token.REST;\n                    return token;\n                }\n\n                if (esutils.code.isDecimalDigit(ch)) {\n                    token = scanNumber();\n                    return token;\n                }\n            }\n            token = Token.ILLEGAL;\n            return token;\n\n        case 0x3C:  /* '<' */\n            advance();\n            token = Token.LT;\n            return token;\n\n        case 0x3E:  /* '>' */\n            advance();\n            token = Token.GT;\n            return token;\n\n        case 0x2A:  /* '*' */\n            advance();\n            token = Token.STAR;\n            return token;\n\n        case 0x7C:  /* '|' */\n            advance();\n            token = Token.PIPE;\n            return token;\n\n        case 0x3F:  /* '?' */\n            advance();\n            token = Token.QUESTION;\n            return token;\n\n        case 0x21:  /* '!' */\n            advance();\n            token = Token.BANG;\n            return token;\n\n        case 0x3D:  /* '=' */\n            advance();\n            token = Token.EQUAL;\n            return token;\n\n        case 0x2D: /* '-' */\n            token = scanNumber();\n            return token;\n\n        default:\n            if (esutils.code.isDecimalDigit(ch)) {\n                token = scanNumber();\n                return token;\n            }\n\n            // type string permits following case,\n            //\n            // namespace.module.MyClass\n            //\n            // this reduced 1 token TK_NAME\n            utility.assert(isTypeName(ch));\n            token = scanTypeName();\n            return token;\n        }\n    }\n\n    function consume(target, text) {\n        utility.assert(token === target, text || 'consumed token not matched');\n        next();\n    }\n\n    function expect(target, message) {\n        if (token !== target) {\n            utility.throwError(message || 'unexpected token');\n        }\n        next();\n    }\n\n    // UnionType := '(' TypeUnionList ')'\n    //\n    // TypeUnionList :=\n    //     <<empty>>\n    //   | NonemptyTypeUnionList\n    //\n    // NonemptyTypeUnionList :=\n    //     TypeExpression\n    //   | TypeExpression '|' NonemptyTypeUnionList\n    function parseUnionType() {\n        var elements, startIndex = index - 1;\n        consume(Token.LPAREN, 'UnionType should start with (');\n        elements = [];\n        if (token !== Token.RPAREN) {\n            while (true) {\n                elements.push(parseTypeExpression());\n                if (token === Token.RPAREN) {\n                    break;\n                }\n                expect(Token.PIPE);\n            }\n        }\n        consume(Token.RPAREN, 'UnionType should end with )');\n        return maybeAddRange({\n            type: Syntax.UnionType,\n            elements: elements\n        }, [startIndex, previous]);\n    }\n\n    // ArrayType := '[' ElementTypeList ']'\n    //\n    // ElementTypeList :=\n    //     <<empty>>\n    //  | TypeExpression\n    //  | '...' TypeExpression\n    //  | TypeExpression ',' ElementTypeList\n    function parseArrayType() {\n        var elements, startIndex = index - 1, restStartIndex;\n        consume(Token.LBRACK, 'ArrayType should start with [');\n        elements = [];\n        while (token !== Token.RBRACK) {\n            if (token === Token.REST) {\n                restStartIndex = index - 3;\n                consume(Token.REST);\n                elements.push(maybeAddRange({\n                    type: Syntax.RestType,\n                    expression: parseTypeExpression()\n                }, [restStartIndex, previous]));\n                break;\n            } else {\n                elements.push(parseTypeExpression());\n            }\n            if (token !== Token.RBRACK) {\n                expect(Token.COMMA);\n            }\n        }\n        expect(Token.RBRACK);\n        return maybeAddRange({\n            type: Syntax.ArrayType,\n            elements: elements\n        }, [startIndex, previous]);\n    }\n\n    function parseFieldName() {\n        var v = value;\n        if (token === Token.NAME || token === Token.STRING) {\n            next();\n            return v;\n        }\n\n        if (token === Token.NUMBER) {\n            consume(Token.NUMBER);\n            return String(v);\n        }\n\n        utility.throwError('unexpected token');\n    }\n\n    // FieldType :=\n    //     FieldName\n    //   | FieldName ':' TypeExpression\n    //\n    // FieldName :=\n    //     NameExpression\n    //   | StringLiteral\n    //   | NumberLiteral\n    //   | ReservedIdentifier\n    function parseFieldType() {\n        var key, rangeStart = previous;\n\n        key = parseFieldName();\n        if (token === Token.COLON) {\n            consume(Token.COLON);\n            return maybeAddRange({\n                type: Syntax.FieldType,\n                key: key,\n                value: parseTypeExpression()\n            }, [rangeStart, previous]);\n        }\n        return maybeAddRange({\n            type: Syntax.FieldType,\n            key: key,\n            value: null\n        }, [rangeStart, previous]);\n    }\n\n    // RecordType := '{' FieldTypeList '}'\n    //\n    // FieldTypeList :=\n    //     <<empty>>\n    //   | FieldType\n    //   | FieldType ',' FieldTypeList\n    function parseRecordType() {\n        var fields, rangeStart = index - 1, rangeEnd;\n\n        consume(Token.LBRACE, 'RecordType should start with {');\n        fields = [];\n        if (token === Token.COMMA) {\n            consume(Token.COMMA);\n        } else {\n            while (token !== Token.RBRACE) {\n                fields.push(parseFieldType());\n                if (token !== Token.RBRACE) {\n                    expect(Token.COMMA);\n                }\n            }\n        }\n        rangeEnd = index;\n        expect(Token.RBRACE);\n        return maybeAddRange({\n            type: Syntax.RecordType,\n            fields: fields\n        }, [rangeStart, rangeEnd]);\n    }\n\n    // NameExpression :=\n    //    Identifier\n    //  | TagIdentifier ':' Identifier\n    //\n    // Tag identifier is one of \"module\", \"external\" or \"event\"\n    // Identifier is the same as Token.NAME, including any dots, something like\n    // namespace.module.MyClass\n    function parseNameExpression() {\n        var name = value, rangeStart = index - name.length;\n        expect(Token.NAME);\n\n        if (token === Token.COLON && (\n                name === 'module' ||\n                name === 'external' ||\n                name === 'event')) {\n            consume(Token.COLON);\n            name += ':' + value;\n            expect(Token.NAME);\n        }\n\n        return maybeAddRange({\n            type: Syntax.NameExpression,\n            name: name\n        }, [rangeStart, previous]);\n    }\n\n    // TypeExpressionList :=\n    //     TopLevelTypeExpression\n    //   | TopLevelTypeExpression ',' TypeExpressionList\n    function parseTypeExpressionList() {\n        var elements = [];\n\n        elements.push(parseTop());\n        while (token === Token.COMMA) {\n            consume(Token.COMMA);\n            elements.push(parseTop());\n        }\n        return elements;\n    }\n\n    // TypeName :=\n    //     NameExpression\n    //   | NameExpression TypeApplication\n    //\n    // TypeApplication :=\n    //     '.<' TypeExpressionList '>'\n    //   | '<' TypeExpressionList '>'   // this is extension of doctrine\n    function parseTypeName() {\n        var expr, applications, startIndex = index - value.length;\n\n        expr = parseNameExpression();\n        if (token === Token.DOT_LT || token === Token.LT) {\n            next();\n            applications = parseTypeExpressionList();\n            expect(Token.GT);\n            return maybeAddRange({\n                type: Syntax.TypeApplication,\n                expression: expr,\n                applications: applications\n            }, [startIndex, previous]);\n        }\n        return expr;\n    }\n\n    // ResultType :=\n    //     <<empty>>\n    //   | ':' void\n    //   | ':' TypeExpression\n    //\n    // BNF is above\n    // but, we remove <<empty>> pattern, so token is always TypeToken::COLON\n    function parseResultType() {\n        consume(Token.COLON, 'ResultType should start with :');\n        if (token === Token.NAME && value === 'void') {\n            consume(Token.NAME);\n            return {\n                type: Syntax.VoidLiteral\n            };\n        }\n        return parseTypeExpression();\n    }\n\n    // ParametersType :=\n    //     RestParameterType\n    //   | NonRestParametersType\n    //   | NonRestParametersType ',' RestParameterType\n    //\n    // RestParameterType :=\n    //     '...'\n    //     '...' Identifier\n    //\n    // NonRestParametersType :=\n    //     ParameterType ',' NonRestParametersType\n    //   | ParameterType\n    //   | OptionalParametersType\n    //\n    // OptionalParametersType :=\n    //     OptionalParameterType\n    //   | OptionalParameterType, OptionalParametersType\n    //\n    // OptionalParameterType := ParameterType=\n    //\n    // ParameterType := TypeExpression | Identifier ':' TypeExpression\n    //\n    // Identifier is \"new\" or \"this\"\n    function parseParametersType() {\n        var params = [], optionalSequence = false, expr, rest = false, startIndex, restStartIndex = index - 3, nameStartIndex;\n\n        while (token !== Token.RPAREN) {\n            if (token === Token.REST) {\n                // RestParameterType\n                consume(Token.REST);\n                rest = true;\n            }\n\n            startIndex = previous;\n\n            expr = parseTypeExpression();\n            if (expr.type === Syntax.NameExpression && token === Token.COLON) {\n                nameStartIndex = previous - expr.name.length;\n                // Identifier ':' TypeExpression\n                consume(Token.COLON);\n                expr = maybeAddRange({\n                    type: Syntax.ParameterType,\n                    name: expr.name,\n                    expression: parseTypeExpression()\n                }, [nameStartIndex, previous]);\n            }\n            if (token === Token.EQUAL) {\n                consume(Token.EQUAL);\n                expr = maybeAddRange({\n                    type: Syntax.OptionalType,\n                    expression: expr\n                }, [startIndex, previous]);\n                optionalSequence = true;\n            } else {\n                if (optionalSequence) {\n                    utility.throwError('unexpected token');\n                }\n            }\n            if (rest) {\n                expr = maybeAddRange({\n                    type: Syntax.RestType,\n                    expression: expr\n                }, [restStartIndex, previous]);\n            }\n            params.push(expr);\n            if (token !== Token.RPAREN) {\n                expect(Token.COMMA);\n            }\n        }\n        return params;\n    }\n\n    // FunctionType := 'function' FunctionSignatureType\n    //\n    // FunctionSignatureType :=\n    //   | TypeParameters '(' ')' ResultType\n    //   | TypeParameters '(' ParametersType ')' ResultType\n    //   | TypeParameters '(' 'this' ':' TypeName ')' ResultType\n    //   | TypeParameters '(' 'this' ':' TypeName ',' ParametersType ')' ResultType\n    function parseFunctionType() {\n        var isNew, thisBinding, params, result, fnType, startIndex = index - value.length;\n        utility.assert(token === Token.NAME && value === 'function', 'FunctionType should start with \\'function\\'');\n        consume(Token.NAME);\n\n        // Google Closure Compiler is not implementing TypeParameters.\n        // So we do not. if we don't get '(', we see it as error.\n        expect(Token.LPAREN);\n\n        isNew = false;\n        params = [];\n        thisBinding = null;\n        if (token !== Token.RPAREN) {\n            // ParametersType or 'this'\n            if (token === Token.NAME &&\n                    (value === 'this' || value === 'new')) {\n                // 'this' or 'new'\n                // 'new' is Closure Compiler extension\n                isNew = value === 'new';\n                consume(Token.NAME);\n                expect(Token.COLON);\n                thisBinding = parseTypeName();\n                if (token === Token.COMMA) {\n                    consume(Token.COMMA);\n                    params = parseParametersType();\n                }\n            } else {\n                params = parseParametersType();\n            }\n        }\n\n        expect(Token.RPAREN);\n\n        result = null;\n        if (token === Token.COLON) {\n            result = parseResultType();\n        }\n\n        fnType = maybeAddRange({\n            type: Syntax.FunctionType,\n            params: params,\n            result: result\n        }, [startIndex, previous]);\n        if (thisBinding) {\n            // avoid adding null 'new' and 'this' properties\n            fnType['this'] = thisBinding;\n            if (isNew) {\n                fnType['new'] = true;\n            }\n        }\n        return fnType;\n    }\n\n    // BasicTypeExpression :=\n    //     '*'\n    //   | 'null'\n    //   | 'undefined'\n    //   | TypeName\n    //   | FunctionType\n    //   | UnionType\n    //   | RecordType\n    //   | ArrayType\n    function parseBasicTypeExpression() {\n        var context, startIndex;\n        switch (token) {\n        case Token.STAR:\n            consume(Token.STAR);\n            return maybeAddRange({\n                type: Syntax.AllLiteral\n            }, [previous - 1, previous]);\n\n        case Token.LPAREN:\n            return parseUnionType();\n\n        case Token.LBRACK:\n            return parseArrayType();\n\n        case Token.LBRACE:\n            return parseRecordType();\n\n        case Token.NAME:\n            startIndex = index - value.length;\n\n            if (value === 'null') {\n                consume(Token.NAME);\n                return maybeAddRange({\n                    type: Syntax.NullLiteral\n                }, [startIndex, previous]);\n            }\n\n            if (value === 'undefined') {\n                consume(Token.NAME);\n                return maybeAddRange({\n                    type: Syntax.UndefinedLiteral\n                }, [startIndex, previous]);\n            }\n\n            if (value === 'true' || value === 'false') {\n                consume(Token.NAME);\n                return maybeAddRange({\n                    type: Syntax.BooleanLiteralType,\n                    value: value === 'true'\n                }, [startIndex, previous]);\n            }\n\n            context = Context.save();\n            if (value === 'function') {\n                try {\n                    return parseFunctionType();\n                } catch (e) {\n                    context.restore();\n                }\n            }\n\n            return parseTypeName();\n\n        case Token.STRING:\n            next();\n            return maybeAddRange({\n                type: Syntax.StringLiteralType,\n                value: value\n            }, [previous - value.length - 2, previous]);\n\n        case Token.NUMBER:\n            next();\n            return maybeAddRange({\n                type: Syntax.NumericLiteralType,\n                value: value\n            }, [previous - String(value).length, previous]);\n\n        default:\n            utility.throwError('unexpected token');\n        }\n    }\n\n    // TypeExpression :=\n    //     BasicTypeExpression\n    //   | '?' BasicTypeExpression\n    //   | '!' BasicTypeExpression\n    //   | BasicTypeExpression '?'\n    //   | BasicTypeExpression '!'\n    //   | '?'\n    //   | BasicTypeExpression '[]'\n    function parseTypeExpression() {\n        var expr, rangeStart;\n\n        if (token === Token.QUESTION) {\n            rangeStart = index - 1;\n            consume(Token.QUESTION);\n            if (token === Token.COMMA || token === Token.EQUAL || token === Token.RBRACE ||\n                    token === Token.RPAREN || token === Token.PIPE || token === Token.EOF ||\n                    token === Token.RBRACK || token === Token.GT) {\n                return maybeAddRange({\n                    type: Syntax.NullableLiteral\n                }, [rangeStart, previous]);\n            }\n            return maybeAddRange({\n                type: Syntax.NullableType,\n                expression: parseBasicTypeExpression(),\n                prefix: true\n            }, [rangeStart, previous]);\n        } else if (token === Token.BANG) {\n            rangeStart = index - 1;\n            consume(Token.BANG);\n            return maybeAddRange({\n                type: Syntax.NonNullableType,\n                expression: parseBasicTypeExpression(),\n                prefix: true\n            }, [rangeStart, previous]);\n        } else {\n            rangeStart = previous;\n        }\n\n        expr = parseBasicTypeExpression();\n        if (token === Token.BANG) {\n            consume(Token.BANG);\n            return maybeAddRange({\n                type: Syntax.NonNullableType,\n                expression: expr,\n                prefix: false\n            }, [rangeStart, previous]);\n        }\n\n        if (token === Token.QUESTION) {\n            consume(Token.QUESTION);\n            return maybeAddRange({\n                type: Syntax.NullableType,\n                expression: expr,\n                prefix: false\n            }, [rangeStart, previous]);\n        }\n\n        if (token === Token.LBRACK) {\n            consume(Token.LBRACK);\n            expect(Token.RBRACK, 'expected an array-style type declaration (' + value + '[])');\n            return maybeAddRange({\n                type: Syntax.TypeApplication,\n                expression: maybeAddRange({\n                    type: Syntax.NameExpression,\n                    name: 'Array'\n                }, [rangeStart, previous]),\n                applications: [expr]\n            }, [rangeStart, previous]);\n        }\n\n        return expr;\n    }\n\n    // TopLevelTypeExpression :=\n    //      TypeExpression\n    //    | TypeUnionList\n    //\n    // This rule is Google Closure Compiler extension, not ES4\n    // like,\n    //   { number | string }\n    // If strict to ES4, we should write it as\n    //   { (number|string) }\n    function parseTop() {\n        var expr, elements;\n\n        expr = parseTypeExpression();\n        if (token !== Token.PIPE) {\n            return expr;\n        }\n\n        elements = [expr];\n        consume(Token.PIPE);\n        while (true) {\n            elements.push(parseTypeExpression());\n            if (token !== Token.PIPE) {\n                break;\n            }\n            consume(Token.PIPE);\n        }\n\n        return maybeAddRange({\n            type: Syntax.UnionType,\n            elements: elements\n        }, [0, index]);\n    }\n\n    function parseTopParamType() {\n        var expr;\n\n        if (token === Token.REST) {\n            consume(Token.REST);\n            return maybeAddRange({\n                type: Syntax.RestType,\n                expression: parseTop()\n            }, [0, index]);\n        }\n\n        expr = parseTop();\n        if (token === Token.EQUAL) {\n            consume(Token.EQUAL);\n            return maybeAddRange({\n                type: Syntax.OptionalType,\n                expression: expr\n            }, [0, index]);\n        }\n\n        return expr;\n    }\n\n    function parseType(src, opt) {\n        var expr;\n\n        source = src;\n        length = source.length;\n        index = 0;\n        previous = 0;\n        addRange = opt && opt.range;\n        rangeOffset = opt && opt.startIndex || 0;\n\n        next();\n        expr = parseTop();\n\n        if (opt && opt.midstream) {\n            return {\n                expression: expr,\n                index: previous\n            };\n        }\n\n        if (token !== Token.EOF) {\n            utility.throwError('not reach to EOF');\n        }\n\n        return expr;\n    }\n\n    function parseParamType(src, opt) {\n        var expr;\n\n        source = src;\n        length = source.length;\n        index = 0;\n        previous = 0;\n        addRange = opt && opt.range;\n        rangeOffset = opt && opt.startIndex || 0;\n\n        next();\n        expr = parseTopParamType();\n\n        if (opt && opt.midstream) {\n            return {\n                expression: expr,\n                index: previous\n            };\n        }\n\n        if (token !== Token.EOF) {\n            utility.throwError('not reach to EOF');\n        }\n\n        return expr;\n    }\n\n    function stringifyImpl(node, compact, topLevel) {\n        var result, i, iz;\n\n        switch (node.type) {\n        case Syntax.NullableLiteral:\n            result = '?';\n            break;\n\n        case Syntax.AllLiteral:\n            result = '*';\n            break;\n\n        case Syntax.NullLiteral:\n            result = 'null';\n            break;\n\n        case Syntax.UndefinedLiteral:\n            result = 'undefined';\n            break;\n\n        case Syntax.VoidLiteral:\n            result = 'void';\n            break;\n\n        case Syntax.UnionType:\n            if (!topLevel) {\n                result = '(';\n            } else {\n                result = '';\n            }\n\n            for (i = 0, iz = node.elements.length; i < iz; ++i) {\n                result += stringifyImpl(node.elements[i], compact);\n                if ((i + 1) !== iz) {\n                    result += compact ? '|' : ' | ';\n                }\n            }\n\n            if (!topLevel) {\n                result += ')';\n            }\n            break;\n\n        case Syntax.ArrayType:\n            result = '[';\n            for (i = 0, iz = node.elements.length; i < iz; ++i) {\n                result += stringifyImpl(node.elements[i], compact);\n                if ((i + 1) !== iz) {\n                    result += compact ? ',' : ', ';\n                }\n            }\n            result += ']';\n            break;\n\n        case Syntax.RecordType:\n            result = '{';\n            for (i = 0, iz = node.fields.length; i < iz; ++i) {\n                result += stringifyImpl(node.fields[i], compact);\n                if ((i + 1) !== iz) {\n                    result += compact ? ',' : ', ';\n                }\n            }\n            result += '}';\n            break;\n\n        case Syntax.FieldType:\n            if (node.value) {\n                result = node.key + (compact ? ':' : ': ') + stringifyImpl(node.value, compact);\n            } else {\n                result = node.key;\n            }\n            break;\n\n        case Syntax.FunctionType:\n            result = compact ? 'function(' : 'function (';\n\n            if (node['this']) {\n                if (node['new']) {\n                    result += (compact ? 'new:' : 'new: ');\n                } else {\n                    result += (compact ? 'this:' : 'this: ');\n                }\n\n                result += stringifyImpl(node['this'], compact);\n\n                if (node.params.length !== 0) {\n                    result += compact ? ',' : ', ';\n                }\n            }\n\n            for (i = 0, iz = node.params.length; i < iz; ++i) {\n                result += stringifyImpl(node.params[i], compact);\n                if ((i + 1) !== iz) {\n                    result += compact ? ',' : ', ';\n                }\n            }\n\n            result += ')';\n\n            if (node.result) {\n                result += (compact ? ':' : ': ') + stringifyImpl(node.result, compact);\n            }\n            break;\n\n        case Syntax.ParameterType:\n            result = node.name + (compact ? ':' : ': ') + stringifyImpl(node.expression, compact);\n            break;\n\n        case Syntax.RestType:\n            result = '...';\n            if (node.expression) {\n                result += stringifyImpl(node.expression, compact);\n            }\n            break;\n\n        case Syntax.NonNullableType:\n            if (node.prefix) {\n                result = '!' + stringifyImpl(node.expression, compact);\n            } else {\n                result = stringifyImpl(node.expression, compact) + '!';\n            }\n            break;\n\n        case Syntax.OptionalType:\n            result = stringifyImpl(node.expression, compact) + '=';\n            break;\n\n        case Syntax.NullableType:\n            if (node.prefix) {\n                result = '?' + stringifyImpl(node.expression, compact);\n            } else {\n                result = stringifyImpl(node.expression, compact) + '?';\n            }\n            break;\n\n        case Syntax.NameExpression:\n            result = node.name;\n            break;\n\n        case Syntax.TypeApplication:\n            result = stringifyImpl(node.expression, compact) + '.<';\n            for (i = 0, iz = node.applications.length; i < iz; ++i) {\n                result += stringifyImpl(node.applications[i], compact);\n                if ((i + 1) !== iz) {\n                    result += compact ? ',' : ', ';\n                }\n            }\n            result += '>';\n            break;\n\n        case Syntax.StringLiteralType:\n            result = '\"' + node.value + '\"';\n            break;\n\n        case Syntax.NumericLiteralType:\n            result = String(node.value);\n            break;\n\n        case Syntax.BooleanLiteralType:\n            result = String(node.value);\n            break;\n\n        default:\n            utility.throwError('Unknown type ' + node.type);\n        }\n\n        return result;\n    }\n\n    function stringify(node, options) {\n        if (options == null) {\n            options = {};\n        }\n        return stringifyImpl(node, options.compact, options.topLevel);\n    }\n\n    exports.parseType = parseType;\n    exports.parseParamType = parseParamType;\n    exports.stringify = stringify;\n    exports.Syntax = Syntax;\n}());\n/* vim: set sw=4 ts=4 et tw=80 : */\n\n\n//# sourceURL=webpack://javascript/./node_modules/doctrine/lib/typed.js?");

/***/ }),

/***/ "./node_modules/doctrine/lib/utility.js":
/*!**********************************************!*\
  !*** ./node_modules/doctrine/lib/utility.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/*\n * @fileoverview Utilities for Doctrine\n * @author Yusuke Suzuki <utatane.tea@gmail.com>\n */\n\n\n(function () {\n    'use strict';\n\n    var VERSION;\n\n    VERSION = (__webpack_require__(/*! ../package.json */ \"./node_modules/doctrine/package.json\").version);\n    exports.VERSION = VERSION;\n\n    function DoctrineError(message) {\n        this.name = 'DoctrineError';\n        this.message = message;\n    }\n    DoctrineError.prototype = (function () {\n        var Middle = function () { };\n        Middle.prototype = Error.prototype;\n        return new Middle();\n    }());\n    DoctrineError.prototype.constructor = DoctrineError;\n    exports.DoctrineError = DoctrineError;\n\n    function throwError(message) {\n        throw new DoctrineError(message);\n    }\n    exports.throwError = throwError;\n\n    exports.assert = __webpack_require__(/*! assert */ \"./node_modules/assert/build/assert.js\");\n}());\n\n/* vim: set sw=4 ts=4 et tw=80 : */\n\n\n//# sourceURL=webpack://javascript/./node_modules/doctrine/lib/utility.js?");

/***/ }),

/***/ "./node_modules/es6-object-assign/index.js":
/*!*************************************************!*\
  !*** ./node_modules/es6-object-assign/index.js ***!
  \*************************************************/
/***/ ((module) => {

"use strict";
eval("/**\n * Code refactored from Mozilla Developer Network:\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\n */\n\n\n\nfunction assign(target, firstSource) {\n  if (target === undefined || target === null) {\n    throw new TypeError('Cannot convert first argument to object');\n  }\n\n  var to = Object(target);\n  for (var i = 1; i < arguments.length; i++) {\n    var nextSource = arguments[i];\n    if (nextSource === undefined || nextSource === null) {\n      continue;\n    }\n\n    var keysArray = Object.keys(Object(nextSource));\n    for (var nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex++) {\n      var nextKey = keysArray[nextIndex];\n      var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);\n      if (desc !== undefined && desc.enumerable) {\n        to[nextKey] = nextSource[nextKey];\n      }\n    }\n  }\n  return to;\n}\n\nfunction polyfill() {\n  if (!Object.assign) {\n    Object.defineProperty(Object, 'assign', {\n      enumerable: false,\n      configurable: true,\n      writable: true,\n      value: assign\n    });\n  }\n}\n\nmodule.exports = {\n  assign: assign,\n  polyfill: polyfill\n};\n\n\n//# sourceURL=webpack://javascript/./node_modules/es6-object-assign/index.js?");

/***/ }),

/***/ "./node_modules/escape-string-regexp/index.js":
/*!****************************************************!*\
  !*** ./node_modules/escape-string-regexp/index.js ***!
  \****************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = string => {\n\tif (typeof string !== 'string') {\n\t\tthrow new TypeError('Expected a string');\n\t}\n\n\t// Escape characters with special meaning either inside or outside character sets.\n\t// Use a simple backslash escape when its always valid, and a \\unnnn escape when the simpler form would be disallowed by Unicode patterns stricter grammar.\n\treturn string\n\t\t.replace(/[|\\\\{}()[\\]^$+*?.]/g, '\\\\$&')\n\t\t.replace(/-/g, '\\\\x2d');\n};\n\n\n//# sourceURL=webpack://javascript/./node_modules/escape-string-regexp/index.js?");

/***/ }),

/***/ "./node_modules/eslint-scope/lib/definition.js":
/*!*****************************************************!*\
  !*** ./node_modules/eslint-scope/lib/definition.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*\n  Copyright (C) 2015 Yusuke Suzuki <utatane.tea@gmail.com>\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n\nconst Variable = __webpack_require__(/*! ./variable */ \"./node_modules/eslint-scope/lib/variable.js\");\n\n/**\n * @class Definition\n */\nclass Definition {\n    constructor(type, name, node, parent, index, kind) {\n\n        /**\n         * @member {String} Definition#type - type of the occurrence (e.g. \"Parameter\", \"Variable\", ...).\n         */\n        this.type = type;\n\n        /**\n         * @member {espree.Identifier} Definition#name - the identifier AST node of the occurrence.\n         */\n        this.name = name;\n\n        /**\n         * @member {espree.Node} Definition#node - the enclosing node of the identifier.\n         */\n        this.node = node;\n\n        /**\n         * @member {espree.Node?} Definition#parent - the enclosing statement node of the identifier.\n         */\n        this.parent = parent;\n\n        /**\n         * @member {Number?} Definition#index - the index in the declaration statement.\n         */\n        this.index = index;\n\n        /**\n         * @member {String?} Definition#kind - the kind of the declaration statement.\n         */\n        this.kind = kind;\n    }\n}\n\n/**\n * @class ParameterDefinition\n */\nclass ParameterDefinition extends Definition {\n    constructor(name, node, index, rest) {\n        super(Variable.Parameter, name, node, null, index, null);\n\n        /**\n         * Whether the parameter definition is a part of a rest parameter.\n         * @member {boolean} ParameterDefinition#rest\n         */\n        this.rest = rest;\n    }\n}\n\nmodule.exports = {\n    ParameterDefinition,\n    Definition\n};\n\n/* vim: set sw=4 ts=4 et tw=80 : */\n\n\n//# sourceURL=webpack://javascript/./node_modules/eslint-scope/lib/definition.js?");

/***/ }),

/***/ "./node_modules/eslint-scope/lib/index.js":
/*!************************************************!*\
  !*** ./node_modules/eslint-scope/lib/index.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*\n  Copyright (C) 2012-2014 Yusuke Suzuki <utatane.tea@gmail.com>\n  Copyright (C) 2013 Alex Seville <hi@alexanderseville.com>\n  Copyright (C) 2014 Thiago de Arruda <tpadilha84@gmail.com>\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/**\n * Escope (<a href=\"http://github.com/estools/escope\">escope</a>) is an <a\n * href=\"http://www.ecma-international.org/publications/standards/Ecma-262.htm\">ECMAScript</a>\n * scope analyzer extracted from the <a\n * href=\"http://github.com/estools/esmangle\">esmangle project</a/>.\n * <p>\n * <em>escope</em> finds lexical scopes in a source program, i.e. areas of that\n * program where different occurrences of the same identifier refer to the same\n * variable. With each scope the contained variables are collected, and each\n * identifier reference in code is linked to its corresponding variable (if\n * possible).\n * <p>\n * <em>escope</em> works on a syntax tree of the parsed source code which has\n * to adhere to the <a\n * href=\"https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API\">\n * Mozilla Parser API</a>. E.g. <a href=\"https://github.com/eslint/espree\">espree</a> is a parser\n * that produces such syntax trees.\n * <p>\n * The main interface is the {@link analyze} function.\n * @module escope\n */\n\n\n/* eslint no-underscore-dangle: [\"error\", { \"allow\": [\"__currentScope\"] }] */\n\nconst assert = __webpack_require__(/*! assert */ \"./node_modules/assert/build/assert.js\");\n\nconst ScopeManager = __webpack_require__(/*! ./scope-manager */ \"./node_modules/eslint-scope/lib/scope-manager.js\");\nconst Referencer = __webpack_require__(/*! ./referencer */ \"./node_modules/eslint-scope/lib/referencer.js\");\nconst Reference = __webpack_require__(/*! ./reference */ \"./node_modules/eslint-scope/lib/reference.js\");\nconst Variable = __webpack_require__(/*! ./variable */ \"./node_modules/eslint-scope/lib/variable.js\");\nconst Scope = (__webpack_require__(/*! ./scope */ \"./node_modules/eslint-scope/lib/scope.js\").Scope);\nconst version = (__webpack_require__(/*! ../package.json */ \"./node_modules/eslint-scope/package.json\").version);\n\n/**\n * Set the default options\n * @returns {Object} options\n */\nfunction defaultOptions() {\n    return {\n        optimistic: false,\n        directive: false,\n        nodejsScope: false,\n        impliedStrict: false,\n        sourceType: \"script\", // one of ['script', 'module']\n        ecmaVersion: 5,\n        childVisitorKeys: null,\n        fallback: \"iteration\"\n    };\n}\n\n/**\n * Preform deep update on option object\n * @param {Object} target - Options\n * @param {Object} override - Updates\n * @returns {Object} Updated options\n */\nfunction updateDeeply(target, override) {\n\n    /**\n     * Is hash object\n     * @param {Object} value - Test value\n     * @returns {boolean} Result\n     */\n    function isHashObject(value) {\n        return typeof value === \"object\" && value instanceof Object && !(value instanceof Array) && !(value instanceof RegExp);\n    }\n\n    for (const key in override) {\n        if (Object.prototype.hasOwnProperty.call(override, key)) {\n            const val = override[key];\n\n            if (isHashObject(val)) {\n                if (isHashObject(target[key])) {\n                    updateDeeply(target[key], val);\n                } else {\n                    target[key] = updateDeeply({}, val);\n                }\n            } else {\n                target[key] = val;\n            }\n        }\n    }\n    return target;\n}\n\n/**\n * Main interface function. Takes an Espree syntax tree and returns the\n * analyzed scopes.\n * @function analyze\n * @param {espree.Tree} tree - Abstract Syntax Tree\n * @param {Object} providedOptions - Options that tailor the scope analysis\n * @param {boolean} [providedOptions.optimistic=false] - the optimistic flag\n * @param {boolean} [providedOptions.directive=false]- the directive flag\n * @param {boolean} [providedOptions.ignoreEval=false]- whether to check 'eval()' calls\n * @param {boolean} [providedOptions.nodejsScope=false]- whether the whole\n * script is executed under node.js environment. When enabled, escope adds\n * a function scope immediately following the global scope.\n * @param {boolean} [providedOptions.impliedStrict=false]- implied strict mode\n * (if ecmaVersion >= 5).\n * @param {string} [providedOptions.sourceType='script']- the source type of the script. one of 'script' and 'module'\n * @param {number} [providedOptions.ecmaVersion=5]- which ECMAScript version is considered\n * @param {Object} [providedOptions.childVisitorKeys=null] - Additional known visitor keys. See [esrecurse](https://github.com/estools/esrecurse)'s the `childVisitorKeys` option.\n * @param {string} [providedOptions.fallback='iteration'] - A kind of the fallback in order to encounter with unknown node. See [esrecurse](https://github.com/estools/esrecurse)'s the `fallback` option.\n * @returns {ScopeManager} ScopeManager\n */\nfunction analyze(tree, providedOptions) {\n    const options = updateDeeply(defaultOptions(), providedOptions);\n    const scopeManager = new ScopeManager(options);\n    const referencer = new Referencer(options, scopeManager);\n\n    referencer.visit(tree);\n\n    assert(scopeManager.__currentScope === null, \"currentScope should be null.\");\n\n    return scopeManager;\n}\n\nmodule.exports = {\n\n    /** @name module:escope.version */\n    version,\n\n    /** @name module:escope.Reference */\n    Reference,\n\n    /** @name module:escope.Variable */\n    Variable,\n\n    /** @name module:escope.Scope */\n    Scope,\n\n    /** @name module:escope.ScopeManager */\n    ScopeManager,\n    analyze\n};\n\n\n/* vim: set sw=4 ts=4 et tw=80 : */\n\n\n//# sourceURL=webpack://javascript/./node_modules/eslint-scope/lib/index.js?");

/***/ }),

/***/ "./node_modules/eslint-scope/lib/pattern-visitor.js":
/*!**********************************************************!*\
  !*** ./node_modules/eslint-scope/lib/pattern-visitor.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*\n  Copyright (C) 2015 Yusuke Suzuki <utatane.tea@gmail.com>\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n\n/* eslint-disable no-undefined */\n\nconst Syntax = (__webpack_require__(/*! estraverse */ \"./node_modules/eslint-scope/node_modules/estraverse/estraverse.js\").Syntax);\nconst esrecurse = __webpack_require__(/*! esrecurse */ \"./node_modules/esrecurse/esrecurse.js\");\n\n/**\n * Get last array element\n * @param {array} xs - array\n * @returns {any} Last elment\n */\nfunction getLast(xs) {\n    return xs[xs.length - 1] || null;\n}\n\nclass PatternVisitor extends esrecurse.Visitor {\n    static isPattern(node) {\n        const nodeType = node.type;\n\n        return (\n            nodeType === Syntax.Identifier ||\n            nodeType === Syntax.ObjectPattern ||\n            nodeType === Syntax.ArrayPattern ||\n            nodeType === Syntax.SpreadElement ||\n            nodeType === Syntax.RestElement ||\n            nodeType === Syntax.AssignmentPattern\n        );\n    }\n\n    constructor(options, rootPattern, callback) {\n        super(null, options);\n        this.rootPattern = rootPattern;\n        this.callback = callback;\n        this.assignments = [];\n        this.rightHandNodes = [];\n        this.restElements = [];\n    }\n\n    Identifier(pattern) {\n        const lastRestElement = getLast(this.restElements);\n\n        this.callback(pattern, {\n            topLevel: pattern === this.rootPattern,\n            rest: lastRestElement !== null && lastRestElement !== undefined && lastRestElement.argument === pattern,\n            assignments: this.assignments\n        });\n    }\n\n    Property(property) {\n\n        // Computed property's key is a right hand node.\n        if (property.computed) {\n            this.rightHandNodes.push(property.key);\n        }\n\n        // If it's shorthand, its key is same as its value.\n        // If it's shorthand and has its default value, its key is same as its value.left (the value is AssignmentPattern).\n        // If it's not shorthand, the name of new variable is its value's.\n        this.visit(property.value);\n    }\n\n    ArrayPattern(pattern) {\n        for (let i = 0, iz = pattern.elements.length; i < iz; ++i) {\n            const element = pattern.elements[i];\n\n            this.visit(element);\n        }\n    }\n\n    AssignmentPattern(pattern) {\n        this.assignments.push(pattern);\n        this.visit(pattern.left);\n        this.rightHandNodes.push(pattern.right);\n        this.assignments.pop();\n    }\n\n    RestElement(pattern) {\n        this.restElements.push(pattern);\n        this.visit(pattern.argument);\n        this.restElements.pop();\n    }\n\n    MemberExpression(node) {\n\n        // Computed property's key is a right hand node.\n        if (node.computed) {\n            this.rightHandNodes.push(node.property);\n        }\n\n        // the object is only read, write to its property.\n        this.rightHandNodes.push(node.object);\n    }\n\n    //\n    // ForInStatement.left and AssignmentExpression.left are LeftHandSideExpression.\n    // By spec, LeftHandSideExpression is Pattern or MemberExpression.\n    //   (see also: https://github.com/estree/estree/pull/20#issuecomment-74584758)\n    // But espree 2.0 parses to ArrayExpression, ObjectExpression, etc...\n    //\n\n    SpreadElement(node) {\n        this.visit(node.argument);\n    }\n\n    ArrayExpression(node) {\n        node.elements.forEach(this.visit, this);\n    }\n\n    AssignmentExpression(node) {\n        this.assignments.push(node);\n        this.visit(node.left);\n        this.rightHandNodes.push(node.right);\n        this.assignments.pop();\n    }\n\n    CallExpression(node) {\n\n        // arguments are right hand nodes.\n        node.arguments.forEach(a => {\n            this.rightHandNodes.push(a);\n        });\n        this.visit(node.callee);\n    }\n}\n\nmodule.exports = PatternVisitor;\n\n/* vim: set sw=4 ts=4 et tw=80 : */\n\n\n//# sourceURL=webpack://javascript/./node_modules/eslint-scope/lib/pattern-visitor.js?");

/***/ }),

/***/ "./node_modules/eslint-scope/lib/reference.js":
/*!****************************************************!*\
  !*** ./node_modules/eslint-scope/lib/reference.js ***!
  \****************************************************/
/***/ ((module) => {

"use strict";
eval("/*\n  Copyright (C) 2015 Yusuke Suzuki <utatane.tea@gmail.com>\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n\nconst READ = 0x1;\nconst WRITE = 0x2;\nconst RW = READ | WRITE;\n\n/**\n * A Reference represents a single occurrence of an identifier in code.\n * @class Reference\n */\nclass Reference {\n    constructor(ident, scope, flag, writeExpr, maybeImplicitGlobal, partial, init) {\n\n        /**\n         * Identifier syntax node.\n         * @member {espreeIdentifier} Reference#identifier\n         */\n        this.identifier = ident;\n\n        /**\n         * Reference to the enclosing Scope.\n         * @member {Scope} Reference#from\n         */\n        this.from = scope;\n\n        /**\n         * Whether the reference comes from a dynamic scope (such as 'eval',\n         * 'with', etc.), and may be trapped by dynamic scopes.\n         * @member {boolean} Reference#tainted\n         */\n        this.tainted = false;\n\n        /**\n         * The variable this reference is resolved with.\n         * @member {Variable} Reference#resolved\n         */\n        this.resolved = null;\n\n        /**\n         * The read-write mode of the reference. (Value is one of {@link\n         * Reference.READ}, {@link Reference.RW}, {@link Reference.WRITE}).\n         * @member {number} Reference#flag\n         * @private\n         */\n        this.flag = flag;\n        if (this.isWrite()) {\n\n            /**\n             * If reference is writeable, this is the tree being written to it.\n             * @member {espreeNode} Reference#writeExpr\n             */\n            this.writeExpr = writeExpr;\n\n            /**\n             * Whether the Reference might refer to a partial value of writeExpr.\n             * @member {boolean} Reference#partial\n             */\n            this.partial = partial;\n\n            /**\n             * Whether the Reference is to write of initialization.\n             * @member {boolean} Reference#init\n             */\n            this.init = init;\n        }\n        this.__maybeImplicitGlobal = maybeImplicitGlobal;\n    }\n\n    /**\n     * Whether the reference is static.\n     * @method Reference#isStatic\n     * @returns {boolean} static\n     */\n    isStatic() {\n        return !this.tainted && this.resolved && this.resolved.scope.isStatic();\n    }\n\n    /**\n     * Whether the reference is writeable.\n     * @method Reference#isWrite\n     * @returns {boolean} write\n     */\n    isWrite() {\n        return !!(this.flag & Reference.WRITE);\n    }\n\n    /**\n     * Whether the reference is readable.\n     * @method Reference#isRead\n     * @returns {boolean} read\n     */\n    isRead() {\n        return !!(this.flag & Reference.READ);\n    }\n\n    /**\n     * Whether the reference is read-only.\n     * @method Reference#isReadOnly\n     * @returns {boolean} read only\n     */\n    isReadOnly() {\n        return this.flag === Reference.READ;\n    }\n\n    /**\n     * Whether the reference is write-only.\n     * @method Reference#isWriteOnly\n     * @returns {boolean} write only\n     */\n    isWriteOnly() {\n        return this.flag === Reference.WRITE;\n    }\n\n    /**\n     * Whether the reference is read-write.\n     * @method Reference#isReadWrite\n     * @returns {boolean} read write\n     */\n    isReadWrite() {\n        return this.flag === Reference.RW;\n    }\n}\n\n/**\n * @constant Reference.READ\n * @private\n */\nReference.READ = READ;\n\n/**\n * @constant Reference.WRITE\n * @private\n */\nReference.WRITE = WRITE;\n\n/**\n * @constant Reference.RW\n * @private\n */\nReference.RW = RW;\n\nmodule.exports = Reference;\n\n/* vim: set sw=4 ts=4 et tw=80 : */\n\n\n//# sourceURL=webpack://javascript/./node_modules/eslint-scope/lib/reference.js?");

/***/ }),

/***/ "./node_modules/eslint-scope/lib/referencer.js":
/*!*****************************************************!*\
  !*** ./node_modules/eslint-scope/lib/referencer.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*\n  Copyright (C) 2015 Yusuke Suzuki <utatane.tea@gmail.com>\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n\n/* eslint-disable no-underscore-dangle */\n/* eslint-disable no-undefined */\n\nconst Syntax = (__webpack_require__(/*! estraverse */ \"./node_modules/eslint-scope/node_modules/estraverse/estraverse.js\").Syntax);\nconst esrecurse = __webpack_require__(/*! esrecurse */ \"./node_modules/esrecurse/esrecurse.js\");\nconst Reference = __webpack_require__(/*! ./reference */ \"./node_modules/eslint-scope/lib/reference.js\");\nconst Variable = __webpack_require__(/*! ./variable */ \"./node_modules/eslint-scope/lib/variable.js\");\nconst PatternVisitor = __webpack_require__(/*! ./pattern-visitor */ \"./node_modules/eslint-scope/lib/pattern-visitor.js\");\nconst definition = __webpack_require__(/*! ./definition */ \"./node_modules/eslint-scope/lib/definition.js\");\nconst assert = __webpack_require__(/*! assert */ \"./node_modules/assert/build/assert.js\");\n\nconst ParameterDefinition = definition.ParameterDefinition;\nconst Definition = definition.Definition;\n\n/**\n * Traverse identifier in pattern\n * @param {Object} options - options\n * @param {pattern} rootPattern - root pattern\n * @param {Refencer} referencer - referencer\n * @param {callback} callback - callback\n * @returns {void}\n */\nfunction traverseIdentifierInPattern(options, rootPattern, referencer, callback) {\n\n    // Call the callback at left hand identifier nodes, and Collect right hand nodes.\n    const visitor = new PatternVisitor(options, rootPattern, callback);\n\n    visitor.visit(rootPattern);\n\n    // Process the right hand nodes recursively.\n    if (referencer !== null && referencer !== undefined) {\n        visitor.rightHandNodes.forEach(referencer.visit, referencer);\n    }\n}\n\n// Importing ImportDeclaration.\n// http://people.mozilla.org/~jorendorff/es6-draft.html#sec-moduledeclarationinstantiation\n// https://github.com/estree/estree/blob/master/es6.md#importdeclaration\n// FIXME: Now, we don't create module environment, because the context is\n// implementation dependent.\n\nclass Importer extends esrecurse.Visitor {\n    constructor(declaration, referencer) {\n        super(null, referencer.options);\n        this.declaration = declaration;\n        this.referencer = referencer;\n    }\n\n    visitImport(id, specifier) {\n        this.referencer.visitPattern(id, pattern => {\n            this.referencer.currentScope().__define(pattern,\n                new Definition(\n                    Variable.ImportBinding,\n                    pattern,\n                    specifier,\n                    this.declaration,\n                    null,\n                    null\n                ));\n        });\n    }\n\n    ImportNamespaceSpecifier(node) {\n        const local = (node.local || node.id);\n\n        if (local) {\n            this.visitImport(local, node);\n        }\n    }\n\n    ImportDefaultSpecifier(node) {\n        const local = (node.local || node.id);\n\n        this.visitImport(local, node);\n    }\n\n    ImportSpecifier(node) {\n        const local = (node.local || node.id);\n\n        if (node.name) {\n            this.visitImport(node.name, node);\n        } else {\n            this.visitImport(local, node);\n        }\n    }\n}\n\n// Referencing variables and creating bindings.\nclass Referencer extends esrecurse.Visitor {\n    constructor(options, scopeManager) {\n        super(null, options);\n        this.options = options;\n        this.scopeManager = scopeManager;\n        this.parent = null;\n        this.isInnerMethodDefinition = false;\n    }\n\n    currentScope() {\n        return this.scopeManager.__currentScope;\n    }\n\n    close(node) {\n        while (this.currentScope() && node === this.currentScope().block) {\n            this.scopeManager.__currentScope = this.currentScope().__close(this.scopeManager);\n        }\n    }\n\n    pushInnerMethodDefinition(isInnerMethodDefinition) {\n        const previous = this.isInnerMethodDefinition;\n\n        this.isInnerMethodDefinition = isInnerMethodDefinition;\n        return previous;\n    }\n\n    popInnerMethodDefinition(isInnerMethodDefinition) {\n        this.isInnerMethodDefinition = isInnerMethodDefinition;\n    }\n\n    referencingDefaultValue(pattern, assignments, maybeImplicitGlobal, init) {\n        const scope = this.currentScope();\n\n        assignments.forEach(assignment => {\n            scope.__referencing(\n                pattern,\n                Reference.WRITE,\n                assignment.right,\n                maybeImplicitGlobal,\n                pattern !== assignment.left,\n                init\n            );\n        });\n    }\n\n    visitPattern(node, options, callback) {\n        let visitPatternOptions = options;\n        let visitPatternCallback = callback;\n\n        if (typeof options === \"function\") {\n            visitPatternCallback = options;\n            visitPatternOptions = { processRightHandNodes: false };\n        }\n\n        traverseIdentifierInPattern(\n            this.options,\n            node,\n            visitPatternOptions.processRightHandNodes ? this : null,\n            visitPatternCallback\n        );\n    }\n\n    visitFunction(node) {\n        let i, iz;\n\n        // FunctionDeclaration name is defined in upper scope\n        // NOTE: Not referring variableScope. It is intended.\n        // Since\n        //  in ES5, FunctionDeclaration should be in FunctionBody.\n        //  in ES6, FunctionDeclaration should be block scoped.\n\n        if (node.type === Syntax.FunctionDeclaration) {\n\n            // id is defined in upper scope\n            this.currentScope().__define(node.id,\n                new Definition(\n                    Variable.FunctionName,\n                    node.id,\n                    node,\n                    null,\n                    null,\n                    null\n                ));\n        }\n\n        // FunctionExpression with name creates its special scope;\n        // FunctionExpressionNameScope.\n        if (node.type === Syntax.FunctionExpression && node.id) {\n            this.scopeManager.__nestFunctionExpressionNameScope(node);\n        }\n\n        // Consider this function is in the MethodDefinition.\n        this.scopeManager.__nestFunctionScope(node, this.isInnerMethodDefinition);\n\n        const that = this;\n\n        /**\n         * Visit pattern callback\n         * @param {pattern} pattern - pattern\n         * @param {Object} info - info\n         * @returns {void}\n         */\n        function visitPatternCallback(pattern, info) {\n            that.currentScope().__define(pattern,\n                new ParameterDefinition(\n                    pattern,\n                    node,\n                    i,\n                    info.rest\n                ));\n\n            that.referencingDefaultValue(pattern, info.assignments, null, true);\n        }\n\n        // Process parameter declarations.\n        for (i = 0, iz = node.params.length; i < iz; ++i) {\n            this.visitPattern(node.params[i], { processRightHandNodes: true }, visitPatternCallback);\n        }\n\n        // if there's a rest argument, add that\n        if (node.rest) {\n            this.visitPattern({\n                type: \"RestElement\",\n                argument: node.rest\n            }, pattern => {\n                this.currentScope().__define(pattern,\n                    new ParameterDefinition(\n                        pattern,\n                        node,\n                        node.params.length,\n                        true\n                    ));\n            });\n        }\n\n        // In TypeScript there are a number of function-like constructs which have no body,\n        // so check it exists before traversing\n        if (node.body) {\n\n            // Skip BlockStatement to prevent creating BlockStatement scope.\n            if (node.body.type === Syntax.BlockStatement) {\n                this.visitChildren(node.body);\n            } else {\n                this.visit(node.body);\n            }\n        }\n\n        this.close(node);\n    }\n\n    visitClass(node) {\n        if (node.type === Syntax.ClassDeclaration) {\n            this.currentScope().__define(node.id,\n                new Definition(\n                    Variable.ClassName,\n                    node.id,\n                    node,\n                    null,\n                    null,\n                    null\n                ));\n        }\n\n        this.visit(node.superClass);\n\n        this.scopeManager.__nestClassScope(node);\n\n        if (node.id) {\n            this.currentScope().__define(node.id,\n                new Definition(\n                    Variable.ClassName,\n                    node.id,\n                    node\n                ));\n        }\n        this.visit(node.body);\n\n        this.close(node);\n    }\n\n    visitProperty(node) {\n        let previous;\n\n        if (node.computed) {\n            this.visit(node.key);\n        }\n\n        const isMethodDefinition = node.type === Syntax.MethodDefinition;\n\n        if (isMethodDefinition) {\n            previous = this.pushInnerMethodDefinition(true);\n        }\n        this.visit(node.value);\n        if (isMethodDefinition) {\n            this.popInnerMethodDefinition(previous);\n        }\n    }\n\n    visitForIn(node) {\n        if (node.left.type === Syntax.VariableDeclaration && node.left.kind !== \"var\") {\n            this.scopeManager.__nestForScope(node);\n        }\n\n        if (node.left.type === Syntax.VariableDeclaration) {\n            this.visit(node.left);\n            this.visitPattern(node.left.declarations[0].id, pattern => {\n                this.currentScope().__referencing(pattern, Reference.WRITE, node.right, null, true, true);\n            });\n        } else {\n            this.visitPattern(node.left, { processRightHandNodes: true }, (pattern, info) => {\n                let maybeImplicitGlobal = null;\n\n                if (!this.currentScope().isStrict) {\n                    maybeImplicitGlobal = {\n                        pattern,\n                        node\n                    };\n                }\n                this.referencingDefaultValue(pattern, info.assignments, maybeImplicitGlobal, false);\n                this.currentScope().__referencing(pattern, Reference.WRITE, node.right, maybeImplicitGlobal, true, false);\n            });\n        }\n        this.visit(node.right);\n        this.visit(node.body);\n\n        this.close(node);\n    }\n\n    visitVariableDeclaration(variableTargetScope, type, node, index) {\n\n        const decl = node.declarations[index];\n        const init = decl.init;\n\n        this.visitPattern(decl.id, { processRightHandNodes: true }, (pattern, info) => {\n            variableTargetScope.__define(\n                pattern,\n                new Definition(\n                    type,\n                    pattern,\n                    decl,\n                    node,\n                    index,\n                    node.kind\n                )\n            );\n\n            this.referencingDefaultValue(pattern, info.assignments, null, true);\n            if (init) {\n                this.currentScope().__referencing(pattern, Reference.WRITE, init, null, !info.topLevel, true);\n            }\n        });\n    }\n\n    AssignmentExpression(node) {\n        if (PatternVisitor.isPattern(node.left)) {\n            if (node.operator === \"=\") {\n                this.visitPattern(node.left, { processRightHandNodes: true }, (pattern, info) => {\n                    let maybeImplicitGlobal = null;\n\n                    if (!this.currentScope().isStrict) {\n                        maybeImplicitGlobal = {\n                            pattern,\n                            node\n                        };\n                    }\n                    this.referencingDefaultValue(pattern, info.assignments, maybeImplicitGlobal, false);\n                    this.currentScope().__referencing(pattern, Reference.WRITE, node.right, maybeImplicitGlobal, !info.topLevel, false);\n                });\n            } else {\n                this.currentScope().__referencing(node.left, Reference.RW, node.right);\n            }\n        } else {\n            this.visit(node.left);\n        }\n        this.visit(node.right);\n    }\n\n    CatchClause(node) {\n        this.scopeManager.__nestCatchScope(node);\n\n        this.visitPattern(node.param, { processRightHandNodes: true }, (pattern, info) => {\n            this.currentScope().__define(pattern,\n                new Definition(\n                    Variable.CatchClause,\n                    node.param,\n                    node,\n                    null,\n                    null,\n                    null\n                ));\n            this.referencingDefaultValue(pattern, info.assignments, null, true);\n        });\n        this.visit(node.body);\n\n        this.close(node);\n    }\n\n    Program(node) {\n        this.scopeManager.__nestGlobalScope(node);\n\n        if (this.scopeManager.__isNodejsScope()) {\n\n            // Force strictness of GlobalScope to false when using node.js scope.\n            this.currentScope().isStrict = false;\n            this.scopeManager.__nestFunctionScope(node, false);\n        }\n\n        if (this.scopeManager.__isES6() && this.scopeManager.isModule()) {\n            this.scopeManager.__nestModuleScope(node);\n        }\n\n        if (this.scopeManager.isStrictModeSupported() && this.scopeManager.isImpliedStrict()) {\n            this.currentScope().isStrict = true;\n        }\n\n        this.visitChildren(node);\n        this.close(node);\n    }\n\n    Identifier(node) {\n        this.currentScope().__referencing(node);\n    }\n\n    UpdateExpression(node) {\n        if (PatternVisitor.isPattern(node.argument)) {\n            this.currentScope().__referencing(node.argument, Reference.RW, null);\n        } else {\n            this.visitChildren(node);\n        }\n    }\n\n    MemberExpression(node) {\n        this.visit(node.object);\n        if (node.computed) {\n            this.visit(node.property);\n        }\n    }\n\n    Property(node) {\n        this.visitProperty(node);\n    }\n\n    MethodDefinition(node) {\n        this.visitProperty(node);\n    }\n\n    BreakStatement() {} // eslint-disable-line class-methods-use-this\n\n    ContinueStatement() {} // eslint-disable-line class-methods-use-this\n\n    LabeledStatement(node) {\n        this.visit(node.body);\n    }\n\n    ForStatement(node) {\n\n        // Create ForStatement declaration.\n        // NOTE: In ES6, ForStatement dynamically generates\n        // per iteration environment. However, escope is\n        // a static analyzer, we only generate one scope for ForStatement.\n        if (node.init && node.init.type === Syntax.VariableDeclaration && node.init.kind !== \"var\") {\n            this.scopeManager.__nestForScope(node);\n        }\n\n        this.visitChildren(node);\n\n        this.close(node);\n    }\n\n    ClassExpression(node) {\n        this.visitClass(node);\n    }\n\n    ClassDeclaration(node) {\n        this.visitClass(node);\n    }\n\n    CallExpression(node) {\n\n        // Check this is direct call to eval\n        if (!this.scopeManager.__ignoreEval() && node.callee.type === Syntax.Identifier && node.callee.name === \"eval\") {\n\n            // NOTE: This should be `variableScope`. Since direct eval call always creates Lexical environment and\n            // let / const should be enclosed into it. Only VariableDeclaration affects on the caller's environment.\n            this.currentScope().variableScope.__detectEval();\n        }\n        this.visitChildren(node);\n    }\n\n    BlockStatement(node) {\n        if (this.scopeManager.__isES6()) {\n            this.scopeManager.__nestBlockScope(node);\n        }\n\n        this.visitChildren(node);\n\n        this.close(node);\n    }\n\n    ThisExpression() {\n        this.currentScope().variableScope.__detectThis();\n    }\n\n    WithStatement(node) {\n        this.visit(node.object);\n\n        // Then nest scope for WithStatement.\n        this.scopeManager.__nestWithScope(node);\n\n        this.visit(node.body);\n\n        this.close(node);\n    }\n\n    VariableDeclaration(node) {\n        const variableTargetScope = (node.kind === \"var\") ? this.currentScope().variableScope : this.currentScope();\n\n        for (let i = 0, iz = node.declarations.length; i < iz; ++i) {\n            const decl = node.declarations[i];\n\n            this.visitVariableDeclaration(variableTargetScope, Variable.Variable, node, i);\n            if (decl.init) {\n                this.visit(decl.init);\n            }\n        }\n    }\n\n    // sec 13.11.8\n    SwitchStatement(node) {\n        this.visit(node.discriminant);\n\n        if (this.scopeManager.__isES6()) {\n            this.scopeManager.__nestSwitchScope(node);\n        }\n\n        for (let i = 0, iz = node.cases.length; i < iz; ++i) {\n            this.visit(node.cases[i]);\n        }\n\n        this.close(node);\n    }\n\n    FunctionDeclaration(node) {\n        this.visitFunction(node);\n    }\n\n    FunctionExpression(node) {\n        this.visitFunction(node);\n    }\n\n    ForOfStatement(node) {\n        this.visitForIn(node);\n    }\n\n    ForInStatement(node) {\n        this.visitForIn(node);\n    }\n\n    ArrowFunctionExpression(node) {\n        this.visitFunction(node);\n    }\n\n    ImportDeclaration(node) {\n        assert(this.scopeManager.__isES6() && this.scopeManager.isModule(), \"ImportDeclaration should appear when the mode is ES6 and in the module context.\");\n\n        const importer = new Importer(node, this);\n\n        importer.visit(node);\n    }\n\n    visitExportDeclaration(node) {\n        if (node.source) {\n            return;\n        }\n        if (node.declaration) {\n            this.visit(node.declaration);\n            return;\n        }\n\n        this.visitChildren(node);\n    }\n\n    // TODO: ExportDeclaration doesn't exist. for bc?\n    ExportDeclaration(node) {\n        this.visitExportDeclaration(node);\n    }\n\n    ExportAllDeclaration(node) {\n        this.visitExportDeclaration(node);\n    }\n\n    ExportDefaultDeclaration(node) {\n        this.visitExportDeclaration(node);\n    }\n\n    ExportNamedDeclaration(node) {\n        this.visitExportDeclaration(node);\n    }\n\n    ExportSpecifier(node) {\n\n        // TODO: `node.id` doesn't exist. for bc?\n        const local = (node.id || node.local);\n\n        this.visit(local);\n    }\n\n    MetaProperty() { // eslint-disable-line class-methods-use-this\n\n        // do nothing.\n    }\n}\n\nmodule.exports = Referencer;\n\n/* vim: set sw=4 ts=4 et tw=80 : */\n\n\n//# sourceURL=webpack://javascript/./node_modules/eslint-scope/lib/referencer.js?");

/***/ }),

/***/ "./node_modules/eslint-scope/lib/scope-manager.js":
/*!********************************************************!*\
  !*** ./node_modules/eslint-scope/lib/scope-manager.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*\n  Copyright (C) 2015 Yusuke Suzuki <utatane.tea@gmail.com>\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n\n/* eslint-disable no-underscore-dangle */\n\nconst Scope = __webpack_require__(/*! ./scope */ \"./node_modules/eslint-scope/lib/scope.js\");\nconst assert = __webpack_require__(/*! assert */ \"./node_modules/assert/build/assert.js\");\n\nconst GlobalScope = Scope.GlobalScope;\nconst CatchScope = Scope.CatchScope;\nconst WithScope = Scope.WithScope;\nconst ModuleScope = Scope.ModuleScope;\nconst ClassScope = Scope.ClassScope;\nconst SwitchScope = Scope.SwitchScope;\nconst FunctionScope = Scope.FunctionScope;\nconst ForScope = Scope.ForScope;\nconst FunctionExpressionNameScope = Scope.FunctionExpressionNameScope;\nconst BlockScope = Scope.BlockScope;\n\n/**\n * @class ScopeManager\n */\nclass ScopeManager {\n    constructor(options) {\n        this.scopes = [];\n        this.globalScope = null;\n        this.__nodeToScope = new WeakMap();\n        this.__currentScope = null;\n        this.__options = options;\n        this.__declaredVariables = new WeakMap();\n    }\n\n    __useDirective() {\n        return this.__options.directive;\n    }\n\n    __isOptimistic() {\n        return this.__options.optimistic;\n    }\n\n    __ignoreEval() {\n        return this.__options.ignoreEval;\n    }\n\n    __isNodejsScope() {\n        return this.__options.nodejsScope;\n    }\n\n    isModule() {\n        return this.__options.sourceType === \"module\";\n    }\n\n    isImpliedStrict() {\n        return this.__options.impliedStrict;\n    }\n\n    isStrictModeSupported() {\n        return this.__options.ecmaVersion >= 5;\n    }\n\n    // Returns appropriate scope for this node.\n    __get(node) {\n        return this.__nodeToScope.get(node);\n    }\n\n    /**\n     * Get variables that are declared by the node.\n     *\n     * \"are declared by the node\" means the node is same as `Variable.defs[].node` or `Variable.defs[].parent`.\n     * If the node declares nothing, this method returns an empty array.\n     * CAUTION: This API is experimental. See https://github.com/estools/escope/pull/69 for more details.\n     *\n     * @param {Espree.Node} node - a node to get.\n     * @returns {Variable[]} variables that declared by the node.\n     */\n    getDeclaredVariables(node) {\n        return this.__declaredVariables.get(node) || [];\n    }\n\n    /**\n     * acquire scope from node.\n     * @method ScopeManager#acquire\n     * @param {Espree.Node} node - node for the acquired scope.\n     * @param {boolean=} inner - look up the most inner scope, default value is false.\n     * @returns {Scope?} Scope from node\n     */\n    acquire(node, inner) {\n\n        /**\n         * predicate\n         * @param {Scope} testScope - scope to test\n         * @returns {boolean} predicate\n         */\n        function predicate(testScope) {\n            if (testScope.type === \"function\" && testScope.functionExpressionScope) {\n                return false;\n            }\n            return true;\n        }\n\n        const scopes = this.__get(node);\n\n        if (!scopes || scopes.length === 0) {\n            return null;\n        }\n\n        // Heuristic selection from all scopes.\n        // If you would like to get all scopes, please use ScopeManager#acquireAll.\n        if (scopes.length === 1) {\n            return scopes[0];\n        }\n\n        if (inner) {\n            for (let i = scopes.length - 1; i >= 0; --i) {\n                const scope = scopes[i];\n\n                if (predicate(scope)) {\n                    return scope;\n                }\n            }\n        } else {\n            for (let i = 0, iz = scopes.length; i < iz; ++i) {\n                const scope = scopes[i];\n\n                if (predicate(scope)) {\n                    return scope;\n                }\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * acquire all scopes from node.\n     * @method ScopeManager#acquireAll\n     * @param {Espree.Node} node - node for the acquired scope.\n     * @returns {Scopes?} Scope array\n     */\n    acquireAll(node) {\n        return this.__get(node);\n    }\n\n    /**\n     * release the node.\n     * @method ScopeManager#release\n     * @param {Espree.Node} node - releasing node.\n     * @param {boolean=} inner - look up the most inner scope, default value is false.\n     * @returns {Scope?} upper scope for the node.\n     */\n    release(node, inner) {\n        const scopes = this.__get(node);\n\n        if (scopes && scopes.length) {\n            const scope = scopes[0].upper;\n\n            if (!scope) {\n                return null;\n            }\n            return this.acquire(scope.block, inner);\n        }\n        return null;\n    }\n\n    attach() { } // eslint-disable-line class-methods-use-this\n\n    detach() { } // eslint-disable-line class-methods-use-this\n\n    __nestScope(scope) {\n        if (scope instanceof GlobalScope) {\n            assert(this.__currentScope === null);\n            this.globalScope = scope;\n        }\n        this.__currentScope = scope;\n        return scope;\n    }\n\n    __nestGlobalScope(node) {\n        return this.__nestScope(new GlobalScope(this, node));\n    }\n\n    __nestBlockScope(node) {\n        return this.__nestScope(new BlockScope(this, this.__currentScope, node));\n    }\n\n    __nestFunctionScope(node, isMethodDefinition) {\n        return this.__nestScope(new FunctionScope(this, this.__currentScope, node, isMethodDefinition));\n    }\n\n    __nestForScope(node) {\n        return this.__nestScope(new ForScope(this, this.__currentScope, node));\n    }\n\n    __nestCatchScope(node) {\n        return this.__nestScope(new CatchScope(this, this.__currentScope, node));\n    }\n\n    __nestWithScope(node) {\n        return this.__nestScope(new WithScope(this, this.__currentScope, node));\n    }\n\n    __nestClassScope(node) {\n        return this.__nestScope(new ClassScope(this, this.__currentScope, node));\n    }\n\n    __nestSwitchScope(node) {\n        return this.__nestScope(new SwitchScope(this, this.__currentScope, node));\n    }\n\n    __nestModuleScope(node) {\n        return this.__nestScope(new ModuleScope(this, this.__currentScope, node));\n    }\n\n    __nestFunctionExpressionNameScope(node) {\n        return this.__nestScope(new FunctionExpressionNameScope(this, this.__currentScope, node));\n    }\n\n    __isES6() {\n        return this.__options.ecmaVersion >= 6;\n    }\n}\n\nmodule.exports = ScopeManager;\n\n/* vim: set sw=4 ts=4 et tw=80 : */\n\n\n//# sourceURL=webpack://javascript/./node_modules/eslint-scope/lib/scope-manager.js?");

/***/ }),

/***/ "./node_modules/eslint-scope/lib/scope.js":
/*!************************************************!*\
  !*** ./node_modules/eslint-scope/lib/scope.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*\n  Copyright (C) 2015 Yusuke Suzuki <utatane.tea@gmail.com>\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n\n/* eslint-disable no-underscore-dangle */\n/* eslint-disable no-undefined */\n\nconst Syntax = (__webpack_require__(/*! estraverse */ \"./node_modules/eslint-scope/node_modules/estraverse/estraverse.js\").Syntax);\n\nconst Reference = __webpack_require__(/*! ./reference */ \"./node_modules/eslint-scope/lib/reference.js\");\nconst Variable = __webpack_require__(/*! ./variable */ \"./node_modules/eslint-scope/lib/variable.js\");\nconst Definition = (__webpack_require__(/*! ./definition */ \"./node_modules/eslint-scope/lib/definition.js\").Definition);\nconst assert = __webpack_require__(/*! assert */ \"./node_modules/assert/build/assert.js\");\n\n/**\n * Test if scope is struct\n * @param {Scope} scope - scope\n * @param {Block} block - block\n * @param {boolean} isMethodDefinition - is method definition\n * @param {boolean} useDirective - use directive\n * @returns {boolean} is strict scope\n */\nfunction isStrictScope(scope, block, isMethodDefinition, useDirective) {\n    let body;\n\n    // When upper scope is exists and strict, inner scope is also strict.\n    if (scope.upper && scope.upper.isStrict) {\n        return true;\n    }\n\n    if (isMethodDefinition) {\n        return true;\n    }\n\n    if (scope.type === \"class\" || scope.type === \"module\") {\n        return true;\n    }\n\n    if (scope.type === \"block\" || scope.type === \"switch\") {\n        return false;\n    }\n\n    if (scope.type === \"function\") {\n        if (block.type === Syntax.ArrowFunctionExpression && block.body.type !== Syntax.BlockStatement) {\n            return false;\n        }\n\n        if (block.type === Syntax.Program) {\n            body = block;\n        } else {\n            body = block.body;\n        }\n\n        if (!body) {\n            return false;\n        }\n    } else if (scope.type === \"global\") {\n        body = block;\n    } else {\n        return false;\n    }\n\n    // Search 'use strict' directive.\n    if (useDirective) {\n        for (let i = 0, iz = body.body.length; i < iz; ++i) {\n            const stmt = body.body[i];\n\n            if (stmt.type !== Syntax.DirectiveStatement) {\n                break;\n            }\n            if (stmt.raw === \"\\\"use strict\\\"\" || stmt.raw === \"'use strict'\") {\n                return true;\n            }\n        }\n    } else {\n        for (let i = 0, iz = body.body.length; i < iz; ++i) {\n            const stmt = body.body[i];\n\n            if (stmt.type !== Syntax.ExpressionStatement) {\n                break;\n            }\n            const expr = stmt.expression;\n\n            if (expr.type !== Syntax.Literal || typeof expr.value !== \"string\") {\n                break;\n            }\n            if (expr.raw !== null && expr.raw !== undefined) {\n                if (expr.raw === \"\\\"use strict\\\"\" || expr.raw === \"'use strict'\") {\n                    return true;\n                }\n            } else {\n                if (expr.value === \"use strict\") {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n\n/**\n * Register scope\n * @param {ScopeManager} scopeManager - scope manager\n * @param {Scope} scope - scope\n * @returns {void}\n */\nfunction registerScope(scopeManager, scope) {\n    scopeManager.scopes.push(scope);\n\n    const scopes = scopeManager.__nodeToScope.get(scope.block);\n\n    if (scopes) {\n        scopes.push(scope);\n    } else {\n        scopeManager.__nodeToScope.set(scope.block, [scope]);\n    }\n}\n\n/**\n * Should be statically\n * @param {Object} def - def\n * @returns {boolean} should be statically\n */\nfunction shouldBeStatically(def) {\n    return (\n        (def.type === Variable.ClassName) ||\n        (def.type === Variable.Variable && def.parent.kind !== \"var\")\n    );\n}\n\n/**\n * @class Scope\n */\nclass Scope {\n    constructor(scopeManager, type, upperScope, block, isMethodDefinition) {\n\n        /**\n         * One of 'module', 'block', 'switch', 'function', 'catch', 'with', 'function', 'class', 'global'.\n         * @member {String} Scope#type\n         */\n        this.type = type;\n\n        /**\n         * The scoped {@link Variable}s of this scope, as <code>{ Variable.name\n         * : Variable }</code>.\n         * @member {Map} Scope#set\n         */\n        this.set = new Map();\n\n        /**\n         * The tainted variables of this scope, as <code>{ Variable.name :\n         * boolean }</code>.\n         * @member {Map} Scope#taints */\n        this.taints = new Map();\n\n        /**\n         * Generally, through the lexical scoping of JS you can always know\n         * which variable an identifier in the source code refers to. There are\n         * a few exceptions to this rule. With 'global' and 'with' scopes you\n         * can only decide at runtime which variable a reference refers to.\n         * Moreover, if 'eval()' is used in a scope, it might introduce new\n         * bindings in this or its parent scopes.\n         * All those scopes are considered 'dynamic'.\n         * @member {boolean} Scope#dynamic\n         */\n        this.dynamic = this.type === \"global\" || this.type === \"with\";\n\n        /**\n         * A reference to the scope-defining syntax node.\n         * @member {espree.Node} Scope#block\n         */\n        this.block = block;\n\n        /**\n         * The {@link Reference|references} that are not resolved with this scope.\n         * @member {Reference[]} Scope#through\n         */\n        this.through = [];\n\n        /**\n         * The scoped {@link Variable}s of this scope. In the case of a\n         * 'function' scope this includes the automatic argument <em>arguments</em> as\n         * its first element, as well as all further formal arguments.\n         * @member {Variable[]} Scope#variables\n         */\n        this.variables = [];\n\n        /**\n         * Any variable {@link Reference|reference} found in this scope. This\n         * includes occurrences of local variables as well as variables from\n         * parent scopes (including the global scope). For local variables\n         * this also includes defining occurrences (like in a 'var' statement).\n         * In a 'function' scope this does not include the occurrences of the\n         * formal parameter in the parameter list.\n         * @member {Reference[]} Scope#references\n         */\n        this.references = [];\n\n        /**\n         * For 'global' and 'function' scopes, this is a self-reference. For\n         * other scope types this is the <em>variableScope</em> value of the\n         * parent scope.\n         * @member {Scope} Scope#variableScope\n         */\n        this.variableScope =\n            (this.type === \"global\" || this.type === \"function\" || this.type === \"module\") ? this : upperScope.variableScope;\n\n        /**\n         * Whether this scope is created by a FunctionExpression.\n         * @member {boolean} Scope#functionExpressionScope\n         */\n        this.functionExpressionScope = false;\n\n        /**\n         * Whether this is a scope that contains an 'eval()' invocation.\n         * @member {boolean} Scope#directCallToEvalScope\n         */\n        this.directCallToEvalScope = false;\n\n        /**\n         * @member {boolean} Scope#thisFound\n         */\n        this.thisFound = false;\n\n        this.__left = [];\n\n        /**\n         * Reference to the parent {@link Scope|scope}.\n         * @member {Scope} Scope#upper\n         */\n        this.upper = upperScope;\n\n        /**\n         * Whether 'use strict' is in effect in this scope.\n         * @member {boolean} Scope#isStrict\n         */\n        this.isStrict = isStrictScope(this, block, isMethodDefinition, scopeManager.__useDirective());\n\n        /**\n         * List of nested {@link Scope}s.\n         * @member {Scope[]} Scope#childScopes\n         */\n        this.childScopes = [];\n        if (this.upper) {\n            this.upper.childScopes.push(this);\n        }\n\n        this.__declaredVariables = scopeManager.__declaredVariables;\n\n        registerScope(scopeManager, this);\n    }\n\n    __shouldStaticallyClose(scopeManager) {\n        return (!this.dynamic || scopeManager.__isOptimistic());\n    }\n\n    __shouldStaticallyCloseForGlobal(ref) {\n\n        // On global scope, let/const/class declarations should be resolved statically.\n        const name = ref.identifier.name;\n\n        if (!this.set.has(name)) {\n            return false;\n        }\n\n        const variable = this.set.get(name);\n        const defs = variable.defs;\n\n        return defs.length > 0 && defs.every(shouldBeStatically);\n    }\n\n    __staticCloseRef(ref) {\n        if (!this.__resolve(ref)) {\n            this.__delegateToUpperScope(ref);\n        }\n    }\n\n    __dynamicCloseRef(ref) {\n\n        // notify all names are through to global\n        let current = this;\n\n        do {\n            current.through.push(ref);\n            current = current.upper;\n        } while (current);\n    }\n\n    __globalCloseRef(ref) {\n\n        // let/const/class declarations should be resolved statically.\n        // others should be resolved dynamically.\n        if (this.__shouldStaticallyCloseForGlobal(ref)) {\n            this.__staticCloseRef(ref);\n        } else {\n            this.__dynamicCloseRef(ref);\n        }\n    }\n\n    __close(scopeManager) {\n        let closeRef;\n\n        if (this.__shouldStaticallyClose(scopeManager)) {\n            closeRef = this.__staticCloseRef;\n        } else if (this.type !== \"global\") {\n            closeRef = this.__dynamicCloseRef;\n        } else {\n            closeRef = this.__globalCloseRef;\n        }\n\n        // Try Resolving all references in this scope.\n        for (let i = 0, iz = this.__left.length; i < iz; ++i) {\n            const ref = this.__left[i];\n\n            closeRef.call(this, ref);\n        }\n        this.__left = null;\n\n        return this.upper;\n    }\n\n    // To override by function scopes.\n    // References in default parameters isn't resolved to variables which are in their function body.\n    __isValidResolution(ref, variable) { // eslint-disable-line class-methods-use-this, no-unused-vars\n        return true;\n    }\n\n    __resolve(ref) {\n        const name = ref.identifier.name;\n\n        if (!this.set.has(name)) {\n            return false;\n        }\n        const variable = this.set.get(name);\n\n        if (!this.__isValidResolution(ref, variable)) {\n            return false;\n        }\n        variable.references.push(ref);\n        variable.stack = variable.stack && ref.from.variableScope === this.variableScope;\n        if (ref.tainted) {\n            variable.tainted = true;\n            this.taints.set(variable.name, true);\n        }\n        ref.resolved = variable;\n\n        return true;\n    }\n\n    __delegateToUpperScope(ref) {\n        if (this.upper) {\n            this.upper.__left.push(ref);\n        }\n        this.through.push(ref);\n    }\n\n    __addDeclaredVariablesOfNode(variable, node) {\n        if (node === null || node === undefined) {\n            return;\n        }\n\n        let variables = this.__declaredVariables.get(node);\n\n        if (variables === null || variables === undefined) {\n            variables = [];\n            this.__declaredVariables.set(node, variables);\n        }\n        if (variables.indexOf(variable) === -1) {\n            variables.push(variable);\n        }\n    }\n\n    __defineGeneric(name, set, variables, node, def) {\n        let variable;\n\n        variable = set.get(name);\n        if (!variable) {\n            variable = new Variable(name, this);\n            set.set(name, variable);\n            variables.push(variable);\n        }\n\n        if (def) {\n            variable.defs.push(def);\n            this.__addDeclaredVariablesOfNode(variable, def.node);\n            this.__addDeclaredVariablesOfNode(variable, def.parent);\n        }\n        if (node) {\n            variable.identifiers.push(node);\n        }\n    }\n\n    __define(node, def) {\n        if (node && node.type === Syntax.Identifier) {\n            this.__defineGeneric(\n                node.name,\n                this.set,\n                this.variables,\n                node,\n                def\n            );\n        }\n    }\n\n    __referencing(node, assign, writeExpr, maybeImplicitGlobal, partial, init) {\n\n        // because Array element may be null\n        if (!node || node.type !== Syntax.Identifier) {\n            return;\n        }\n\n        // Specially handle like `this`.\n        if (node.name === \"super\") {\n            return;\n        }\n\n        const ref = new Reference(node, this, assign || Reference.READ, writeExpr, maybeImplicitGlobal, !!partial, !!init);\n\n        this.references.push(ref);\n        this.__left.push(ref);\n    }\n\n    __detectEval() {\n        let current = this;\n\n        this.directCallToEvalScope = true;\n        do {\n            current.dynamic = true;\n            current = current.upper;\n        } while (current);\n    }\n\n    __detectThis() {\n        this.thisFound = true;\n    }\n\n    __isClosed() {\n        return this.__left === null;\n    }\n\n    /**\n     * returns resolved {Reference}\n     * @method Scope#resolve\n     * @param {Espree.Identifier} ident - identifier to be resolved.\n     * @returns {Reference} reference\n     */\n    resolve(ident) {\n        let ref, i, iz;\n\n        assert(this.__isClosed(), \"Scope should be closed.\");\n        assert(ident.type === Syntax.Identifier, \"Target should be identifier.\");\n        for (i = 0, iz = this.references.length; i < iz; ++i) {\n            ref = this.references[i];\n            if (ref.identifier === ident) {\n                return ref;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * returns this scope is static\n     * @method Scope#isStatic\n     * @returns {boolean} static\n     */\n    isStatic() {\n        return !this.dynamic;\n    }\n\n    /**\n     * returns this scope has materialized arguments\n     * @method Scope#isArgumentsMaterialized\n     * @returns {boolean} arguemnts materialized\n     */\n    isArgumentsMaterialized() { // eslint-disable-line class-methods-use-this\n        return true;\n    }\n\n    /**\n     * returns this scope has materialized `this` reference\n     * @method Scope#isThisMaterialized\n     * @returns {boolean} this materialized\n     */\n    isThisMaterialized() { // eslint-disable-line class-methods-use-this\n        return true;\n    }\n\n    isUsedName(name) {\n        if (this.set.has(name)) {\n            return true;\n        }\n        for (let i = 0, iz = this.through.length; i < iz; ++i) {\n            if (this.through[i].identifier.name === name) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n\nclass GlobalScope extends Scope {\n    constructor(scopeManager, block) {\n        super(scopeManager, \"global\", null, block, false);\n        this.implicit = {\n            set: new Map(),\n            variables: [],\n\n            /**\n            * List of {@link Reference}s that are left to be resolved (i.e. which\n            * need to be linked to the variable they refer to).\n            * @member {Reference[]} Scope#implicit#left\n            */\n            left: []\n        };\n    }\n\n    __close(scopeManager) {\n        const implicit = [];\n\n        for (let i = 0, iz = this.__left.length; i < iz; ++i) {\n            const ref = this.__left[i];\n\n            if (ref.__maybeImplicitGlobal && !this.set.has(ref.identifier.name)) {\n                implicit.push(ref.__maybeImplicitGlobal);\n            }\n        }\n\n        // create an implicit global variable from assignment expression\n        for (let i = 0, iz = implicit.length; i < iz; ++i) {\n            const info = implicit[i];\n\n            this.__defineImplicit(info.pattern,\n                new Definition(\n                    Variable.ImplicitGlobalVariable,\n                    info.pattern,\n                    info.node,\n                    null,\n                    null,\n                    null\n                ));\n\n        }\n\n        this.implicit.left = this.__left;\n\n        return super.__close(scopeManager);\n    }\n\n    __defineImplicit(node, def) {\n        if (node && node.type === Syntax.Identifier) {\n            this.__defineGeneric(\n                node.name,\n                this.implicit.set,\n                this.implicit.variables,\n                node,\n                def\n            );\n        }\n    }\n}\n\nclass ModuleScope extends Scope {\n    constructor(scopeManager, upperScope, block) {\n        super(scopeManager, \"module\", upperScope, block, false);\n    }\n}\n\nclass FunctionExpressionNameScope extends Scope {\n    constructor(scopeManager, upperScope, block) {\n        super(scopeManager, \"function-expression-name\", upperScope, block, false);\n        this.__define(block.id,\n            new Definition(\n                Variable.FunctionName,\n                block.id,\n                block,\n                null,\n                null,\n                null\n            ));\n        this.functionExpressionScope = true;\n    }\n}\n\nclass CatchScope extends Scope {\n    constructor(scopeManager, upperScope, block) {\n        super(scopeManager, \"catch\", upperScope, block, false);\n    }\n}\n\nclass WithScope extends Scope {\n    constructor(scopeManager, upperScope, block) {\n        super(scopeManager, \"with\", upperScope, block, false);\n    }\n\n    __close(scopeManager) {\n        if (this.__shouldStaticallyClose(scopeManager)) {\n            return super.__close(scopeManager);\n        }\n\n        for (let i = 0, iz = this.__left.length; i < iz; ++i) {\n            const ref = this.__left[i];\n\n            ref.tainted = true;\n            this.__delegateToUpperScope(ref);\n        }\n        this.__left = null;\n\n        return this.upper;\n    }\n}\n\nclass BlockScope extends Scope {\n    constructor(scopeManager, upperScope, block) {\n        super(scopeManager, \"block\", upperScope, block, false);\n    }\n}\n\nclass SwitchScope extends Scope {\n    constructor(scopeManager, upperScope, block) {\n        super(scopeManager, \"switch\", upperScope, block, false);\n    }\n}\n\nclass FunctionScope extends Scope {\n    constructor(scopeManager, upperScope, block, isMethodDefinition) {\n        super(scopeManager, \"function\", upperScope, block, isMethodDefinition);\n\n        // section 9.2.13, FunctionDeclarationInstantiation.\n        // NOTE Arrow functions never have an arguments objects.\n        if (this.block.type !== Syntax.ArrowFunctionExpression) {\n            this.__defineArguments();\n        }\n    }\n\n    isArgumentsMaterialized() {\n\n        // TODO(Constellation)\n        // We can more aggressive on this condition like this.\n        //\n        // function t() {\n        //     // arguments of t is always hidden.\n        //     function arguments() {\n        //     }\n        // }\n        if (this.block.type === Syntax.ArrowFunctionExpression) {\n            return false;\n        }\n\n        if (!this.isStatic()) {\n            return true;\n        }\n\n        const variable = this.set.get(\"arguments\");\n\n        assert(variable, \"Always have arguments variable.\");\n        return variable.tainted || variable.references.length !== 0;\n    }\n\n    isThisMaterialized() {\n        if (!this.isStatic()) {\n            return true;\n        }\n        return this.thisFound;\n    }\n\n    __defineArguments() {\n        this.__defineGeneric(\n            \"arguments\",\n            this.set,\n            this.variables,\n            null,\n            null\n        );\n        this.taints.set(\"arguments\", true);\n    }\n\n    // References in default parameters isn't resolved to variables which are in their function body.\n    //     const x = 1\n    //     function f(a = x) { // This `x` is resolved to the `x` in the outer scope.\n    //         const x = 2\n    //         console.log(a)\n    //     }\n    __isValidResolution(ref, variable) {\n\n        // If `options.nodejsScope` is true, `this.block` becomes a Program node.\n        if (this.block.type === \"Program\") {\n            return true;\n        }\n\n        const bodyStart = this.block.body.range[0];\n\n        // It's invalid resolution in the following case:\n        return !(\n            variable.scope === this &&\n            ref.identifier.range[0] < bodyStart && // the reference is in the parameter part.\n            variable.defs.every(d => d.name.range[0] >= bodyStart) // the variable is in the body.\n        );\n    }\n}\n\nclass ForScope extends Scope {\n    constructor(scopeManager, upperScope, block) {\n        super(scopeManager, \"for\", upperScope, block, false);\n    }\n}\n\nclass ClassScope extends Scope {\n    constructor(scopeManager, upperScope, block) {\n        super(scopeManager, \"class\", upperScope, block, false);\n    }\n}\n\nmodule.exports = {\n    Scope,\n    GlobalScope,\n    ModuleScope,\n    FunctionExpressionNameScope,\n    CatchScope,\n    WithScope,\n    BlockScope,\n    SwitchScope,\n    FunctionScope,\n    ForScope,\n    ClassScope\n};\n\n/* vim: set sw=4 ts=4 et tw=80 : */\n\n\n//# sourceURL=webpack://javascript/./node_modules/eslint-scope/lib/scope.js?");

/***/ }),

/***/ "./node_modules/eslint-scope/lib/variable.js":
/*!***************************************************!*\
  !*** ./node_modules/eslint-scope/lib/variable.js ***!
  \***************************************************/
/***/ ((module) => {

"use strict";
eval("/*\n  Copyright (C) 2015 Yusuke Suzuki <utatane.tea@gmail.com>\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n\n/**\n * A Variable represents a locally scoped identifier. These include arguments to\n * functions.\n * @class Variable\n */\nclass Variable {\n    constructor(name, scope) {\n\n        /**\n         * The variable name, as given in the source code.\n         * @member {String} Variable#name\n         */\n        this.name = name;\n\n        /**\n         * List of defining occurrences of this variable (like in 'var ...'\n         * statements or as parameter), as AST nodes.\n         * @member {espree.Identifier[]} Variable#identifiers\n         */\n        this.identifiers = [];\n\n        /**\n         * List of {@link Reference|references} of this variable (excluding parameter entries)\n         * in its defining scope and all nested scopes. For defining\n         * occurrences only see {@link Variable#defs}.\n         * @member {Reference[]} Variable#references\n         */\n        this.references = [];\n\n        /**\n         * List of defining occurrences of this variable (like in 'var ...'\n         * statements or as parameter), as custom objects.\n         * @member {Definition[]} Variable#defs\n         */\n        this.defs = [];\n\n        this.tainted = false;\n\n        /**\n         * Whether this is a stack variable.\n         * @member {boolean} Variable#stack\n         */\n        this.stack = true;\n\n        /**\n         * Reference to the enclosing Scope.\n         * @member {Scope} Variable#scope\n         */\n        this.scope = scope;\n    }\n}\n\nVariable.CatchClause = \"CatchClause\";\nVariable.Parameter = \"Parameter\";\nVariable.FunctionName = \"FunctionName\";\nVariable.ClassName = \"ClassName\";\nVariable.Variable = \"Variable\";\nVariable.ImportBinding = \"ImportBinding\";\nVariable.ImplicitGlobalVariable = \"ImplicitGlobalVariable\";\n\nmodule.exports = Variable;\n\n/* vim: set sw=4 ts=4 et tw=80 : */\n\n\n//# sourceURL=webpack://javascript/./node_modules/eslint-scope/lib/variable.js?");

/***/ }),

/***/ "./node_modules/eslint-scope/node_modules/estraverse/estraverse.js":
/*!*************************************************************************!*\
  !*** ./node_modules/eslint-scope/node_modules/estraverse/estraverse.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/*\n  Copyright (C) 2012-2013 Yusuke Suzuki <utatane.tea@gmail.com>\n  Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com>\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n/*jslint vars:false, bitwise:true*/\n/*jshint indent:4*/\n/*global exports:true*/\n(function clone(exports) {\n    'use strict';\n\n    var Syntax,\n        VisitorOption,\n        VisitorKeys,\n        BREAK,\n        SKIP,\n        REMOVE;\n\n    function deepCopy(obj) {\n        var ret = {}, key, val;\n        for (key in obj) {\n            if (obj.hasOwnProperty(key)) {\n                val = obj[key];\n                if (typeof val === 'object' && val !== null) {\n                    ret[key] = deepCopy(val);\n                } else {\n                    ret[key] = val;\n                }\n            }\n        }\n        return ret;\n    }\n\n    // based on LLVM libc++ upper_bound / lower_bound\n    // MIT License\n\n    function upperBound(array, func) {\n        var diff, len, i, current;\n\n        len = array.length;\n        i = 0;\n\n        while (len) {\n            diff = len >>> 1;\n            current = i + diff;\n            if (func(array[current])) {\n                len = diff;\n            } else {\n                i = current + 1;\n                len -= diff + 1;\n            }\n        }\n        return i;\n    }\n\n    Syntax = {\n        AssignmentExpression: 'AssignmentExpression',\n        AssignmentPattern: 'AssignmentPattern',\n        ArrayExpression: 'ArrayExpression',\n        ArrayPattern: 'ArrayPattern',\n        ArrowFunctionExpression: 'ArrowFunctionExpression',\n        AwaitExpression: 'AwaitExpression', // CAUTION: It's deferred to ES7.\n        BlockStatement: 'BlockStatement',\n        BinaryExpression: 'BinaryExpression',\n        BreakStatement: 'BreakStatement',\n        CallExpression: 'CallExpression',\n        CatchClause: 'CatchClause',\n        ClassBody: 'ClassBody',\n        ClassDeclaration: 'ClassDeclaration',\n        ClassExpression: 'ClassExpression',\n        ComprehensionBlock: 'ComprehensionBlock',  // CAUTION: It's deferred to ES7.\n        ComprehensionExpression: 'ComprehensionExpression',  // CAUTION: It's deferred to ES7.\n        ConditionalExpression: 'ConditionalExpression',\n        ContinueStatement: 'ContinueStatement',\n        DebuggerStatement: 'DebuggerStatement',\n        DirectiveStatement: 'DirectiveStatement',\n        DoWhileStatement: 'DoWhileStatement',\n        EmptyStatement: 'EmptyStatement',\n        ExportAllDeclaration: 'ExportAllDeclaration',\n        ExportDefaultDeclaration: 'ExportDefaultDeclaration',\n        ExportNamedDeclaration: 'ExportNamedDeclaration',\n        ExportSpecifier: 'ExportSpecifier',\n        ExpressionStatement: 'ExpressionStatement',\n        ForStatement: 'ForStatement',\n        ForInStatement: 'ForInStatement',\n        ForOfStatement: 'ForOfStatement',\n        FunctionDeclaration: 'FunctionDeclaration',\n        FunctionExpression: 'FunctionExpression',\n        GeneratorExpression: 'GeneratorExpression',  // CAUTION: It's deferred to ES7.\n        Identifier: 'Identifier',\n        IfStatement: 'IfStatement',\n        ImportExpression: 'ImportExpression',\n        ImportDeclaration: 'ImportDeclaration',\n        ImportDefaultSpecifier: 'ImportDefaultSpecifier',\n        ImportNamespaceSpecifier: 'ImportNamespaceSpecifier',\n        ImportSpecifier: 'ImportSpecifier',\n        Literal: 'Literal',\n        LabeledStatement: 'LabeledStatement',\n        LogicalExpression: 'LogicalExpression',\n        MemberExpression: 'MemberExpression',\n        MetaProperty: 'MetaProperty',\n        MethodDefinition: 'MethodDefinition',\n        ModuleSpecifier: 'ModuleSpecifier',\n        NewExpression: 'NewExpression',\n        ObjectExpression: 'ObjectExpression',\n        ObjectPattern: 'ObjectPattern',\n        Program: 'Program',\n        Property: 'Property',\n        RestElement: 'RestElement',\n        ReturnStatement: 'ReturnStatement',\n        SequenceExpression: 'SequenceExpression',\n        SpreadElement: 'SpreadElement',\n        Super: 'Super',\n        SwitchStatement: 'SwitchStatement',\n        SwitchCase: 'SwitchCase',\n        TaggedTemplateExpression: 'TaggedTemplateExpression',\n        TemplateElement: 'TemplateElement',\n        TemplateLiteral: 'TemplateLiteral',\n        ThisExpression: 'ThisExpression',\n        ThrowStatement: 'ThrowStatement',\n        TryStatement: 'TryStatement',\n        UnaryExpression: 'UnaryExpression',\n        UpdateExpression: 'UpdateExpression',\n        VariableDeclaration: 'VariableDeclaration',\n        VariableDeclarator: 'VariableDeclarator',\n        WhileStatement: 'WhileStatement',\n        WithStatement: 'WithStatement',\n        YieldExpression: 'YieldExpression'\n    };\n\n    VisitorKeys = {\n        AssignmentExpression: ['left', 'right'],\n        AssignmentPattern: ['left', 'right'],\n        ArrayExpression: ['elements'],\n        ArrayPattern: ['elements'],\n        ArrowFunctionExpression: ['params', 'body'],\n        AwaitExpression: ['argument'], // CAUTION: It's deferred to ES7.\n        BlockStatement: ['body'],\n        BinaryExpression: ['left', 'right'],\n        BreakStatement: ['label'],\n        CallExpression: ['callee', 'arguments'],\n        CatchClause: ['param', 'body'],\n        ClassBody: ['body'],\n        ClassDeclaration: ['id', 'superClass', 'body'],\n        ClassExpression: ['id', 'superClass', 'body'],\n        ComprehensionBlock: ['left', 'right'],  // CAUTION: It's deferred to ES7.\n        ComprehensionExpression: ['blocks', 'filter', 'body'],  // CAUTION: It's deferred to ES7.\n        ConditionalExpression: ['test', 'consequent', 'alternate'],\n        ContinueStatement: ['label'],\n        DebuggerStatement: [],\n        DirectiveStatement: [],\n        DoWhileStatement: ['body', 'test'],\n        EmptyStatement: [],\n        ExportAllDeclaration: ['source'],\n        ExportDefaultDeclaration: ['declaration'],\n        ExportNamedDeclaration: ['declaration', 'specifiers', 'source'],\n        ExportSpecifier: ['exported', 'local'],\n        ExpressionStatement: ['expression'],\n        ForStatement: ['init', 'test', 'update', 'body'],\n        ForInStatement: ['left', 'right', 'body'],\n        ForOfStatement: ['left', 'right', 'body'],\n        FunctionDeclaration: ['id', 'params', 'body'],\n        FunctionExpression: ['id', 'params', 'body'],\n        GeneratorExpression: ['blocks', 'filter', 'body'],  // CAUTION: It's deferred to ES7.\n        Identifier: [],\n        IfStatement: ['test', 'consequent', 'alternate'],\n        ImportExpression: ['source'],\n        ImportDeclaration: ['specifiers', 'source'],\n        ImportDefaultSpecifier: ['local'],\n        ImportNamespaceSpecifier: ['local'],\n        ImportSpecifier: ['imported', 'local'],\n        Literal: [],\n        LabeledStatement: ['label', 'body'],\n        LogicalExpression: ['left', 'right'],\n        MemberExpression: ['object', 'property'],\n        MetaProperty: ['meta', 'property'],\n        MethodDefinition: ['key', 'value'],\n        ModuleSpecifier: [],\n        NewExpression: ['callee', 'arguments'],\n        ObjectExpression: ['properties'],\n        ObjectPattern: ['properties'],\n        Program: ['body'],\n        Property: ['key', 'value'],\n        RestElement: [ 'argument' ],\n        ReturnStatement: ['argument'],\n        SequenceExpression: ['expressions'],\n        SpreadElement: ['argument'],\n        Super: [],\n        SwitchStatement: ['discriminant', 'cases'],\n        SwitchCase: ['test', 'consequent'],\n        TaggedTemplateExpression: ['tag', 'quasi'],\n        TemplateElement: [],\n        TemplateLiteral: ['quasis', 'expressions'],\n        ThisExpression: [],\n        ThrowStatement: ['argument'],\n        TryStatement: ['block', 'handler', 'finalizer'],\n        UnaryExpression: ['argument'],\n        UpdateExpression: ['argument'],\n        VariableDeclaration: ['declarations'],\n        VariableDeclarator: ['id', 'init'],\n        WhileStatement: ['test', 'body'],\n        WithStatement: ['object', 'body'],\n        YieldExpression: ['argument']\n    };\n\n    // unique id\n    BREAK = {};\n    SKIP = {};\n    REMOVE = {};\n\n    VisitorOption = {\n        Break: BREAK,\n        Skip: SKIP,\n        Remove: REMOVE\n    };\n\n    function Reference(parent, key) {\n        this.parent = parent;\n        this.key = key;\n    }\n\n    Reference.prototype.replace = function replace(node) {\n        this.parent[this.key] = node;\n    };\n\n    Reference.prototype.remove = function remove() {\n        if (Array.isArray(this.parent)) {\n            this.parent.splice(this.key, 1);\n            return true;\n        } else {\n            this.replace(null);\n            return false;\n        }\n    };\n\n    function Element(node, path, wrap, ref) {\n        this.node = node;\n        this.path = path;\n        this.wrap = wrap;\n        this.ref = ref;\n    }\n\n    function Controller() { }\n\n    // API:\n    // return property path array from root to current node\n    Controller.prototype.path = function path() {\n        var i, iz, j, jz, result, element;\n\n        function addToPath(result, path) {\n            if (Array.isArray(path)) {\n                for (j = 0, jz = path.length; j < jz; ++j) {\n                    result.push(path[j]);\n                }\n            } else {\n                result.push(path);\n            }\n        }\n\n        // root node\n        if (!this.__current.path) {\n            return null;\n        }\n\n        // first node is sentinel, second node is root element\n        result = [];\n        for (i = 2, iz = this.__leavelist.length; i < iz; ++i) {\n            element = this.__leavelist[i];\n            addToPath(result, element.path);\n        }\n        addToPath(result, this.__current.path);\n        return result;\n    };\n\n    // API:\n    // return type of current node\n    Controller.prototype.type = function () {\n        var node = this.current();\n        return node.type || this.__current.wrap;\n    };\n\n    // API:\n    // return array of parent elements\n    Controller.prototype.parents = function parents() {\n        var i, iz, result;\n\n        // first node is sentinel\n        result = [];\n        for (i = 1, iz = this.__leavelist.length; i < iz; ++i) {\n            result.push(this.__leavelist[i].node);\n        }\n\n        return result;\n    };\n\n    // API:\n    // return current node\n    Controller.prototype.current = function current() {\n        return this.__current.node;\n    };\n\n    Controller.prototype.__execute = function __execute(callback, element) {\n        var previous, result;\n\n        result = undefined;\n\n        previous  = this.__current;\n        this.__current = element;\n        this.__state = null;\n        if (callback) {\n            result = callback.call(this, element.node, this.__leavelist[this.__leavelist.length - 1].node);\n        }\n        this.__current = previous;\n\n        return result;\n    };\n\n    // API:\n    // notify control skip / break\n    Controller.prototype.notify = function notify(flag) {\n        this.__state = flag;\n    };\n\n    // API:\n    // skip child nodes of current node\n    Controller.prototype.skip = function () {\n        this.notify(SKIP);\n    };\n\n    // API:\n    // break traversals\n    Controller.prototype['break'] = function () {\n        this.notify(BREAK);\n    };\n\n    // API:\n    // remove node\n    Controller.prototype.remove = function () {\n        this.notify(REMOVE);\n    };\n\n    Controller.prototype.__initialize = function(root, visitor) {\n        this.visitor = visitor;\n        this.root = root;\n        this.__worklist = [];\n        this.__leavelist = [];\n        this.__current = null;\n        this.__state = null;\n        this.__fallback = null;\n        if (visitor.fallback === 'iteration') {\n            this.__fallback = Object.keys;\n        } else if (typeof visitor.fallback === 'function') {\n            this.__fallback = visitor.fallback;\n        }\n\n        this.__keys = VisitorKeys;\n        if (visitor.keys) {\n            this.__keys = Object.assign(Object.create(this.__keys), visitor.keys);\n        }\n    };\n\n    function isNode(node) {\n        if (node == null) {\n            return false;\n        }\n        return typeof node === 'object' && typeof node.type === 'string';\n    }\n\n    function isProperty(nodeType, key) {\n        return (nodeType === Syntax.ObjectExpression || nodeType === Syntax.ObjectPattern) && 'properties' === key;\n    }\n\n    Controller.prototype.traverse = function traverse(root, visitor) {\n        var worklist,\n            leavelist,\n            element,\n            node,\n            nodeType,\n            ret,\n            key,\n            current,\n            current2,\n            candidates,\n            candidate,\n            sentinel;\n\n        this.__initialize(root, visitor);\n\n        sentinel = {};\n\n        // reference\n        worklist = this.__worklist;\n        leavelist = this.__leavelist;\n\n        // initialize\n        worklist.push(new Element(root, null, null, null));\n        leavelist.push(new Element(null, null, null, null));\n\n        while (worklist.length) {\n            element = worklist.pop();\n\n            if (element === sentinel) {\n                element = leavelist.pop();\n\n                ret = this.__execute(visitor.leave, element);\n\n                if (this.__state === BREAK || ret === BREAK) {\n                    return;\n                }\n                continue;\n            }\n\n            if (element.node) {\n\n                ret = this.__execute(visitor.enter, element);\n\n                if (this.__state === BREAK || ret === BREAK) {\n                    return;\n                }\n\n                worklist.push(sentinel);\n                leavelist.push(element);\n\n                if (this.__state === SKIP || ret === SKIP) {\n                    continue;\n                }\n\n                node = element.node;\n                nodeType = node.type || element.wrap;\n                candidates = this.__keys[nodeType];\n                if (!candidates) {\n                    if (this.__fallback) {\n                        candidates = this.__fallback(node);\n                    } else {\n                        throw new Error('Unknown node type ' + nodeType + '.');\n                    }\n                }\n\n                current = candidates.length;\n                while ((current -= 1) >= 0) {\n                    key = candidates[current];\n                    candidate = node[key];\n                    if (!candidate) {\n                        continue;\n                    }\n\n                    if (Array.isArray(candidate)) {\n                        current2 = candidate.length;\n                        while ((current2 -= 1) >= 0) {\n                            if (!candidate[current2]) {\n                                continue;\n                            }\n                            if (isProperty(nodeType, candidates[current])) {\n                                element = new Element(candidate[current2], [key, current2], 'Property', null);\n                            } else if (isNode(candidate[current2])) {\n                                element = new Element(candidate[current2], [key, current2], null, null);\n                            } else {\n                                continue;\n                            }\n                            worklist.push(element);\n                        }\n                    } else if (isNode(candidate)) {\n                        worklist.push(new Element(candidate, key, null, null));\n                    }\n                }\n            }\n        }\n    };\n\n    Controller.prototype.replace = function replace(root, visitor) {\n        var worklist,\n            leavelist,\n            node,\n            nodeType,\n            target,\n            element,\n            current,\n            current2,\n            candidates,\n            candidate,\n            sentinel,\n            outer,\n            key;\n\n        function removeElem(element) {\n            var i,\n                key,\n                nextElem,\n                parent;\n\n            if (element.ref.remove()) {\n                // When the reference is an element of an array.\n                key = element.ref.key;\n                parent = element.ref.parent;\n\n                // If removed from array, then decrease following items' keys.\n                i = worklist.length;\n                while (i--) {\n                    nextElem = worklist[i];\n                    if (nextElem.ref && nextElem.ref.parent === parent) {\n                        if  (nextElem.ref.key < key) {\n                            break;\n                        }\n                        --nextElem.ref.key;\n                    }\n                }\n            }\n        }\n\n        this.__initialize(root, visitor);\n\n        sentinel = {};\n\n        // reference\n        worklist = this.__worklist;\n        leavelist = this.__leavelist;\n\n        // initialize\n        outer = {\n            root: root\n        };\n        element = new Element(root, null, null, new Reference(outer, 'root'));\n        worklist.push(element);\n        leavelist.push(element);\n\n        while (worklist.length) {\n            element = worklist.pop();\n\n            if (element === sentinel) {\n                element = leavelist.pop();\n\n                target = this.__execute(visitor.leave, element);\n\n                // node may be replaced with null,\n                // so distinguish between undefined and null in this place\n                if (target !== undefined && target !== BREAK && target !== SKIP && target !== REMOVE) {\n                    // replace\n                    element.ref.replace(target);\n                }\n\n                if (this.__state === REMOVE || target === REMOVE) {\n                    removeElem(element);\n                }\n\n                if (this.__state === BREAK || target === BREAK) {\n                    return outer.root;\n                }\n                continue;\n            }\n\n            target = this.__execute(visitor.enter, element);\n\n            // node may be replaced with null,\n            // so distinguish between undefined and null in this place\n            if (target !== undefined && target !== BREAK && target !== SKIP && target !== REMOVE) {\n                // replace\n                element.ref.replace(target);\n                element.node = target;\n            }\n\n            if (this.__state === REMOVE || target === REMOVE) {\n                removeElem(element);\n                element.node = null;\n            }\n\n            if (this.__state === BREAK || target === BREAK) {\n                return outer.root;\n            }\n\n            // node may be null\n            node = element.node;\n            if (!node) {\n                continue;\n            }\n\n            worklist.push(sentinel);\n            leavelist.push(element);\n\n            if (this.__state === SKIP || target === SKIP) {\n                continue;\n            }\n\n            nodeType = node.type || element.wrap;\n            candidates = this.__keys[nodeType];\n            if (!candidates) {\n                if (this.__fallback) {\n                    candidates = this.__fallback(node);\n                } else {\n                    throw new Error('Unknown node type ' + nodeType + '.');\n                }\n            }\n\n            current = candidates.length;\n            while ((current -= 1) >= 0) {\n                key = candidates[current];\n                candidate = node[key];\n                if (!candidate) {\n                    continue;\n                }\n\n                if (Array.isArray(candidate)) {\n                    current2 = candidate.length;\n                    while ((current2 -= 1) >= 0) {\n                        if (!candidate[current2]) {\n                            continue;\n                        }\n                        if (isProperty(nodeType, candidates[current])) {\n                            element = new Element(candidate[current2], [key, current2], 'Property', new Reference(candidate, current2));\n                        } else if (isNode(candidate[current2])) {\n                            element = new Element(candidate[current2], [key, current2], null, new Reference(candidate, current2));\n                        } else {\n                            continue;\n                        }\n                        worklist.push(element);\n                    }\n                } else if (isNode(candidate)) {\n                    worklist.push(new Element(candidate, key, null, new Reference(node, key)));\n                }\n            }\n        }\n\n        return outer.root;\n    };\n\n    function traverse(root, visitor) {\n        var controller = new Controller();\n        return controller.traverse(root, visitor);\n    }\n\n    function replace(root, visitor) {\n        var controller = new Controller();\n        return controller.replace(root, visitor);\n    }\n\n    function extendCommentRange(comment, tokens) {\n        var target;\n\n        target = upperBound(tokens, function search(token) {\n            return token.range[0] > comment.range[0];\n        });\n\n        comment.extendedRange = [comment.range[0], comment.range[1]];\n\n        if (target !== tokens.length) {\n            comment.extendedRange[1] = tokens[target].range[0];\n        }\n\n        target -= 1;\n        if (target >= 0) {\n            comment.extendedRange[0] = tokens[target].range[1];\n        }\n\n        return comment;\n    }\n\n    function attachComments(tree, providedComments, tokens) {\n        // At first, we should calculate extended comment ranges.\n        var comments = [], comment, len, i, cursor;\n\n        if (!tree.range) {\n            throw new Error('attachComments needs range information');\n        }\n\n        // tokens array is empty, we attach comments to tree as 'leadingComments'\n        if (!tokens.length) {\n            if (providedComments.length) {\n                for (i = 0, len = providedComments.length; i < len; i += 1) {\n                    comment = deepCopy(providedComments[i]);\n                    comment.extendedRange = [0, tree.range[0]];\n                    comments.push(comment);\n                }\n                tree.leadingComments = comments;\n            }\n            return tree;\n        }\n\n        for (i = 0, len = providedComments.length; i < len; i += 1) {\n            comments.push(extendCommentRange(deepCopy(providedComments[i]), tokens));\n        }\n\n        // This is based on John Freeman's implementation.\n        cursor = 0;\n        traverse(tree, {\n            enter: function (node) {\n                var comment;\n\n                while (cursor < comments.length) {\n                    comment = comments[cursor];\n                    if (comment.extendedRange[1] > node.range[0]) {\n                        break;\n                    }\n\n                    if (comment.extendedRange[1] === node.range[0]) {\n                        if (!node.leadingComments) {\n                            node.leadingComments = [];\n                        }\n                        node.leadingComments.push(comment);\n                        comments.splice(cursor, 1);\n                    } else {\n                        cursor += 1;\n                    }\n                }\n\n                // already out of owned node\n                if (cursor === comments.length) {\n                    return VisitorOption.Break;\n                }\n\n                if (comments[cursor].extendedRange[0] > node.range[1]) {\n                    return VisitorOption.Skip;\n                }\n            }\n        });\n\n        cursor = 0;\n        traverse(tree, {\n            leave: function (node) {\n                var comment;\n\n                while (cursor < comments.length) {\n                    comment = comments[cursor];\n                    if (node.range[1] < comment.extendedRange[0]) {\n                        break;\n                    }\n\n                    if (node.range[1] === comment.extendedRange[0]) {\n                        if (!node.trailingComments) {\n                            node.trailingComments = [];\n                        }\n                        node.trailingComments.push(comment);\n                        comments.splice(cursor, 1);\n                    } else {\n                        cursor += 1;\n                    }\n                }\n\n                // already out of owned node\n                if (cursor === comments.length) {\n                    return VisitorOption.Break;\n                }\n\n                if (comments[cursor].extendedRange[0] > node.range[1]) {\n                    return VisitorOption.Skip;\n                }\n            }\n        });\n\n        return tree;\n    }\n\n    exports.version = (__webpack_require__(/*! ./package.json */ \"./node_modules/eslint-scope/node_modules/estraverse/package.json\").version);\n    exports.Syntax = Syntax;\n    exports.traverse = traverse;\n    exports.replace = replace;\n    exports.attachComments = attachComments;\n    exports.VisitorKeys = VisitorKeys;\n    exports.VisitorOption = VisitorOption;\n    exports.Controller = Controller;\n    exports.cloneEnvironment = function () { return clone({}); };\n\n    return exports;\n}(exports));\n/* vim: set sw=4 ts=4 et tw=80 : */\n\n\n//# sourceURL=webpack://javascript/./node_modules/eslint-scope/node_modules/estraverse/estraverse.js?");

/***/ }),

/***/ "./node_modules/eslint-visitor-keys/lib/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/eslint-visitor-keys/lib/index.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * @author Toru Nagashima <https://github.com/mysticatea>\n * See LICENSE file in root directory for full license.\n */\n\n\nconst KEYS = __webpack_require__(/*! ./visitor-keys.json */ \"./node_modules/eslint-visitor-keys/lib/visitor-keys.json\");\n\n// Types.\nconst NODE_TYPES = Object.freeze(Object.keys(KEYS));\n\n// Freeze the keys.\nfor (const type of NODE_TYPES) {\n    Object.freeze(KEYS[type]);\n}\nObject.freeze(KEYS);\n\n// List to ignore keys.\nconst KEY_BLACKLIST = new Set([\n    \"parent\",\n    \"leadingComments\",\n    \"trailingComments\"\n]);\n\n/**\n * Check whether a given key should be used or not.\n * @param {string} key The key to check.\n * @returns {boolean} `true` if the key should be used.\n */\nfunction filterKey(key) {\n    return !KEY_BLACKLIST.has(key) && key[0] !== \"_\";\n}\n\n//------------------------------------------------------------------------------\n// Public interfaces\n//------------------------------------------------------------------------------\n\nmodule.exports = Object.freeze({\n\n    /**\n     * Visitor keys.\n     * @type {{ [type: string]: string[] | undefined }}\n     */\n    KEYS,\n\n    /**\n     * Get visitor keys of a given node.\n     * @param {Object} node The AST node to get keys.\n     * @returns {string[]} Visitor keys of the node.\n     */\n    getKeys(node) {\n        return Object.keys(node).filter(filterKey);\n    },\n\n    // Disable valid-jsdoc rule because it reports syntax error on the type of @returns.\n    // eslint-disable-next-line valid-jsdoc\n    /**\n     * Make the union set with `KEYS` and given keys.\n     * @param {Object} additionalKeys The additional keys.\n     * @returns {{ [type: string]: string[] | undefined }} The union set.\n     */\n    unionWith(additionalKeys) {\n        const retv = Object.assign({}, KEYS);\n\n        for (const type of Object.keys(additionalKeys)) {\n            if (retv.hasOwnProperty(type)) {\n                const keys = new Set(additionalKeys[type]);\n\n                for (const key of retv[type]) {\n                    keys.add(key);\n                }\n\n                retv[type] = Object.freeze(Array.from(keys));\n            } else {\n                retv[type] = Object.freeze(Array.from(additionalKeys[type]));\n            }\n        }\n\n        return Object.freeze(retv);\n    }\n});\n\n\n//# sourceURL=webpack://javascript/./node_modules/eslint-visitor-keys/lib/index.js?");

/***/ }),

/***/ "./node_modules/eslint4b/dist/_commonjsHelpers-11cbc178.js":
/*!*****************************************************************!*\
  !*** ./node_modules/eslint4b/dist/_commonjsHelpers-11cbc178.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar eslintVisitorKeys = __webpack_require__(/*! eslint-visitor-keys */ \"./node_modules/eslint4b/node_modules/eslint-visitor-keys/lib/index.js\");\n\nvar debug$1 = __webpack_require__(/*! debug */ \"./node_modules/eslint4b/node_modules/debug/src/browser.js\");\n\nfunction _interopDefaultLegacy(e) {\n  return e && typeof e === 'object' && 'default' in e ? e : {\n    'default': e\n  };\n}\n\nvar eslintVisitorKeys__default = _interopDefaultLegacy(eslintVisitorKeys);\n\nvar debug__default = _interopDefaultLegacy(debug$1);\n\nconst breakableTypePattern = /^(?:(?:Do)?While|For(?:In|Of)?|Switch)Statement$/u;\nconst lineBreakPattern = /\\r\\n|[\\r\\n\\u2028\\u2029]/u;\nconst shebangPattern = /^#!([^\\r\\n]+)/u;\n\nfunction createGlobalLinebreakMatcher() {\n  return new RegExp(lineBreakPattern.source, \"gu\");\n}\n\nvar astUtils = {\n  breakableTypePattern,\n  lineBreakPattern,\n  createGlobalLinebreakMatcher,\n  shebangPattern\n};\nconst debug = debug__default['default'](\"eslint:traverser\");\n\nfunction noop() {}\n\nfunction isNode(x) {\n  return x !== null && typeof x === \"object\" && typeof x.type === \"string\";\n}\n\nfunction getVisitorKeys(visitorKeys, node) {\n  let keys = visitorKeys[node.type];\n\n  if (!keys) {\n    keys = eslintVisitorKeys__default['default'].getKeys(node);\n    debug(\"Unknown node type \\\"%s\\\": Estimated visitor keys %j\", node.type, keys);\n  }\n\n  return keys;\n}\n\nclass Traverser {\n  constructor() {\n    this._current = null;\n    this._parents = [];\n    this._skipped = false;\n    this._broken = false;\n    this._visitorKeys = null;\n    this._enter = null;\n    this._leave = null;\n  }\n\n  current() {\n    return this._current;\n  }\n\n  parents() {\n    return this._parents.slice(0);\n  }\n\n  break() {\n    this._broken = true;\n  }\n\n  skip() {\n    this._skipped = true;\n  }\n\n  traverse(node, options) {\n    this._current = null;\n    this._parents = [];\n    this._skipped = false;\n    this._broken = false;\n    this._visitorKeys = options.visitorKeys || eslintVisitorKeys__default['default'].KEYS;\n    this._enter = options.enter || noop;\n    this._leave = options.leave || noop;\n\n    this._traverse(node, null);\n  }\n\n  _traverse(node, parent) {\n    if (!isNode(node)) {\n      return;\n    }\n\n    this._current = node;\n    this._skipped = false;\n\n    this._enter(node, parent);\n\n    if (!this._skipped && !this._broken) {\n      const keys = getVisitorKeys(this._visitorKeys, node);\n\n      if (keys.length >= 1) {\n        this._parents.push(node);\n\n        for (let i = 0; i < keys.length && !this._broken; ++i) {\n          const child = node[keys[i]];\n\n          if (Array.isArray(child)) {\n            for (let j = 0; j < child.length && !this._broken; ++j) {\n              this._traverse(child[j], node);\n            }\n          } else {\n            this._traverse(child, node);\n          }\n        }\n\n        this._parents.pop();\n      }\n    }\n\n    if (!this._broken) {\n      this._leave(node, parent);\n    }\n\n    this._current = parent;\n  }\n\n  static getKeys(node) {\n    return eslintVisitorKeys__default['default'].getKeys(node);\n  }\n\n  static traverse(node, options) {\n    new Traverser().traverse(node, options);\n  }\n\n  static get DEFAULT_VISITOR_KEYS() {\n    return eslintVisitorKeys__default['default'].KEYS;\n  }\n\n}\n\nvar traverser = Traverser;\n\nfunction createCommonjsModule(fn, module) {\n  return module = {\n    exports: {}\n  }, fn(module, module.exports), module.exports;\n}\n\nfunction getCjsExportFromNamespace(n) {\n  return n && n['default'] || n;\n}\n\nexports.astUtils = astUtils;\nexports.createCommonjsModule = createCommonjsModule;\nexports.getCjsExportFromNamespace = getCjsExportFromNamespace;\nexports.traverser = traverser;\n//# sourceMappingURL=_commonjsHelpers-11cbc178.js.map\n\n//# sourceURL=webpack://javascript/./node_modules/eslint4b/dist/_commonjsHelpers-11cbc178.js?");

/***/ }),

/***/ "./node_modules/eslint4b/dist/core-rules.js":
/*!**************************************************!*\
  !*** ./node_modules/eslint4b/dist/core-rules.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar _commonjsHelpers = __webpack_require__(/*! ./_commonjsHelpers-11cbc178.js */ \"./node_modules/eslint4b/dist/_commonjsHelpers-11cbc178.js\");\n\nvar esutils = __webpack_require__(/*! esutils */ \"./node_modules/esutils/lib/utils.js\");\n\nvar espree = __webpack_require__(/*! espree */ \"./node_modules/espree/espree.js\");\n\nvar escapeStringRegexp = __webpack_require__(/*! escape-string-regexp */ \"./node_modules/escape-string-regexp/index.js\");\n\nvar functionalRedBlackTree = __webpack_require__(/*! functional-red-black-tree */ \"./node_modules/functional-red-black-tree/rbtree.js\");\n\nvar regexpp = __webpack_require__(/*! regexpp */ \"./node_modules/regexpp/index.js\");\n\nvar globals = __webpack_require__(/*! globals */ \"./node_modules/globals/index.js\");\n\nvar eslintUtils = __webpack_require__(/*! eslint-utils */ \"./node_modules/eslint-utils/index.mjs\");\n\nvar ignore = __webpack_require__(/*! ignore */ \"./node_modules/ignore/index.js\");\n\nvar naturalCompare = __webpack_require__(/*! natural-compare */ \"./node_modules/natural-compare/index.js\");\n\nvar doctrine = __webpack_require__(/*! doctrine */ \"./node_modules/doctrine/lib/doctrine.js\");\n\nfunction _interopDefaultLegacy(e) {\n  return e && typeof e === 'object' && 'default' in e ? e : {\n    'default': e\n  };\n}\n\nvar esutils__default = _interopDefaultLegacy(esutils);\n\nvar espree__default = _interopDefaultLegacy(espree);\n\nvar escapeStringRegexp__default = _interopDefaultLegacy(escapeStringRegexp);\n\nvar functionalRedBlackTree__default = _interopDefaultLegacy(functionalRedBlackTree);\n\nvar regexpp__default = _interopDefaultLegacy(regexpp);\n\nvar globals__default = _interopDefaultLegacy(globals);\n\nvar eslintUtils__default = _interopDefaultLegacy(eslintUtils);\n\nvar ignore__default = _interopDefaultLegacy(ignore);\n\nvar naturalCompare__default = _interopDefaultLegacy(naturalCompare);\n\nvar doctrine__default = _interopDefaultLegacy(doctrine);\n\nvar astUtils = _commonjsHelpers.createCommonjsModule(function (module) {\n  const {\n    breakableTypePattern,\n    createGlobalLinebreakMatcher,\n    lineBreakPattern,\n    shebangPattern\n  } = _commonjsHelpers.astUtils;\n  const anyFunctionPattern = /^(?:Function(?:Declaration|Expression)|ArrowFunctionExpression)$/u;\n  const thisTagPattern = /^[\\s*]*@this/mu;\n  const LINEBREAKS = new Set([\"\\r\\n\", \"\\r\", \"\\n\", \"\\u2028\", \"\\u2029\"]);\n  const STATEMENT_LIST_PARENTS = new Set([\"Program\", \"BlockStatement\", \"SwitchCase\"]);\n  const DECIMAL_INTEGER_PATTERN = /^(?:0|0[0-7]*[89]\\d*|[1-9](?:_?\\d)*)$/u;\n  const LOGICAL_ASSIGNMENT_OPERATORS = new Set([\"&&=\", \"||=\", \"??=\"]);\n\n  function isModifyingReference(reference, index, references) {\n    const identifier = reference.identifier;\n    const modifyingDifferentIdentifier = index === 0 || references[index - 1].identifier !== identifier;\n    return identifier && reference.init === false && reference.isWrite() && modifyingDifferentIdentifier;\n  }\n\n  function startsWithUpperCase(s) {\n    return s[0] !== s[0].toLocaleLowerCase();\n  }\n\n  function isES5Constructor(node) {\n    return node.id && startsWithUpperCase(node.id.name);\n  }\n\n  function getUpperFunction(node) {\n    for (let currentNode = node; currentNode; currentNode = currentNode.parent) {\n      if (anyFunctionPattern.test(currentNode.type)) {\n        return currentNode;\n      }\n    }\n\n    return null;\n  }\n\n  function isFunction(node) {\n    return Boolean(node && anyFunctionPattern.test(node.type));\n  }\n\n  function isLoop(node) {\n    return Boolean(node && /^(?:DoWhile|For|ForIn|ForOf|While)Statement$/u.test(node.type));\n  }\n\n  function isNullLiteral(node) {\n    return node.type === \"Literal\" && node.value === null && !node.regex && !node.bigint;\n  }\n\n  function isNullOrUndefined(node) {\n    return isNullLiteral(node) || node.type === \"Identifier\" && node.name === \"undefined\" || node.type === \"UnaryExpression\" && node.operator === \"void\";\n  }\n\n  function isCallee(node) {\n    return node.parent.type === \"CallExpression\" && node.parent.callee === node;\n  }\n\n  function getStaticStringValue(node) {\n    switch (node.type) {\n      case \"Literal\":\n        if (node.value === null) {\n          if (isNullLiteral(node)) {\n            return String(node.value);\n          }\n\n          if (node.regex) {\n            return `/${node.regex.pattern}/${node.regex.flags}`;\n          }\n\n          if (node.bigint) {\n            return node.bigint;\n          }\n        } else {\n          return String(node.value);\n        }\n\n        break;\n\n      case \"TemplateLiteral\":\n        if (node.expressions.length === 0 && node.quasis.length === 1) {\n          return node.quasis[0].value.cooked;\n        }\n\n        break;\n    }\n\n    return null;\n  }\n\n  function getStaticPropertyName(node) {\n    let prop;\n\n    switch (node && node.type) {\n      case \"ChainExpression\":\n        return getStaticPropertyName(node.expression);\n\n      case \"Property\":\n      case \"MethodDefinition\":\n        prop = node.key;\n        break;\n\n      case \"MemberExpression\":\n        prop = node.property;\n        break;\n    }\n\n    if (prop) {\n      if (prop.type === \"Identifier\" && !node.computed) {\n        return prop.name;\n      }\n\n      return getStaticStringValue(prop);\n    }\n\n    return null;\n  }\n\n  function skipChainExpression(node) {\n    return node && node.type === \"ChainExpression\" ? node.expression : node;\n  }\n\n  function checkText(actual, expected) {\n    return typeof expected === \"string\" ? actual === expected : expected.test(actual);\n  }\n\n  function isSpecificId(node, name) {\n    return node.type === \"Identifier\" && checkText(node.name, name);\n  }\n\n  function isSpecificMemberAccess(node, objectName, propertyName) {\n    const checkNode = skipChainExpression(node);\n\n    if (checkNode.type !== \"MemberExpression\") {\n      return false;\n    }\n\n    if (objectName && !isSpecificId(checkNode.object, objectName)) {\n      return false;\n    }\n\n    if (propertyName) {\n      const actualPropertyName = getStaticPropertyName(checkNode);\n\n      if (typeof actualPropertyName !== \"string\" || !checkText(actualPropertyName, propertyName)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  function equalLiteralValue(left, right) {\n    if (left.regex || right.regex) {\n      return Boolean(left.regex && right.regex && left.regex.pattern === right.regex.pattern && left.regex.flags === right.regex.flags);\n    }\n\n    if (left.bigint || right.bigint) {\n      return left.bigint === right.bigint;\n    }\n\n    return left.value === right.value;\n  }\n\n  function isSameReference(left, right, disableStaticComputedKey = false) {\n    if (left.type !== right.type) {\n      if (left.type === \"ChainExpression\") {\n        return isSameReference(left.expression, right, disableStaticComputedKey);\n      }\n\n      if (right.type === \"ChainExpression\") {\n        return isSameReference(left, right.expression, disableStaticComputedKey);\n      }\n\n      return false;\n    }\n\n    switch (left.type) {\n      case \"Super\":\n      case \"ThisExpression\":\n        return true;\n\n      case \"Identifier\":\n        return left.name === right.name;\n\n      case \"Literal\":\n        return equalLiteralValue(left, right);\n\n      case \"ChainExpression\":\n        return isSameReference(left.expression, right.expression, disableStaticComputedKey);\n\n      case \"MemberExpression\":\n        {\n          if (!disableStaticComputedKey) {\n            const nameA = getStaticPropertyName(left);\n\n            if (nameA !== null) {\n              return isSameReference(left.object, right.object, disableStaticComputedKey) && nameA === getStaticPropertyName(right);\n            }\n          }\n\n          return left.computed === right.computed && isSameReference(left.object, right.object, disableStaticComputedKey) && isSameReference(left.property, right.property, disableStaticComputedKey);\n        }\n\n      default:\n        return false;\n    }\n  }\n\n  function isReflectApply(node) {\n    return isSpecificMemberAccess(node, \"Reflect\", \"apply\");\n  }\n\n  function isArrayFromMethod(node) {\n    return isSpecificMemberAccess(node, /Array$/u, \"from\");\n  }\n\n  function isMethodWhichHasThisArg(node) {\n    return isSpecificMemberAccess(node, null, /^(?:every|filter|find|findIndex|forEach|map|some)$/u);\n  }\n\n  function negate(f) {\n    return token => !f(token);\n  }\n\n  function hasJSDocThisTag(node, sourceCode) {\n    const jsdocComment = sourceCode.getJSDocComment(node);\n\n    if (jsdocComment && thisTagPattern.test(jsdocComment.value)) {\n      return true;\n    }\n\n    return sourceCode.getCommentsBefore(node).some(comment => thisTagPattern.test(comment.value));\n  }\n\n  function isArrowToken(token) {\n    return token.value === \"=>\" && token.type === \"Punctuator\";\n  }\n\n  function isCommaToken(token) {\n    return token.value === \",\" && token.type === \"Punctuator\";\n  }\n\n  function isDotToken(token) {\n    return token.value === \".\" && token.type === \"Punctuator\";\n  }\n\n  function isQuestionDotToken(token) {\n    return token.value === \"?.\" && token.type === \"Punctuator\";\n  }\n\n  function isSemicolonToken(token) {\n    return token.value === \";\" && token.type === \"Punctuator\";\n  }\n\n  function isColonToken(token) {\n    return token.value === \":\" && token.type === \"Punctuator\";\n  }\n\n  function isOpeningParenToken(token) {\n    return token.value === \"(\" && token.type === \"Punctuator\";\n  }\n\n  function isClosingParenToken(token) {\n    return token.value === \")\" && token.type === \"Punctuator\";\n  }\n\n  function isOpeningBracketToken(token) {\n    return token.value === \"[\" && token.type === \"Punctuator\";\n  }\n\n  function isClosingBracketToken(token) {\n    return token.value === \"]\" && token.type === \"Punctuator\";\n  }\n\n  function isOpeningBraceToken(token) {\n    return token.value === \"{\" && token.type === \"Punctuator\";\n  }\n\n  function isClosingBraceToken(token) {\n    return token.value === \"}\" && token.type === \"Punctuator\";\n  }\n\n  function getOpeningParenOfParams(node, sourceCode) {\n    return node.id ? sourceCode.getTokenAfter(node.id, isOpeningParenToken) : sourceCode.getFirstToken(node, isOpeningParenToken);\n  }\n\n  function isLogicalExpression(node) {\n    return node.type === \"LogicalExpression\" && (node.operator === \"&&\" || node.operator === \"||\");\n  }\n\n  function isCoalesceExpression(node) {\n    return node.type === \"LogicalExpression\" && node.operator === \"??\";\n  }\n\n  module.exports = {\n    COMMENTS_IGNORE_PATTERN: /^\\s*(?:eslint|jshint\\s+|jslint\\s+|istanbul\\s+|globals?\\s+|exported\\s+|jscs)/u,\n    LINEBREAKS,\n    LINEBREAK_MATCHER: lineBreakPattern,\n    SHEBANG_MATCHER: shebangPattern,\n    STATEMENT_LIST_PARENTS,\n\n    isTokenOnSameLine(left, right) {\n      return left.loc.end.line === right.loc.start.line;\n    },\n\n    isNullOrUndefined,\n    isCallee,\n    isES5Constructor,\n    getUpperFunction,\n    isFunction,\n    isLoop,\n    isInLoop: function (node) {\n      for (let currentNode = node; currentNode && !isFunction(currentNode); currentNode = currentNode.parent) {\n        if (isLoop(currentNode)) {\n          return true;\n        }\n      }\n\n      return false;\n    },\n    isArrayFromMethod,\n    isParenthesised: function (sourceCode, node) {\n      const previousToken = sourceCode.getTokenBefore(node),\n            nextToken = sourceCode.getTokenAfter(node);\n      return Boolean(previousToken && nextToken) && previousToken.value === \"(\" && previousToken.range[1] <= node.range[0] && nextToken.value === \")\" && nextToken.range[0] >= node.range[1];\n    },\n    createGlobalLinebreakMatcher,\n    equalTokens: function (left, right, sourceCode) {\n      const tokensL = sourceCode.getTokens(left);\n      const tokensR = sourceCode.getTokens(right);\n\n      if (tokensL.length !== tokensR.length) {\n        return false;\n      }\n\n      for (let i = 0; i < tokensL.length; ++i) {\n        if (tokensL[i].type !== tokensR[i].type || tokensL[i].value !== tokensR[i].value) {\n          return false;\n        }\n      }\n\n      return true;\n    },\n    isArrowToken,\n    isClosingBraceToken,\n    isClosingBracketToken,\n    isClosingParenToken,\n    isColonToken,\n    isCommaToken,\n    isCommentToken: function (token) {\n      return token.type === \"Line\" || token.type === \"Block\" || token.type === \"Shebang\";\n    },\n    isDotToken,\n    isQuestionDotToken,\n    isKeywordToken: function (token) {\n      return token.type === \"Keyword\";\n    },\n    isNotClosingBraceToken: negate(isClosingBraceToken),\n    isNotClosingBracketToken: negate(isClosingBracketToken),\n    isNotClosingParenToken: negate(isClosingParenToken),\n    isNotColonToken: negate(isColonToken),\n    isNotCommaToken: negate(isCommaToken),\n    isNotDotToken: negate(isDotToken),\n    isNotQuestionDotToken: negate(isQuestionDotToken),\n    isNotOpeningBraceToken: negate(isOpeningBraceToken),\n    isNotOpeningBracketToken: negate(isOpeningBracketToken),\n    isNotOpeningParenToken: negate(isOpeningParenToken),\n    isNotSemicolonToken: negate(isSemicolonToken),\n    isOpeningBraceToken,\n    isOpeningBracketToken,\n    isOpeningParenToken,\n    isSemicolonToken,\n\n    isStringLiteral(node) {\n      return node.type === \"Literal\" && typeof node.value === \"string\" || node.type === \"TemplateLiteral\";\n    },\n\n    isBreakableStatement(node) {\n      return breakableTypePattern.test(node.type);\n    },\n\n    getModifyingReferences(references) {\n      return references.filter(isModifyingReference);\n    },\n\n    isSurroundedBy(val, character) {\n      return val[0] === character && val[val.length - 1] === character;\n    },\n\n    isDirectiveComment(node) {\n      const comment = node.value.trim();\n      return node.type === \"Line\" && comment.indexOf(\"eslint-\") === 0 || node.type === \"Block\" && (comment.indexOf(\"global \") === 0 || comment.indexOf(\"eslint \") === 0 || comment.indexOf(\"eslint-\") === 0);\n    },\n\n    getTrailingStatement: esutils__default['default'].ast.trailingStatement,\n\n    getVariableByName(initScope, name) {\n      let scope = initScope;\n\n      while (scope) {\n        const variable = scope.set.get(name);\n\n        if (variable) {\n          return variable;\n        }\n\n        scope = scope.upper;\n      }\n\n      return null;\n    },\n\n    isDefaultThisBinding(node, sourceCode, {\n      capIsConstructor = true\n    } = {}) {\n      if (capIsConstructor && isES5Constructor(node) || hasJSDocThisTag(node, sourceCode)) {\n        return false;\n      }\n\n      const isAnonymous = node.id === null;\n      let currentNode = node;\n\n      while (currentNode) {\n        const parent = currentNode.parent;\n\n        switch (parent.type) {\n          case \"LogicalExpression\":\n          case \"ConditionalExpression\":\n          case \"ChainExpression\":\n            currentNode = parent;\n            break;\n\n          case \"ReturnStatement\":\n            {\n              const func = getUpperFunction(parent);\n\n              if (func === null || !isCallee(func)) {\n                return true;\n              }\n\n              currentNode = func.parent;\n              break;\n            }\n\n          case \"ArrowFunctionExpression\":\n            if (currentNode !== parent.body || !isCallee(parent)) {\n              return true;\n            }\n\n            currentNode = parent.parent;\n            break;\n\n          case \"Property\":\n          case \"MethodDefinition\":\n            return parent.value !== currentNode;\n\n          case \"AssignmentExpression\":\n          case \"AssignmentPattern\":\n            if (parent.left.type === \"MemberExpression\") {\n              return false;\n            }\n\n            if (capIsConstructor && isAnonymous && parent.left.type === \"Identifier\" && startsWithUpperCase(parent.left.name)) {\n              return false;\n            }\n\n            return true;\n\n          case \"VariableDeclarator\":\n            return !(capIsConstructor && isAnonymous && parent.init === currentNode && parent.id.type === \"Identifier\" && startsWithUpperCase(parent.id.name));\n\n          case \"MemberExpression\":\n            if (parent.object === currentNode && isSpecificMemberAccess(parent, null, /^(?:bind|call|apply)$/u)) {\n              const maybeCalleeNode = parent.parent.type === \"ChainExpression\" ? parent.parent : parent;\n              return !(isCallee(maybeCalleeNode) && maybeCalleeNode.parent.arguments.length >= 1 && !isNullOrUndefined(maybeCalleeNode.parent.arguments[0]));\n            }\n\n            return true;\n\n          case \"CallExpression\":\n            if (isReflectApply(parent.callee)) {\n              return parent.arguments.length !== 3 || parent.arguments[0] !== currentNode || isNullOrUndefined(parent.arguments[1]);\n            }\n\n            if (isArrayFromMethod(parent.callee)) {\n              return parent.arguments.length !== 3 || parent.arguments[1] !== currentNode || isNullOrUndefined(parent.arguments[2]);\n            }\n\n            if (isMethodWhichHasThisArg(parent.callee)) {\n              return parent.arguments.length !== 2 || parent.arguments[0] !== currentNode || isNullOrUndefined(parent.arguments[1]);\n            }\n\n            return true;\n\n          default:\n            return true;\n        }\n      }\n\n      return true;\n    },\n\n    getPrecedence(node) {\n      switch (node.type) {\n        case \"SequenceExpression\":\n          return 0;\n\n        case \"AssignmentExpression\":\n        case \"ArrowFunctionExpression\":\n        case \"YieldExpression\":\n          return 1;\n\n        case \"ConditionalExpression\":\n          return 3;\n\n        case \"LogicalExpression\":\n          switch (node.operator) {\n            case \"||\":\n            case \"??\":\n              return 4;\n\n            case \"&&\":\n              return 5;\n          }\n\n        case \"BinaryExpression\":\n          switch (node.operator) {\n            case \"|\":\n              return 6;\n\n            case \"^\":\n              return 7;\n\n            case \"&\":\n              return 8;\n\n            case \"==\":\n            case \"!=\":\n            case \"===\":\n            case \"!==\":\n              return 9;\n\n            case \"<\":\n            case \"<=\":\n            case \">\":\n            case \">=\":\n            case \"in\":\n            case \"instanceof\":\n              return 10;\n\n            case \"<<\":\n            case \">>\":\n            case \">>>\":\n              return 11;\n\n            case \"+\":\n            case \"-\":\n              return 12;\n\n            case \"*\":\n            case \"/\":\n            case \"%\":\n              return 13;\n\n            case \"**\":\n              return 15;\n          }\n\n        case \"UnaryExpression\":\n        case \"AwaitExpression\":\n          return 16;\n\n        case \"UpdateExpression\":\n          return 17;\n\n        case \"CallExpression\":\n        case \"ChainExpression\":\n        case \"ImportExpression\":\n          return 18;\n\n        case \"NewExpression\":\n          return 19;\n\n        default:\n          return 20;\n      }\n    },\n\n    isEmptyBlock(node) {\n      return Boolean(node && node.type === \"BlockStatement\" && node.body.length === 0);\n    },\n\n    isEmptyFunction(node) {\n      return isFunction(node) && module.exports.isEmptyBlock(node.body);\n    },\n\n    getDirectivePrologue(node) {\n      const directives = [];\n\n      if (node.type === \"Program\" || node.type === \"FunctionDeclaration\" || node.type === \"FunctionExpression\" || node.type === \"ArrowFunctionExpression\" && node.body.type === \"BlockStatement\") {\n        const statements = node.type === \"Program\" ? node.body : node.body.body;\n\n        for (const statement of statements) {\n          if (statement.type === \"ExpressionStatement\" && statement.expression.type === \"Literal\") {\n            directives.push(statement);\n          } else {\n            break;\n          }\n        }\n      }\n\n      return directives;\n    },\n\n    isDecimalInteger(node) {\n      return node.type === \"Literal\" && typeof node.value === \"number\" && DECIMAL_INTEGER_PATTERN.test(node.raw);\n    },\n\n    isDecimalIntegerNumericToken(token) {\n      return token.type === \"Numeric\" && DECIMAL_INTEGER_PATTERN.test(token.value);\n    },\n\n    getFunctionNameWithKind(node) {\n      const parent = node.parent;\n      const tokens = [];\n\n      if (parent.type === \"MethodDefinition\" && parent.static) {\n        tokens.push(\"static\");\n      }\n\n      if (node.async) {\n        tokens.push(\"async\");\n      }\n\n      if (node.generator) {\n        tokens.push(\"generator\");\n      }\n\n      if (node.type === \"ArrowFunctionExpression\") {\n        tokens.push(\"arrow\", \"function\");\n      } else if (parent.type === \"Property\" || parent.type === \"MethodDefinition\") {\n        if (parent.kind === \"constructor\") {\n          return \"constructor\";\n        }\n\n        if (parent.kind === \"get\") {\n          tokens.push(\"getter\");\n        } else if (parent.kind === \"set\") {\n          tokens.push(\"setter\");\n        } else {\n          tokens.push(\"method\");\n        }\n      } else {\n        tokens.push(\"function\");\n      }\n\n      if (node.id) {\n        tokens.push(`'${node.id.name}'`);\n      } else {\n        const name = getStaticPropertyName(parent);\n\n        if (name !== null) {\n          tokens.push(`'${name}'`);\n        }\n      }\n\n      return tokens.join(\" \");\n    },\n\n    getFunctionHeadLoc(node, sourceCode) {\n      const parent = node.parent;\n      let start = null;\n      let end = null;\n\n      if (node.type === \"ArrowFunctionExpression\") {\n        const arrowToken = sourceCode.getTokenBefore(node.body, isArrowToken);\n        start = arrowToken.loc.start;\n        end = arrowToken.loc.end;\n      } else if (parent.type === \"Property\" || parent.type === \"MethodDefinition\") {\n        start = parent.loc.start;\n        end = getOpeningParenOfParams(node, sourceCode).loc.start;\n      } else {\n        start = node.loc.start;\n        end = getOpeningParenOfParams(node, sourceCode).loc.start;\n      }\n\n      return {\n        start: Object.assign({}, start),\n        end: Object.assign({}, end)\n      };\n    },\n\n    getNextLocation(sourceCode, {\n      line,\n      column\n    }) {\n      if (column < sourceCode.lines[line - 1].length) {\n        return {\n          line,\n          column: column + 1\n        };\n      }\n\n      if (line < sourceCode.lines.length) {\n        return {\n          line: line + 1,\n          column: 0\n        };\n      }\n\n      return null;\n    },\n\n    getParenthesisedText(sourceCode, node) {\n      let leftToken = sourceCode.getFirstToken(node);\n      let rightToken = sourceCode.getLastToken(node);\n\n      while (sourceCode.getTokenBefore(leftToken) && sourceCode.getTokenBefore(leftToken).type === \"Punctuator\" && sourceCode.getTokenBefore(leftToken).value === \"(\" && sourceCode.getTokenAfter(rightToken) && sourceCode.getTokenAfter(rightToken).type === \"Punctuator\" && sourceCode.getTokenAfter(rightToken).value === \")\") {\n        leftToken = sourceCode.getTokenBefore(leftToken);\n        rightToken = sourceCode.getTokenAfter(rightToken);\n      }\n\n      return sourceCode.getText().slice(leftToken.range[0], rightToken.range[1]);\n    },\n\n    couldBeError(node) {\n      switch (node.type) {\n        case \"Identifier\":\n        case \"CallExpression\":\n        case \"NewExpression\":\n        case \"MemberExpression\":\n        case \"TaggedTemplateExpression\":\n        case \"YieldExpression\":\n        case \"AwaitExpression\":\n        case \"ChainExpression\":\n          return true;\n\n        case \"AssignmentExpression\":\n          if ([\"=\", \"&&=\"].includes(node.operator)) {\n            return module.exports.couldBeError(node.right);\n          }\n\n          if ([\"||=\", \"??=\"].includes(node.operator)) {\n            return module.exports.couldBeError(node.left) || module.exports.couldBeError(node.right);\n          }\n\n          return false;\n\n        case \"SequenceExpression\":\n          {\n            const exprs = node.expressions;\n            return exprs.length !== 0 && module.exports.couldBeError(exprs[exprs.length - 1]);\n          }\n\n        case \"LogicalExpression\":\n          if (node.operator === \"&&\") {\n            return module.exports.couldBeError(node.right);\n          }\n\n          return module.exports.couldBeError(node.left) || module.exports.couldBeError(node.right);\n\n        case \"ConditionalExpression\":\n          return module.exports.couldBeError(node.consequent) || module.exports.couldBeError(node.alternate);\n\n        default:\n          return false;\n      }\n    },\n\n    isNumericLiteral(node) {\n      return node.type === \"Literal\" && (typeof node.value === \"number\" || Boolean(node.bigint));\n    },\n\n    canTokensBeAdjacent(leftValue, rightValue) {\n      const espreeOptions = {\n        ecmaVersion: espree__default['default'].latestEcmaVersion,\n        comment: true,\n        range: true\n      };\n      let leftToken;\n\n      if (typeof leftValue === \"string\") {\n        let tokens;\n\n        try {\n          tokens = espree__default['default'].tokenize(leftValue, espreeOptions);\n        } catch {\n          return false;\n        }\n\n        const comments = tokens.comments;\n        leftToken = tokens[tokens.length - 1];\n\n        if (comments.length) {\n          const lastComment = comments[comments.length - 1];\n\n          if (lastComment.range[0] > leftToken.range[0]) {\n            leftToken = lastComment;\n          }\n        }\n      } else {\n        leftToken = leftValue;\n      }\n\n      if (leftToken.type === \"Shebang\") {\n        return false;\n      }\n\n      let rightToken;\n\n      if (typeof rightValue === \"string\") {\n        let tokens;\n\n        try {\n          tokens = espree__default['default'].tokenize(rightValue, espreeOptions);\n        } catch {\n          return false;\n        }\n\n        const comments = tokens.comments;\n        rightToken = tokens[0];\n\n        if (comments.length) {\n          const firstComment = comments[0];\n\n          if (firstComment.range[0] < rightToken.range[0]) {\n            rightToken = firstComment;\n          }\n        }\n      } else {\n        rightToken = rightValue;\n      }\n\n      if (leftToken.type === \"Punctuator\" || rightToken.type === \"Punctuator\") {\n        if (leftToken.type === \"Punctuator\" && rightToken.type === \"Punctuator\") {\n          const PLUS_TOKENS = new Set([\"+\", \"++\"]);\n          const MINUS_TOKENS = new Set([\"-\", \"--\"]);\n          return !(PLUS_TOKENS.has(leftToken.value) && PLUS_TOKENS.has(rightToken.value) || MINUS_TOKENS.has(leftToken.value) && MINUS_TOKENS.has(rightToken.value));\n        }\n\n        if (leftToken.type === \"Punctuator\" && leftToken.value === \"/\") {\n          return ![\"Block\", \"Line\", \"RegularExpression\"].includes(rightToken.type);\n        }\n\n        return true;\n      }\n\n      if (leftToken.type === \"String\" || rightToken.type === \"String\" || leftToken.type === \"Template\" || rightToken.type === \"Template\") {\n        return true;\n      }\n\n      if (leftToken.type !== \"Numeric\" && rightToken.type === \"Numeric\" && rightToken.value.startsWith(\".\")) {\n        return true;\n      }\n\n      if (leftToken.type === \"Block\" || rightToken.type === \"Block\" || rightToken.type === \"Line\") {\n        return true;\n      }\n\n      return false;\n    },\n\n    getNameLocationInGlobalDirectiveComment(sourceCode, comment, name) {\n      const namePattern = new RegExp(`[\\\\s,]${escapeStringRegexp__default['default'](name)}(?:$|[\\\\s,:])`, \"gu\");\n      namePattern.lastIndex = comment.value.indexOf(\"global\") + 6;\n      const match = namePattern.exec(comment.value);\n      const start = sourceCode.getLocFromIndex(comment.range[0] + 2 + (match ? match.index + 1 : 0));\n      const end = {\n        line: start.line,\n        column: start.column + (match ? name.length : 1)\n      };\n      return {\n        start,\n        end\n      };\n    },\n\n    hasOctalOrNonOctalDecimalEscapeSequence(rawString) {\n      return /^(?:[^\\\\]|\\\\.)*\\\\(?:[1-9]|0[0-9])/su.test(rawString);\n    },\n\n    isLogicalExpression,\n    isCoalesceExpression,\n    isMixedLogicalAndCoalesceExpressions: function (left, right) {\n      return isLogicalExpression(left) && isCoalesceExpression(right) || isCoalesceExpression(left) && isLogicalExpression(right);\n    },\n    isNullLiteral,\n    getStaticStringValue,\n    getStaticPropertyName,\n    skipChainExpression,\n    isSpecificId,\n    isSpecificMemberAccess,\n    equalLiteralValue,\n    isSameReference,\n    isLogicalAssignmentOperator: function (operator) {\n      return LOGICAL_ASSIGNMENT_OPERATORS.has(operator);\n    }\n  };\n});\n\nastUtils.COMMENTS_IGNORE_PATTERN;\nastUtils.LINEBREAKS;\nastUtils.LINEBREAK_MATCHER;\nastUtils.SHEBANG_MATCHER;\nastUtils.STATEMENT_LIST_PARENTS;\nastUtils.isTokenOnSameLine;\nastUtils.isNullOrUndefined;\nastUtils.isCallee;\nastUtils.isES5Constructor;\nastUtils.getUpperFunction;\nastUtils.isFunction;\nastUtils.isLoop;\nastUtils.isInLoop;\nastUtils.isArrayFromMethod;\nastUtils.isParenthesised;\nastUtils.createGlobalLinebreakMatcher;\nastUtils.equalTokens;\nastUtils.isArrowToken;\nastUtils.isClosingBraceToken;\nastUtils.isClosingBracketToken;\nastUtils.isClosingParenToken;\nastUtils.isColonToken;\nastUtils.isCommaToken;\nastUtils.isCommentToken;\nastUtils.isDotToken;\nastUtils.isQuestionDotToken;\nastUtils.isKeywordToken;\nastUtils.isNotClosingBraceToken;\nastUtils.isNotClosingBracketToken;\nastUtils.isNotClosingParenToken;\nastUtils.isNotColonToken;\nastUtils.isNotCommaToken;\nastUtils.isNotDotToken;\nastUtils.isNotQuestionDotToken;\nastUtils.isNotOpeningBraceToken;\nastUtils.isNotOpeningBracketToken;\nastUtils.isNotOpeningParenToken;\nastUtils.isNotSemicolonToken;\nastUtils.isOpeningBraceToken;\nastUtils.isOpeningBracketToken;\nastUtils.isOpeningParenToken;\nastUtils.isSemicolonToken;\nastUtils.isStringLiteral;\nastUtils.isBreakableStatement;\nastUtils.getModifyingReferences;\nastUtils.isSurroundedBy;\nastUtils.isDirectiveComment;\nastUtils.getTrailingStatement;\nastUtils.getVariableByName;\nastUtils.isDefaultThisBinding;\nastUtils.getPrecedence;\nastUtils.isEmptyBlock;\nastUtils.isEmptyFunction;\nastUtils.getDirectivePrologue;\nastUtils.isDecimalInteger;\nastUtils.isDecimalIntegerNumericToken;\nastUtils.getFunctionNameWithKind;\nastUtils.getFunctionHeadLoc;\nastUtils.getNextLocation;\nastUtils.getParenthesisedText;\nastUtils.couldBeError;\nastUtils.isNumericLiteral;\nastUtils.canTokensBeAdjacent;\nastUtils.getNameLocationInGlobalDirectiveComment;\nastUtils.hasOctalOrNonOctalDecimalEscapeSequence;\nastUtils.isLogicalExpression;\nastUtils.isCoalesceExpression;\nastUtils.isMixedLogicalAndCoalesceExpressions;\nastUtils.isNullLiteral;\nastUtils.getStaticStringValue;\nastUtils.getStaticPropertyName;\nastUtils.skipChainExpression;\nastUtils.isSpecificId;\nastUtils.isSpecificMemberAccess;\nastUtils.equalLiteralValue;\nastUtils.isSameReference;\nastUtils.isLogicalAssignmentOperator;\n\nfunction areEqualTokenLists$1(left, right) {\n  if (left.length !== right.length) {\n    return false;\n  }\n\n  for (let i = 0; i < left.length; i++) {\n    const leftToken = left[i],\n          rightToken = right[i];\n\n    if (leftToken.type !== rightToken.type || leftToken.value !== rightToken.value) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction areEqualKeys$1(left, right) {\n  if (typeof left === \"string\" && typeof right === \"string\") {\n    return left === right;\n  }\n\n  if (Array.isArray(left) && Array.isArray(right)) {\n    return areEqualTokenLists$1(left, right);\n  }\n\n  return false;\n}\n\nfunction isAccessorKind$1(node) {\n  return node.kind === \"get\" || node.kind === \"set\";\n}\n\nfunction isArgumentOfMethodCall(node, index, object, property) {\n  const parent = node.parent;\n  return parent.type === \"CallExpression\" && astUtils.isSpecificMemberAccess(parent.callee, object, property) && parent.arguments[index] === node;\n}\n\nfunction isPropertyDescriptor$1(node) {\n  if (isArgumentOfMethodCall(node, 2, \"Object\", \"defineProperty\") || isArgumentOfMethodCall(node, 2, \"Reflect\", \"defineProperty\")) {\n    return true;\n  }\n\n  const grandparent = node.parent.parent;\n  return grandparent.type === \"ObjectExpression\" && (isArgumentOfMethodCall(grandparent, 1, \"Object\", \"create\") || isArgumentOfMethodCall(grandparent, 1, \"Object\", \"defineProperties\"));\n}\n\nvar accessorPairs = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"enforce getter and setter pairs in objects and classes\",\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/accessor-pairs\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        getWithoutSet: {\n          type: \"boolean\",\n          default: false\n        },\n        setWithoutGet: {\n          type: \"boolean\",\n          default: true\n        },\n        enforceForClassMembers: {\n          type: \"boolean\",\n          default: true\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      missingGetterInPropertyDescriptor: \"Getter is not present in property descriptor.\",\n      missingSetterInPropertyDescriptor: \"Setter is not present in property descriptor.\",\n      missingGetterInObjectLiteral: \"Getter is not present for {{ name }}.\",\n      missingSetterInObjectLiteral: \"Setter is not present for {{ name }}.\",\n      missingGetterInClass: \"Getter is not present for class {{ name }}.\",\n      missingSetterInClass: \"Setter is not present for class {{ name }}.\"\n    }\n  },\n\n  create(context) {\n    const config = context.options[0] || {};\n    const checkGetWithoutSet = config.getWithoutSet === true;\n    const checkSetWithoutGet = config.setWithoutGet !== false;\n    const enforceForClassMembers = config.enforceForClassMembers !== false;\n    const sourceCode = context.getSourceCode();\n\n    function report(node, messageKind) {\n      if (node.type === \"Property\") {\n        context.report({\n          node,\n          messageId: `${messageKind}InObjectLiteral`,\n          loc: astUtils.getFunctionHeadLoc(node.value, sourceCode),\n          data: {\n            name: astUtils.getFunctionNameWithKind(node.value)\n          }\n        });\n      } else if (node.type === \"MethodDefinition\") {\n        context.report({\n          node,\n          messageId: `${messageKind}InClass`,\n          loc: astUtils.getFunctionHeadLoc(node.value, sourceCode),\n          data: {\n            name: astUtils.getFunctionNameWithKind(node.value)\n          }\n        });\n      } else {\n        context.report({\n          node,\n          messageId: `${messageKind}InPropertyDescriptor`\n        });\n      }\n    }\n\n    function reportList(nodes, messageKind) {\n      for (const node of nodes) {\n        report(node, messageKind);\n      }\n    }\n\n    function createAccessorData(node) {\n      const name = astUtils.getStaticPropertyName(node);\n      const key = name !== null ? name : sourceCode.getTokens(node.key);\n      return {\n        key,\n        getters: node.kind === \"get\" ? [node] : [],\n        setters: node.kind === \"set\" ? [node] : []\n      };\n    }\n\n    function mergeAccessorData(accessors, accessorData) {\n      const equalKeyElement = accessors.find(a => areEqualKeys$1(a.key, accessorData.key));\n\n      if (equalKeyElement) {\n        equalKeyElement.getters.push(...accessorData.getters);\n        equalKeyElement.setters.push(...accessorData.setters);\n      } else {\n        accessors.push(accessorData);\n      }\n\n      return accessors;\n    }\n\n    function checkList(nodes) {\n      const accessors = nodes.filter(isAccessorKind$1).map(createAccessorData).reduce(mergeAccessorData, []);\n\n      for (const {\n        getters,\n        setters\n      } of accessors) {\n        if (checkSetWithoutGet && setters.length && !getters.length) {\n          reportList(setters, \"missingGetter\");\n        }\n\n        if (checkGetWithoutSet && getters.length && !setters.length) {\n          reportList(getters, \"missingSetter\");\n        }\n      }\n    }\n\n    function checkObjectLiteral(node) {\n      checkList(node.properties.filter(p => p.type === \"Property\"));\n    }\n\n    function checkPropertyDescriptor(node) {\n      const namesToCheck = node.properties.filter(p => p.type === \"Property\" && p.kind === \"init\" && !p.computed).map(({\n        key\n      }) => key.name);\n      const hasGetter = namesToCheck.includes(\"get\");\n      const hasSetter = namesToCheck.includes(\"set\");\n\n      if (checkSetWithoutGet && hasSetter && !hasGetter) {\n        report(node, \"missingGetter\");\n      }\n\n      if (checkGetWithoutSet && hasGetter && !hasSetter) {\n        report(node, \"missingSetter\");\n      }\n    }\n\n    function checkObjectExpression(node) {\n      checkObjectLiteral(node);\n\n      if (isPropertyDescriptor$1(node)) {\n        checkPropertyDescriptor(node);\n      }\n    }\n\n    function checkClassBody(node) {\n      const methodDefinitions = node.body.filter(m => m.type === \"MethodDefinition\");\n      checkList(methodDefinitions.filter(m => m.static));\n      checkList(methodDefinitions.filter(m => !m.static));\n    }\n\n    const listeners = {};\n\n    if (checkSetWithoutGet || checkGetWithoutSet) {\n      listeners.ObjectExpression = checkObjectExpression;\n\n      if (enforceForClassMembers) {\n        listeners.ClassBody = checkClassBody;\n      }\n    }\n\n    return listeners;\n  }\n\n};\naccessorPairs.meta;\naccessorPairs.create;\nvar arrayBracketNewline = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"enforce linebreaks after opening and before closing array brackets\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/array-bracket-newline\"\n    },\n    fixable: \"whitespace\",\n    schema: [{\n      oneOf: [{\n        enum: [\"always\", \"never\", \"consistent\"]\n      }, {\n        type: \"object\",\n        properties: {\n          multiline: {\n            type: \"boolean\"\n          },\n          minItems: {\n            type: [\"integer\", \"null\"],\n            minimum: 0\n          }\n        },\n        additionalProperties: false\n      }]\n    }],\n    messages: {\n      unexpectedOpeningLinebreak: \"There should be no linebreak after '['.\",\n      unexpectedClosingLinebreak: \"There should be no linebreak before ']'.\",\n      missingOpeningLinebreak: \"A linebreak is required after '['.\",\n      missingClosingLinebreak: \"A linebreak is required before ']'.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n\n    function normalizeOptionValue(option) {\n      let consistent = false;\n      let multiline = false;\n      let minItems = 0;\n\n      if (option) {\n        if (option === \"consistent\") {\n          consistent = true;\n          minItems = Number.POSITIVE_INFINITY;\n        } else if (option === \"always\" || option.minItems === 0) {\n          minItems = 0;\n        } else if (option === \"never\") {\n          minItems = Number.POSITIVE_INFINITY;\n        } else {\n          multiline = Boolean(option.multiline);\n          minItems = option.minItems || Number.POSITIVE_INFINITY;\n        }\n      } else {\n        consistent = false;\n        multiline = true;\n        minItems = Number.POSITIVE_INFINITY;\n      }\n\n      return {\n        consistent,\n        multiline,\n        minItems\n      };\n    }\n\n    function normalizeOptions(options) {\n      const value = normalizeOptionValue(options);\n      return {\n        ArrayExpression: value,\n        ArrayPattern: value\n      };\n    }\n\n    function reportNoBeginningLinebreak(node, token) {\n      context.report({\n        node,\n        loc: token.loc,\n        messageId: \"unexpectedOpeningLinebreak\",\n\n        fix(fixer) {\n          const nextToken = sourceCode.getTokenAfter(token, {\n            includeComments: true\n          });\n\n          if (astUtils.isCommentToken(nextToken)) {\n            return null;\n          }\n\n          return fixer.removeRange([token.range[1], nextToken.range[0]]);\n        }\n\n      });\n    }\n\n    function reportNoEndingLinebreak(node, token) {\n      context.report({\n        node,\n        loc: token.loc,\n        messageId: \"unexpectedClosingLinebreak\",\n\n        fix(fixer) {\n          const previousToken = sourceCode.getTokenBefore(token, {\n            includeComments: true\n          });\n\n          if (astUtils.isCommentToken(previousToken)) {\n            return null;\n          }\n\n          return fixer.removeRange([previousToken.range[1], token.range[0]]);\n        }\n\n      });\n    }\n\n    function reportRequiredBeginningLinebreak(node, token) {\n      context.report({\n        node,\n        loc: token.loc,\n        messageId: \"missingOpeningLinebreak\",\n\n        fix(fixer) {\n          return fixer.insertTextAfter(token, \"\\n\");\n        }\n\n      });\n    }\n\n    function reportRequiredEndingLinebreak(node, token) {\n      context.report({\n        node,\n        loc: token.loc,\n        messageId: \"missingClosingLinebreak\",\n\n        fix(fixer) {\n          return fixer.insertTextBefore(token, \"\\n\");\n        }\n\n      });\n    }\n\n    function check(node) {\n      const elements = node.elements;\n      const normalizedOptions = normalizeOptions(context.options[0]);\n      const options = normalizedOptions[node.type];\n      const openBracket = sourceCode.getFirstToken(node);\n      const closeBracket = sourceCode.getLastToken(node);\n      const firstIncComment = sourceCode.getTokenAfter(openBracket, {\n        includeComments: true\n      });\n      const lastIncComment = sourceCode.getTokenBefore(closeBracket, {\n        includeComments: true\n      });\n      const first = sourceCode.getTokenAfter(openBracket);\n      const last = sourceCode.getTokenBefore(closeBracket);\n      const needsLinebreaks = elements.length >= options.minItems || options.multiline && elements.length > 0 && firstIncComment.loc.start.line !== lastIncComment.loc.end.line || elements.length === 0 && firstIncComment.type === \"Block\" && firstIncComment.loc.start.line !== lastIncComment.loc.end.line && firstIncComment === lastIncComment || options.consistent && openBracket.loc.end.line !== first.loc.start.line;\n\n      if (needsLinebreaks) {\n        if (astUtils.isTokenOnSameLine(openBracket, first)) {\n          reportRequiredBeginningLinebreak(node, openBracket);\n        }\n\n        if (astUtils.isTokenOnSameLine(last, closeBracket)) {\n          reportRequiredEndingLinebreak(node, closeBracket);\n        }\n      } else {\n        if (!astUtils.isTokenOnSameLine(openBracket, first)) {\n          reportNoBeginningLinebreak(node, openBracket);\n        }\n\n        if (!astUtils.isTokenOnSameLine(last, closeBracket)) {\n          reportNoEndingLinebreak(node, closeBracket);\n        }\n      }\n    }\n\n    return {\n      ArrayPattern: check,\n      ArrayExpression: check\n    };\n  }\n\n};\narrayBracketNewline.meta;\narrayBracketNewline.create;\nvar arrayBracketSpacing = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"enforce consistent spacing inside array brackets\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/array-bracket-spacing\"\n    },\n    fixable: \"whitespace\",\n    schema: [{\n      enum: [\"always\", \"never\"]\n    }, {\n      type: \"object\",\n      properties: {\n        singleValue: {\n          type: \"boolean\"\n        },\n        objectsInArrays: {\n          type: \"boolean\"\n        },\n        arraysInArrays: {\n          type: \"boolean\"\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      unexpectedSpaceAfter: \"There should be no space after '{{tokenValue}}'.\",\n      unexpectedSpaceBefore: \"There should be no space before '{{tokenValue}}'.\",\n      missingSpaceAfter: \"A space is required after '{{tokenValue}}'.\",\n      missingSpaceBefore: \"A space is required before '{{tokenValue}}'.\"\n    }\n  },\n\n  create(context) {\n    const spaced = context.options[0] === \"always\",\n          sourceCode = context.getSourceCode();\n\n    function isOptionSet(option) {\n      return context.options[1] ? context.options[1][option] === !spaced : false;\n    }\n\n    const options = {\n      spaced,\n      singleElementException: isOptionSet(\"singleValue\"),\n      objectsInArraysException: isOptionSet(\"objectsInArrays\"),\n      arraysInArraysException: isOptionSet(\"arraysInArrays\")\n    };\n\n    function reportNoBeginningSpace(node, token) {\n      const nextToken = sourceCode.getTokenAfter(token);\n      context.report({\n        node,\n        loc: {\n          start: token.loc.end,\n          end: nextToken.loc.start\n        },\n        messageId: \"unexpectedSpaceAfter\",\n        data: {\n          tokenValue: token.value\n        },\n\n        fix(fixer) {\n          return fixer.removeRange([token.range[1], nextToken.range[0]]);\n        }\n\n      });\n    }\n\n    function reportNoEndingSpace(node, token) {\n      const previousToken = sourceCode.getTokenBefore(token);\n      context.report({\n        node,\n        loc: {\n          start: previousToken.loc.end,\n          end: token.loc.start\n        },\n        messageId: \"unexpectedSpaceBefore\",\n        data: {\n          tokenValue: token.value\n        },\n\n        fix(fixer) {\n          return fixer.removeRange([previousToken.range[1], token.range[0]]);\n        }\n\n      });\n    }\n\n    function reportRequiredBeginningSpace(node, token) {\n      context.report({\n        node,\n        loc: token.loc,\n        messageId: \"missingSpaceAfter\",\n        data: {\n          tokenValue: token.value\n        },\n\n        fix(fixer) {\n          return fixer.insertTextAfter(token, \" \");\n        }\n\n      });\n    }\n\n    function reportRequiredEndingSpace(node, token) {\n      context.report({\n        node,\n        loc: token.loc,\n        messageId: \"missingSpaceBefore\",\n        data: {\n          tokenValue: token.value\n        },\n\n        fix(fixer) {\n          return fixer.insertTextBefore(token, \" \");\n        }\n\n      });\n    }\n\n    function isObjectType(node) {\n      return node && (node.type === \"ObjectExpression\" || node.type === \"ObjectPattern\");\n    }\n\n    function isArrayType(node) {\n      return node && (node.type === \"ArrayExpression\" || node.type === \"ArrayPattern\");\n    }\n\n    function validateArraySpacing(node) {\n      if (options.spaced && node.elements.length === 0) {\n        return;\n      }\n\n      const first = sourceCode.getFirstToken(node),\n            second = sourceCode.getFirstToken(node, 1),\n            last = node.typeAnnotation ? sourceCode.getTokenBefore(node.typeAnnotation) : sourceCode.getLastToken(node),\n            penultimate = sourceCode.getTokenBefore(last),\n            firstElement = node.elements[0],\n            lastElement = node.elements[node.elements.length - 1];\n      const openingBracketMustBeSpaced = options.objectsInArraysException && isObjectType(firstElement) || options.arraysInArraysException && isArrayType(firstElement) || options.singleElementException && node.elements.length === 1 ? !options.spaced : options.spaced;\n      const closingBracketMustBeSpaced = options.objectsInArraysException && isObjectType(lastElement) || options.arraysInArraysException && isArrayType(lastElement) || options.singleElementException && node.elements.length === 1 ? !options.spaced : options.spaced;\n\n      if (astUtils.isTokenOnSameLine(first, second)) {\n        if (openingBracketMustBeSpaced && !sourceCode.isSpaceBetweenTokens(first, second)) {\n          reportRequiredBeginningSpace(node, first);\n        }\n\n        if (!openingBracketMustBeSpaced && sourceCode.isSpaceBetweenTokens(first, second)) {\n          reportNoBeginningSpace(node, first);\n        }\n      }\n\n      if (first !== penultimate && astUtils.isTokenOnSameLine(penultimate, last)) {\n        if (closingBracketMustBeSpaced && !sourceCode.isSpaceBetweenTokens(penultimate, last)) {\n          reportRequiredEndingSpace(node, last);\n        }\n\n        if (!closingBracketMustBeSpaced && sourceCode.isSpaceBetweenTokens(penultimate, last)) {\n          reportNoEndingSpace(node, last);\n        }\n      }\n    }\n\n    return {\n      ArrayPattern: validateArraySpacing,\n      ArrayExpression: validateArraySpacing\n    };\n  }\n\n};\narrayBracketSpacing.meta;\narrayBracketSpacing.create;\nconst TARGET_NODE_TYPE$2 = /^(?:Arrow)?FunctionExpression$/u;\nconst TARGET_METHODS = /^(?:every|filter|find(?:Index)?|flatMap|forEach|map|reduce(?:Right)?|some|sort)$/u;\n\nfunction isReachable$3(segment) {\n  return segment.reachable;\n}\n\nfunction isTargetMethod(node) {\n  return astUtils.isSpecificMemberAccess(node, null, TARGET_METHODS);\n}\n\nfunction fullMethodName(arrayMethodName) {\n  if ([\"from\", \"of\", \"isArray\"].includes(arrayMethodName)) {\n    return \"Array.\".concat(arrayMethodName);\n  }\n\n  return \"Array.prototype.\".concat(arrayMethodName);\n}\n\nfunction getArrayMethodName(node) {\n  let currentNode = node;\n\n  while (currentNode) {\n    const parent = currentNode.parent;\n\n    switch (parent.type) {\n      case \"LogicalExpression\":\n      case \"ConditionalExpression\":\n      case \"ChainExpression\":\n        currentNode = parent;\n        break;\n\n      case \"ReturnStatement\":\n        {\n          const func = astUtils.getUpperFunction(parent);\n\n          if (func === null || !astUtils.isCallee(func)) {\n            return null;\n          }\n\n          currentNode = func.parent;\n          break;\n        }\n\n      case \"CallExpression\":\n        if (astUtils.isArrayFromMethod(parent.callee)) {\n          if (parent.arguments.length >= 2 && parent.arguments[1] === currentNode) {\n            return \"from\";\n          }\n        }\n\n        if (isTargetMethod(parent.callee)) {\n          if (parent.arguments.length >= 1 && parent.arguments[0] === currentNode) {\n            return astUtils.getStaticPropertyName(parent.callee);\n          }\n        }\n\n        return null;\n\n      default:\n        return null;\n    }\n  }\n\n  return null;\n}\n\nvar arrayCallbackReturn = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"enforce `return` statements in callbacks of array methods\",\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/array-callback-return\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        allowImplicit: {\n          type: \"boolean\",\n          default: false\n        },\n        checkForEach: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      expectedAtEnd: \"{{arrayMethodName}}() expects a value to be returned at the end of {{name}}.\",\n      expectedInside: \"{{arrayMethodName}}() expects a return value from {{name}}.\",\n      expectedReturnValue: \"{{arrayMethodName}}() expects a return value from {{name}}.\",\n      expectedNoReturnValue: \"{{arrayMethodName}}() expects no useless return value from {{name}}.\"\n    }\n  },\n\n  create(context) {\n    const options = context.options[0] || {\n      allowImplicit: false,\n      checkForEach: false\n    };\n    const sourceCode = context.getSourceCode();\n    let funcInfo = {\n      arrayMethodName: null,\n      upper: null,\n      codePath: null,\n      hasReturn: false,\n      shouldCheck: false,\n      node: null\n    };\n\n    function checkLastSegment(node) {\n      if (!funcInfo.shouldCheck) {\n        return;\n      }\n\n      let messageId = null;\n\n      if (funcInfo.arrayMethodName === \"forEach\") {\n        if (options.checkForEach && node.type === \"ArrowFunctionExpression\" && node.expression) {\n          messageId = \"expectedNoReturnValue\";\n        }\n      } else {\n        if (node.body.type === \"BlockStatement\" && funcInfo.codePath.currentSegments.some(isReachable$3)) {\n          messageId = funcInfo.hasReturn ? \"expectedAtEnd\" : \"expectedInside\";\n        }\n      }\n\n      if (messageId) {\n        const name = astUtils.getFunctionNameWithKind(node);\n        context.report({\n          node,\n          loc: astUtils.getFunctionHeadLoc(node, sourceCode),\n          messageId,\n          data: {\n            name,\n            arrayMethodName: fullMethodName(funcInfo.arrayMethodName)\n          }\n        });\n      }\n    }\n\n    return {\n      onCodePathStart(codePath, node) {\n        let methodName = null;\n\n        if (TARGET_NODE_TYPE$2.test(node.type)) {\n          methodName = getArrayMethodName(node);\n        }\n\n        funcInfo = {\n          arrayMethodName: methodName,\n          upper: funcInfo,\n          codePath,\n          hasReturn: false,\n          shouldCheck: methodName && !node.async && !node.generator,\n          node\n        };\n      },\n\n      onCodePathEnd() {\n        funcInfo = funcInfo.upper;\n      },\n\n      ReturnStatement(node) {\n        if (!funcInfo.shouldCheck) {\n          return;\n        }\n\n        funcInfo.hasReturn = true;\n        let messageId = null;\n\n        if (funcInfo.arrayMethodName === \"forEach\") {\n          if (options.checkForEach && node.argument) {\n            messageId = \"expectedNoReturnValue\";\n          }\n        } else {\n          if (!options.allowImplicit && !node.argument) {\n            messageId = \"expectedReturnValue\";\n          }\n        }\n\n        if (messageId) {\n          context.report({\n            node,\n            messageId,\n            data: {\n              name: astUtils.getFunctionNameWithKind(funcInfo.node),\n              arrayMethodName: fullMethodName(funcInfo.arrayMethodName)\n            }\n          });\n        }\n      },\n\n      \"FunctionExpression:exit\": checkLastSegment,\n      \"ArrowFunctionExpression:exit\": checkLastSegment\n    };\n  }\n\n};\narrayCallbackReturn.meta;\narrayCallbackReturn.create;\nvar arrayElementNewline = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"enforce line breaks after each array element\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/array-element-newline\"\n    },\n    fixable: \"whitespace\",\n    schema: {\n      definitions: {\n        basicConfig: {\n          oneOf: [{\n            enum: [\"always\", \"never\", \"consistent\"]\n          }, {\n            type: \"object\",\n            properties: {\n              multiline: {\n                type: \"boolean\"\n              },\n              minItems: {\n                type: [\"integer\", \"null\"],\n                minimum: 0\n              }\n            },\n            additionalProperties: false\n          }]\n        }\n      },\n      items: [{\n        oneOf: [{\n          $ref: \"#/definitions/basicConfig\"\n        }, {\n          type: \"object\",\n          properties: {\n            ArrayExpression: {\n              $ref: \"#/definitions/basicConfig\"\n            },\n            ArrayPattern: {\n              $ref: \"#/definitions/basicConfig\"\n            }\n          },\n          additionalProperties: false,\n          minProperties: 1\n        }]\n      }]\n    },\n    messages: {\n      unexpectedLineBreak: \"There should be no linebreak here.\",\n      missingLineBreak: \"There should be a linebreak after this element.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n\n    function normalizeOptionValue(providedOption) {\n      let consistent = false;\n      let multiline = false;\n      let minItems;\n      const option = providedOption || \"always\";\n\n      if (!option || option === \"always\" || option.minItems === 0) {\n        minItems = 0;\n      } else if (option === \"never\") {\n        minItems = Number.POSITIVE_INFINITY;\n      } else if (option === \"consistent\") {\n        consistent = true;\n        minItems = Number.POSITIVE_INFINITY;\n      } else {\n        multiline = Boolean(option.multiline);\n        minItems = option.minItems || Number.POSITIVE_INFINITY;\n      }\n\n      return {\n        consistent,\n        multiline,\n        minItems\n      };\n    }\n\n    function normalizeOptions(options) {\n      if (options && (options.ArrayExpression || options.ArrayPattern)) {\n        let expressionOptions, patternOptions;\n\n        if (options.ArrayExpression) {\n          expressionOptions = normalizeOptionValue(options.ArrayExpression);\n        }\n\n        if (options.ArrayPattern) {\n          patternOptions = normalizeOptionValue(options.ArrayPattern);\n        }\n\n        return {\n          ArrayExpression: expressionOptions,\n          ArrayPattern: patternOptions\n        };\n      }\n\n      const value = normalizeOptionValue(options);\n      return {\n        ArrayExpression: value,\n        ArrayPattern: value\n      };\n    }\n\n    function reportNoLineBreak(token) {\n      const tokenBefore = sourceCode.getTokenBefore(token, {\n        includeComments: true\n      });\n      context.report({\n        loc: {\n          start: tokenBefore.loc.end,\n          end: token.loc.start\n        },\n        messageId: \"unexpectedLineBreak\",\n\n        fix(fixer) {\n          if (astUtils.isCommentToken(tokenBefore)) {\n            return null;\n          }\n\n          if (!astUtils.isTokenOnSameLine(tokenBefore, token)) {\n            return fixer.replaceTextRange([tokenBefore.range[1], token.range[0]], \" \");\n          }\n\n          const twoTokensBefore = sourceCode.getTokenBefore(tokenBefore, {\n            includeComments: true\n          });\n\n          if (astUtils.isCommentToken(twoTokensBefore)) {\n            return null;\n          }\n\n          return fixer.replaceTextRange([twoTokensBefore.range[1], tokenBefore.range[0]], \"\");\n        }\n\n      });\n    }\n\n    function reportRequiredLineBreak(token) {\n      const tokenBefore = sourceCode.getTokenBefore(token, {\n        includeComments: true\n      });\n      context.report({\n        loc: {\n          start: tokenBefore.loc.end,\n          end: token.loc.start\n        },\n        messageId: \"missingLineBreak\",\n\n        fix(fixer) {\n          return fixer.replaceTextRange([tokenBefore.range[1], token.range[0]], \"\\n\");\n        }\n\n      });\n    }\n\n    function check(node) {\n      const elements = node.elements;\n      const normalizedOptions = normalizeOptions(context.options[0]);\n      const options = normalizedOptions[node.type];\n\n      if (!options) {\n        return;\n      }\n\n      let elementBreak = false;\n\n      if (options.multiline) {\n        elementBreak = elements.filter(element => element !== null).some(element => element.loc.start.line !== element.loc.end.line);\n      }\n\n      const linebreaksCount = node.elements.map((element, i) => {\n        const previousElement = elements[i - 1];\n\n        if (i === 0 || element === null || previousElement === null) {\n          return false;\n        }\n\n        const commaToken = sourceCode.getFirstTokenBetween(previousElement, element, astUtils.isCommaToken);\n        const lastTokenOfPreviousElement = sourceCode.getTokenBefore(commaToken);\n        const firstTokenOfCurrentElement = sourceCode.getTokenAfter(commaToken);\n        return !astUtils.isTokenOnSameLine(lastTokenOfPreviousElement, firstTokenOfCurrentElement);\n      }).filter(isBreak => isBreak === true).length;\n      const needsLinebreaks = elements.length >= options.minItems || options.multiline && elementBreak || options.consistent && linebreaksCount > 0 && linebreaksCount < node.elements.length;\n      elements.forEach((element, i) => {\n        const previousElement = elements[i - 1];\n\n        if (i === 0 || element === null || previousElement === null) {\n          return;\n        }\n\n        const commaToken = sourceCode.getFirstTokenBetween(previousElement, element, astUtils.isCommaToken);\n        const lastTokenOfPreviousElement = sourceCode.getTokenBefore(commaToken);\n        const firstTokenOfCurrentElement = sourceCode.getTokenAfter(commaToken);\n\n        if (needsLinebreaks) {\n          if (astUtils.isTokenOnSameLine(lastTokenOfPreviousElement, firstTokenOfCurrentElement)) {\n            reportRequiredLineBreak(firstTokenOfCurrentElement);\n          }\n        } else {\n          if (!astUtils.isTokenOnSameLine(lastTokenOfPreviousElement, firstTokenOfCurrentElement)) {\n            reportNoLineBreak(firstTokenOfCurrentElement);\n          }\n        }\n      });\n    }\n\n    return {\n      ArrayPattern: check,\n      ArrayExpression: check\n    };\n  }\n\n};\narrayElementNewline.meta;\narrayElementNewline.create;\nvar arrowBodyStyle = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"require braces around arrow function bodies\",\n      category: \"ECMAScript 6\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/arrow-body-style\"\n    },\n    schema: {\n      anyOf: [{\n        type: \"array\",\n        items: [{\n          enum: [\"always\", \"never\"]\n        }],\n        minItems: 0,\n        maxItems: 1\n      }, {\n        type: \"array\",\n        items: [{\n          enum: [\"as-needed\"]\n        }, {\n          type: \"object\",\n          properties: {\n            requireReturnForObjectLiteral: {\n              type: \"boolean\"\n            }\n          },\n          additionalProperties: false\n        }],\n        minItems: 0,\n        maxItems: 2\n      }]\n    },\n    fixable: \"code\",\n    messages: {\n      unexpectedOtherBlock: \"Unexpected block statement surrounding arrow body.\",\n      unexpectedEmptyBlock: \"Unexpected block statement surrounding arrow body; put a value of `undefined` immediately after the `=>`.\",\n      unexpectedObjectBlock: \"Unexpected block statement surrounding arrow body; parenthesize the returned value and move it immediately after the `=>`.\",\n      unexpectedSingleBlock: \"Unexpected block statement surrounding arrow body; move the returned value immediately after the `=>`.\",\n      expectedBlock: \"Expected block statement surrounding arrow body.\"\n    }\n  },\n\n  create(context) {\n    const options = context.options;\n    const always = options[0] === \"always\";\n    const asNeeded = !options[0] || options[0] === \"as-needed\";\n    const never = options[0] === \"never\";\n    const requireReturnForObjectLiteral = options[1] && options[1].requireReturnForObjectLiteral;\n    const sourceCode = context.getSourceCode();\n    let funcInfo = null;\n\n    function hasASIProblem(token) {\n      return token && token.type === \"Punctuator\" && /^[([/`+-]/u.test(token.value);\n    }\n\n    function findClosingParen(node) {\n      let nodeToCheck = node;\n\n      while (!astUtils.isParenthesised(sourceCode, nodeToCheck)) {\n        nodeToCheck = nodeToCheck.parent;\n      }\n\n      return sourceCode.getTokenAfter(nodeToCheck);\n    }\n\n    function isInsideForLoopInitializer(node) {\n      if (node && node.parent) {\n        if (node.parent.type === \"ForStatement\" && node.parent.init === node) {\n          return true;\n        }\n\n        return isInsideForLoopInitializer(node.parent);\n      }\n\n      return false;\n    }\n\n    function validate(node) {\n      const arrowBody = node.body;\n\n      if (arrowBody.type === \"BlockStatement\") {\n        const blockBody = arrowBody.body;\n\n        if (blockBody.length !== 1 && !never) {\n          return;\n        }\n\n        if (asNeeded && requireReturnForObjectLiteral && blockBody[0].type === \"ReturnStatement\" && blockBody[0].argument && blockBody[0].argument.type === \"ObjectExpression\") {\n          return;\n        }\n\n        if (never || asNeeded && blockBody[0].type === \"ReturnStatement\") {\n          let messageId;\n\n          if (blockBody.length === 0) {\n            messageId = \"unexpectedEmptyBlock\";\n          } else if (blockBody.length > 1) {\n            messageId = \"unexpectedOtherBlock\";\n          } else if (blockBody[0].argument === null) {\n            messageId = \"unexpectedSingleBlock\";\n          } else if (astUtils.isOpeningBraceToken(sourceCode.getFirstToken(blockBody[0], {\n            skip: 1\n          }))) {\n            messageId = \"unexpectedObjectBlock\";\n          } else {\n            messageId = \"unexpectedSingleBlock\";\n          }\n\n          context.report({\n            node,\n            loc: arrowBody.loc,\n            messageId,\n\n            fix(fixer) {\n              const fixes = [];\n\n              if (blockBody.length !== 1 || blockBody[0].type !== \"ReturnStatement\" || !blockBody[0].argument || hasASIProblem(sourceCode.getTokenAfter(arrowBody))) {\n                return fixes;\n              }\n\n              const openingBrace = sourceCode.getFirstToken(arrowBody);\n              const closingBrace = sourceCode.getLastToken(arrowBody);\n              const firstValueToken = sourceCode.getFirstToken(blockBody[0], 1);\n              const lastValueToken = sourceCode.getLastToken(blockBody[0]);\n              const commentsExist = sourceCode.commentsExistBetween(openingBrace, firstValueToken) || sourceCode.commentsExistBetween(lastValueToken, closingBrace);\n\n              if (commentsExist) {\n                fixes.push(fixer.remove(openingBrace), fixer.remove(closingBrace), fixer.remove(sourceCode.getTokenAfter(openingBrace)));\n              } else {\n                fixes.push(fixer.removeRange([openingBrace.range[0], firstValueToken.range[0]]), fixer.removeRange([lastValueToken.range[1], closingBrace.range[1]]));\n              }\n\n              if (astUtils.isOpeningBraceToken(firstValueToken) || blockBody[0].argument.type === \"SequenceExpression\" || funcInfo.hasInOperator && isInsideForLoopInitializer(node)) {\n                if (!astUtils.isParenthesised(sourceCode, blockBody[0].argument)) {\n                  fixes.push(fixer.insertTextBefore(firstValueToken, \"(\"), fixer.insertTextAfter(lastValueToken, \")\"));\n                }\n              }\n\n              if (astUtils.isSemicolonToken(lastValueToken)) {\n                fixes.push(fixer.remove(lastValueToken));\n              }\n\n              return fixes;\n            }\n\n          });\n        }\n      } else {\n        if (always || asNeeded && requireReturnForObjectLiteral && arrowBody.type === \"ObjectExpression\") {\n          context.report({\n            node,\n            loc: arrowBody.loc,\n            messageId: \"expectedBlock\",\n\n            fix(fixer) {\n              const fixes = [];\n              const arrowToken = sourceCode.getTokenBefore(arrowBody, astUtils.isArrowToken);\n              const [firstTokenAfterArrow, secondTokenAfterArrow] = sourceCode.getTokensAfter(arrowToken, {\n                count: 2\n              });\n              const lastToken = sourceCode.getLastToken(node);\n              let parenthesisedObjectLiteral = null;\n\n              if (astUtils.isOpeningParenToken(firstTokenAfterArrow) && astUtils.isOpeningBraceToken(secondTokenAfterArrow)) {\n                const braceNode = sourceCode.getNodeByRangeIndex(secondTokenAfterArrow.range[0]);\n\n                if (braceNode.type === \"ObjectExpression\") {\n                  parenthesisedObjectLiteral = braceNode;\n                }\n              }\n\n              if (parenthesisedObjectLiteral) {\n                const openingParenToken = firstTokenAfterArrow;\n                const openingBraceToken = secondTokenAfterArrow;\n\n                if (astUtils.isTokenOnSameLine(openingParenToken, openingBraceToken)) {\n                  fixes.push(fixer.replaceText(openingParenToken, \"{return \"));\n                } else {\n                  fixes.push(fixer.replaceText(openingParenToken, \"{\"), fixer.insertTextBefore(openingBraceToken, \"return \"));\n                }\n\n                fixes.push(fixer.remove(findClosingParen(parenthesisedObjectLiteral)));\n                fixes.push(fixer.insertTextAfter(lastToken, \"}\"));\n              } else {\n                fixes.push(fixer.insertTextBefore(firstTokenAfterArrow, \"{return \"));\n                fixes.push(fixer.insertTextAfter(lastToken, \"}\"));\n              }\n\n              return fixes;\n            }\n\n          });\n        }\n      }\n    }\n\n    return {\n      \"BinaryExpression[operator='in']\"() {\n        let info = funcInfo;\n\n        while (info) {\n          info.hasInOperator = true;\n          info = info.upper;\n        }\n      },\n\n      ArrowFunctionExpression() {\n        funcInfo = {\n          upper: funcInfo,\n          hasInOperator: false\n        };\n      },\n\n      \"ArrowFunctionExpression:exit\"(node) {\n        validate(node);\n        funcInfo = funcInfo.upper;\n      }\n\n    };\n  }\n\n};\narrowBodyStyle.meta;\narrowBodyStyle.create;\n\nfunction hasBlockBody(node) {\n  return node.body.type === \"BlockStatement\";\n}\n\nvar arrowParens = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"require parentheses around arrow function arguments\",\n      category: \"ECMAScript 6\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/arrow-parens\"\n    },\n    fixable: \"code\",\n    schema: [{\n      enum: [\"always\", \"as-needed\"]\n    }, {\n      type: \"object\",\n      properties: {\n        requireForBlockBody: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      unexpectedParens: \"Unexpected parentheses around single function argument.\",\n      expectedParens: \"Expected parentheses around arrow function argument.\",\n      unexpectedParensInline: \"Unexpected parentheses around single function argument having a body with no curly braces.\",\n      expectedParensBlock: \"Expected parentheses around arrow function argument having a body with curly braces.\"\n    }\n  },\n\n  create(context) {\n    const asNeeded = context.options[0] === \"as-needed\";\n    const requireForBlockBody = asNeeded && context.options[1] && context.options[1].requireForBlockBody === true;\n    const sourceCode = context.getSourceCode();\n\n    function findOpeningParenOfParams(node) {\n      const tokenBeforeParams = sourceCode.getTokenBefore(node.params[0]);\n\n      if (tokenBeforeParams && astUtils.isOpeningParenToken(tokenBeforeParams) && node.range[0] <= tokenBeforeParams.range[0]) {\n        return tokenBeforeParams;\n      }\n\n      return null;\n    }\n\n    function getClosingParenOfParams(node) {\n      return sourceCode.getTokenAfter(node.params[0], astUtils.isClosingParenToken);\n    }\n\n    function hasCommentsInParensOfParams(node, openingParen) {\n      return sourceCode.commentsExistBetween(openingParen, getClosingParenOfParams(node));\n    }\n\n    function hasUnexpectedTokensBeforeOpeningParen(node, openingParen) {\n      const expectedCount = node.async ? 1 : 0;\n      return sourceCode.getFirstToken(node, {\n        skip: expectedCount\n      }) !== openingParen;\n    }\n\n    return {\n      \"ArrowFunctionExpression[params.length=1]\"(node) {\n        const shouldHaveParens = !asNeeded || requireForBlockBody && hasBlockBody(node);\n        const openingParen = findOpeningParenOfParams(node);\n        const hasParens = openingParen !== null;\n        const [param] = node.params;\n\n        if (shouldHaveParens && !hasParens) {\n          context.report({\n            node,\n            messageId: requireForBlockBody ? \"expectedParensBlock\" : \"expectedParens\",\n            loc: param.loc,\n\n            *fix(fixer) {\n              yield fixer.insertTextBefore(param, \"(\");\n              yield fixer.insertTextAfter(param, \")\");\n            }\n\n          });\n        }\n\n        if (!shouldHaveParens && hasParens && param.type === \"Identifier\" && !param.typeAnnotation && !node.returnType && !hasCommentsInParensOfParams(node, openingParen) && !hasUnexpectedTokensBeforeOpeningParen(node, openingParen)) {\n          context.report({\n            node,\n            messageId: requireForBlockBody ? \"unexpectedParensInline\" : \"unexpectedParens\",\n            loc: param.loc,\n\n            *fix(fixer) {\n              const tokenBeforeOpeningParen = sourceCode.getTokenBefore(openingParen);\n              const closingParen = getClosingParenOfParams(node);\n\n              if (tokenBeforeOpeningParen && tokenBeforeOpeningParen.range[1] === openingParen.range[0] && !astUtils.canTokensBeAdjacent(tokenBeforeOpeningParen, sourceCode.getFirstToken(param))) {\n                yield fixer.insertTextBefore(openingParen, \" \");\n              }\n\n              yield fixer.removeRange([openingParen.range[0], param.range[0]]);\n              yield fixer.removeRange([param.range[1], closingParen.range[1]]);\n            }\n\n          });\n        }\n      }\n\n    };\n  }\n\n};\narrowParens.meta;\narrowParens.create;\nvar arrowSpacing = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"enforce consistent spacing before and after the arrow in arrow functions\",\n      category: \"ECMAScript 6\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/arrow-spacing\"\n    },\n    fixable: \"whitespace\",\n    schema: [{\n      type: \"object\",\n      properties: {\n        before: {\n          type: \"boolean\",\n          default: true\n        },\n        after: {\n          type: \"boolean\",\n          default: true\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      expectedBefore: \"Missing space before =>.\",\n      unexpectedBefore: \"Unexpected space before =>.\",\n      expectedAfter: \"Missing space after =>.\",\n      unexpectedAfter: \"Unexpected space after =>.\"\n    }\n  },\n\n  create(context) {\n    const rule = Object.assign({}, context.options[0]);\n    rule.before = rule.before !== false;\n    rule.after = rule.after !== false;\n    const sourceCode = context.getSourceCode();\n\n    function getTokens(node) {\n      const arrow = sourceCode.getTokenBefore(node.body, astUtils.isArrowToken);\n      return {\n        before: sourceCode.getTokenBefore(arrow),\n        arrow,\n        after: sourceCode.getTokenAfter(arrow)\n      };\n    }\n\n    function countSpaces(tokens) {\n      const before = tokens.arrow.range[0] - tokens.before.range[1];\n      const after = tokens.after.range[0] - tokens.arrow.range[1];\n      return {\n        before,\n        after\n      };\n    }\n\n    return {\n      ArrowFunctionExpression: function (node) {\n        const tokens = getTokens(node);\n        const countSpace = countSpaces(tokens);\n\n        if (rule.before) {\n          if (countSpace.before === 0) {\n            context.report({\n              node: tokens.before,\n              messageId: \"expectedBefore\",\n\n              fix(fixer) {\n                return fixer.insertTextBefore(tokens.arrow, \" \");\n              }\n\n            });\n          }\n        } else {\n          if (countSpace.before > 0) {\n            context.report({\n              node: tokens.before,\n              messageId: \"unexpectedBefore\",\n\n              fix(fixer) {\n                return fixer.removeRange([tokens.before.range[1], tokens.arrow.range[0]]);\n              }\n\n            });\n          }\n        }\n\n        if (rule.after) {\n          if (countSpace.after === 0) {\n            context.report({\n              node: tokens.after,\n              messageId: \"expectedAfter\",\n\n              fix(fixer) {\n                return fixer.insertTextAfter(tokens.arrow, \" \");\n              }\n\n            });\n          }\n        } else {\n          if (countSpace.after > 0) {\n            context.report({\n              node: tokens.after,\n              messageId: \"unexpectedAfter\",\n\n              fix(fixer) {\n                return fixer.removeRange([tokens.arrow.range[1], tokens.after.range[0]]);\n              }\n\n            });\n          }\n        }\n      }\n    };\n  }\n\n};\narrowSpacing.meta;\narrowSpacing.create;\nvar blockScopedVar = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"enforce the use of variables within the scope they are defined\",\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/block-scoped-var\"\n    },\n    schema: [],\n    messages: {\n      outOfScope: \"'{{name}}' used outside of binding context.\"\n    }\n  },\n\n  create(context) {\n    let stack = [];\n\n    function enterScope(node) {\n      stack.push(node.range);\n    }\n\n    function exitScope() {\n      stack.pop();\n    }\n\n    function report(reference) {\n      const identifier = reference.identifier;\n      context.report({\n        node: identifier,\n        messageId: \"outOfScope\",\n        data: {\n          name: identifier.name\n        }\n      });\n    }\n\n    function checkForVariables(node) {\n      if (node.kind !== \"var\") {\n        return;\n      }\n\n      const scopeRange = stack[stack.length - 1];\n\n      function isOutsideOfScope(reference) {\n        const idRange = reference.identifier.range;\n        return idRange[0] < scopeRange[0] || idRange[1] > scopeRange[1];\n      }\n\n      const variables = context.getDeclaredVariables(node);\n\n      for (let i = 0; i < variables.length; ++i) {\n        variables[i].references.filter(isOutsideOfScope).forEach(report);\n      }\n    }\n\n    return {\n      Program(node) {\n        stack = [node.range];\n      },\n\n      BlockStatement: enterScope,\n      \"BlockStatement:exit\": exitScope,\n      ForStatement: enterScope,\n      \"ForStatement:exit\": exitScope,\n      ForInStatement: enterScope,\n      \"ForInStatement:exit\": exitScope,\n      ForOfStatement: enterScope,\n      \"ForOfStatement:exit\": exitScope,\n      SwitchStatement: enterScope,\n      \"SwitchStatement:exit\": exitScope,\n      CatchClause: enterScope,\n      \"CatchClause:exit\": exitScope,\n      VariableDeclaration: checkForVariables\n    };\n  }\n\n};\nblockScopedVar.meta;\nblockScopedVar.create;\nvar blockSpacing = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"disallow or enforce spaces inside of blocks after opening block and before closing block\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/block-spacing\"\n    },\n    fixable: \"whitespace\",\n    schema: [{\n      enum: [\"always\", \"never\"]\n    }],\n    messages: {\n      missing: \"Requires a space {{location}} '{{token}}'.\",\n      extra: \"Unexpected space(s) {{location}} '{{token}}'.\"\n    }\n  },\n\n  create(context) {\n    const always = context.options[0] !== \"never\",\n          messageId = always ? \"missing\" : \"extra\",\n          sourceCode = context.getSourceCode();\n\n    function getOpenBrace(node) {\n      if (node.type === \"SwitchStatement\") {\n        if (node.cases.length > 0) {\n          return sourceCode.getTokenBefore(node.cases[0]);\n        }\n\n        return sourceCode.getLastToken(node, 1);\n      }\n\n      return sourceCode.getFirstToken(node);\n    }\n\n    function isValid(left, right) {\n      return !astUtils.isTokenOnSameLine(left, right) || sourceCode.isSpaceBetweenTokens(left, right) === always;\n    }\n\n    function checkSpacingInsideBraces(node) {\n      const openBrace = getOpenBrace(node);\n      const closeBrace = sourceCode.getLastToken(node);\n      const firstToken = sourceCode.getTokenAfter(openBrace, {\n        includeComments: true\n      });\n      const lastToken = sourceCode.getTokenBefore(closeBrace, {\n        includeComments: true\n      });\n\n      if (openBrace.type !== \"Punctuator\" || openBrace.value !== \"{\" || closeBrace.type !== \"Punctuator\" || closeBrace.value !== \"}\" || firstToken === closeBrace) {\n        return;\n      }\n\n      if (!always && firstToken.type === \"Line\") {\n        return;\n      }\n\n      if (!isValid(openBrace, firstToken)) {\n        let loc = openBrace.loc;\n\n        if (messageId === \"extra\") {\n          loc = {\n            start: openBrace.loc.end,\n            end: firstToken.loc.start\n          };\n        }\n\n        context.report({\n          node,\n          loc,\n          messageId,\n          data: {\n            location: \"after\",\n            token: openBrace.value\n          },\n\n          fix(fixer) {\n            if (always) {\n              return fixer.insertTextBefore(firstToken, \" \");\n            }\n\n            return fixer.removeRange([openBrace.range[1], firstToken.range[0]]);\n          }\n\n        });\n      }\n\n      if (!isValid(lastToken, closeBrace)) {\n        let loc = closeBrace.loc;\n\n        if (messageId === \"extra\") {\n          loc = {\n            start: lastToken.loc.end,\n            end: closeBrace.loc.start\n          };\n        }\n\n        context.report({\n          node,\n          loc,\n          messageId,\n          data: {\n            location: \"before\",\n            token: closeBrace.value\n          },\n\n          fix(fixer) {\n            if (always) {\n              return fixer.insertTextAfter(lastToken, \" \");\n            }\n\n            return fixer.removeRange([lastToken.range[1], closeBrace.range[0]]);\n          }\n\n        });\n      }\n    }\n\n    return {\n      BlockStatement: checkSpacingInsideBraces,\n      SwitchStatement: checkSpacingInsideBraces\n    };\n  }\n\n};\nblockSpacing.meta;\nblockSpacing.create;\nvar braceStyle = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"enforce consistent brace style for blocks\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/brace-style\"\n    },\n    schema: [{\n      enum: [\"1tbs\", \"stroustrup\", \"allman\"]\n    }, {\n      type: \"object\",\n      properties: {\n        allowSingleLine: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    fixable: \"whitespace\",\n    messages: {\n      nextLineOpen: \"Opening curly brace does not appear on the same line as controlling statement.\",\n      sameLineOpen: \"Opening curly brace appears on the same line as controlling statement.\",\n      blockSameLine: \"Statement inside of curly braces should be on next line.\",\n      nextLineClose: \"Closing curly brace does not appear on the same line as the subsequent block.\",\n      singleLineClose: \"Closing curly brace should be on the same line as opening curly brace or on the line after the previous block.\",\n      sameLineClose: \"Closing curly brace appears on the same line as the subsequent block.\"\n    }\n  },\n\n  create(context) {\n    const style = context.options[0] || \"1tbs\",\n          params = context.options[1] || {},\n          sourceCode = context.getSourceCode();\n\n    function removeNewlineBetween(firstToken, secondToken) {\n      const textRange = [firstToken.range[1], secondToken.range[0]];\n      const textBetween = sourceCode.text.slice(textRange[0], textRange[1]);\n\n      if (textBetween.trim()) {\n        return null;\n      }\n\n      return fixer => fixer.replaceTextRange(textRange, \" \");\n    }\n\n    function validateCurlyPair(openingCurly, closingCurly) {\n      const tokenBeforeOpeningCurly = sourceCode.getTokenBefore(openingCurly);\n      const tokenAfterOpeningCurly = sourceCode.getTokenAfter(openingCurly);\n      const tokenBeforeClosingCurly = sourceCode.getTokenBefore(closingCurly);\n      const singleLineException = params.allowSingleLine && astUtils.isTokenOnSameLine(openingCurly, closingCurly);\n\n      if (style !== \"allman\" && !astUtils.isTokenOnSameLine(tokenBeforeOpeningCurly, openingCurly)) {\n        context.report({\n          node: openingCurly,\n          messageId: \"nextLineOpen\",\n          fix: removeNewlineBetween(tokenBeforeOpeningCurly, openingCurly)\n        });\n      }\n\n      if (style === \"allman\" && astUtils.isTokenOnSameLine(tokenBeforeOpeningCurly, openingCurly) && !singleLineException) {\n        context.report({\n          node: openingCurly,\n          messageId: \"sameLineOpen\",\n          fix: fixer => fixer.insertTextBefore(openingCurly, \"\\n\")\n        });\n      }\n\n      if (astUtils.isTokenOnSameLine(openingCurly, tokenAfterOpeningCurly) && tokenAfterOpeningCurly !== closingCurly && !singleLineException) {\n        context.report({\n          node: openingCurly,\n          messageId: \"blockSameLine\",\n          fix: fixer => fixer.insertTextAfter(openingCurly, \"\\n\")\n        });\n      }\n\n      if (tokenBeforeClosingCurly !== openingCurly && !singleLineException && astUtils.isTokenOnSameLine(tokenBeforeClosingCurly, closingCurly)) {\n        context.report({\n          node: closingCurly,\n          messageId: \"singleLineClose\",\n          fix: fixer => fixer.insertTextBefore(closingCurly, \"\\n\")\n        });\n      }\n    }\n\n    function validateCurlyBeforeKeyword(curlyToken) {\n      const keywordToken = sourceCode.getTokenAfter(curlyToken);\n\n      if (style === \"1tbs\" && !astUtils.isTokenOnSameLine(curlyToken, keywordToken)) {\n        context.report({\n          node: curlyToken,\n          messageId: \"nextLineClose\",\n          fix: removeNewlineBetween(curlyToken, keywordToken)\n        });\n      }\n\n      if (style !== \"1tbs\" && astUtils.isTokenOnSameLine(curlyToken, keywordToken)) {\n        context.report({\n          node: curlyToken,\n          messageId: \"sameLineClose\",\n          fix: fixer => fixer.insertTextAfter(curlyToken, \"\\n\")\n        });\n      }\n    }\n\n    return {\n      BlockStatement(node) {\n        if (!astUtils.STATEMENT_LIST_PARENTS.has(node.parent.type)) {\n          validateCurlyPair(sourceCode.getFirstToken(node), sourceCode.getLastToken(node));\n        }\n      },\n\n      ClassBody(node) {\n        validateCurlyPair(sourceCode.getFirstToken(node), sourceCode.getLastToken(node));\n      },\n\n      SwitchStatement(node) {\n        const closingCurly = sourceCode.getLastToken(node);\n        const openingCurly = sourceCode.getTokenBefore(node.cases.length ? node.cases[0] : closingCurly);\n        validateCurlyPair(openingCurly, closingCurly);\n      },\n\n      IfStatement(node) {\n        if (node.consequent.type === \"BlockStatement\" && node.alternate) {\n          validateCurlyBeforeKeyword(sourceCode.getLastToken(node.consequent));\n        }\n      },\n\n      TryStatement(node) {\n        validateCurlyBeforeKeyword(sourceCode.getLastToken(node.block));\n\n        if (node.handler && node.finalizer) {\n          validateCurlyBeforeKeyword(sourceCode.getLastToken(node.handler.body));\n        }\n      }\n\n    };\n  }\n\n};\nbraceStyle.meta;\nbraceStyle.create;\nvar callbackReturn = {\n  meta: {\n    deprecated: true,\n    replacedBy: [],\n    type: \"suggestion\",\n    docs: {\n      description: \"require `return` statements after callbacks\",\n      category: \"Node.js and CommonJS\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/callback-return\"\n    },\n    schema: [{\n      type: \"array\",\n      items: {\n        type: \"string\"\n      }\n    }],\n    messages: {\n      missingReturn: \"Expected return with your callback function.\"\n    }\n  },\n\n  create(context) {\n    const callbacks = context.options[0] || [\"callback\", \"cb\", \"next\"],\n          sourceCode = context.getSourceCode();\n\n    function findClosestParentOfType(node, types) {\n      if (!node.parent) {\n        return null;\n      }\n\n      if (types.indexOf(node.parent.type) === -1) {\n        return findClosestParentOfType(node.parent, types);\n      }\n\n      return node.parent;\n    }\n\n    function containsOnlyIdentifiers(node) {\n      if (node.type === \"Identifier\") {\n        return true;\n      }\n\n      if (node.type === \"MemberExpression\") {\n        if (node.object.type === \"Identifier\") {\n          return true;\n        }\n\n        if (node.object.type === \"MemberExpression\") {\n          return containsOnlyIdentifiers(node.object);\n        }\n      }\n\n      return false;\n    }\n\n    function isCallback(node) {\n      return containsOnlyIdentifiers(node.callee) && callbacks.indexOf(sourceCode.getText(node.callee)) > -1;\n    }\n\n    function isCallbackExpression(node, parentNode) {\n      if (!parentNode || parentNode.type !== \"ExpressionStatement\") {\n        return false;\n      }\n\n      if (parentNode.expression === node) {\n        return true;\n      }\n\n      if (parentNode.expression.type === \"BinaryExpression\" || parentNode.expression.type === \"LogicalExpression\") {\n        if (parentNode.expression.right === node) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n\n    return {\n      CallExpression(node) {\n        if (!isCallback(node)) {\n          return;\n        }\n\n        const closestBlock = findClosestParentOfType(node, [\"BlockStatement\", \"ReturnStatement\", \"ArrowFunctionExpression\"]) || {};\n\n        if (closestBlock.type === \"ReturnStatement\") {\n          return;\n        }\n\n        if (closestBlock.type === \"ArrowFunctionExpression\") {\n          return;\n        }\n\n        if (closestBlock.type === \"BlockStatement\") {\n          const lastItem = closestBlock.body[closestBlock.body.length - 1];\n\n          if (isCallbackExpression(node, lastItem)) {\n            const parentType = closestBlock.parent.type;\n\n            if (parentType === \"FunctionExpression\" || parentType === \"FunctionDeclaration\" || parentType === \"ArrowFunctionExpression\") {\n              return;\n            }\n          }\n\n          if (lastItem.type === \"ReturnStatement\") {\n            if (isCallbackExpression(node, closestBlock.body[closestBlock.body.length - 2])) {\n              return;\n            }\n          }\n        }\n\n        if (findClosestParentOfType(node, [\"FunctionDeclaration\", \"FunctionExpression\", \"ArrowFunctionExpression\"])) {\n          context.report({\n            node,\n            messageId: \"missingReturn\"\n          });\n        }\n      }\n\n    };\n  }\n\n};\ncallbackReturn.meta;\ncallbackReturn.create;\nvar camelcase = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"enforce camelcase naming convention\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/camelcase\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        ignoreDestructuring: {\n          type: \"boolean\",\n          default: false\n        },\n        ignoreImports: {\n          type: \"boolean\",\n          default: false\n        },\n        ignoreGlobals: {\n          type: \"boolean\",\n          default: false\n        },\n        properties: {\n          enum: [\"always\", \"never\"]\n        },\n        allow: {\n          type: \"array\",\n          items: [{\n            type: \"string\"\n          }],\n          minItems: 0,\n          uniqueItems: true\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      notCamelCase: \"Identifier '{{name}}' is not in camel case.\"\n    }\n  },\n\n  create(context) {\n    const options = context.options[0] || {};\n    let properties = options.properties || \"\";\n    const ignoreDestructuring = options.ignoreDestructuring;\n    const ignoreImports = options.ignoreImports;\n    const ignoreGlobals = options.ignoreGlobals;\n    const allow = options.allow || [];\n    let globalScope;\n\n    if (properties !== \"always\" && properties !== \"never\") {\n      properties = \"always\";\n    }\n\n    const reported = [];\n    const ALLOWED_PARENT_TYPES = new Set([\"CallExpression\", \"NewExpression\"]);\n\n    function isUnderscored(name) {\n      return name.includes(\"_\") && name !== name.toUpperCase();\n    }\n\n    function isAllowed(name) {\n      return allow.some(entry => name === entry || name.match(new RegExp(entry, \"u\")));\n    }\n\n    function isInsideObjectPattern(node) {\n      let current = node;\n\n      while (current) {\n        const parent = current.parent;\n\n        if (parent && parent.type === \"Property\" && parent.computed && parent.key === current) {\n          return false;\n        }\n\n        if (current.type === \"ObjectPattern\") {\n          return true;\n        }\n\n        current = parent;\n      }\n\n      return false;\n    }\n\n    function isAssignmentTargetPropertyInDestructuring(node) {\n      if (node.parent.type === \"MemberExpression\" && node.parent.property === node && !node.parent.computed) {\n        const effectiveParent = node.parent.parent;\n        return effectiveParent.type === \"Property\" && effectiveParent.value === node.parent && effectiveParent.parent.type === \"ObjectPattern\" || effectiveParent.type === \"ArrayPattern\" || effectiveParent.type === \"RestElement\" || effectiveParent.type === \"AssignmentPattern\" && effectiveParent.left === node.parent;\n      }\n\n      return false;\n    }\n\n    function isReferenceToGlobalVariable(node) {\n      const variable = globalScope.set.get(node.name);\n      return variable && variable.defs.length === 0 && variable.references.some(ref => ref.identifier === node);\n    }\n\n    function isPropertyNameInObjectLiteral(node) {\n      const parent = node.parent;\n      return parent.type === \"Property\" && parent.parent.type === \"ObjectExpression\" && !parent.computed && parent.key === node;\n    }\n\n    function report(node) {\n      if (!reported.includes(node)) {\n        reported.push(node);\n        context.report({\n          node,\n          messageId: \"notCamelCase\",\n          data: {\n            name: node.name\n          }\n        });\n      }\n    }\n\n    return {\n      Program() {\n        globalScope = context.getScope();\n      },\n\n      Identifier(node) {\n        const name = node.name,\n              nameIsUnderscored = isUnderscored(name.replace(/^_+|_+$/gu, \"\")),\n              effectiveParent = node.parent.type === \"MemberExpression\" ? node.parent.parent : node.parent;\n\n        if (isAllowed(name)) {\n          return;\n        }\n\n        if (ignoreGlobals && isReferenceToGlobalVariable(node) && !isPropertyNameInObjectLiteral(node)) {\n          return;\n        }\n\n        if (node.parent.type === \"MemberExpression\") {\n          if (properties === \"never\") {\n            return;\n          }\n\n          if (node.parent.object.type === \"Identifier\" && node.parent.object.name === node.name && nameIsUnderscored) {\n            report(node);\n          } else if (effectiveParent.type === \"AssignmentExpression\" && nameIsUnderscored && (effectiveParent.right.type !== \"MemberExpression\" || effectiveParent.left.type === \"MemberExpression\" && effectiveParent.left.property.name === node.name)) {\n            report(node);\n          } else if (isAssignmentTargetPropertyInDestructuring(node) && nameIsUnderscored) {\n            report(node);\n          }\n        } else if (node.parent.type === \"Property\" || node.parent.type === \"AssignmentPattern\") {\n          if (node.parent.parent && node.parent.parent.type === \"ObjectPattern\") {\n            if (node.parent.shorthand && node.parent.value.left && nameIsUnderscored) {\n              report(node);\n            }\n\n            const assignmentKeyEqualsValue = node.parent.key.name === node.parent.value.name;\n\n            if (nameIsUnderscored && node.parent.computed) {\n              report(node);\n            }\n\n            if (node.parent.key === node && node.parent.value !== node) {\n              return;\n            }\n\n            const valueIsUnderscored = node.parent.value.name && nameIsUnderscored;\n\n            if (valueIsUnderscored && !(assignmentKeyEqualsValue && ignoreDestructuring)) {\n              report(node);\n            }\n          }\n\n          if (properties === \"never\" || ignoreDestructuring && isInsideObjectPattern(node)) {\n            return;\n          }\n\n          if (nameIsUnderscored && !ALLOWED_PARENT_TYPES.has(effectiveParent.type) && !(node.parent.right === node)) {\n            report(node);\n          }\n        } else if ([\"ImportSpecifier\", \"ImportNamespaceSpecifier\", \"ImportDefaultSpecifier\"].includes(node.parent.type)) {\n          if (node.parent.type === \"ImportSpecifier\" && ignoreImports) {\n            return;\n          }\n\n          if (node.parent.local && node.parent.local.name === node.name && nameIsUnderscored) {\n            report(node);\n          }\n        } else if (nameIsUnderscored && !ALLOWED_PARENT_TYPES.has(effectiveParent.type)) {\n          report(node);\n        }\n      }\n\n    };\n  }\n\n};\ncamelcase.meta;\ncamelcase.create;\n/**\n * @fileoverview Pattern for detecting any letter (even letters outside of ASCII).\n * NOTE: This file was generated using this script in JSCS based on the Unicode 7.0.0 standard: https://github.com/jscs-dev/node-jscs/blob/f5ed14427deb7e7aac84f3056a5aab2d9f3e563e/publish/helpers/generate-patterns.js\n * Do not edit this file by hand-- please use https://github.com/mathiasbynens/regenerate to regenerate the regular expression exported from this file.\n * @author Kevin Partington\n * @license MIT License (from JSCS). See below.\n */\n\nvar letters = /[A-Za-z\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u08A0-\\u08B2\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58\\u0C59\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D60\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16F1-\\u16F8\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19C1-\\u19C7\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2183\\u2184\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005\\u3006\\u3031-\\u3035\\u303B\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6E5\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]|\\uD800[\\uDC00-\\uDC0B\\uDC0D-\\uDC26\\uDC28-\\uDC3A\\uDC3C\\uDC3D\\uDC3F-\\uDC4D\\uDC50-\\uDC5D\\uDC80-\\uDCFA\\uDE80-\\uDE9C\\uDEA0-\\uDED0\\uDF00-\\uDF1F\\uDF30-\\uDF40\\uDF42-\\uDF49\\uDF50-\\uDF75\\uDF80-\\uDF9D\\uDFA0-\\uDFC3\\uDFC8-\\uDFCF]|\\uD801[\\uDC00-\\uDC9D\\uDD00-\\uDD27\\uDD30-\\uDD63\\uDE00-\\uDF36\\uDF40-\\uDF55\\uDF60-\\uDF67]|\\uD802[\\uDC00-\\uDC05\\uDC08\\uDC0A-\\uDC35\\uDC37\\uDC38\\uDC3C\\uDC3F-\\uDC55\\uDC60-\\uDC76\\uDC80-\\uDC9E\\uDD00-\\uDD15\\uDD20-\\uDD39\\uDD80-\\uDDB7\\uDDBE\\uDDBF\\uDE00\\uDE10-\\uDE13\\uDE15-\\uDE17\\uDE19-\\uDE33\\uDE60-\\uDE7C\\uDE80-\\uDE9C\\uDEC0-\\uDEC7\\uDEC9-\\uDEE4\\uDF00-\\uDF35\\uDF40-\\uDF55\\uDF60-\\uDF72\\uDF80-\\uDF91]|\\uD803[\\uDC00-\\uDC48]|\\uD804[\\uDC03-\\uDC37\\uDC83-\\uDCAF\\uDCD0-\\uDCE8\\uDD03-\\uDD26\\uDD50-\\uDD72\\uDD76\\uDD83-\\uDDB2\\uDDC1-\\uDDC4\\uDDDA\\uDE00-\\uDE11\\uDE13-\\uDE2B\\uDEB0-\\uDEDE\\uDF05-\\uDF0C\\uDF0F\\uDF10\\uDF13-\\uDF28\\uDF2A-\\uDF30\\uDF32\\uDF33\\uDF35-\\uDF39\\uDF3D\\uDF5D-\\uDF61]|\\uD805[\\uDC80-\\uDCAF\\uDCC4\\uDCC5\\uDCC7\\uDD80-\\uDDAE\\uDE00-\\uDE2F\\uDE44\\uDE80-\\uDEAA]|\\uD806[\\uDCA0-\\uDCDF\\uDCFF\\uDEC0-\\uDEF8]|\\uD808[\\uDC00-\\uDF98]|[\\uD80C\\uD840-\\uD868\\uD86A-\\uD86C][\\uDC00-\\uDFFF]|\\uD80D[\\uDC00-\\uDC2E]|\\uD81A[\\uDC00-\\uDE38\\uDE40-\\uDE5E\\uDED0-\\uDEED\\uDF00-\\uDF2F\\uDF40-\\uDF43\\uDF63-\\uDF77\\uDF7D-\\uDF8F]|\\uD81B[\\uDF00-\\uDF44\\uDF50\\uDF93-\\uDF9F]|\\uD82C[\\uDC00\\uDC01]|\\uD82F[\\uDC00-\\uDC6A\\uDC70-\\uDC7C\\uDC80-\\uDC88\\uDC90-\\uDC99]|\\uD835[\\uDC00-\\uDC54\\uDC56-\\uDC9C\\uDC9E\\uDC9F\\uDCA2\\uDCA5\\uDCA6\\uDCA9-\\uDCAC\\uDCAE-\\uDCB9\\uDCBB\\uDCBD-\\uDCC3\\uDCC5-\\uDD05\\uDD07-\\uDD0A\\uDD0D-\\uDD14\\uDD16-\\uDD1C\\uDD1E-\\uDD39\\uDD3B-\\uDD3E\\uDD40-\\uDD44\\uDD46\\uDD4A-\\uDD50\\uDD52-\\uDEA5\\uDEA8-\\uDEC0\\uDEC2-\\uDEDA\\uDEDC-\\uDEFA\\uDEFC-\\uDF14\\uDF16-\\uDF34\\uDF36-\\uDF4E\\uDF50-\\uDF6E\\uDF70-\\uDF88\\uDF8A-\\uDFA8\\uDFAA-\\uDFC2\\uDFC4-\\uDFCB]|\\uD83A[\\uDC00-\\uDCC4]|\\uD83B[\\uDE00-\\uDE03\\uDE05-\\uDE1F\\uDE21\\uDE22\\uDE24\\uDE27\\uDE29-\\uDE32\\uDE34-\\uDE37\\uDE39\\uDE3B\\uDE42\\uDE47\\uDE49\\uDE4B\\uDE4D-\\uDE4F\\uDE51\\uDE52\\uDE54\\uDE57\\uDE59\\uDE5B\\uDE5D\\uDE5F\\uDE61\\uDE62\\uDE64\\uDE67-\\uDE6A\\uDE6C-\\uDE72\\uDE74-\\uDE77\\uDE79-\\uDE7C\\uDE7E\\uDE80-\\uDE89\\uDE8B-\\uDE9B\\uDEA1-\\uDEA3\\uDEA5-\\uDEA9\\uDEAB-\\uDEBB]|\\uD869[\\uDC00-\\uDED6\\uDF00-\\uDFFF]|\\uD86D[\\uDC00-\\uDF34\\uDF40-\\uDFFF]|\\uD86E[\\uDC00-\\uDC1D]|\\uD87E[\\uDC00-\\uDE1D]/u;\nconst DEFAULT_IGNORE_PATTERN = astUtils.COMMENTS_IGNORE_PATTERN,\n      WHITESPACE = /\\s/gu,\n      MAYBE_URL = /^\\s*[^:/?#\\s]+:\\/\\/[^?#]/u;\nconst SCHEMA_BODY = {\n  type: \"object\",\n  properties: {\n    ignorePattern: {\n      type: \"string\"\n    },\n    ignoreInlineComments: {\n      type: \"boolean\"\n    },\n    ignoreConsecutiveComments: {\n      type: \"boolean\"\n    }\n  },\n  additionalProperties: false\n};\nconst DEFAULTS = {\n  ignorePattern: \"\",\n  ignoreInlineComments: false,\n  ignoreConsecutiveComments: false\n};\n\nfunction getNormalizedOptions(rawOptions, which) {\n  return Object.assign({}, DEFAULTS, rawOptions[which] || rawOptions);\n}\n\nfunction getAllNormalizedOptions(rawOptions = {}) {\n  return {\n    Line: getNormalizedOptions(rawOptions, \"line\"),\n    Block: getNormalizedOptions(rawOptions, \"block\")\n  };\n}\n\nfunction createRegExpForIgnorePatterns(normalizedOptions) {\n  Object.keys(normalizedOptions).forEach(key => {\n    const ignorePatternStr = normalizedOptions[key].ignorePattern;\n\n    if (ignorePatternStr) {\n      const regExp = RegExp(`^\\\\s*(?:${ignorePatternStr})`, \"u\");\n      normalizedOptions[key].ignorePatternRegExp = regExp;\n    }\n  });\n}\n\nvar capitalizedComments = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"enforce or disallow capitalization of the first letter of a comment\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/capitalized-comments\"\n    },\n    fixable: \"code\",\n    schema: [{\n      enum: [\"always\", \"never\"]\n    }, {\n      oneOf: [SCHEMA_BODY, {\n        type: \"object\",\n        properties: {\n          line: SCHEMA_BODY,\n          block: SCHEMA_BODY\n        },\n        additionalProperties: false\n      }]\n    }],\n    messages: {\n      unexpectedLowercaseComment: \"Comments should not begin with a lowercase character.\",\n      unexpectedUppercaseComment: \"Comments should not begin with an uppercase character.\"\n    }\n  },\n\n  create(context) {\n    const capitalize = context.options[0] || \"always\",\n          normalizedOptions = getAllNormalizedOptions(context.options[1]),\n          sourceCode = context.getSourceCode();\n    createRegExpForIgnorePatterns(normalizedOptions);\n\n    function isInlineComment(comment) {\n      const previousToken = sourceCode.getTokenBefore(comment, {\n        includeComments: true\n      }),\n            nextToken = sourceCode.getTokenAfter(comment, {\n        includeComments: true\n      });\n      return Boolean(previousToken && nextToken && comment.loc.start.line === previousToken.loc.end.line && comment.loc.end.line === nextToken.loc.start.line);\n    }\n\n    function isConsecutiveComment(comment) {\n      const previousTokenOrComment = sourceCode.getTokenBefore(comment, {\n        includeComments: true\n      });\n      return Boolean(previousTokenOrComment && [\"Block\", \"Line\"].indexOf(previousTokenOrComment.type) !== -1);\n    }\n\n    function isCommentValid(comment, options) {\n      if (DEFAULT_IGNORE_PATTERN.test(comment.value)) {\n        return true;\n      }\n\n      const commentWithoutAsterisks = comment.value.replace(/\\*/gu, \"\");\n\n      if (options.ignorePatternRegExp && options.ignorePatternRegExp.test(commentWithoutAsterisks)) {\n        return true;\n      }\n\n      if (options.ignoreInlineComments && isInlineComment(comment)) {\n        return true;\n      }\n\n      if (options.ignoreConsecutiveComments && isConsecutiveComment(comment)) {\n        return true;\n      }\n\n      if (MAYBE_URL.test(commentWithoutAsterisks)) {\n        return true;\n      }\n\n      const commentWordCharsOnly = commentWithoutAsterisks.replace(WHITESPACE, \"\");\n\n      if (commentWordCharsOnly.length === 0) {\n        return true;\n      }\n\n      const firstWordChar = commentWordCharsOnly[0];\n\n      if (!letters.test(firstWordChar)) {\n        return true;\n      }\n\n      const isUppercase = firstWordChar !== firstWordChar.toLocaleLowerCase(),\n            isLowercase = firstWordChar !== firstWordChar.toLocaleUpperCase();\n\n      if (capitalize === \"always\" && isLowercase) {\n        return false;\n      }\n\n      if (capitalize === \"never\" && isUppercase) {\n        return false;\n      }\n\n      return true;\n    }\n\n    function processComment(comment) {\n      const options = normalizedOptions[comment.type],\n            commentValid = isCommentValid(comment, options);\n\n      if (!commentValid) {\n        const messageId = capitalize === \"always\" ? \"unexpectedLowercaseComment\" : \"unexpectedUppercaseComment\";\n        context.report({\n          node: null,\n          loc: comment.loc,\n          messageId,\n\n          fix(fixer) {\n            const match = comment.value.match(letters);\n            return fixer.replaceTextRange([comment.range[0] + match.index + 2, comment.range[0] + match.index + 3], capitalize === \"always\" ? match[0].toLocaleUpperCase() : match[0].toLocaleLowerCase());\n          }\n\n        });\n      }\n    }\n\n    return {\n      Program() {\n        const comments = sourceCode.getAllComments();\n        comments.filter(token => token.type !== \"Shebang\").forEach(processComment);\n      }\n\n    };\n  }\n\n};\ncapitalizedComments.meta;\ncapitalizedComments.create;\nvar classMethodsUseThis = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"enforce that class methods utilize `this`\",\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/class-methods-use-this\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        exceptMethods: {\n          type: \"array\",\n          items: {\n            type: \"string\"\n          }\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      missingThis: \"Expected 'this' to be used by class {{name}}.\"\n    }\n  },\n\n  create(context) {\n    const config = Object.assign({}, context.options[0]);\n    const exceptMethods = new Set(config.exceptMethods || []);\n    const stack = [];\n\n    function enterFunction() {\n      stack.push(false);\n    }\n\n    function isInstanceMethod(node) {\n      return !node.static && node.kind !== \"constructor\" && node.type === \"MethodDefinition\";\n    }\n\n    function isIncludedInstanceMethod(node) {\n      return isInstanceMethod(node) && (node.computed || !exceptMethods.has(node.key.name));\n    }\n\n    function exitFunction(node) {\n      const methodUsesThis = stack.pop();\n\n      if (isIncludedInstanceMethod(node.parent) && !methodUsesThis) {\n        context.report({\n          node,\n          messageId: \"missingThis\",\n          data: {\n            name: astUtils.getFunctionNameWithKind(node)\n          }\n        });\n      }\n    }\n\n    function markThisUsed() {\n      if (stack.length) {\n        stack[stack.length - 1] = true;\n      }\n    }\n\n    return {\n      FunctionDeclaration: enterFunction,\n      \"FunctionDeclaration:exit\": exitFunction,\n      FunctionExpression: enterFunction,\n      \"FunctionExpression:exit\": exitFunction,\n      ThisExpression: markThisUsed,\n      Super: markThisUsed\n    };\n  }\n\n};\nclassMethodsUseThis.meta;\nclassMethodsUseThis.create;\nconst DEFAULT_OPTIONS$1 = Object.freeze({\n  arrays: \"never\",\n  objects: \"never\",\n  imports: \"never\",\n  exports: \"never\",\n  functions: \"never\"\n});\n\nfunction isTrailingCommaAllowed(lastItem) {\n  return !(lastItem.type === \"RestElement\" || lastItem.type === \"RestProperty\" || lastItem.type === \"ExperimentalRestProperty\");\n}\n\nfunction normalizeOptions$2(optionValue, ecmaVersion) {\n  if (typeof optionValue === \"string\") {\n    return {\n      arrays: optionValue,\n      objects: optionValue,\n      imports: optionValue,\n      exports: optionValue,\n      functions: !ecmaVersion || ecmaVersion < 8 ? \"ignore\" : optionValue\n    };\n  }\n\n  if (typeof optionValue === \"object\" && optionValue !== null) {\n    return {\n      arrays: optionValue.arrays || DEFAULT_OPTIONS$1.arrays,\n      objects: optionValue.objects || DEFAULT_OPTIONS$1.objects,\n      imports: optionValue.imports || DEFAULT_OPTIONS$1.imports,\n      exports: optionValue.exports || DEFAULT_OPTIONS$1.exports,\n      functions: optionValue.functions || DEFAULT_OPTIONS$1.functions\n    };\n  }\n\n  return DEFAULT_OPTIONS$1;\n}\n\nvar commaDangle = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"require or disallow trailing commas\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/comma-dangle\"\n    },\n    fixable: \"code\",\n    schema: {\n      definitions: {\n        value: {\n          enum: [\"always-multiline\", \"always\", \"never\", \"only-multiline\"]\n        },\n        valueWithIgnore: {\n          enum: [\"always-multiline\", \"always\", \"ignore\", \"never\", \"only-multiline\"]\n        }\n      },\n      type: \"array\",\n      items: [{\n        oneOf: [{\n          $ref: \"#/definitions/value\"\n        }, {\n          type: \"object\",\n          properties: {\n            arrays: {\n              $ref: \"#/definitions/valueWithIgnore\"\n            },\n            objects: {\n              $ref: \"#/definitions/valueWithIgnore\"\n            },\n            imports: {\n              $ref: \"#/definitions/valueWithIgnore\"\n            },\n            exports: {\n              $ref: \"#/definitions/valueWithIgnore\"\n            },\n            functions: {\n              $ref: \"#/definitions/valueWithIgnore\"\n            }\n          },\n          additionalProperties: false\n        }]\n      }]\n    },\n    messages: {\n      unexpected: \"Unexpected trailing comma.\",\n      missing: \"Missing trailing comma.\"\n    }\n  },\n\n  create(context) {\n    const options = normalizeOptions$2(context.options[0], context.parserOptions.ecmaVersion);\n    const sourceCode = context.getSourceCode();\n\n    function getLastItem(node) {\n      function last(array) {\n        return array[array.length - 1];\n      }\n\n      switch (node.type) {\n        case \"ObjectExpression\":\n        case \"ObjectPattern\":\n          return last(node.properties);\n\n        case \"ArrayExpression\":\n        case \"ArrayPattern\":\n          return last(node.elements);\n\n        case \"ImportDeclaration\":\n        case \"ExportNamedDeclaration\":\n          return last(node.specifiers);\n\n        case \"FunctionDeclaration\":\n        case \"FunctionExpression\":\n        case \"ArrowFunctionExpression\":\n          return last(node.params);\n\n        case \"CallExpression\":\n        case \"NewExpression\":\n          return last(node.arguments);\n\n        default:\n          return null;\n      }\n    }\n\n    function getTrailingToken(node, lastItem) {\n      switch (node.type) {\n        case \"ObjectExpression\":\n        case \"ArrayExpression\":\n        case \"CallExpression\":\n        case \"NewExpression\":\n          return sourceCode.getLastToken(node, 1);\n\n        default:\n          {\n            const nextToken = sourceCode.getTokenAfter(lastItem);\n\n            if (astUtils.isCommaToken(nextToken)) {\n              return nextToken;\n            }\n\n            return sourceCode.getLastToken(lastItem);\n          }\n      }\n    }\n\n    function isMultiline(node) {\n      const lastItem = getLastItem(node);\n\n      if (!lastItem) {\n        return false;\n      }\n\n      const penultimateToken = getTrailingToken(node, lastItem);\n      const lastToken = sourceCode.getTokenAfter(penultimateToken);\n      return lastToken.loc.end.line !== penultimateToken.loc.end.line;\n    }\n\n    function forbidTrailingComma(node) {\n      const lastItem = getLastItem(node);\n\n      if (!lastItem || node.type === \"ImportDeclaration\" && lastItem.type !== \"ImportSpecifier\") {\n        return;\n      }\n\n      const trailingToken = getTrailingToken(node, lastItem);\n\n      if (astUtils.isCommaToken(trailingToken)) {\n        context.report({\n          node: lastItem,\n          loc: trailingToken.loc,\n          messageId: \"unexpected\",\n\n          fix(fixer) {\n            return fixer.remove(trailingToken);\n          }\n\n        });\n      }\n    }\n\n    function forceTrailingComma(node) {\n      const lastItem = getLastItem(node);\n\n      if (!lastItem || node.type === \"ImportDeclaration\" && lastItem.type !== \"ImportSpecifier\") {\n        return;\n      }\n\n      if (!isTrailingCommaAllowed(lastItem)) {\n        forbidTrailingComma(node);\n        return;\n      }\n\n      const trailingToken = getTrailingToken(node, lastItem);\n\n      if (trailingToken.value !== \",\") {\n        context.report({\n          node: lastItem,\n          loc: {\n            start: trailingToken.loc.end,\n            end: astUtils.getNextLocation(sourceCode, trailingToken.loc.end)\n          },\n          messageId: \"missing\",\n\n          fix(fixer) {\n            return fixer.insertTextAfter(trailingToken, \",\");\n          }\n\n        });\n      }\n    }\n\n    const predicate = {\n      always: forceTrailingComma,\n      \"always-multiline\": function (node) {\n        if (isMultiline(node)) {\n          forceTrailingComma(node);\n        } else {\n          forbidTrailingComma(node);\n        }\n      },\n      \"only-multiline\": function (node) {\n        if (!isMultiline(node)) {\n          forbidTrailingComma(node);\n        }\n      },\n      never: forbidTrailingComma,\n      ignore: () => {}\n    };\n    return {\n      ObjectExpression: predicate[options.objects],\n      ObjectPattern: predicate[options.objects],\n      ArrayExpression: predicate[options.arrays],\n      ArrayPattern: predicate[options.arrays],\n      ImportDeclaration: predicate[options.imports],\n      ExportNamedDeclaration: predicate[options.exports],\n      FunctionDeclaration: predicate[options.functions],\n      FunctionExpression: predicate[options.functions],\n      ArrowFunctionExpression: predicate[options.functions],\n      CallExpression: predicate[options.functions],\n      NewExpression: predicate[options.functions]\n    };\n  }\n\n};\ncommaDangle.meta;\ncommaDangle.create;\nvar commaSpacing = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"enforce consistent spacing before and after commas\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/comma-spacing\"\n    },\n    fixable: \"whitespace\",\n    schema: [{\n      type: \"object\",\n      properties: {\n        before: {\n          type: \"boolean\",\n          default: false\n        },\n        after: {\n          type: \"boolean\",\n          default: true\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      missing: \"A space is required {{loc}} ','.\",\n      unexpected: \"There should be no space {{loc}} ','.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    const tokensAndComments = sourceCode.tokensAndComments;\n    const options = {\n      before: context.options[0] ? context.options[0].before : false,\n      after: context.options[0] ? context.options[0].after : true\n    };\n    const commaTokensToIgnore = [];\n\n    function report(node, loc, otherNode) {\n      context.report({\n        node,\n\n        fix(fixer) {\n          if (options[loc]) {\n            if (loc === \"before\") {\n              return fixer.insertTextBefore(node, \" \");\n            }\n\n            return fixer.insertTextAfter(node, \" \");\n          }\n\n          let start, end;\n\n          if (loc === \"before\") {\n            start = otherNode.range[1];\n            end = node.range[0];\n          } else {\n            start = node.range[1];\n            end = otherNode.range[0];\n          }\n\n          return fixer.replaceTextRange([start, end], \"\");\n        },\n\n        messageId: options[loc] ? \"missing\" : \"unexpected\",\n        data: {\n          loc\n        }\n      });\n    }\n\n    function validateCommaItemSpacing(tokens, reportItem) {\n      if (tokens.left && astUtils.isTokenOnSameLine(tokens.left, tokens.comma) && options.before !== sourceCode.isSpaceBetweenTokens(tokens.left, tokens.comma)) {\n        report(reportItem, \"before\", tokens.left);\n      }\n\n      if (tokens.right && astUtils.isClosingParenToken(tokens.right)) {\n        return;\n      }\n\n      if (tokens.right && !options.after && tokens.right.type === \"Line\") {\n        return;\n      }\n\n      if (tokens.right && astUtils.isTokenOnSameLine(tokens.comma, tokens.right) && options.after !== sourceCode.isSpaceBetweenTokens(tokens.comma, tokens.right)) {\n        report(reportItem, \"after\", tokens.right);\n      }\n    }\n\n    function addNullElementsToIgnoreList(node) {\n      let previousToken = sourceCode.getFirstToken(node);\n      node.elements.forEach(element => {\n        let token;\n\n        if (element === null) {\n          token = sourceCode.getTokenAfter(previousToken);\n\n          if (astUtils.isCommaToken(token)) {\n            commaTokensToIgnore.push(token);\n          }\n        } else {\n          token = sourceCode.getTokenAfter(element);\n        }\n\n        previousToken = token;\n      });\n    }\n\n    return {\n      \"Program:exit\"() {\n        tokensAndComments.forEach((token, i) => {\n          if (!astUtils.isCommaToken(token)) {\n            return;\n          }\n\n          if (token && token.type === \"JSXText\") {\n            return;\n          }\n\n          const previousToken = tokensAndComments[i - 1];\n          const nextToken = tokensAndComments[i + 1];\n          validateCommaItemSpacing({\n            comma: token,\n            left: astUtils.isCommaToken(previousToken) || commaTokensToIgnore.includes(token) ? null : previousToken,\n            right: astUtils.isCommaToken(nextToken) ? null : nextToken\n          }, token);\n        });\n      },\n\n      ArrayExpression: addNullElementsToIgnoreList,\n      ArrayPattern: addNullElementsToIgnoreList\n    };\n  }\n\n};\ncommaSpacing.meta;\ncommaSpacing.create;\nvar commaStyle = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"enforce consistent comma style\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/comma-style\"\n    },\n    fixable: \"code\",\n    schema: [{\n      enum: [\"first\", \"last\"]\n    }, {\n      type: \"object\",\n      properties: {\n        exceptions: {\n          type: \"object\",\n          additionalProperties: {\n            type: \"boolean\"\n          }\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      unexpectedLineBeforeAndAfterComma: \"Bad line breaking before and after ','.\",\n      expectedCommaFirst: \"',' should be placed first.\",\n      expectedCommaLast: \"',' should be placed last.\"\n    }\n  },\n\n  create(context) {\n    const style = context.options[0] || \"last\",\n          sourceCode = context.getSourceCode();\n    const exceptions = {\n      ArrayPattern: true,\n      ArrowFunctionExpression: true,\n      CallExpression: true,\n      FunctionDeclaration: true,\n      FunctionExpression: true,\n      ImportDeclaration: true,\n      ObjectPattern: true,\n      NewExpression: true\n    };\n\n    if (context.options.length === 2 && Object.prototype.hasOwnProperty.call(context.options[1], \"exceptions\")) {\n      const keys = Object.keys(context.options[1].exceptions);\n\n      for (let i = 0; i < keys.length; i++) {\n        exceptions[keys[i]] = context.options[1].exceptions[keys[i]];\n      }\n    }\n\n    function getReplacedText(styleType, text) {\n      switch (styleType) {\n        case \"between\":\n          return `,${text.replace(astUtils.LINEBREAK_MATCHER, \"\")}`;\n\n        case \"first\":\n          return `${text},`;\n\n        case \"last\":\n          return `,${text}`;\n\n        default:\n          return \"\";\n      }\n    }\n\n    function getFixerFunction(styleType, previousItemToken, commaToken, currentItemToken) {\n      const text = sourceCode.text.slice(previousItemToken.range[1], commaToken.range[0]) + sourceCode.text.slice(commaToken.range[1], currentItemToken.range[0]);\n      const range = [previousItemToken.range[1], currentItemToken.range[0]];\n      return function (fixer) {\n        return fixer.replaceTextRange(range, getReplacedText(styleType, text));\n      };\n    }\n\n    function validateCommaItemSpacing(previousItemToken, commaToken, currentItemToken, reportItem) {\n      if (astUtils.isTokenOnSameLine(commaToken, currentItemToken) && astUtils.isTokenOnSameLine(previousItemToken, commaToken)) ;else if (!astUtils.isTokenOnSameLine(commaToken, currentItemToken) && !astUtils.isTokenOnSameLine(previousItemToken, commaToken)) {\n        const comment = sourceCode.getCommentsAfter(commaToken)[0];\n        const styleType = comment && comment.type === \"Block\" && astUtils.isTokenOnSameLine(commaToken, comment) ? style : \"between\";\n        context.report({\n          node: reportItem,\n          loc: commaToken.loc,\n          messageId: \"unexpectedLineBeforeAndAfterComma\",\n          fix: getFixerFunction(styleType, previousItemToken, commaToken, currentItemToken)\n        });\n      } else if (style === \"first\" && !astUtils.isTokenOnSameLine(commaToken, currentItemToken)) {\n        context.report({\n          node: reportItem,\n          loc: commaToken.loc,\n          messageId: \"expectedCommaFirst\",\n          fix: getFixerFunction(style, previousItemToken, commaToken, currentItemToken)\n        });\n      } else if (style === \"last\" && astUtils.isTokenOnSameLine(commaToken, currentItemToken)) {\n        context.report({\n          node: reportItem,\n          loc: commaToken.loc,\n          messageId: \"expectedCommaLast\",\n          fix: getFixerFunction(style, previousItemToken, commaToken, currentItemToken)\n        });\n      }\n    }\n\n    function validateComma(node, property) {\n      const items = node[property],\n            arrayLiteral = node.type === \"ArrayExpression\" || node.type === \"ArrayPattern\";\n\n      if (items.length > 1 || arrayLiteral) {\n        let previousItemToken = sourceCode.getFirstToken(node);\n        items.forEach(item => {\n          const commaToken = item ? sourceCode.getTokenBefore(item) : previousItemToken,\n                currentItemToken = item ? sourceCode.getFirstToken(item) : sourceCode.getTokenAfter(commaToken);\n\n          if (astUtils.isCommaToken(commaToken)) {\n            validateCommaItemSpacing(previousItemToken, commaToken, currentItemToken, item || currentItemToken);\n          }\n\n          if (item) {\n            const tokenAfterItem = sourceCode.getTokenAfter(item, astUtils.isNotClosingParenToken);\n            previousItemToken = tokenAfterItem ? sourceCode.getTokenBefore(tokenAfterItem) : sourceCode.ast.tokens[sourceCode.ast.tokens.length - 1];\n          } else {\n            previousItemToken = currentItemToken;\n          }\n        });\n\n        if (arrayLiteral) {\n          const lastToken = sourceCode.getLastToken(node),\n                nextToLastToken = sourceCode.getTokenBefore(lastToken);\n\n          if (astUtils.isCommaToken(nextToLastToken)) {\n            validateCommaItemSpacing(sourceCode.getTokenBefore(nextToLastToken), nextToLastToken, lastToken, lastToken);\n          }\n        }\n      }\n    }\n\n    const nodes = {};\n\n    if (!exceptions.VariableDeclaration) {\n      nodes.VariableDeclaration = function (node) {\n        validateComma(node, \"declarations\");\n      };\n    }\n\n    if (!exceptions.ObjectExpression) {\n      nodes.ObjectExpression = function (node) {\n        validateComma(node, \"properties\");\n      };\n    }\n\n    if (!exceptions.ObjectPattern) {\n      nodes.ObjectPattern = function (node) {\n        validateComma(node, \"properties\");\n      };\n    }\n\n    if (!exceptions.ArrayExpression) {\n      nodes.ArrayExpression = function (node) {\n        validateComma(node, \"elements\");\n      };\n    }\n\n    if (!exceptions.ArrayPattern) {\n      nodes.ArrayPattern = function (node) {\n        validateComma(node, \"elements\");\n      };\n    }\n\n    if (!exceptions.FunctionDeclaration) {\n      nodes.FunctionDeclaration = function (node) {\n        validateComma(node, \"params\");\n      };\n    }\n\n    if (!exceptions.FunctionExpression) {\n      nodes.FunctionExpression = function (node) {\n        validateComma(node, \"params\");\n      };\n    }\n\n    if (!exceptions.ArrowFunctionExpression) {\n      nodes.ArrowFunctionExpression = function (node) {\n        validateComma(node, \"params\");\n      };\n    }\n\n    if (!exceptions.CallExpression) {\n      nodes.CallExpression = function (node) {\n        validateComma(node, \"arguments\");\n      };\n    }\n\n    if (!exceptions.ImportDeclaration) {\n      nodes.ImportDeclaration = function (node) {\n        validateComma(node, \"specifiers\");\n      };\n    }\n\n    if (!exceptions.NewExpression) {\n      nodes.NewExpression = function (node) {\n        validateComma(node, \"arguments\");\n      };\n    }\n\n    return nodes;\n  }\n\n};\ncommaStyle.meta;\ncommaStyle.create;\n\nfunction upperCaseFirst$5(string) {\n  if (string.length <= 1) {\n    return string.toUpperCase();\n  }\n\n  return string[0].toUpperCase() + string.slice(1);\n}\n\nvar stringUtils = {\n  upperCaseFirst: upperCaseFirst$5\n};\nconst {\n  upperCaseFirst: upperCaseFirst$4\n} = stringUtils;\nvar complexity = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"enforce a maximum cyclomatic complexity allowed in a program\",\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/complexity\"\n    },\n    schema: [{\n      oneOf: [{\n        type: \"integer\",\n        minimum: 0\n      }, {\n        type: \"object\",\n        properties: {\n          maximum: {\n            type: \"integer\",\n            minimum: 0\n          },\n          max: {\n            type: \"integer\",\n            minimum: 0\n          }\n        },\n        additionalProperties: false\n      }]\n    }],\n    messages: {\n      complex: \"{{name}} has a complexity of {{complexity}}. Maximum allowed is {{max}}.\"\n    }\n  },\n\n  create(context) {\n    const option = context.options[0];\n    let THRESHOLD = 20;\n\n    if (typeof option === \"object\" && (Object.prototype.hasOwnProperty.call(option, \"maximum\") || Object.prototype.hasOwnProperty.call(option, \"max\"))) {\n      THRESHOLD = option.maximum || option.max;\n    } else if (typeof option === \"number\") {\n      THRESHOLD = option;\n    }\n\n    const fns = [];\n\n    function startFunction() {\n      fns.push(1);\n    }\n\n    function endFunction(node) {\n      const name = upperCaseFirst$4(astUtils.getFunctionNameWithKind(node));\n      const complexity = fns.pop();\n\n      if (complexity > THRESHOLD) {\n        context.report({\n          node,\n          messageId: \"complex\",\n          data: {\n            name,\n            complexity,\n            max: THRESHOLD\n          }\n        });\n      }\n    }\n\n    function increaseComplexity() {\n      if (fns.length) {\n        fns[fns.length - 1]++;\n      }\n    }\n\n    return {\n      FunctionDeclaration: startFunction,\n      FunctionExpression: startFunction,\n      ArrowFunctionExpression: startFunction,\n      \"FunctionDeclaration:exit\": endFunction,\n      \"FunctionExpression:exit\": endFunction,\n      \"ArrowFunctionExpression:exit\": endFunction,\n      CatchClause: increaseComplexity,\n      ConditionalExpression: increaseComplexity,\n      LogicalExpression: increaseComplexity,\n      ForStatement: increaseComplexity,\n      ForInStatement: increaseComplexity,\n      ForOfStatement: increaseComplexity,\n      IfStatement: increaseComplexity,\n      SwitchCase: function (node) {\n        if (node.test) {\n          increaseComplexity();\n        }\n      },\n      WhileStatement: increaseComplexity,\n      DoWhileStatement: increaseComplexity,\n\n      AssignmentExpression(node) {\n        if (astUtils.isLogicalAssignmentOperator(node.operator)) {\n          increaseComplexity();\n        }\n      }\n\n    };\n  }\n\n};\ncomplexity.meta;\ncomplexity.create;\nvar computedPropertySpacing = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"enforce consistent spacing inside computed property brackets\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/computed-property-spacing\"\n    },\n    fixable: \"whitespace\",\n    schema: [{\n      enum: [\"always\", \"never\"]\n    }, {\n      type: \"object\",\n      properties: {\n        enforceForClassMembers: {\n          type: \"boolean\",\n          default: true\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      unexpectedSpaceBefore: \"There should be no space before '{{tokenValue}}'.\",\n      unexpectedSpaceAfter: \"There should be no space after '{{tokenValue}}'.\",\n      missingSpaceBefore: \"A space is required before '{{tokenValue}}'.\",\n      missingSpaceAfter: \"A space is required after '{{tokenValue}}'.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    const propertyNameMustBeSpaced = context.options[0] === \"always\";\n    const enforceForClassMembers = !context.options[1] || context.options[1].enforceForClassMembers;\n\n    function reportNoBeginningSpace(node, token, tokenAfter) {\n      context.report({\n        node,\n        loc: {\n          start: token.loc.end,\n          end: tokenAfter.loc.start\n        },\n        messageId: \"unexpectedSpaceAfter\",\n        data: {\n          tokenValue: token.value\n        },\n\n        fix(fixer) {\n          return fixer.removeRange([token.range[1], tokenAfter.range[0]]);\n        }\n\n      });\n    }\n\n    function reportNoEndingSpace(node, token, tokenBefore) {\n      context.report({\n        node,\n        loc: {\n          start: tokenBefore.loc.end,\n          end: token.loc.start\n        },\n        messageId: \"unexpectedSpaceBefore\",\n        data: {\n          tokenValue: token.value\n        },\n\n        fix(fixer) {\n          return fixer.removeRange([tokenBefore.range[1], token.range[0]]);\n        }\n\n      });\n    }\n\n    function reportRequiredBeginningSpace(node, token) {\n      context.report({\n        node,\n        loc: token.loc,\n        messageId: \"missingSpaceAfter\",\n        data: {\n          tokenValue: token.value\n        },\n\n        fix(fixer) {\n          return fixer.insertTextAfter(token, \" \");\n        }\n\n      });\n    }\n\n    function reportRequiredEndingSpace(node, token) {\n      context.report({\n        node,\n        loc: token.loc,\n        messageId: \"missingSpaceBefore\",\n        data: {\n          tokenValue: token.value\n        },\n\n        fix(fixer) {\n          return fixer.insertTextBefore(token, \" \");\n        }\n\n      });\n    }\n\n    function checkSpacing(propertyName) {\n      return function (node) {\n        if (!node.computed) {\n          return;\n        }\n\n        const property = node[propertyName];\n        const before = sourceCode.getTokenBefore(property, astUtils.isOpeningBracketToken),\n              first = sourceCode.getTokenAfter(before, {\n          includeComments: true\n        }),\n              after = sourceCode.getTokenAfter(property, astUtils.isClosingBracketToken),\n              last = sourceCode.getTokenBefore(after, {\n          includeComments: true\n        });\n\n        if (astUtils.isTokenOnSameLine(before, first)) {\n          if (propertyNameMustBeSpaced) {\n            if (!sourceCode.isSpaceBetweenTokens(before, first) && astUtils.isTokenOnSameLine(before, first)) {\n              reportRequiredBeginningSpace(node, before);\n            }\n          } else {\n            if (sourceCode.isSpaceBetweenTokens(before, first)) {\n              reportNoBeginningSpace(node, before, first);\n            }\n          }\n        }\n\n        if (astUtils.isTokenOnSameLine(last, after)) {\n          if (propertyNameMustBeSpaced) {\n            if (!sourceCode.isSpaceBetweenTokens(last, after) && astUtils.isTokenOnSameLine(last, after)) {\n              reportRequiredEndingSpace(node, after);\n            }\n          } else {\n            if (sourceCode.isSpaceBetweenTokens(last, after)) {\n              reportNoEndingSpace(node, after, last);\n            }\n          }\n        }\n      };\n    }\n\n    const listeners = {\n      Property: checkSpacing(\"key\"),\n      MemberExpression: checkSpacing(\"property\")\n    };\n\n    if (enforceForClassMembers) {\n      listeners.MethodDefinition = checkSpacing(\"key\");\n    }\n\n    return listeners;\n  }\n\n};\ncomputedPropertySpacing.meta;\ncomputedPropertySpacing.create;\nconst {\n  upperCaseFirst: upperCaseFirst$3\n} = stringUtils;\n\nfunction isUnreachable$1(segment) {\n  return !segment.reachable;\n}\n\nfunction isClassConstructor(node) {\n  return node.type === \"FunctionExpression\" && node.parent && node.parent.type === \"MethodDefinition\" && node.parent.kind === \"constructor\";\n}\n\nvar consistentReturn = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"require `return` statements to either always or never specify values\",\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/consistent-return\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        treatUndefinedAsUnspecified: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      missingReturn: \"Expected to return a value at the end of {{name}}.\",\n      missingReturnValue: \"{{name}} expected a return value.\",\n      unexpectedReturnValue: \"{{name}} expected no return value.\"\n    }\n  },\n\n  create(context) {\n    const options = context.options[0] || {};\n    const treatUndefinedAsUnspecified = options.treatUndefinedAsUnspecified === true;\n    let funcInfo = null;\n\n    function checkLastSegment(node) {\n      let loc, name;\n\n      if (!funcInfo.hasReturnValue || funcInfo.codePath.currentSegments.every(isUnreachable$1) || astUtils.isES5Constructor(node) || isClassConstructor(node)) {\n        return;\n      }\n\n      if (node.type === \"Program\") {\n        loc = {\n          line: 1,\n          column: 0\n        };\n        name = \"program\";\n      } else if (node.type === \"ArrowFunctionExpression\") {\n        loc = context.getSourceCode().getTokenBefore(node.body, astUtils.isArrowToken).loc;\n      } else if (node.parent.type === \"MethodDefinition\" || node.parent.type === \"Property\" && node.parent.method) {\n        loc = node.parent.key.loc;\n      } else {\n        loc = (node.id || context.getSourceCode().getFirstToken(node)).loc;\n      }\n\n      if (!name) {\n        name = astUtils.getFunctionNameWithKind(node);\n      }\n\n      context.report({\n        node,\n        loc,\n        messageId: \"missingReturn\",\n        data: {\n          name\n        }\n      });\n    }\n\n    return {\n      onCodePathStart(codePath, node) {\n        funcInfo = {\n          upper: funcInfo,\n          codePath,\n          hasReturn: false,\n          hasReturnValue: false,\n          messageId: \"\",\n          node\n        };\n      },\n\n      onCodePathEnd() {\n        funcInfo = funcInfo.upper;\n      },\n\n      ReturnStatement(node) {\n        const argument = node.argument;\n        let hasReturnValue = Boolean(argument);\n\n        if (treatUndefinedAsUnspecified && hasReturnValue) {\n          hasReturnValue = !astUtils.isSpecificId(argument, \"undefined\") && argument.operator !== \"void\";\n        }\n\n        if (!funcInfo.hasReturn) {\n          funcInfo.hasReturn = true;\n          funcInfo.hasReturnValue = hasReturnValue;\n          funcInfo.messageId = hasReturnValue ? \"missingReturnValue\" : \"unexpectedReturnValue\";\n          funcInfo.data = {\n            name: funcInfo.node.type === \"Program\" ? \"Program\" : upperCaseFirst$3(astUtils.getFunctionNameWithKind(funcInfo.node))\n          };\n        } else if (funcInfo.hasReturnValue !== hasReturnValue) {\n          context.report({\n            node,\n            messageId: funcInfo.messageId,\n            data: funcInfo.data\n          });\n        }\n      },\n\n      \"Program:exit\": checkLastSegment,\n      \"FunctionDeclaration:exit\": checkLastSegment,\n      \"FunctionExpression:exit\": checkLastSegment,\n      \"ArrowFunctionExpression:exit\": checkLastSegment\n    };\n  }\n\n};\nconsistentReturn.meta;\nconsistentReturn.create;\nvar consistentThis = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"enforce consistent naming when capturing the current execution context\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/consistent-this\"\n    },\n    schema: {\n      type: \"array\",\n      items: {\n        type: \"string\",\n        minLength: 1\n      },\n      uniqueItems: true\n    },\n    messages: {\n      aliasNotAssignedToThis: \"Designated alias '{{name}}' is not assigned to 'this'.\",\n      unexpectedAlias: \"Unexpected alias '{{name}}' for 'this'.\"\n    }\n  },\n\n  create(context) {\n    let aliases = [];\n\n    if (context.options.length === 0) {\n      aliases.push(\"that\");\n    } else {\n      aliases = context.options;\n    }\n\n    function reportBadAssignment(node, name) {\n      context.report({\n        node,\n        messageId: \"aliasNotAssignedToThis\",\n        data: {\n          name\n        }\n      });\n    }\n\n    function checkAssignment(node, name, value) {\n      const isThis = value.type === \"ThisExpression\";\n\n      if (aliases.indexOf(name) !== -1) {\n        if (!isThis || node.operator && node.operator !== \"=\") {\n          reportBadAssignment(node, name);\n        }\n      } else if (isThis) {\n        context.report({\n          node,\n          messageId: \"unexpectedAlias\",\n          data: {\n            name\n          }\n        });\n      }\n    }\n\n    function checkWasAssigned(alias, scope) {\n      const variable = scope.set.get(alias);\n\n      if (!variable) {\n        return;\n      }\n\n      if (variable.defs.some(def => def.node.type === \"VariableDeclarator\" && def.node.init !== null)) {\n        return;\n      }\n\n      if (!variable.references.some(reference => {\n        const write = reference.writeExpr;\n        return reference.from === scope && write && write.type === \"ThisExpression\" && write.parent.operator === \"=\";\n      })) {\n        variable.defs.map(def => def.node).forEach(node => {\n          reportBadAssignment(node, alias);\n        });\n      }\n    }\n\n    function ensureWasAssigned() {\n      const scope = context.getScope();\n      aliases.forEach(alias => {\n        checkWasAssigned(alias, scope);\n      });\n    }\n\n    return {\n      \"Program:exit\": ensureWasAssigned,\n      \"FunctionExpression:exit\": ensureWasAssigned,\n      \"FunctionDeclaration:exit\": ensureWasAssigned,\n\n      VariableDeclarator(node) {\n        const id = node.id;\n        const isDestructuring = id.type === \"ArrayPattern\" || id.type === \"ObjectPattern\";\n\n        if (node.init !== null && !isDestructuring) {\n          checkAssignment(node, id.name, node.init);\n        }\n      },\n\n      AssignmentExpression(node) {\n        if (node.left.type === \"Identifier\") {\n          checkAssignment(node, node.left.name, node.right);\n        }\n      }\n\n    };\n  }\n\n};\nconsistentThis.meta;\nconsistentThis.create;\n\nfunction isReachable$2(segment) {\n  return segment.reachable;\n}\n\nfunction isConstructorFunction$1(node) {\n  return node.type === \"FunctionExpression\" && node.parent.type === \"MethodDefinition\" && node.parent.kind === \"constructor\";\n}\n\nfunction isPossibleConstructor(node) {\n  if (!node) {\n    return false;\n  }\n\n  switch (node.type) {\n    case \"ClassExpression\":\n    case \"FunctionExpression\":\n    case \"ThisExpression\":\n    case \"MemberExpression\":\n    case \"CallExpression\":\n    case \"NewExpression\":\n    case \"ChainExpression\":\n    case \"YieldExpression\":\n    case \"TaggedTemplateExpression\":\n    case \"MetaProperty\":\n      return true;\n\n    case \"Identifier\":\n      return node.name !== \"undefined\";\n\n    case \"AssignmentExpression\":\n      if ([\"=\", \"&&=\"].includes(node.operator)) {\n        return isPossibleConstructor(node.right);\n      }\n\n      if ([\"||=\", \"??=\"].includes(node.operator)) {\n        return isPossibleConstructor(node.left) || isPossibleConstructor(node.right);\n      }\n\n      return false;\n\n    case \"LogicalExpression\":\n      if (node.operator === \"&&\") {\n        return isPossibleConstructor(node.right);\n      }\n\n      return isPossibleConstructor(node.left) || isPossibleConstructor(node.right);\n\n    case \"ConditionalExpression\":\n      return isPossibleConstructor(node.alternate) || isPossibleConstructor(node.consequent);\n\n    case \"SequenceExpression\":\n      {\n        const lastExpression = node.expressions[node.expressions.length - 1];\n        return isPossibleConstructor(lastExpression);\n      }\n\n    default:\n      return false;\n  }\n}\n\nvar constructorSuper = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"require `super()` calls in constructors\",\n      category: \"ECMAScript 6\",\n      recommended: true,\n      url: \"https://eslint.org/docs/rules/constructor-super\"\n    },\n    schema: [],\n    messages: {\n      missingSome: \"Lacked a call of 'super()' in some code paths.\",\n      missingAll: \"Expected to call 'super()'.\",\n      duplicate: \"Unexpected duplicate 'super()'.\",\n      badSuper: \"Unexpected 'super()' because 'super' is not a constructor.\",\n      unexpected: \"Unexpected 'super()'.\"\n    }\n  },\n\n  create(context) {\n    let funcInfo = null;\n    let segInfoMap = Object.create(null);\n\n    function isCalledInSomePath(segment) {\n      return segment.reachable && segInfoMap[segment.id].calledInSomePaths;\n    }\n\n    function isCalledInEveryPath(segment) {\n      if (segment.nextSegments.length === 1 && segment.nextSegments[0].isLoopedPrevSegment(segment)) {\n        return true;\n      }\n\n      return segment.reachable && segInfoMap[segment.id].calledInEveryPaths;\n    }\n\n    return {\n      onCodePathStart(codePath, node) {\n        if (isConstructorFunction$1(node)) {\n          const classNode = node.parent.parent.parent;\n          const superClass = classNode.superClass;\n          funcInfo = {\n            upper: funcInfo,\n            isConstructor: true,\n            hasExtends: Boolean(superClass),\n            superIsConstructor: isPossibleConstructor(superClass),\n            codePath\n          };\n        } else {\n          funcInfo = {\n            upper: funcInfo,\n            isConstructor: false,\n            hasExtends: false,\n            superIsConstructor: false,\n            codePath\n          };\n        }\n      },\n\n      onCodePathEnd(codePath, node) {\n        const hasExtends = funcInfo.hasExtends;\n        funcInfo = funcInfo.upper;\n\n        if (!hasExtends) {\n          return;\n        }\n\n        const segments = codePath.returnedSegments;\n        const calledInEveryPaths = segments.every(isCalledInEveryPath);\n        const calledInSomePaths = segments.some(isCalledInSomePath);\n\n        if (!calledInEveryPaths) {\n          context.report({\n            messageId: calledInSomePaths ? \"missingSome\" : \"missingAll\",\n            node: node.parent\n          });\n        }\n      },\n\n      onCodePathSegmentStart(segment) {\n        if (!(funcInfo && funcInfo.isConstructor && funcInfo.hasExtends)) {\n          return;\n        }\n\n        const info = segInfoMap[segment.id] = {\n          calledInSomePaths: false,\n          calledInEveryPaths: false,\n          validNodes: []\n        };\n        const prevSegments = segment.prevSegments;\n\n        if (prevSegments.length > 0) {\n          info.calledInSomePaths = prevSegments.some(isCalledInSomePath);\n          info.calledInEveryPaths = prevSegments.every(isCalledInEveryPath);\n        }\n      },\n\n      onCodePathSegmentLoop(fromSegment, toSegment) {\n        if (!(funcInfo && funcInfo.isConstructor && funcInfo.hasExtends)) {\n          return;\n        }\n\n        const isRealLoop = toSegment.prevSegments.length >= 2;\n        funcInfo.codePath.traverseSegments({\n          first: toSegment,\n          last: fromSegment\n        }, segment => {\n          const info = segInfoMap[segment.id];\n          const prevSegments = segment.prevSegments;\n          info.calledInSomePaths = prevSegments.some(isCalledInSomePath);\n          info.calledInEveryPaths = prevSegments.every(isCalledInEveryPath);\n\n          if (info.calledInSomePaths || isRealLoop) {\n            const nodes = info.validNodes;\n            info.validNodes = [];\n\n            for (let i = 0; i < nodes.length; ++i) {\n              const node = nodes[i];\n              context.report({\n                messageId: \"duplicate\",\n                node\n              });\n            }\n          }\n        });\n      },\n\n      \"CallExpression:exit\"(node) {\n        if (!(funcInfo && funcInfo.isConstructor)) {\n          return;\n        }\n\n        if (node.callee.type !== \"Super\") {\n          return;\n        }\n\n        if (funcInfo.hasExtends) {\n          const segments = funcInfo.codePath.currentSegments;\n          let duplicate = false;\n          let info = null;\n\n          for (let i = 0; i < segments.length; ++i) {\n            const segment = segments[i];\n\n            if (segment.reachable) {\n              info = segInfoMap[segment.id];\n              duplicate = duplicate || info.calledInSomePaths;\n              info.calledInSomePaths = info.calledInEveryPaths = true;\n            }\n          }\n\n          if (info) {\n            if (duplicate) {\n              context.report({\n                messageId: \"duplicate\",\n                node\n              });\n            } else if (!funcInfo.superIsConstructor) {\n              context.report({\n                messageId: \"badSuper\",\n                node\n              });\n            } else {\n              info.validNodes.push(node);\n            }\n          }\n        } else if (funcInfo.codePath.currentSegments.some(isReachable$2)) {\n          context.report({\n            messageId: \"unexpected\",\n            node\n          });\n        }\n      },\n\n      ReturnStatement(node) {\n        if (!(funcInfo && funcInfo.isConstructor && funcInfo.hasExtends)) {\n          return;\n        }\n\n        if (!node.argument) {\n          return;\n        }\n\n        const segments = funcInfo.codePath.currentSegments;\n\n        for (let i = 0; i < segments.length; ++i) {\n          const segment = segments[i];\n\n          if (segment.reachable) {\n            const info = segInfoMap[segment.id];\n            info.calledInSomePaths = info.calledInEveryPaths = true;\n          }\n        }\n      },\n\n      \"Program:exit\"() {\n        segInfoMap = Object.create(null);\n      }\n\n    };\n  }\n\n};\nconstructorSuper.meta;\nconstructorSuper.create;\nvar curly = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"enforce consistent brace style for all control statements\",\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/curly\"\n    },\n    schema: {\n      anyOf: [{\n        type: \"array\",\n        items: [{\n          enum: [\"all\"]\n        }],\n        minItems: 0,\n        maxItems: 1\n      }, {\n        type: \"array\",\n        items: [{\n          enum: [\"multi\", \"multi-line\", \"multi-or-nest\"]\n        }, {\n          enum: [\"consistent\"]\n        }],\n        minItems: 0,\n        maxItems: 2\n      }]\n    },\n    fixable: \"code\",\n    messages: {\n      missingCurlyAfter: \"Expected { after '{{name}}'.\",\n      missingCurlyAfterCondition: \"Expected { after '{{name}}' condition.\",\n      unexpectedCurlyAfter: \"Unnecessary { after '{{name}}'.\",\n      unexpectedCurlyAfterCondition: \"Unnecessary { after '{{name}}' condition.\"\n    }\n  },\n\n  create(context) {\n    const multiOnly = context.options[0] === \"multi\";\n    const multiLine = context.options[0] === \"multi-line\";\n    const multiOrNest = context.options[0] === \"multi-or-nest\";\n    const consistent = context.options[1] === \"consistent\";\n    const sourceCode = context.getSourceCode();\n\n    function isCollapsedOneLiner(node) {\n      const before = sourceCode.getTokenBefore(node);\n      const last = sourceCode.getLastToken(node);\n      const lastExcludingSemicolon = astUtils.isSemicolonToken(last) ? sourceCode.getTokenBefore(last) : last;\n      return before.loc.start.line === lastExcludingSemicolon.loc.end.line;\n    }\n\n    function isOneLiner(node) {\n      if (node.type === \"EmptyStatement\") {\n        return true;\n      }\n\n      const first = sourceCode.getFirstToken(node);\n      const last = sourceCode.getLastToken(node);\n      const lastExcludingSemicolon = astUtils.isSemicolonToken(last) ? sourceCode.getTokenBefore(last) : last;\n      return first.loc.start.line === lastExcludingSemicolon.loc.end.line;\n    }\n\n    function isLexicalDeclaration(node) {\n      if (node.type === \"VariableDeclaration\") {\n        return node.kind === \"const\" || node.kind === \"let\";\n      }\n\n      return node.type === \"FunctionDeclaration\" || node.type === \"ClassDeclaration\";\n    }\n\n    function isElseKeywordToken(token) {\n      return token.value === \"else\" && token.type === \"Keyword\";\n    }\n\n    function isFollowedByElseKeyword(node) {\n      const nextToken = sourceCode.getTokenAfter(node);\n      return Boolean(nextToken) && isElseKeywordToken(nextToken);\n    }\n\n    function needsSemicolon(closingBracket) {\n      const tokenBefore = sourceCode.getTokenBefore(closingBracket);\n      const tokenAfter = sourceCode.getTokenAfter(closingBracket);\n      const lastBlockNode = sourceCode.getNodeByRangeIndex(tokenBefore.range[0]);\n\n      if (astUtils.isSemicolonToken(tokenBefore)) {\n        return false;\n      }\n\n      if (!tokenAfter) {\n        return false;\n      }\n\n      if (lastBlockNode.type === \"BlockStatement\" && lastBlockNode.parent.type !== \"FunctionExpression\" && lastBlockNode.parent.type !== \"ArrowFunctionExpression\") {\n        return false;\n      }\n\n      if (tokenBefore.loc.end.line === tokenAfter.loc.start.line) {\n        return true;\n      }\n\n      if (/^[([/`+-]/u.test(tokenAfter.value)) {\n        return true;\n      }\n\n      if (tokenBefore.type === \"Punctuator\" && (tokenBefore.value === \"++\" || tokenBefore.value === \"--\")) {\n        return true;\n      }\n\n      return false;\n    }\n\n    function hasUnsafeIf(node) {\n      switch (node.type) {\n        case \"IfStatement\":\n          if (!node.alternate) {\n            return true;\n          }\n\n          return hasUnsafeIf(node.alternate);\n\n        case \"ForStatement\":\n        case \"ForInStatement\":\n        case \"ForOfStatement\":\n        case \"LabeledStatement\":\n        case \"WithStatement\":\n        case \"WhileStatement\":\n          return hasUnsafeIf(node.body);\n\n        default:\n          return false;\n      }\n    }\n\n    function areBracesNecessary(node) {\n      const statement = node.body[0];\n      return isLexicalDeclaration(statement) || hasUnsafeIf(statement) && isFollowedByElseKeyword(node);\n    }\n\n    function prepareCheck(node, body, name, opts) {\n      const hasBlock = body.type === \"BlockStatement\";\n      let expected = null;\n\n      if (hasBlock && (body.body.length !== 1 || areBracesNecessary(body))) {\n        expected = true;\n      } else if (multiOnly) {\n        expected = false;\n      } else if (multiLine) {\n        if (!isCollapsedOneLiner(body)) {\n          expected = true;\n        }\n      } else if (multiOrNest) {\n        if (hasBlock) {\n          const statement = body.body[0];\n          const leadingCommentsInBlock = sourceCode.getCommentsBefore(statement);\n          expected = !isOneLiner(statement) || leadingCommentsInBlock.length > 0;\n        } else {\n          expected = !isOneLiner(body);\n        }\n      } else {\n        expected = true;\n      }\n\n      return {\n        actual: hasBlock,\n        expected,\n\n        check() {\n          if (this.expected !== null && this.expected !== this.actual) {\n            if (this.expected) {\n              context.report({\n                node,\n                loc: body.loc,\n                messageId: opts && opts.condition ? \"missingCurlyAfterCondition\" : \"missingCurlyAfter\",\n                data: {\n                  name\n                },\n                fix: fixer => fixer.replaceText(body, `{${sourceCode.getText(body)}}`)\n              });\n            } else {\n              context.report({\n                node,\n                loc: body.loc,\n                messageId: opts && opts.condition ? \"unexpectedCurlyAfterCondition\" : \"unexpectedCurlyAfter\",\n                data: {\n                  name\n                },\n\n                fix(fixer) {\n                  const needsPrecedingSpace = node.type === \"DoWhileStatement\" && sourceCode.getTokenBefore(body).range[1] === body.range[0] && !astUtils.canTokensBeAdjacent(\"do\", sourceCode.getFirstToken(body, {\n                    skip: 1\n                  }));\n                  const openingBracket = sourceCode.getFirstToken(body);\n                  const closingBracket = sourceCode.getLastToken(body);\n                  const lastTokenInBlock = sourceCode.getTokenBefore(closingBracket);\n\n                  if (needsSemicolon(closingBracket)) {\n                    return null;\n                  }\n\n                  const resultingBodyText = sourceCode.getText().slice(openingBracket.range[1], lastTokenInBlock.range[0]) + sourceCode.getText(lastTokenInBlock) + sourceCode.getText().slice(lastTokenInBlock.range[1], closingBracket.range[0]);\n                  return fixer.replaceText(body, (needsPrecedingSpace ? \" \" : \"\") + resultingBodyText);\n                }\n\n              });\n            }\n          }\n        }\n\n      };\n    }\n\n    function prepareIfChecks(node) {\n      const preparedChecks = [];\n\n      for (let currentNode = node; currentNode; currentNode = currentNode.alternate) {\n        preparedChecks.push(prepareCheck(currentNode, currentNode.consequent, \"if\", {\n          condition: true\n        }));\n\n        if (currentNode.alternate && currentNode.alternate.type !== \"IfStatement\") {\n          preparedChecks.push(prepareCheck(currentNode, currentNode.alternate, \"else\"));\n          break;\n        }\n      }\n\n      if (consistent) {\n        const expected = preparedChecks.some(preparedCheck => {\n          if (preparedCheck.expected !== null) {\n            return preparedCheck.expected;\n          }\n\n          return preparedCheck.actual;\n        });\n        preparedChecks.forEach(preparedCheck => {\n          preparedCheck.expected = expected;\n        });\n      }\n\n      return preparedChecks;\n    }\n\n    return {\n      IfStatement(node) {\n        const parent = node.parent;\n        const isElseIf = parent.type === \"IfStatement\" && parent.alternate === node;\n\n        if (!isElseIf) {\n          prepareIfChecks(node).forEach(preparedCheck => {\n            preparedCheck.check();\n          });\n        }\n      },\n\n      WhileStatement(node) {\n        prepareCheck(node, node.body, \"while\", {\n          condition: true\n        }).check();\n      },\n\n      DoWhileStatement(node) {\n        prepareCheck(node, node.body, \"do\").check();\n      },\n\n      ForStatement(node) {\n        prepareCheck(node, node.body, \"for\", {\n          condition: true\n        }).check();\n      },\n\n      ForInStatement(node) {\n        prepareCheck(node, node.body, \"for-in\").check();\n      },\n\n      ForOfStatement(node) {\n        prepareCheck(node, node.body, \"for-of\").check();\n      }\n\n    };\n  }\n\n};\ncurly.meta;\ncurly.create;\nvar defaultCaseLast = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"enforce default clauses in switch statements to be last\",\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/default-case-last\"\n    },\n    schema: [],\n    messages: {\n      notLast: \"Default clause should be the last clause.\"\n    }\n  },\n\n  create(context) {\n    return {\n      SwitchStatement(node) {\n        const cases = node.cases,\n              indexOfDefault = cases.findIndex(c => c.test === null);\n\n        if (indexOfDefault !== -1 && indexOfDefault !== cases.length - 1) {\n          const defaultClause = cases[indexOfDefault];\n          context.report({\n            node: defaultClause,\n            messageId: \"notLast\"\n          });\n        }\n      }\n\n    };\n  }\n\n};\ndefaultCaseLast.meta;\ndefaultCaseLast.create;\nconst DEFAULT_COMMENT_PATTERN = /^no default$/iu;\nvar defaultCase = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"require `default` cases in `switch` statements\",\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/default-case\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        commentPattern: {\n          type: \"string\"\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      missingDefaultCase: \"Expected a default case.\"\n    }\n  },\n\n  create(context) {\n    const options = context.options[0] || {};\n    const commentPattern = options.commentPattern ? new RegExp(options.commentPattern, \"u\") : DEFAULT_COMMENT_PATTERN;\n    const sourceCode = context.getSourceCode();\n\n    function last(collection) {\n      return collection[collection.length - 1];\n    }\n\n    return {\n      SwitchStatement(node) {\n        if (!node.cases.length) {\n          return;\n        }\n\n        const hasDefault = node.cases.some(v => v.test === null);\n\n        if (!hasDefault) {\n          let comment;\n          const lastCase = last(node.cases);\n          const comments = sourceCode.getCommentsAfter(lastCase);\n\n          if (comments.length) {\n            comment = last(comments);\n          }\n\n          if (!comment || !commentPattern.test(comment.value.trim())) {\n            context.report({\n              node,\n              messageId: \"missingDefaultCase\"\n            });\n          }\n        }\n      }\n\n    };\n  }\n\n};\ndefaultCase.meta;\ndefaultCase.create;\nvar defaultParamLast = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"enforce default parameters to be last\",\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/default-param-last\"\n    },\n    schema: [],\n    messages: {\n      shouldBeLast: \"Default parameters should be last.\"\n    }\n  },\n\n  create(context) {\n    function handleFunction(node) {\n      let hasSeenPlainParam = false;\n\n      for (let i = node.params.length - 1; i >= 0; i -= 1) {\n        const param = node.params[i];\n\n        if (param.type !== \"AssignmentPattern\" && param.type !== \"RestElement\") {\n          hasSeenPlainParam = true;\n          continue;\n        }\n\n        if (hasSeenPlainParam && param.type === \"AssignmentPattern\") {\n          context.report({\n            node: param,\n            messageId: \"shouldBeLast\"\n          });\n        }\n      }\n    }\n\n    return {\n      FunctionDeclaration: handleFunction,\n      FunctionExpression: handleFunction,\n      ArrowFunctionExpression: handleFunction\n    };\n  }\n\n};\ndefaultParamLast.meta;\ndefaultParamLast.create;\nvar dotLocation = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"enforce consistent newlines before and after dots\",\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/dot-location\"\n    },\n    schema: [{\n      enum: [\"object\", \"property\"]\n    }],\n    fixable: \"code\",\n    messages: {\n      expectedDotAfterObject: \"Expected dot to be on same line as object.\",\n      expectedDotBeforeProperty: \"Expected dot to be on same line as property.\"\n    }\n  },\n\n  create(context) {\n    const config = context.options[0];\n    const sourceCode = context.getSourceCode();\n\n    function checkDotLocation(node) {\n      const property = node.property;\n      const dotToken = sourceCode.getTokenBefore(property);\n\n      if (config === \"object\" || !config) {\n        const tokenBeforeDot = sourceCode.getTokenBefore(dotToken);\n\n        if (!astUtils.isTokenOnSameLine(tokenBeforeDot, dotToken)) {\n          context.report({\n            node,\n            loc: dotToken.loc,\n            messageId: \"expectedDotAfterObject\",\n\n            *fix(fixer) {\n              if (dotToken.value.startsWith(\".\") && astUtils.isDecimalIntegerNumericToken(tokenBeforeDot)) {\n                yield fixer.insertTextAfter(tokenBeforeDot, ` ${dotToken.value}`);\n              } else {\n                yield fixer.insertTextAfter(tokenBeforeDot, dotToken.value);\n              }\n\n              yield fixer.remove(dotToken);\n            }\n\n          });\n        }\n      } else if (!astUtils.isTokenOnSameLine(dotToken, property)) {\n        context.report({\n          node,\n          loc: dotToken.loc,\n          messageId: \"expectedDotBeforeProperty\",\n\n          *fix(fixer) {\n            yield fixer.remove(dotToken);\n            yield fixer.insertTextBefore(property, dotToken.value);\n          }\n\n        });\n      }\n    }\n\n    return {\n      MemberExpression: function (node) {\n        if (!node.computed) {\n          checkDotLocation(node);\n        }\n      }\n    };\n  }\n\n};\ndotLocation.meta;\ndotLocation.create;\nvar keywords = [\"abstract\", \"boolean\", \"break\", \"byte\", \"case\", \"catch\", \"char\", \"class\", \"const\", \"continue\", \"debugger\", \"default\", \"delete\", \"do\", \"double\", \"else\", \"enum\", \"export\", \"extends\", \"false\", \"final\", \"finally\", \"float\", \"for\", \"function\", \"goto\", \"if\", \"implements\", \"import\", \"in\", \"instanceof\", \"int\", \"interface\", \"long\", \"native\", \"new\", \"null\", \"package\", \"private\", \"protected\", \"public\", \"return\", \"short\", \"static\", \"super\", \"switch\", \"synchronized\", \"this\", \"throw\", \"throws\", \"transient\", \"true\", \"try\", \"typeof\", \"var\", \"void\", \"volatile\", \"while\", \"with\"];\nconst validIdentifier = /^[a-zA-Z_$][a-zA-Z0-9_$]*$/u;\nconst literalTypesToCheck = new Set([\"string\", \"boolean\"]);\nvar dotNotation = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"enforce dot notation whenever possible\",\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/dot-notation\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        allowKeywords: {\n          type: \"boolean\",\n          default: true\n        },\n        allowPattern: {\n          type: \"string\",\n          default: \"\"\n        }\n      },\n      additionalProperties: false\n    }],\n    fixable: \"code\",\n    messages: {\n      useDot: \"[{{key}}] is better written in dot notation.\",\n      useBrackets: \".{{key}} is a syntax error.\"\n    }\n  },\n\n  create(context) {\n    const options = context.options[0] || {};\n    const allowKeywords = options.allowKeywords === void 0 || options.allowKeywords;\n    const sourceCode = context.getSourceCode();\n    let allowPattern;\n\n    if (options.allowPattern) {\n      allowPattern = new RegExp(options.allowPattern, \"u\");\n    }\n\n    function checkComputedProperty(node, value) {\n      if (validIdentifier.test(value) && (allowKeywords || keywords.indexOf(String(value)) === -1) && !(allowPattern && allowPattern.test(value))) {\n        const formattedValue = node.property.type === \"Literal\" ? JSON.stringify(value) : `\\`${value}\\``;\n        context.report({\n          node: node.property,\n          messageId: \"useDot\",\n          data: {\n            key: formattedValue\n          },\n\n          *fix(fixer) {\n            const leftBracket = sourceCode.getTokenAfter(node.object, astUtils.isOpeningBracketToken);\n            const rightBracket = sourceCode.getLastToken(node);\n            const nextToken = sourceCode.getTokenAfter(node);\n\n            if (sourceCode.commentsExistBetween(leftBracket, rightBracket)) {\n              return;\n            }\n\n            if (!node.optional) {\n              yield fixer.insertTextBefore(leftBracket, astUtils.isDecimalInteger(node.object) ? \" .\" : \".\");\n            }\n\n            yield fixer.replaceTextRange([leftBracket.range[0], rightBracket.range[1]], value);\n\n            if (nextToken && rightBracket.range[1] === nextToken.range[0] && !astUtils.canTokensBeAdjacent(String(value), nextToken)) {\n              yield fixer.insertTextAfter(node, \" \");\n            }\n          }\n\n        });\n      }\n    }\n\n    return {\n      MemberExpression(node) {\n        if (node.computed && node.property.type === \"Literal\" && (literalTypesToCheck.has(typeof node.property.value) || astUtils.isNullLiteral(node.property))) {\n          checkComputedProperty(node, node.property.value);\n        }\n\n        if (node.computed && node.property.type === \"TemplateLiteral\" && node.property.expressions.length === 0) {\n          checkComputedProperty(node, node.property.quasis[0].value.cooked);\n        }\n\n        if (!allowKeywords && !node.computed && keywords.indexOf(String(node.property.name)) !== -1) {\n          context.report({\n            node: node.property,\n            messageId: \"useBrackets\",\n            data: {\n              key: node.property.name\n            },\n\n            *fix(fixer) {\n              const dotToken = sourceCode.getTokenBefore(node.property);\n\n              if (node.object.type === \"Identifier\" && node.object.name === \"let\" && !node.optional) {\n                return;\n              }\n\n              if (sourceCode.commentsExistBetween(dotToken, node.property)) {\n                return;\n              }\n\n              if (!node.optional) {\n                yield fixer.remove(dotToken);\n              }\n\n              yield fixer.replaceText(node.property, `[\"${node.property.name}\"]`);\n            }\n\n          });\n        }\n      }\n\n    };\n  }\n\n};\ndotNotation.meta;\ndotNotation.create;\nvar eolLast = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"require or disallow newline at the end of files\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/eol-last\"\n    },\n    fixable: \"whitespace\",\n    schema: [{\n      enum: [\"always\", \"never\", \"unix\", \"windows\"]\n    }],\n    messages: {\n      missing: \"Newline required at end of file but not found.\",\n      unexpected: \"Newline not allowed at end of file.\"\n    }\n  },\n\n  create(context) {\n    return {\n      Program: function (node) {\n        const sourceCode = context.getSourceCode(),\n              src = sourceCode.getText(),\n              lastLine = sourceCode.lines[sourceCode.lines.length - 1],\n              location = {\n          column: lastLine.length,\n          line: sourceCode.lines.length\n        },\n              endsWithNewline = src.endsWith(\"\\n\");\n\n        if (!src.length) {\n          return;\n        }\n\n        let mode = context.options[0] || \"always\",\n            appendCRLF = false;\n\n        if (mode === \"unix\") {\n          mode = \"always\";\n        }\n\n        if (mode === \"windows\") {\n          mode = \"always\";\n          appendCRLF = true;\n        }\n\n        if (mode === \"always\" && !endsWithNewline) {\n          context.report({\n            node,\n            loc: location,\n            messageId: \"missing\",\n\n            fix(fixer) {\n              return fixer.insertTextAfterRange([0, src.length], appendCRLF ? `\\r${\"\\n\"}` : \"\\n\");\n            }\n\n          });\n        } else if (mode === \"never\" && endsWithNewline) {\n          context.report({\n            node,\n            loc: location,\n            messageId: \"unexpected\",\n\n            fix(fixer) {\n              const match = /(?:\\r?\\n)+$/u.exec(sourceCode.text),\n                    start = match.index,\n                    end = sourceCode.text.length;\n              return fixer.replaceTextRange([start, end], \"\");\n            }\n\n          });\n        }\n      }\n    };\n  }\n\n};\neolLast.meta;\neolLast.create;\nvar eqeqeq = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"require the use of `===` and `!==`\",\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/eqeqeq\"\n    },\n    schema: {\n      anyOf: [{\n        type: \"array\",\n        items: [{\n          enum: [\"always\"]\n        }, {\n          type: \"object\",\n          properties: {\n            null: {\n              enum: [\"always\", \"never\", \"ignore\"]\n            }\n          },\n          additionalProperties: false\n        }],\n        additionalItems: false\n      }, {\n        type: \"array\",\n        items: [{\n          enum: [\"smart\", \"allow-null\"]\n        }],\n        additionalItems: false\n      }]\n    },\n    fixable: \"code\",\n    messages: {\n      unexpected: \"Expected '{{expectedOperator}}' and instead saw '{{actualOperator}}'.\"\n    }\n  },\n\n  create(context) {\n    const config = context.options[0] || \"always\";\n    const options = context.options[1] || {};\n    const sourceCode = context.getSourceCode();\n    const nullOption = config === \"always\" ? options.null || \"always\" : \"ignore\";\n\n    function isTypeOf(node) {\n      return node.type === \"UnaryExpression\" && node.operator === \"typeof\";\n    }\n\n    function isTypeOfBinary(node) {\n      return isTypeOf(node.left) || isTypeOf(node.right);\n    }\n\n    function areLiteralsAndSameType(node) {\n      return node.left.type === \"Literal\" && node.right.type === \"Literal\" && typeof node.left.value === typeof node.right.value;\n    }\n\n    function isNullCheck(node) {\n      return astUtils.isNullLiteral(node.right) || astUtils.isNullLiteral(node.left);\n    }\n\n    function report(node, expectedOperator) {\n      const operatorToken = sourceCode.getFirstTokenBetween(node.left, node.right, token => token.value === node.operator);\n      context.report({\n        node,\n        loc: operatorToken.loc,\n        messageId: \"unexpected\",\n        data: {\n          expectedOperator,\n          actualOperator: node.operator\n        },\n\n        fix(fixer) {\n          if (isTypeOfBinary(node) || areLiteralsAndSameType(node)) {\n            return fixer.replaceText(operatorToken, expectedOperator);\n          }\n\n          return null;\n        }\n\n      });\n    }\n\n    return {\n      BinaryExpression(node) {\n        const isNull = isNullCheck(node);\n\n        if (node.operator !== \"==\" && node.operator !== \"!=\") {\n          if (nullOption === \"never\" && isNull) {\n            report(node, node.operator.slice(0, -1));\n          }\n\n          return;\n        }\n\n        if (config === \"smart\" && (isTypeOfBinary(node) || areLiteralsAndSameType(node) || isNull)) {\n          return;\n        }\n\n        if (!(nullOption === \"always\") && isNull) {\n          return;\n        }\n\n        report(node, `${node.operator}=`);\n      }\n\n    };\n  }\n\n};\neqeqeq.meta;\neqeqeq.create;\nvar forDirection = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"enforce \\\"for\\\" loop update clause moving the counter in the right direction.\",\n      category: \"Possible Errors\",\n      recommended: true,\n      url: \"https://eslint.org/docs/rules/for-direction\"\n    },\n    fixable: null,\n    schema: [],\n    messages: {\n      incorrectDirection: \"The update clause in this loop moves the variable in the wrong direction.\"\n    }\n  },\n\n  create(context) {\n    function report(node) {\n      context.report({\n        node,\n        messageId: \"incorrectDirection\"\n      });\n    }\n\n    function getRightDirection(update, dir) {\n      if (update.right.type === \"UnaryExpression\") {\n        if (update.right.operator === \"-\") {\n          return -dir;\n        }\n      } else if (update.right.type === \"Identifier\") {\n        return 0;\n      }\n\n      return dir;\n    }\n\n    function getUpdateDirection(update, counter) {\n      if (update.argument.type === \"Identifier\" && update.argument.name === counter) {\n        if (update.operator === \"++\") {\n          return 1;\n        }\n\n        if (update.operator === \"--\") {\n          return -1;\n        }\n      }\n\n      return 0;\n    }\n\n    function getAssignmentDirection(update, counter) {\n      if (update.left.name === counter) {\n        if (update.operator === \"+=\") {\n          return getRightDirection(update, 1);\n        }\n\n        if (update.operator === \"-=\") {\n          return getRightDirection(update, -1);\n        }\n      }\n\n      return 0;\n    }\n\n    return {\n      ForStatement(node) {\n        if (node.test && node.test.type === \"BinaryExpression\" && node.test.left.type === \"Identifier\" && node.update) {\n          const counter = node.test.left.name;\n          const operator = node.test.operator;\n          const update = node.update;\n          let wrongDirection;\n\n          if (operator === \"<\" || operator === \"<=\") {\n            wrongDirection = -1;\n          } else if (operator === \">\" || operator === \">=\") {\n            wrongDirection = 1;\n          } else {\n            return;\n          }\n\n          if (update.type === \"UpdateExpression\") {\n            if (getUpdateDirection(update, counter) === wrongDirection) {\n              report(node);\n            }\n          } else if (update.type === \"AssignmentExpression\" && getAssignmentDirection(update, counter) === wrongDirection) {\n            report(node);\n          }\n        }\n      }\n\n    };\n  }\n\n};\nforDirection.meta;\nforDirection.create;\nvar funcCallSpacing = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"require or disallow spacing between function identifiers and their invocations\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/func-call-spacing\"\n    },\n    fixable: \"whitespace\",\n    schema: {\n      anyOf: [{\n        type: \"array\",\n        items: [{\n          enum: [\"never\"]\n        }],\n        minItems: 0,\n        maxItems: 1\n      }, {\n        type: \"array\",\n        items: [{\n          enum: [\"always\"]\n        }, {\n          type: \"object\",\n          properties: {\n            allowNewlines: {\n              type: \"boolean\"\n            }\n          },\n          additionalProperties: false\n        }],\n        minItems: 0,\n        maxItems: 2\n      }]\n    },\n    messages: {\n      unexpectedWhitespace: \"Unexpected whitespace between function name and paren.\",\n      unexpectedNewline: \"Unexpected newline between function name and paren.\",\n      missing: \"Missing space between function name and paren.\"\n    }\n  },\n\n  create(context) {\n    const never = context.options[0] !== \"always\";\n    const allowNewlines = !never && context.options[1] && context.options[1].allowNewlines;\n    const sourceCode = context.getSourceCode();\n    const text = sourceCode.getText();\n\n    function checkSpacing(node, leftToken, rightToken) {\n      const textBetweenTokens = text.slice(leftToken.range[1], rightToken.range[0]).replace(/\\/\\*.*?\\*\\//gu, \"\");\n      const hasWhitespace = /\\s/u.test(textBetweenTokens);\n      const hasNewline = hasWhitespace && astUtils.LINEBREAK_MATCHER.test(textBetweenTokens);\n\n      if (never && hasWhitespace) {\n        context.report({\n          node,\n          loc: {\n            start: leftToken.loc.end,\n            end: {\n              line: rightToken.loc.start.line,\n              column: rightToken.loc.start.column - 1\n            }\n          },\n          messageId: \"unexpectedWhitespace\",\n\n          fix(fixer) {\n            if (sourceCode.commentsExistBetween(leftToken, rightToken)) {\n              return null;\n            }\n\n            if (node.optional) {\n              return fixer.replaceTextRange([leftToken.range[1], rightToken.range[0]], \"?.\");\n            }\n\n            if (hasNewline) {\n              return null;\n            }\n\n            return fixer.removeRange([leftToken.range[1], rightToken.range[0]]);\n          }\n\n        });\n      } else if (!never && !hasWhitespace) {\n        context.report({\n          node,\n          loc: {\n            start: {\n              line: leftToken.loc.end.line,\n              column: leftToken.loc.end.column - 1\n            },\n            end: rightToken.loc.start\n          },\n          messageId: \"missing\",\n\n          fix(fixer) {\n            if (node.optional) {\n              return null;\n            }\n\n            return fixer.insertTextBefore(rightToken, \" \");\n          }\n\n        });\n      } else if (!never && !allowNewlines && hasNewline) {\n        context.report({\n          node,\n          loc: {\n            start: leftToken.loc.end,\n            end: rightToken.loc.start\n          },\n          messageId: \"unexpectedNewline\",\n\n          fix(fixer) {\n            if (!node.optional) {\n              return null;\n            }\n\n            if (sourceCode.commentsExistBetween(leftToken, rightToken)) {\n              return null;\n            }\n\n            const range = [leftToken.range[1], rightToken.range[0]];\n            const qdToken = sourceCode.getTokenAfter(leftToken);\n\n            if (qdToken.range[0] === leftToken.range[1]) {\n              return fixer.replaceTextRange(range, \"?. \");\n            }\n\n            if (qdToken.range[1] === rightToken.range[0]) {\n              return fixer.replaceTextRange(range, \" ?.\");\n            }\n\n            return fixer.replaceTextRange(range, \" ?. \");\n          }\n\n        });\n      }\n    }\n\n    return {\n      \"CallExpression, NewExpression\"(node) {\n        const lastToken = sourceCode.getLastToken(node);\n        const lastCalleeToken = sourceCode.getLastToken(node.callee);\n        const parenToken = sourceCode.getFirstTokenBetween(lastCalleeToken, lastToken, astUtils.isOpeningParenToken);\n        const prevToken = parenToken && sourceCode.getTokenBefore(parenToken, astUtils.isNotQuestionDotToken);\n\n        if (!(parenToken && parenToken.range[1] < node.range[1])) {\n          return;\n        }\n\n        checkSpacing(node, prevToken, parenToken);\n      },\n\n      ImportExpression(node) {\n        const leftToken = sourceCode.getFirstToken(node);\n        const rightToken = sourceCode.getTokenAfter(leftToken);\n        checkSpacing(node, leftToken, rightToken);\n      }\n\n    };\n  }\n\n};\nfuncCallSpacing.meta;\nfuncCallSpacing.create;\n\nfunction isModuleExports(pattern) {\n  if (pattern.type === \"MemberExpression\" && pattern.object.type === \"Identifier\" && pattern.object.name === \"module\") {\n    if (pattern.property.type === \"Identifier\" && pattern.property.name === \"exports\") {\n      return true;\n    }\n\n    if (pattern.property.type === \"Literal\" && pattern.property.value === \"exports\") {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction isIdentifier(name, ecmaVersion) {\n  if (ecmaVersion >= 6) {\n    return esutils__default['default'].keyword.isIdentifierES6(name);\n  }\n\n  return esutils__default['default'].keyword.isIdentifierES5(name);\n}\n\nconst alwaysOrNever = {\n  enum: [\"always\", \"never\"]\n};\nconst optionsObject = {\n  type: \"object\",\n  properties: {\n    considerPropertyDescriptor: {\n      type: \"boolean\"\n    },\n    includeCommonJSModuleExports: {\n      type: \"boolean\"\n    }\n  },\n  additionalProperties: false\n};\nvar funcNameMatching = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"require function names to match the name of the variable or property to which they are assigned\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/func-name-matching\"\n    },\n    schema: {\n      anyOf: [{\n        type: \"array\",\n        additionalItems: false,\n        items: [alwaysOrNever, optionsObject]\n      }, {\n        type: \"array\",\n        additionalItems: false,\n        items: [optionsObject]\n      }]\n    },\n    messages: {\n      matchProperty: \"Function name `{{funcName}}` should match property name `{{name}}`.\",\n      matchVariable: \"Function name `{{funcName}}` should match variable name `{{name}}`.\",\n      notMatchProperty: \"Function name `{{funcName}}` should not match property name `{{name}}`.\",\n      notMatchVariable: \"Function name `{{funcName}}` should not match variable name `{{name}}`.\"\n    }\n  },\n\n  create(context) {\n    const options = (typeof context.options[0] === \"object\" ? context.options[0] : context.options[1]) || {};\n    const nameMatches = typeof context.options[0] === \"string\" ? context.options[0] : \"always\";\n    const considerPropertyDescriptor = options.considerPropertyDescriptor;\n    const includeModuleExports = options.includeCommonJSModuleExports;\n    const ecmaVersion = context.parserOptions && context.parserOptions.ecmaVersion ? context.parserOptions.ecmaVersion : 5;\n\n    function isPropertyCall(objName, funcName, node) {\n      if (!node) {\n        return false;\n      }\n\n      return node.type === \"CallExpression\" && astUtils.isSpecificMemberAccess(node.callee, objName, funcName);\n    }\n\n    function shouldWarn(x, y) {\n      return nameMatches === \"always\" && x !== y || nameMatches === \"never\" && x === y;\n    }\n\n    function report(node, name, funcName, isProp) {\n      let messageId;\n\n      if (nameMatches === \"always\" && isProp) {\n        messageId = \"matchProperty\";\n      } else if (nameMatches === \"always\") {\n        messageId = \"matchVariable\";\n      } else if (isProp) {\n        messageId = \"notMatchProperty\";\n      } else {\n        messageId = \"notMatchVariable\";\n      }\n\n      context.report({\n        node,\n        messageId,\n        data: {\n          name,\n          funcName\n        }\n      });\n    }\n\n    function isStringLiteral(node) {\n      return node.type === \"Literal\" && typeof node.value === \"string\";\n    }\n\n    return {\n      VariableDeclarator(node) {\n        if (!node.init || node.init.type !== \"FunctionExpression\" || node.id.type !== \"Identifier\") {\n          return;\n        }\n\n        if (node.init.id && shouldWarn(node.id.name, node.init.id.name)) {\n          report(node, node.id.name, node.init.id.name, false);\n        }\n      },\n\n      AssignmentExpression(node) {\n        if (node.right.type !== \"FunctionExpression\" || node.left.computed && node.left.property.type !== \"Literal\" || !includeModuleExports && isModuleExports(node.left) || node.left.type !== \"Identifier\" && node.left.type !== \"MemberExpression\") {\n          return;\n        }\n\n        const isProp = node.left.type === \"MemberExpression\";\n        const name = isProp ? astUtils.getStaticPropertyName(node.left) : node.left.name;\n\n        if (node.right.id && isIdentifier(name) && shouldWarn(name, node.right.id.name)) {\n          report(node, name, node.right.id.name, isProp);\n        }\n      },\n\n      Property(node) {\n        if (node.value.type !== \"FunctionExpression\" || !node.value.id || node.computed && !isStringLiteral(node.key)) {\n          return;\n        }\n\n        if (node.key.type === \"Identifier\") {\n          const functionName = node.value.id.name;\n          let propertyName = node.key.name;\n\n          if (considerPropertyDescriptor && propertyName === \"value\") {\n            if (isPropertyCall(\"Object\", \"defineProperty\", node.parent.parent) || isPropertyCall(\"Reflect\", \"defineProperty\", node.parent.parent)) {\n              const property = node.parent.parent.arguments[1];\n\n              if (isStringLiteral(property) && shouldWarn(property.value, functionName)) {\n                report(node, property.value, functionName, true);\n              }\n            } else if (isPropertyCall(\"Object\", \"defineProperties\", node.parent.parent.parent.parent)) {\n              propertyName = node.parent.parent.key.name;\n\n              if (!node.parent.parent.computed && shouldWarn(propertyName, functionName)) {\n                report(node, propertyName, functionName, true);\n              }\n            } else if (isPropertyCall(\"Object\", \"create\", node.parent.parent.parent.parent)) {\n              propertyName = node.parent.parent.key.name;\n\n              if (!node.parent.parent.computed && shouldWarn(propertyName, functionName)) {\n                report(node, propertyName, functionName, true);\n              }\n            } else if (shouldWarn(propertyName, functionName)) {\n              report(node, propertyName, functionName, true);\n            }\n          } else if (shouldWarn(propertyName, functionName)) {\n            report(node, propertyName, functionName, true);\n          }\n\n          return;\n        }\n\n        if (isStringLiteral(node.key) && isIdentifier(node.key.value, ecmaVersion) && shouldWarn(node.key.value, node.value.id.name)) {\n          report(node, node.key.value, node.value.id.name, true);\n        }\n      }\n\n    };\n  }\n\n};\nfuncNameMatching.meta;\nfuncNameMatching.create;\n\nfunction isFunctionName$1(variable) {\n  return variable && variable.defs[0].type === \"FunctionName\";\n}\n\nvar funcNames = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"require or disallow named `function` expressions\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/func-names\"\n    },\n    schema: {\n      definitions: {\n        value: {\n          enum: [\"always\", \"as-needed\", \"never\"]\n        }\n      },\n      items: [{\n        $ref: \"#/definitions/value\"\n      }, {\n        type: \"object\",\n        properties: {\n          generators: {\n            $ref: \"#/definitions/value\"\n          }\n        },\n        additionalProperties: false\n      }]\n    },\n    messages: {\n      unnamed: \"Unexpected unnamed {{name}}.\",\n      named: \"Unexpected named {{name}}.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n\n    function getConfigForNode(node) {\n      if (node.generator && context.options.length > 1 && context.options[1].generators) {\n        return context.options[1].generators;\n      }\n\n      return context.options[0] || \"always\";\n    }\n\n    function isObjectOrClassMethod(node) {\n      const parent = node.parent;\n      return parent.type === \"MethodDefinition\" || parent.type === \"Property\" && (parent.method || parent.kind === \"get\" || parent.kind === \"set\");\n    }\n\n    function hasInferredName(node) {\n      const parent = node.parent;\n      return isObjectOrClassMethod(node) || parent.type === \"VariableDeclarator\" && parent.id.type === \"Identifier\" && parent.init === node || parent.type === \"Property\" && parent.value === node || parent.type === \"AssignmentExpression\" && parent.left.type === \"Identifier\" && parent.right === node || parent.type === \"AssignmentPattern\" && parent.left.type === \"Identifier\" && parent.right === node;\n    }\n\n    function reportUnexpectedUnnamedFunction(node) {\n      context.report({\n        node,\n        messageId: \"unnamed\",\n        loc: astUtils.getFunctionHeadLoc(node, sourceCode),\n        data: {\n          name: astUtils.getFunctionNameWithKind(node)\n        }\n      });\n    }\n\n    function reportUnexpectedNamedFunction(node) {\n      context.report({\n        node,\n        messageId: \"named\",\n        loc: astUtils.getFunctionHeadLoc(node, sourceCode),\n        data: {\n          name: astUtils.getFunctionNameWithKind(node)\n        }\n      });\n    }\n\n    function handleFunction(node) {\n      const nameVar = context.getDeclaredVariables(node)[0];\n\n      if (isFunctionName$1(nameVar) && nameVar.references.length > 0) {\n        return;\n      }\n\n      const hasName = Boolean(node.id && node.id.name);\n      const config = getConfigForNode(node);\n\n      if (config === \"never\") {\n        if (hasName && node.type !== \"FunctionDeclaration\") {\n          reportUnexpectedNamedFunction(node);\n        }\n      } else if (config === \"as-needed\") {\n        if (!hasName && !hasInferredName(node)) {\n          reportUnexpectedUnnamedFunction(node);\n        }\n      } else {\n        if (!hasName && !isObjectOrClassMethod(node)) {\n          reportUnexpectedUnnamedFunction(node);\n        }\n      }\n    }\n\n    return {\n      \"FunctionExpression:exit\": handleFunction,\n      \"ExportDefaultDeclaration > FunctionDeclaration\": handleFunction\n    };\n  }\n\n};\nfuncNames.meta;\nfuncNames.create;\nvar funcStyle = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"enforce the consistent use of either `function` declarations or expressions\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/func-style\"\n    },\n    schema: [{\n      enum: [\"declaration\", \"expression\"]\n    }, {\n      type: \"object\",\n      properties: {\n        allowArrowFunctions: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      expression: \"Expected a function expression.\",\n      declaration: \"Expected a function declaration.\"\n    }\n  },\n\n  create(context) {\n    const style = context.options[0],\n          allowArrowFunctions = context.options[1] && context.options[1].allowArrowFunctions,\n          enforceDeclarations = style === \"declaration\",\n          stack = [];\n    const nodesToCheck = {\n      FunctionDeclaration(node) {\n        stack.push(false);\n\n        if (!enforceDeclarations && node.parent.type !== \"ExportDefaultDeclaration\") {\n          context.report({\n            node,\n            messageId: \"expression\"\n          });\n        }\n      },\n\n      \"FunctionDeclaration:exit\"() {\n        stack.pop();\n      },\n\n      FunctionExpression(node) {\n        stack.push(false);\n\n        if (enforceDeclarations && node.parent.type === \"VariableDeclarator\") {\n          context.report({\n            node: node.parent,\n            messageId: \"declaration\"\n          });\n        }\n      },\n\n      \"FunctionExpression:exit\"() {\n        stack.pop();\n      },\n\n      ThisExpression() {\n        if (stack.length > 0) {\n          stack[stack.length - 1] = true;\n        }\n      }\n\n    };\n\n    if (!allowArrowFunctions) {\n      nodesToCheck.ArrowFunctionExpression = function () {\n        stack.push(false);\n      };\n\n      nodesToCheck[\"ArrowFunctionExpression:exit\"] = function (node) {\n        const hasThisExpr = stack.pop();\n\n        if (enforceDeclarations && !hasThisExpr && node.parent.type === \"VariableDeclarator\") {\n          context.report({\n            node: node.parent,\n            messageId: \"declaration\"\n          });\n        }\n      };\n    }\n\n    return nodesToCheck;\n  }\n\n};\nfuncStyle.meta;\nfuncStyle.create;\nvar functionCallArgumentNewline = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"enforce line breaks between arguments of a function call\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/function-call-argument-newline\"\n    },\n    fixable: \"whitespace\",\n    schema: [{\n      enum: [\"always\", \"never\", \"consistent\"]\n    }],\n    messages: {\n      unexpectedLineBreak: \"There should be no line break here.\",\n      missingLineBreak: \"There should be a line break after this argument.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    const checkers = {\n      unexpected: {\n        messageId: \"unexpectedLineBreak\",\n        check: (prevToken, currentToken) => prevToken.loc.end.line !== currentToken.loc.start.line,\n        createFix: (token, tokenBefore) => fixer => fixer.replaceTextRange([tokenBefore.range[1], token.range[0]], \" \")\n      },\n      missing: {\n        messageId: \"missingLineBreak\",\n        check: (prevToken, currentToken) => prevToken.loc.end.line === currentToken.loc.start.line,\n        createFix: (token, tokenBefore) => fixer => fixer.replaceTextRange([tokenBefore.range[1], token.range[0]], \"\\n\")\n      }\n    };\n\n    function checkArguments(node, checker) {\n      for (let i = 1; i < node.arguments.length; i++) {\n        const prevArgToken = sourceCode.getLastToken(node.arguments[i - 1]);\n        const currentArgToken = sourceCode.getFirstToken(node.arguments[i]);\n\n        if (checker.check(prevArgToken, currentArgToken)) {\n          const tokenBefore = sourceCode.getTokenBefore(currentArgToken, {\n            includeComments: true\n          });\n          const hasLineCommentBefore = tokenBefore.type === \"Line\";\n          context.report({\n            node,\n            loc: {\n              start: tokenBefore.loc.end,\n              end: currentArgToken.loc.start\n            },\n            messageId: checker.messageId,\n            fix: hasLineCommentBefore ? null : checker.createFix(currentArgToken, tokenBefore)\n          });\n        }\n      }\n    }\n\n    function check(node) {\n      if (node.arguments.length < 2) {\n        return;\n      }\n\n      const option = context.options[0] || \"always\";\n\n      if (option === \"never\") {\n        checkArguments(node, checkers.unexpected);\n      } else if (option === \"always\") {\n        checkArguments(node, checkers.missing);\n      } else if (option === \"consistent\") {\n        const firstArgToken = sourceCode.getLastToken(node.arguments[0]);\n        const secondArgToken = sourceCode.getFirstToken(node.arguments[1]);\n\n        if (firstArgToken.loc.end.line === secondArgToken.loc.start.line) {\n          checkArguments(node, checkers.unexpected);\n        } else {\n          checkArguments(node, checkers.missing);\n        }\n      }\n    }\n\n    return {\n      CallExpression: check,\n      NewExpression: check\n    };\n  }\n\n};\nfunctionCallArgumentNewline.meta;\nfunctionCallArgumentNewline.create;\nvar functionParenNewline = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"enforce consistent line breaks inside function parentheses\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/function-paren-newline\"\n    },\n    fixable: \"whitespace\",\n    schema: [{\n      oneOf: [{\n        enum: [\"always\", \"never\", \"consistent\", \"multiline\", \"multiline-arguments\"]\n      }, {\n        type: \"object\",\n        properties: {\n          minItems: {\n            type: \"integer\",\n            minimum: 0\n          }\n        },\n        additionalProperties: false\n      }]\n    }],\n    messages: {\n      expectedBefore: \"Expected newline before ')'.\",\n      expectedAfter: \"Expected newline after '('.\",\n      expectedBetween: \"Expected newline between arguments/params.\",\n      unexpectedBefore: \"Unexpected newline before ')'.\",\n      unexpectedAfter: \"Unexpected newline after '('.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    const rawOption = context.options[0] || \"multiline\";\n    const multilineArgumentsOption = rawOption === \"multiline-arguments\";\n    let minItems;\n\n    if (typeof rawOption === \"object\") {\n      minItems = rawOption.minItems;\n    } else if (rawOption === \"always\") {\n      minItems = 0;\n    } else if (rawOption === \"never\") {\n      minItems = Infinity;\n    } else {\n      minItems = null;\n    }\n\n    function shouldHaveNewlines(elements, hasLeftNewline) {\n      if (multilineArgumentsOption && elements.length === 1) {\n        return hasLeftNewline;\n      }\n\n      if (rawOption === \"multiline\" || multilineArgumentsOption) {\n        return elements.some((element, index) => index !== elements.length - 1 && element.loc.end.line !== elements[index + 1].loc.start.line);\n      }\n\n      if (rawOption === \"consistent\") {\n        return hasLeftNewline;\n      }\n\n      return elements.length >= minItems;\n    }\n\n    function validateParens(parens, elements) {\n      const leftParen = parens.leftParen;\n      const rightParen = parens.rightParen;\n      const tokenAfterLeftParen = sourceCode.getTokenAfter(leftParen);\n      const tokenBeforeRightParen = sourceCode.getTokenBefore(rightParen);\n      const hasLeftNewline = !astUtils.isTokenOnSameLine(leftParen, tokenAfterLeftParen);\n      const hasRightNewline = !astUtils.isTokenOnSameLine(tokenBeforeRightParen, rightParen);\n      const needsNewlines = shouldHaveNewlines(elements, hasLeftNewline);\n\n      if (hasLeftNewline && !needsNewlines) {\n        context.report({\n          node: leftParen,\n          messageId: \"unexpectedAfter\",\n\n          fix(fixer) {\n            return sourceCode.getText().slice(leftParen.range[1], tokenAfterLeftParen.range[0]).trim() ? null : fixer.removeRange([leftParen.range[1], tokenAfterLeftParen.range[0]]);\n          }\n\n        });\n      } else if (!hasLeftNewline && needsNewlines) {\n        context.report({\n          node: leftParen,\n          messageId: \"expectedAfter\",\n          fix: fixer => fixer.insertTextAfter(leftParen, \"\\n\")\n        });\n      }\n\n      if (hasRightNewline && !needsNewlines) {\n        context.report({\n          node: rightParen,\n          messageId: \"unexpectedBefore\",\n\n          fix(fixer) {\n            return sourceCode.getText().slice(tokenBeforeRightParen.range[1], rightParen.range[0]).trim() ? null : fixer.removeRange([tokenBeforeRightParen.range[1], rightParen.range[0]]);\n          }\n\n        });\n      } else if (!hasRightNewline && needsNewlines) {\n        context.report({\n          node: rightParen,\n          messageId: \"expectedBefore\",\n          fix: fixer => fixer.insertTextBefore(rightParen, \"\\n\")\n        });\n      }\n    }\n\n    function validateArguments(parens, elements) {\n      const leftParen = parens.leftParen;\n      const tokenAfterLeftParen = sourceCode.getTokenAfter(leftParen);\n      const hasLeftNewline = !astUtils.isTokenOnSameLine(leftParen, tokenAfterLeftParen);\n      const needsNewlines = shouldHaveNewlines(elements, hasLeftNewline);\n\n      for (let i = 0; i <= elements.length - 2; i++) {\n        const currentElement = elements[i];\n        const nextElement = elements[i + 1];\n        const hasNewLine = currentElement.loc.end.line !== nextElement.loc.start.line;\n\n        if (!hasNewLine && needsNewlines) {\n          context.report({\n            node: currentElement,\n            messageId: \"expectedBetween\",\n            fix: fixer => fixer.insertTextBefore(nextElement, \"\\n\")\n          });\n        }\n      }\n    }\n\n    function getParenTokens(node) {\n      switch (node.type) {\n        case \"NewExpression\":\n          if (!node.arguments.length && !(astUtils.isOpeningParenToken(sourceCode.getLastToken(node, {\n            skip: 1\n          })) && astUtils.isClosingParenToken(sourceCode.getLastToken(node)))) {\n            return null;\n          }\n\n        case \"CallExpression\":\n          return {\n            leftParen: sourceCode.getTokenAfter(node.callee, astUtils.isOpeningParenToken),\n            rightParen: sourceCode.getLastToken(node)\n          };\n\n        case \"FunctionDeclaration\":\n        case \"FunctionExpression\":\n          {\n            const leftParen = sourceCode.getFirstToken(node, astUtils.isOpeningParenToken);\n            const rightParen = node.params.length ? sourceCode.getTokenAfter(node.params[node.params.length - 1], astUtils.isClosingParenToken) : sourceCode.getTokenAfter(leftParen);\n            return {\n              leftParen,\n              rightParen\n            };\n          }\n\n        case \"ArrowFunctionExpression\":\n          {\n            const firstToken = sourceCode.getFirstToken(node, {\n              skip: node.async ? 1 : 0\n            });\n\n            if (!astUtils.isOpeningParenToken(firstToken)) {\n              return null;\n            }\n\n            return {\n              leftParen: firstToken,\n              rightParen: sourceCode.getTokenBefore(node.body, astUtils.isClosingParenToken)\n            };\n          }\n\n        case \"ImportExpression\":\n          {\n            const leftParen = sourceCode.getFirstToken(node, 1);\n            const rightParen = sourceCode.getLastToken(node);\n            return {\n              leftParen,\n              rightParen\n            };\n          }\n\n        default:\n          throw new TypeError(`unexpected node with type ${node.type}`);\n      }\n    }\n\n    return {\n      [[\"ArrowFunctionExpression\", \"CallExpression\", \"FunctionDeclaration\", \"FunctionExpression\", \"ImportExpression\", \"NewExpression\"]](node) {\n        const parens = getParenTokens(node);\n        let params;\n\n        if (node.type === \"ImportExpression\") {\n          params = [node.source];\n        } else if (astUtils.isFunction(node)) {\n          params = node.params;\n        } else {\n          params = node.arguments;\n        }\n\n        if (parens) {\n          validateParens(parens, params);\n\n          if (multilineArgumentsOption) {\n            validateArguments(parens, params);\n          }\n        }\n      }\n\n    };\n  }\n\n};\nfunctionParenNewline.meta;\nfunctionParenNewline.create;\nconst OVERRIDE_SCHEMA = {\n  oneOf: [{\n    enum: [\"before\", \"after\", \"both\", \"neither\"]\n  }, {\n    type: \"object\",\n    properties: {\n      before: {\n        type: \"boolean\"\n      },\n      after: {\n        type: \"boolean\"\n      }\n    },\n    additionalProperties: false\n  }]\n};\nvar generatorStarSpacing = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"enforce consistent spacing around `*` operators in generator functions\",\n      category: \"ECMAScript 6\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/generator-star-spacing\"\n    },\n    fixable: \"whitespace\",\n    schema: [{\n      oneOf: [{\n        enum: [\"before\", \"after\", \"both\", \"neither\"]\n      }, {\n        type: \"object\",\n        properties: {\n          before: {\n            type: \"boolean\"\n          },\n          after: {\n            type: \"boolean\"\n          },\n          named: OVERRIDE_SCHEMA,\n          anonymous: OVERRIDE_SCHEMA,\n          method: OVERRIDE_SCHEMA\n        },\n        additionalProperties: false\n      }]\n    }],\n    messages: {\n      missingBefore: \"Missing space before *.\",\n      missingAfter: \"Missing space after *.\",\n      unexpectedBefore: \"Unexpected space before *.\",\n      unexpectedAfter: \"Unexpected space after *.\"\n    }\n  },\n\n  create(context) {\n    const optionDefinitions = {\n      before: {\n        before: true,\n        after: false\n      },\n      after: {\n        before: false,\n        after: true\n      },\n      both: {\n        before: true,\n        after: true\n      },\n      neither: {\n        before: false,\n        after: false\n      }\n    };\n\n    function optionToDefinition(option, defaults) {\n      if (!option) {\n        return defaults;\n      }\n\n      return typeof option === \"string\" ? optionDefinitions[option] : Object.assign({}, defaults, option);\n    }\n\n    const modes = function (option) {\n      const defaults = optionToDefinition(option, optionDefinitions.before);\n      return {\n        named: optionToDefinition(option.named, defaults),\n        anonymous: optionToDefinition(option.anonymous, defaults),\n        method: optionToDefinition(option.method, defaults)\n      };\n    }(context.options[0] || {});\n\n    const sourceCode = context.getSourceCode();\n\n    function isStarToken(token) {\n      return token.value === \"*\" && token.type === \"Punctuator\";\n    }\n\n    function getStarToken(node) {\n      return sourceCode.getFirstToken(node.parent.method || node.parent.type === \"MethodDefinition\" ? node.parent : node, isStarToken);\n    }\n\n    function capitalize(str) {\n      return str[0].toUpperCase() + str.slice(1);\n    }\n\n    function checkSpacing(kind, side, leftToken, rightToken) {\n      if (!!(rightToken.range[0] - leftToken.range[1]) !== modes[kind][side]) {\n        const after = leftToken.value === \"*\";\n        const spaceRequired = modes[kind][side];\n        const node = after ? leftToken : rightToken;\n        const messageId = `${spaceRequired ? \"missing\" : \"unexpected\"}${capitalize(side)}`;\n        context.report({\n          node,\n          messageId,\n\n          fix(fixer) {\n            if (spaceRequired) {\n              if (after) {\n                return fixer.insertTextAfter(node, \" \");\n              }\n\n              return fixer.insertTextBefore(node, \" \");\n            }\n\n            return fixer.removeRange([leftToken.range[1], rightToken.range[0]]);\n          }\n\n        });\n      }\n    }\n\n    function checkFunction(node) {\n      if (!node.generator) {\n        return;\n      }\n\n      const starToken = getStarToken(node);\n      const prevToken = sourceCode.getTokenBefore(starToken);\n      const nextToken = sourceCode.getTokenAfter(starToken);\n      let kind = \"named\";\n\n      if (node.parent.type === \"MethodDefinition\" || node.parent.type === \"Property\" && node.parent.method) {\n        kind = \"method\";\n      } else if (!node.id) {\n        kind = \"anonymous\";\n      }\n\n      if (!(kind === \"method\" && starToken === sourceCode.getFirstToken(node.parent))) {\n        checkSpacing(kind, \"before\", prevToken, starToken);\n      }\n\n      checkSpacing(kind, \"after\", starToken, nextToken);\n    }\n\n    return {\n      FunctionDeclaration: checkFunction,\n      FunctionExpression: checkFunction\n    };\n  }\n\n};\ngeneratorStarSpacing.meta;\ngeneratorStarSpacing.create;\nconst TARGET_NODE_TYPE$1 = /^(?:Arrow)?FunctionExpression$/u;\n\nfunction isReachable$1(segment) {\n  return segment.reachable;\n}\n\nvar getterReturn = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"enforce `return` statements in getters\",\n      category: \"Possible Errors\",\n      recommended: true,\n      url: \"https://eslint.org/docs/rules/getter-return\"\n    },\n    fixable: null,\n    schema: [{\n      type: \"object\",\n      properties: {\n        allowImplicit: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      expected: \"Expected to return a value in {{name}}.\",\n      expectedAlways: \"Expected {{name}} to always return a value.\"\n    }\n  },\n\n  create(context) {\n    const options = context.options[0] || {\n      allowImplicit: false\n    };\n    const sourceCode = context.getSourceCode();\n    let funcInfo = {\n      upper: null,\n      codePath: null,\n      hasReturn: false,\n      shouldCheck: false,\n      node: null\n    };\n\n    function checkLastSegment(node) {\n      if (funcInfo.shouldCheck && funcInfo.codePath.currentSegments.some(isReachable$1)) {\n        context.report({\n          node,\n          loc: astUtils.getFunctionHeadLoc(node, sourceCode),\n          messageId: funcInfo.hasReturn ? \"expectedAlways\" : \"expected\",\n          data: {\n            name: astUtils.getFunctionNameWithKind(funcInfo.node)\n          }\n        });\n      }\n    }\n\n    function isGetter(node) {\n      const parent = node.parent;\n\n      if (TARGET_NODE_TYPE$1.test(node.type) && node.body.type === \"BlockStatement\") {\n        if (parent.kind === \"get\") {\n          return true;\n        }\n\n        if (parent.type === \"Property\" && astUtils.getStaticPropertyName(parent) === \"get\" && parent.parent.type === \"ObjectExpression\") {\n          if (parent.parent.parent.type === \"CallExpression\" && astUtils.getStaticPropertyName(parent.parent.parent.callee) === \"defineProperty\") {\n            return true;\n          }\n\n          if (parent.parent.parent.type === \"Property\" && parent.parent.parent.parent.type === \"ObjectExpression\" && parent.parent.parent.parent.parent.type === \"CallExpression\" && astUtils.getStaticPropertyName(parent.parent.parent.parent.parent.callee) === \"defineProperties\") {\n            return true;\n          }\n        }\n      }\n\n      return false;\n    }\n\n    return {\n      onCodePathStart(codePath, node) {\n        funcInfo = {\n          upper: funcInfo,\n          codePath,\n          hasReturn: false,\n          shouldCheck: isGetter(node),\n          node\n        };\n      },\n\n      onCodePathEnd() {\n        funcInfo = funcInfo.upper;\n      },\n\n      ReturnStatement(node) {\n        if (funcInfo.shouldCheck) {\n          funcInfo.hasReturn = true;\n\n          if (!options.allowImplicit && !node.argument) {\n            context.report({\n              node,\n              messageId: \"expected\",\n              data: {\n                name: astUtils.getFunctionNameWithKind(funcInfo.node)\n              }\n            });\n          }\n        }\n      },\n\n      \"FunctionExpression:exit\": checkLastSegment,\n      \"ArrowFunctionExpression:exit\": checkLastSegment\n    };\n  }\n\n};\ngetterReturn.meta;\ngetterReturn.create;\nconst ACCEPTABLE_PARENTS = [\"AssignmentExpression\", \"VariableDeclarator\", \"MemberExpression\", \"ExpressionStatement\", \"CallExpression\", \"ConditionalExpression\", \"Program\", \"VariableDeclaration\", \"ChainExpression\"];\n\nfunction findReference$1(scope, node) {\n  const references = scope.references.filter(reference => reference.identifier.range[0] === node.range[0] && reference.identifier.range[1] === node.range[1]);\n\n  if (references.length === 1) {\n    return references[0];\n  }\n\n  return null;\n}\n\nfunction isShadowed$2(scope, node) {\n  const reference = findReference$1(scope, node);\n  return reference && reference.resolved && reference.resolved.defs.length > 0;\n}\n\nvar globalRequire = {\n  meta: {\n    deprecated: true,\n    replacedBy: [],\n    type: \"suggestion\",\n    docs: {\n      description: \"require `require()` calls to be placed at top-level module scope\",\n      category: \"Node.js and CommonJS\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/global-require\"\n    },\n    schema: [],\n    messages: {\n      unexpected: \"Unexpected require().\"\n    }\n  },\n\n  create(context) {\n    return {\n      CallExpression(node) {\n        const currentScope = context.getScope();\n\n        if (node.callee.name === \"require\" && !isShadowed$2(currentScope, node.callee)) {\n          const isGoodRequire = context.getAncestors().every(parent => ACCEPTABLE_PARENTS.indexOf(parent.type) > -1);\n\n          if (!isGoodRequire) {\n            context.report({\n              node,\n              messageId: \"unexpected\"\n            });\n          }\n        }\n      }\n\n    };\n  }\n\n};\nglobalRequire.meta;\nglobalRequire.create;\n\nfunction areEqualTokenLists(left, right) {\n  if (left.length !== right.length) {\n    return false;\n  }\n\n  for (let i = 0; i < left.length; i++) {\n    const leftToken = left[i],\n          rightToken = right[i];\n\n    if (leftToken.type !== rightToken.type || leftToken.value !== rightToken.value) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction areEqualKeys(left, right) {\n  if (typeof left === \"string\" && typeof right === \"string\") {\n    return left === right;\n  }\n\n  if (Array.isArray(left) && Array.isArray(right)) {\n    return areEqualTokenLists(left, right);\n  }\n\n  return false;\n}\n\nfunction isAccessorKind(node) {\n  return node.kind === \"get\" || node.kind === \"set\";\n}\n\nvar groupedAccessorPairs = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"require grouped accessor pairs in object literals and classes\",\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/grouped-accessor-pairs\"\n    },\n    schema: [{\n      enum: [\"anyOrder\", \"getBeforeSet\", \"setBeforeGet\"]\n    }],\n    messages: {\n      notGrouped: \"Accessor pair {{ formerName }} and {{ latterName }} should be grouped.\",\n      invalidOrder: \"Expected {{ latterName }} to be before {{ formerName }}.\"\n    }\n  },\n\n  create(context) {\n    const order = context.options[0] || \"anyOrder\";\n    const sourceCode = context.getSourceCode();\n\n    function report(messageId, formerNode, latterNode) {\n      context.report({\n        node: latterNode,\n        messageId,\n        loc: astUtils.getFunctionHeadLoc(latterNode.value, sourceCode),\n        data: {\n          formerName: astUtils.getFunctionNameWithKind(formerNode.value),\n          latterName: astUtils.getFunctionNameWithKind(latterNode.value)\n        }\n      });\n    }\n\n    function createAccessorData(node) {\n      const name = astUtils.getStaticPropertyName(node);\n      const key = name !== null ? name : sourceCode.getTokens(node.key);\n      return {\n        key,\n        getters: node.kind === \"get\" ? [node] : [],\n        setters: node.kind === \"set\" ? [node] : []\n      };\n    }\n\n    function mergeAccessorData(accessors, accessorData) {\n      const equalKeyElement = accessors.find(a => areEqualKeys(a.key, accessorData.key));\n\n      if (equalKeyElement) {\n        equalKeyElement.getters.push(...accessorData.getters);\n        equalKeyElement.setters.push(...accessorData.setters);\n      } else {\n        accessors.push(accessorData);\n      }\n\n      return accessors;\n    }\n\n    function checkList(nodes, shouldCheck) {\n      const accessors = nodes.filter(shouldCheck).filter(isAccessorKind).map(createAccessorData).reduce(mergeAccessorData, []);\n\n      for (const {\n        getters,\n        setters\n      } of accessors) {\n        if (getters.length === 1 && setters.length === 1) {\n          const [getter] = getters,\n                [setter] = setters,\n                getterIndex = nodes.indexOf(getter),\n                setterIndex = nodes.indexOf(setter),\n                formerNode = getterIndex < setterIndex ? getter : setter,\n                latterNode = getterIndex < setterIndex ? setter : getter;\n\n          if (Math.abs(getterIndex - setterIndex) > 1) {\n            report(\"notGrouped\", formerNode, latterNode);\n          } else if (order === \"getBeforeSet\" && getterIndex > setterIndex || order === \"setBeforeGet\" && getterIndex < setterIndex) {\n            report(\"invalidOrder\", formerNode, latterNode);\n          }\n        }\n      }\n    }\n\n    return {\n      ObjectExpression(node) {\n        checkList(node.properties, n => n.type === \"Property\");\n      },\n\n      ClassBody(node) {\n        checkList(node.body, n => n.type === \"MethodDefinition\" && !n.static);\n        checkList(node.body, n => n.type === \"MethodDefinition\" && n.static);\n      }\n\n    };\n  }\n\n};\ngroupedAccessorPairs.meta;\ngroupedAccessorPairs.create;\nvar guardForIn = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"require `for-in` loops to include an `if` statement\",\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/guard-for-in\"\n    },\n    schema: [],\n    messages: {\n      wrap: \"The body of a for-in should be wrapped in an if statement to filter unwanted properties from the prototype.\"\n    }\n  },\n\n  create(context) {\n    return {\n      ForInStatement(node) {\n        const body = node.body;\n\n        if (body.type === \"EmptyStatement\") {\n          return;\n        }\n\n        if (body.type === \"IfStatement\") {\n          return;\n        }\n\n        if (body.type === \"BlockStatement\" && body.body.length === 0) {\n          return;\n        }\n\n        if (body.type === \"BlockStatement\" && body.body.length === 1 && body.body[0].type === \"IfStatement\") {\n          return;\n        }\n\n        if (body.type === \"BlockStatement\" && body.body.length >= 1 && body.body[0].type === \"IfStatement\") {\n          const i = body.body[0];\n\n          if (i.consequent.type === \"ContinueStatement\") {\n            return;\n          }\n\n          if (i.consequent.type === \"BlockStatement\" && i.consequent.body.length === 1 && i.consequent.body[0].type === \"ContinueStatement\") {\n            return;\n          }\n        }\n\n        context.report({\n          node,\n          messageId: \"wrap\"\n        });\n      }\n\n    };\n  }\n\n};\nguardForIn.meta;\nguardForIn.create;\nvar handleCallbackErr = {\n  meta: {\n    deprecated: true,\n    replacedBy: [],\n    type: \"suggestion\",\n    docs: {\n      description: \"require error handling in callbacks\",\n      category: \"Node.js and CommonJS\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/handle-callback-err\"\n    },\n    schema: [{\n      type: \"string\"\n    }],\n    messages: {\n      expected: \"Expected error to be handled.\"\n    }\n  },\n\n  create(context) {\n    const errorArgument = context.options[0] || \"err\";\n\n    function isPattern(stringToCheck) {\n      const firstChar = stringToCheck[0];\n      return firstChar === \"^\";\n    }\n\n    function matchesConfiguredErrorName(name) {\n      if (isPattern(errorArgument)) {\n        const regexp = new RegExp(errorArgument, \"u\");\n        return regexp.test(name);\n      }\n\n      return name === errorArgument;\n    }\n\n    function getParameters(scope) {\n      return scope.variables.filter(variable => variable.defs[0] && variable.defs[0].type === \"Parameter\");\n    }\n\n    function checkForError(node) {\n      const scope = context.getScope(),\n            parameters = getParameters(scope),\n            firstParameter = parameters[0];\n\n      if (firstParameter && matchesConfiguredErrorName(firstParameter.name)) {\n        if (firstParameter.references.length === 0) {\n          context.report({\n            node,\n            messageId: \"expected\"\n          });\n        }\n      }\n    }\n\n    return {\n      FunctionDeclaration: checkForError,\n      FunctionExpression: checkForError,\n      ArrowFunctionExpression: checkForError\n    };\n  }\n\n};\nhandleCallbackErr.meta;\nhandleCallbackErr.create;\n\nfunction isAssignmentTarget$1(node) {\n  const parent = node.parent;\n  return parent.type === \"AssignmentExpression\" && parent.left === node || parent.type === \"ArrayPattern\" || parent.type === \"RestElement\" || parent.type === \"Property\" && parent.value === node && parent.parent.type === \"ObjectPattern\" || parent.type === \"AssignmentPattern\" && parent.left === node;\n}\n\nfunction isRenamedImport$1(node) {\n  const parent = node.parent;\n  return parent.type === \"ImportSpecifier\" && parent.imported !== parent.local && parent.imported === node || parent.type === \"ExportSpecifier\" && parent.parent.source && parent.local !== parent.exported && parent.local === node;\n}\n\nfunction isRenamedInDestructuring$1(node) {\n  const parent = node.parent;\n  return !parent.computed && parent.type === \"Property\" && parent.parent.type === \"ObjectPattern\" && parent.value !== node && parent.key === node;\n}\n\nfunction isShorthandPropertyDefinition$1(node) {\n  const parent = node.parent;\n  return parent.type === \"Property\" && parent.parent.type === \"ObjectExpression\" && parent.shorthand;\n}\n\nvar idBlacklist = {\n  meta: {\n    deprecated: true,\n    replacedBy: [\"id-denylist\"],\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow specified identifiers\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/id-blacklist\"\n    },\n    schema: {\n      type: \"array\",\n      items: {\n        type: \"string\"\n      },\n      uniqueItems: true\n    },\n    messages: {\n      restricted: \"Identifier '{{name}}' is restricted.\"\n    }\n  },\n\n  create(context) {\n    const denyList = new Set(context.options);\n    const reportedNodes = new Set();\n    let globalScope;\n\n    function isRestricted(name) {\n      return denyList.has(name);\n    }\n\n    function isReferenceToGlobalVariable(node) {\n      const variable = globalScope.set.get(node.name);\n      return variable && variable.defs.length === 0 && variable.references.some(ref => ref.identifier === node);\n    }\n\n    function shouldCheck(node) {\n      const parent = node.parent;\n\n      if (parent.type === \"MemberExpression\" && parent.property === node && !parent.computed) {\n        return isAssignmentTarget$1(parent);\n      }\n\n      return parent.type !== \"CallExpression\" && parent.type !== \"NewExpression\" && !isRenamedImport$1(node) && !isRenamedInDestructuring$1(node) && !(isReferenceToGlobalVariable(node) && !isShorthandPropertyDefinition$1(node));\n    }\n\n    function report(node) {\n      if (!reportedNodes.has(node)) {\n        context.report({\n          node,\n          messageId: \"restricted\",\n          data: {\n            name: node.name\n          }\n        });\n        reportedNodes.add(node);\n      }\n    }\n\n    return {\n      Program() {\n        globalScope = context.getScope();\n      },\n\n      Identifier(node) {\n        if (isRestricted(node.name) && shouldCheck(node)) {\n          report(node);\n        }\n      }\n\n    };\n  }\n\n};\nidBlacklist.meta;\nidBlacklist.create;\n\nfunction isAssignmentTarget(node) {\n  const parent = node.parent;\n  return parent.type === \"AssignmentExpression\" && parent.left === node || parent.type === \"ArrayPattern\" || parent.type === \"RestElement\" || parent.type === \"Property\" && parent.value === node && parent.parent.type === \"ObjectPattern\" || parent.type === \"AssignmentPattern\" && parent.left === node;\n}\n\nfunction isRenamedImport(node) {\n  const parent = node.parent;\n  return parent.type === \"ImportSpecifier\" && parent.imported !== parent.local && parent.imported === node || parent.type === \"ExportSpecifier\" && parent.parent.source && parent.local !== parent.exported && parent.local === node;\n}\n\nfunction isRenamedInDestructuring(node) {\n  const parent = node.parent;\n  return !parent.computed && parent.type === \"Property\" && parent.parent.type === \"ObjectPattern\" && parent.value !== node && parent.key === node;\n}\n\nfunction isShorthandPropertyDefinition(node) {\n  const parent = node.parent;\n  return parent.type === \"Property\" && parent.parent.type === \"ObjectExpression\" && parent.shorthand;\n}\n\nvar idDenylist = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow specified identifiers\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/id-denylist\"\n    },\n    schema: {\n      type: \"array\",\n      items: {\n        type: \"string\"\n      },\n      uniqueItems: true\n    },\n    messages: {\n      restricted: \"Identifier '{{name}}' is restricted.\"\n    }\n  },\n\n  create(context) {\n    const denyList = new Set(context.options);\n    const reportedNodes = new Set();\n    let globalScope;\n\n    function isRestricted(name) {\n      return denyList.has(name);\n    }\n\n    function isReferenceToGlobalVariable(node) {\n      const variable = globalScope.set.get(node.name);\n      return variable && variable.defs.length === 0 && variable.references.some(ref => ref.identifier === node);\n    }\n\n    function shouldCheck(node) {\n      const parent = node.parent;\n\n      if (parent.type === \"MemberExpression\" && parent.property === node && !parent.computed) {\n        return isAssignmentTarget(parent);\n      }\n\n      return parent.type !== \"CallExpression\" && parent.type !== \"NewExpression\" && !isRenamedImport(node) && !isRenamedInDestructuring(node) && !(isReferenceToGlobalVariable(node) && !isShorthandPropertyDefinition(node));\n    }\n\n    function report(node) {\n      if (!reportedNodes.has(node)) {\n        context.report({\n          node,\n          messageId: \"restricted\",\n          data: {\n            name: node.name\n          }\n        });\n        reportedNodes.add(node);\n      }\n    }\n\n    return {\n      Program() {\n        globalScope = context.getScope();\n      },\n\n      Identifier(node) {\n        if (isRestricted(node.name) && shouldCheck(node)) {\n          report(node);\n        }\n      }\n\n    };\n  }\n\n};\nidDenylist.meta;\nidDenylist.create;\nvar idLength = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"enforce minimum and maximum identifier lengths\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/id-length\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        min: {\n          type: \"integer\",\n          default: 2\n        },\n        max: {\n          type: \"integer\"\n        },\n        exceptions: {\n          type: \"array\",\n          uniqueItems: true,\n          items: {\n            type: \"string\"\n          }\n        },\n        exceptionPatterns: {\n          type: \"array\",\n          uniqueItems: true,\n          items: {\n            type: \"string\"\n          }\n        },\n        properties: {\n          enum: [\"always\", \"never\"]\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      tooShort: \"Identifier name '{{name}}' is too short (< {{min}}).\",\n      tooLong: \"Identifier name '{{name}}' is too long (> {{max}}).\"\n    }\n  },\n\n  create(context) {\n    const options = context.options[0] || {};\n    const minLength = typeof options.min !== \"undefined\" ? options.min : 2;\n    const maxLength = typeof options.max !== \"undefined\" ? options.max : Infinity;\n    const properties = options.properties !== \"never\";\n    const exceptions = new Set(options.exceptions);\n    const exceptionPatterns = (options.exceptionPatterns || []).map(pattern => new RegExp(pattern, \"u\"));\n    const reportedNode = new Set();\n\n    function matchesExceptionPattern(name) {\n      return exceptionPatterns.some(pattern => pattern.test(name));\n    }\n\n    const SUPPORTED_EXPRESSIONS = {\n      MemberExpression: properties && function (parent) {\n        return !parent.computed && (parent.parent.left === parent && parent.parent.type === \"AssignmentExpression\" || parent.parent.type === \"Property\" && parent.parent.value === parent && parent.parent.parent.type === \"ObjectPattern\" && parent.parent.parent.parent.left === parent.parent.parent);\n      },\n\n      AssignmentPattern(parent, node) {\n        return parent.left === node;\n      },\n\n      VariableDeclarator(parent, node) {\n        return parent.id === node;\n      },\n\n      Property(parent, node) {\n        if (parent.parent.type === \"ObjectPattern\") {\n          return parent.value !== parent.key && parent.value === node || parent.value === parent.key && parent.key === node && properties;\n        }\n\n        return properties && !parent.computed && parent.key === node;\n      },\n\n      ImportDefaultSpecifier: true,\n      RestElement: true,\n      FunctionExpression: true,\n      ArrowFunctionExpression: true,\n      ClassDeclaration: true,\n      FunctionDeclaration: true,\n      MethodDefinition: true,\n      CatchClause: true,\n      ArrayPattern: true\n    };\n    return {\n      Identifier(node) {\n        const name = node.name;\n        const parent = node.parent;\n        const isShort = name.length < minLength;\n        const isLong = name.length > maxLength;\n\n        if (!(isShort || isLong) || exceptions.has(name) || matchesExceptionPattern(name)) {\n          return;\n        }\n\n        const isValidExpression = SUPPORTED_EXPRESSIONS[parent.type];\n\n        if (isValidExpression && !reportedNode.has(node) && (isValidExpression === true || isValidExpression(parent, node))) {\n          reportedNode.add(node);\n          context.report({\n            node,\n            messageId: isShort ? \"tooShort\" : \"tooLong\",\n            data: {\n              name,\n              min: minLength,\n              max: maxLength\n            }\n          });\n        }\n      }\n\n    };\n  }\n\n};\nidLength.meta;\nidLength.create;\nvar idMatch = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"require identifiers to match a specified regular expression\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/id-match\"\n    },\n    schema: [{\n      type: \"string\"\n    }, {\n      type: \"object\",\n      properties: {\n        properties: {\n          type: \"boolean\",\n          default: false\n        },\n        onlyDeclarations: {\n          type: \"boolean\",\n          default: false\n        },\n        ignoreDestructuring: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      notMatch: \"Identifier '{{name}}' does not match the pattern '{{pattern}}'.\"\n    }\n  },\n\n  create(context) {\n    const pattern = context.options[0] || \"^.+$\",\n          regexp = new RegExp(pattern, \"u\");\n    const options = context.options[1] || {},\n          properties = !!options.properties,\n          onlyDeclarations = !!options.onlyDeclarations,\n          ignoreDestructuring = !!options.ignoreDestructuring;\n    const reported = new Map();\n    const ALLOWED_PARENT_TYPES = new Set([\"CallExpression\", \"NewExpression\"]);\n    const DECLARATION_TYPES = new Set([\"FunctionDeclaration\", \"VariableDeclarator\"]);\n    const IMPORT_TYPES = new Set([\"ImportSpecifier\", \"ImportNamespaceSpecifier\", \"ImportDefaultSpecifier\"]);\n\n    function isInvalid(name) {\n      return !regexp.test(name);\n    }\n\n    function isInsideObjectPattern(node) {\n      let {\n        parent\n      } = node;\n\n      while (parent) {\n        if (parent.type === \"ObjectPattern\") {\n          return true;\n        }\n\n        parent = parent.parent;\n      }\n\n      return false;\n    }\n\n    function shouldReport(effectiveParent, name) {\n      return (!onlyDeclarations || DECLARATION_TYPES.has(effectiveParent.type)) && !ALLOWED_PARENT_TYPES.has(effectiveParent.type) && isInvalid(name);\n    }\n\n    function report(node) {\n      if (!reported.has(node)) {\n        context.report({\n          node,\n          messageId: \"notMatch\",\n          data: {\n            name: node.name,\n            pattern\n          }\n        });\n        reported.set(node, true);\n      }\n    }\n\n    return {\n      Identifier(node) {\n        const name = node.name,\n              parent = node.parent,\n              effectiveParent = parent.type === \"MemberExpression\" ? parent.parent : parent;\n\n        if (parent.type === \"MemberExpression\") {\n          if (!properties) {\n            return;\n          }\n\n          if (parent.object.type === \"Identifier\" && parent.object.name === name) {\n            if (isInvalid(name)) {\n              report(node);\n            }\n          } else if (effectiveParent.type === \"AssignmentExpression\" && effectiveParent.left.type === \"MemberExpression\" && effectiveParent.left.property.name === node.name) {\n            if (isInvalid(name)) {\n              report(node);\n            }\n          } else if (effectiveParent.type === \"AssignmentExpression\" && effectiveParent.right.type !== \"MemberExpression\") {\n            if (isInvalid(name)) {\n              report(node);\n            }\n          }\n        } else if (parent.type === \"Property\" || parent.type === \"AssignmentPattern\") {\n          if (parent.parent && parent.parent.type === \"ObjectPattern\") {\n            if (parent.shorthand && parent.value.left && isInvalid(name)) {\n              report(node);\n            }\n\n            const assignmentKeyEqualsValue = parent.key.name === parent.value.name;\n\n            if (!assignmentKeyEqualsValue && parent.key === node) {\n              return;\n            }\n\n            const valueIsInvalid = parent.value.name && isInvalid(name);\n\n            if (valueIsInvalid && !(assignmentKeyEqualsValue && ignoreDestructuring)) {\n              report(node);\n            }\n          }\n\n          if (!properties || ignoreDestructuring && isInsideObjectPattern(node)) {\n            return;\n          }\n\n          if (parent.right !== node && shouldReport(effectiveParent, name)) {\n            report(node);\n          }\n        } else if (IMPORT_TYPES.has(parent.type)) {\n          if (parent.local && parent.local.name === node.name && isInvalid(name)) {\n            report(node);\n          }\n        } else if (shouldReport(effectiveParent, name)) {\n          report(node);\n        }\n      }\n\n    };\n  }\n\n};\nidMatch.meta;\nidMatch.create;\nconst {\n  isCommentToken,\n  isNotOpeningParenToken\n} = astUtils;\nvar implicitArrowLinebreak = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"enforce the location of arrow function bodies\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/implicit-arrow-linebreak\"\n    },\n    fixable: \"whitespace\",\n    schema: [{\n      enum: [\"beside\", \"below\"]\n    }],\n    messages: {\n      expected: \"Expected a linebreak before this expression.\",\n      unexpected: \"Expected no linebreak before this expression.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    const option = context.options[0] || \"beside\";\n\n    function validateExpression(node) {\n      if (node.body.type === \"BlockStatement\") {\n        return;\n      }\n\n      const arrowToken = sourceCode.getTokenBefore(node.body, isNotOpeningParenToken);\n      const firstTokenOfBody = sourceCode.getTokenAfter(arrowToken);\n\n      if (arrowToken.loc.end.line === firstTokenOfBody.loc.start.line && option === \"below\") {\n        context.report({\n          node: firstTokenOfBody,\n          messageId: \"expected\",\n          fix: fixer => fixer.insertTextBefore(firstTokenOfBody, \"\\n\")\n        });\n      } else if (arrowToken.loc.end.line !== firstTokenOfBody.loc.start.line && option === \"beside\") {\n        context.report({\n          node: firstTokenOfBody,\n          messageId: \"unexpected\",\n\n          fix(fixer) {\n            if (sourceCode.getFirstTokenBetween(arrowToken, firstTokenOfBody, {\n              includeComments: true,\n              filter: isCommentToken\n            })) {\n              return null;\n            }\n\n            return fixer.replaceTextRange([arrowToken.range[1], firstTokenOfBody.range[0]], \" \");\n          }\n\n        });\n      }\n    }\n\n    return {\n      ArrowFunctionExpression: node => validateExpression(node)\n    };\n  }\n\n};\nimplicitArrowLinebreak.meta;\nimplicitArrowLinebreak.create;\nvar indentLegacy = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"enforce consistent indentation\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/indent-legacy\"\n    },\n    deprecated: true,\n    replacedBy: [\"indent\"],\n    fixable: \"whitespace\",\n    schema: [{\n      oneOf: [{\n        enum: [\"tab\"]\n      }, {\n        type: \"integer\",\n        minimum: 0\n      }]\n    }, {\n      type: \"object\",\n      properties: {\n        SwitchCase: {\n          type: \"integer\",\n          minimum: 0\n        },\n        VariableDeclarator: {\n          oneOf: [{\n            type: \"integer\",\n            minimum: 0\n          }, {\n            type: \"object\",\n            properties: {\n              var: {\n                type: \"integer\",\n                minimum: 0\n              },\n              let: {\n                type: \"integer\",\n                minimum: 0\n              },\n              const: {\n                type: \"integer\",\n                minimum: 0\n              }\n            }\n          }]\n        },\n        outerIIFEBody: {\n          type: \"integer\",\n          minimum: 0\n        },\n        MemberExpression: {\n          type: \"integer\",\n          minimum: 0\n        },\n        FunctionDeclaration: {\n          type: \"object\",\n          properties: {\n            parameters: {\n              oneOf: [{\n                type: \"integer\",\n                minimum: 0\n              }, {\n                enum: [\"first\"]\n              }]\n            },\n            body: {\n              type: \"integer\",\n              minimum: 0\n            }\n          }\n        },\n        FunctionExpression: {\n          type: \"object\",\n          properties: {\n            parameters: {\n              oneOf: [{\n                type: \"integer\",\n                minimum: 0\n              }, {\n                enum: [\"first\"]\n              }]\n            },\n            body: {\n              type: \"integer\",\n              minimum: 0\n            }\n          }\n        },\n        CallExpression: {\n          type: \"object\",\n          properties: {\n            parameters: {\n              oneOf: [{\n                type: \"integer\",\n                minimum: 0\n              }, {\n                enum: [\"first\"]\n              }]\n            }\n          }\n        },\n        ArrayExpression: {\n          oneOf: [{\n            type: \"integer\",\n            minimum: 0\n          }, {\n            enum: [\"first\"]\n          }]\n        },\n        ObjectExpression: {\n          oneOf: [{\n            type: \"integer\",\n            minimum: 0\n          }, {\n            enum: [\"first\"]\n          }]\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      expected: \"Expected indentation of {{expected}} but found {{actual}}.\"\n    }\n  },\n\n  create(context) {\n    const DEFAULT_PARAMETER_INDENT = null;\n    let indentType = \"space\";\n    let indentSize = 4;\n    const options = {\n      SwitchCase: 0,\n      VariableDeclarator: {\n        var: 1,\n        let: 1,\n        const: 1\n      },\n      outerIIFEBody: null,\n      FunctionDeclaration: {\n        parameters: DEFAULT_PARAMETER_INDENT,\n        body: 1\n      },\n      FunctionExpression: {\n        parameters: DEFAULT_PARAMETER_INDENT,\n        body: 1\n      },\n      CallExpression: {\n        arguments: DEFAULT_PARAMETER_INDENT\n      },\n      ArrayExpression: 1,\n      ObjectExpression: 1\n    };\n    const sourceCode = context.getSourceCode();\n\n    if (context.options.length) {\n      if (context.options[0] === \"tab\") {\n        indentSize = 1;\n        indentType = \"tab\";\n      } else if (typeof context.options[0] === \"number\") {\n        indentSize = context.options[0];\n        indentType = \"space\";\n      }\n\n      if (context.options[1]) {\n        const opts = context.options[1];\n        options.SwitchCase = opts.SwitchCase || 0;\n        const variableDeclaratorRules = opts.VariableDeclarator;\n\n        if (typeof variableDeclaratorRules === \"number\") {\n          options.VariableDeclarator = {\n            var: variableDeclaratorRules,\n            let: variableDeclaratorRules,\n            const: variableDeclaratorRules\n          };\n        } else if (typeof variableDeclaratorRules === \"object\") {\n          Object.assign(options.VariableDeclarator, variableDeclaratorRules);\n        }\n\n        if (typeof opts.outerIIFEBody === \"number\") {\n          options.outerIIFEBody = opts.outerIIFEBody;\n        }\n\n        if (typeof opts.MemberExpression === \"number\") {\n          options.MemberExpression = opts.MemberExpression;\n        }\n\n        if (typeof opts.FunctionDeclaration === \"object\") {\n          Object.assign(options.FunctionDeclaration, opts.FunctionDeclaration);\n        }\n\n        if (typeof opts.FunctionExpression === \"object\") {\n          Object.assign(options.FunctionExpression, opts.FunctionExpression);\n        }\n\n        if (typeof opts.CallExpression === \"object\") {\n          Object.assign(options.CallExpression, opts.CallExpression);\n        }\n\n        if (typeof opts.ArrayExpression === \"number\" || typeof opts.ArrayExpression === \"string\") {\n          options.ArrayExpression = opts.ArrayExpression;\n        }\n\n        if (typeof opts.ObjectExpression === \"number\" || typeof opts.ObjectExpression === \"string\") {\n          options.ObjectExpression = opts.ObjectExpression;\n        }\n      }\n    }\n\n    const caseIndentStore = {};\n\n    function createErrorMessageData(expectedAmount, actualSpaces, actualTabs) {\n      const expectedStatement = `${expectedAmount} ${indentType}${expectedAmount === 1 ? \"\" : \"s\"}`;\n      const foundSpacesWord = `space${actualSpaces === 1 ? \"\" : \"s\"}`;\n      const foundTabsWord = `tab${actualTabs === 1 ? \"\" : \"s\"}`;\n      let foundStatement;\n\n      if (actualSpaces > 0 && actualTabs > 0) {\n        foundStatement = `${actualSpaces} ${foundSpacesWord} and ${actualTabs} ${foundTabsWord}`;\n      } else if (actualSpaces > 0) {\n        foundStatement = indentType === \"space\" ? actualSpaces : `${actualSpaces} ${foundSpacesWord}`;\n      } else if (actualTabs > 0) {\n        foundStatement = indentType === \"tab\" ? actualTabs : `${actualTabs} ${foundTabsWord}`;\n      } else {\n        foundStatement = \"0\";\n      }\n\n      return {\n        expected: expectedStatement,\n        actual: foundStatement\n      };\n    }\n\n    function report(node, needed, gottenSpaces, gottenTabs, loc, isLastNodeCheck) {\n      if (gottenSpaces && gottenTabs) {\n        return;\n      }\n\n      const desiredIndent = (indentType === \"space\" ? \" \" : \"\\t\").repeat(needed);\n      const textRange = isLastNodeCheck ? [node.range[1] - node.loc.end.column, node.range[1] - node.loc.end.column + gottenSpaces + gottenTabs] : [node.range[0] - node.loc.start.column, node.range[0] - node.loc.start.column + gottenSpaces + gottenTabs];\n      context.report({\n        node,\n        loc,\n        messageId: \"expected\",\n        data: createErrorMessageData(needed, gottenSpaces, gottenTabs),\n        fix: fixer => fixer.replaceTextRange(textRange, desiredIndent)\n      });\n    }\n\n    function getNodeIndent(node, byLastLine) {\n      const token = byLastLine ? sourceCode.getLastToken(node) : sourceCode.getFirstToken(node);\n      const srcCharsBeforeNode = sourceCode.getText(token, token.loc.start.column).split(\"\");\n      const indentChars = srcCharsBeforeNode.slice(0, srcCharsBeforeNode.findIndex(char => char !== \" \" && char !== \"\\t\"));\n      const spaces = indentChars.filter(char => char === \" \").length;\n      const tabs = indentChars.filter(char => char === \"\\t\").length;\n      return {\n        space: spaces,\n        tab: tabs,\n        goodChar: indentType === \"space\" ? spaces : tabs,\n        badChar: indentType === \"space\" ? tabs : spaces\n      };\n    }\n\n    function isNodeFirstInLine(node, byEndLocation) {\n      const firstToken = byEndLocation === true ? sourceCode.getLastToken(node, 1) : sourceCode.getTokenBefore(node),\n            startLine = byEndLocation === true ? node.loc.end.line : node.loc.start.line,\n            endLine = firstToken ? firstToken.loc.end.line : -1;\n      return startLine !== endLine;\n    }\n\n    function checkNodeIndent(node, neededIndent) {\n      const actualIndent = getNodeIndent(node, false);\n\n      if (node.type !== \"ArrayExpression\" && node.type !== \"ObjectExpression\" && (actualIndent.goodChar !== neededIndent || actualIndent.badChar !== 0) && isNodeFirstInLine(node)) {\n        report(node, neededIndent, actualIndent.space, actualIndent.tab);\n      }\n\n      if (node.type === \"IfStatement\" && node.alternate) {\n        const elseToken = sourceCode.getTokenBefore(node.alternate);\n        checkNodeIndent(elseToken, neededIndent);\n\n        if (!isNodeFirstInLine(node.alternate)) {\n          checkNodeIndent(node.alternate, neededIndent);\n        }\n      }\n\n      if (node.type === \"TryStatement\" && node.handler) {\n        const catchToken = sourceCode.getFirstToken(node.handler);\n        checkNodeIndent(catchToken, neededIndent);\n      }\n\n      if (node.type === \"TryStatement\" && node.finalizer) {\n        const finallyToken = sourceCode.getTokenBefore(node.finalizer);\n        checkNodeIndent(finallyToken, neededIndent);\n      }\n\n      if (node.type === \"DoWhileStatement\") {\n        const whileToken = sourceCode.getTokenAfter(node.body);\n        checkNodeIndent(whileToken, neededIndent);\n      }\n    }\n\n    function checkNodesIndent(nodes, indent) {\n      nodes.forEach(node => checkNodeIndent(node, indent));\n    }\n\n    function checkLastNodeLineIndent(node, lastLineIndent) {\n      const lastToken = sourceCode.getLastToken(node);\n      const endIndent = getNodeIndent(lastToken, true);\n\n      if ((endIndent.goodChar !== lastLineIndent || endIndent.badChar !== 0) && isNodeFirstInLine(node, true)) {\n        report(node, lastLineIndent, endIndent.space, endIndent.tab, {\n          line: lastToken.loc.start.line,\n          column: lastToken.loc.start.column\n        }, true);\n      }\n    }\n\n    function checkLastReturnStatementLineIndent(node, firstLineIndent) {\n      const lastToken = sourceCode.getLastToken(node, astUtils.isClosingParenToken);\n      const textBeforeClosingParenthesis = sourceCode.getText(lastToken, lastToken.loc.start.column).slice(0, -1);\n\n      if (textBeforeClosingParenthesis.trim()) {\n        return;\n      }\n\n      const endIndent = getNodeIndent(lastToken, true);\n\n      if (endIndent.goodChar !== firstLineIndent) {\n        report(node, firstLineIndent, endIndent.space, endIndent.tab, {\n          line: lastToken.loc.start.line,\n          column: lastToken.loc.start.column\n        }, true);\n      }\n    }\n\n    function checkFirstNodeLineIndent(node, firstLineIndent) {\n      const startIndent = getNodeIndent(node, false);\n\n      if ((startIndent.goodChar !== firstLineIndent || startIndent.badChar !== 0) && isNodeFirstInLine(node)) {\n        report(node, firstLineIndent, startIndent.space, startIndent.tab, {\n          line: node.loc.start.line,\n          column: node.loc.start.column\n        });\n      }\n    }\n\n    function getParentNodeByType(node, type, stopAtList) {\n      let parent = node.parent;\n      const stopAtSet = new Set(stopAtList || [\"Program\"]);\n\n      while (parent.type !== type && !stopAtSet.has(parent.type) && parent.type !== \"Program\") {\n        parent = parent.parent;\n      }\n\n      return parent.type === type ? parent : null;\n    }\n\n    function getVariableDeclaratorNode(node) {\n      return getParentNodeByType(node, \"VariableDeclarator\");\n    }\n\n    function isNodeInVarOnTop(node, varNode) {\n      return varNode && varNode.parent.loc.start.line === node.loc.start.line && varNode.parent.declarations.length > 1;\n    }\n\n    function isArgBeforeCalleeNodeMultiline(node) {\n      const parent = node.parent;\n\n      if (parent.arguments.length >= 2 && parent.arguments[1] === node) {\n        return parent.arguments[0].loc.end.line > parent.arguments[0].loc.start.line;\n      }\n\n      return false;\n    }\n\n    function isOuterIIFE(node) {\n      const parent = node.parent;\n      let stmt = parent.parent;\n\n      if (parent.type !== \"CallExpression\" || parent.callee !== node) {\n        return false;\n      }\n\n      while (stmt.type === \"UnaryExpression\" && (stmt.operator === \"!\" || stmt.operator === \"~\" || stmt.operator === \"+\" || stmt.operator === \"-\") || stmt.type === \"AssignmentExpression\" || stmt.type === \"LogicalExpression\" || stmt.type === \"SequenceExpression\" || stmt.type === \"VariableDeclarator\") {\n        stmt = stmt.parent;\n      }\n\n      return (stmt.type === \"ExpressionStatement\" || stmt.type === \"VariableDeclaration\") && stmt.parent && stmt.parent.type === \"Program\";\n    }\n\n    function checkIndentInFunctionBlock(node) {\n      const calleeNode = node.parent;\n      let indent;\n\n      if (calleeNode.parent && (calleeNode.parent.type === \"Property\" || calleeNode.parent.type === \"ArrayExpression\")) {\n        indent = getNodeIndent(calleeNode, false).goodChar;\n      } else {\n        indent = getNodeIndent(calleeNode).goodChar;\n      }\n\n      if (calleeNode.parent.type === \"CallExpression\") {\n        const calleeParent = calleeNode.parent;\n\n        if (calleeNode.type !== \"FunctionExpression\" && calleeNode.type !== \"ArrowFunctionExpression\") {\n          if (calleeParent && calleeParent.loc.start.line < node.loc.start.line) {\n            indent = getNodeIndent(calleeParent).goodChar;\n          }\n        } else {\n          if (isArgBeforeCalleeNodeMultiline(calleeNode) && calleeParent.callee.loc.start.line === calleeParent.callee.loc.end.line && !isNodeFirstInLine(calleeNode)) {\n            indent = getNodeIndent(calleeParent).goodChar;\n          }\n        }\n      }\n\n      let functionOffset = indentSize;\n\n      if (options.outerIIFEBody !== null && isOuterIIFE(calleeNode)) {\n        functionOffset = options.outerIIFEBody * indentSize;\n      } else if (calleeNode.type === \"FunctionExpression\") {\n        functionOffset = options.FunctionExpression.body * indentSize;\n      } else if (calleeNode.type === \"FunctionDeclaration\") {\n        functionOffset = options.FunctionDeclaration.body * indentSize;\n      }\n\n      indent += functionOffset;\n      const parentVarNode = getVariableDeclaratorNode(node);\n\n      if (parentVarNode && isNodeInVarOnTop(node, parentVarNode)) {\n        indent += indentSize * options.VariableDeclarator[parentVarNode.parent.kind];\n      }\n\n      if (node.body.length > 0) {\n        checkNodesIndent(node.body, indent);\n      }\n\n      checkLastNodeLineIndent(node, indent - functionOffset);\n    }\n\n    function isSingleLineNode(node) {\n      const lastToken = sourceCode.getLastToken(node),\n            startLine = node.loc.start.line,\n            endLine = lastToken.loc.end.line;\n      return startLine === endLine;\n    }\n\n    function checkIndentInArrayOrObjectBlock(node) {\n      if (isSingleLineNode(node)) {\n        return;\n      }\n\n      let elements = node.type === \"ArrayExpression\" ? node.elements : node.properties;\n      elements = elements.filter(elem => elem !== null);\n      let nodeIndent;\n      let elementsIndent;\n      const parentVarNode = getVariableDeclaratorNode(node);\n\n      if (isNodeFirstInLine(node)) {\n        const parent = node.parent;\n        nodeIndent = getNodeIndent(parent).goodChar;\n\n        if (!parentVarNode || parentVarNode.loc.start.line !== node.loc.start.line) {\n          if (parent.type !== \"VariableDeclarator\" || parentVarNode === parentVarNode.parent.declarations[0]) {\n            if (parent.type === \"VariableDeclarator\" && parentVarNode.loc.start.line === parent.loc.start.line) {\n              nodeIndent += indentSize * options.VariableDeclarator[parentVarNode.parent.kind];\n            } else if (parent.type === \"ObjectExpression\" || parent.type === \"ArrayExpression\") {\n              const parentElements = node.parent.type === \"ObjectExpression\" ? node.parent.properties : node.parent.elements;\n              if (parentElements[0] && parentElements[0].loc.start.line === parent.loc.start.line && parentElements[0].loc.end.line !== parent.loc.start.line) ;else if (typeof options[parent.type] === \"number\") {\n                nodeIndent += options[parent.type] * indentSize;\n              } else {\n                nodeIndent = parentElements[0].loc.start.column;\n              }\n            } else if (parent.type === \"CallExpression\" || parent.type === \"NewExpression\") {\n              if (typeof options.CallExpression.arguments === \"number\") {\n                nodeIndent += options.CallExpression.arguments * indentSize;\n              } else if (options.CallExpression.arguments === \"first\") {\n                if (parent.arguments.indexOf(node) !== -1) {\n                  nodeIndent = parent.arguments[0].loc.start.column;\n                }\n              } else {\n                nodeIndent += indentSize;\n              }\n            } else if (parent.type === \"LogicalExpression\" || parent.type === \"ArrowFunctionExpression\") {\n              nodeIndent += indentSize;\n            }\n          }\n        }\n\n        checkFirstNodeLineIndent(node, nodeIndent);\n      } else {\n        nodeIndent = getNodeIndent(node).goodChar;\n      }\n\n      if (options[node.type] === \"first\") {\n        elementsIndent = elements.length ? elements[0].loc.start.column : 0;\n      } else {\n        elementsIndent = nodeIndent + indentSize * options[node.type];\n      }\n\n      if (isNodeInVarOnTop(node, parentVarNode)) {\n        elementsIndent += indentSize * options.VariableDeclarator[parentVarNode.parent.kind];\n      }\n\n      checkNodesIndent(elements, elementsIndent);\n\n      if (elements.length > 0) {\n        if (elements[elements.length - 1].loc.end.line === node.loc.end.line) {\n          return;\n        }\n      }\n\n      checkLastNodeLineIndent(node, nodeIndent + (isNodeInVarOnTop(node, parentVarNode) ? options.VariableDeclarator[parentVarNode.parent.kind] * indentSize : 0));\n    }\n\n    function isNodeBodyBlock(node) {\n      return node.type === \"BlockStatement\" || node.type === \"ClassBody\" || node.body && node.body.type === \"BlockStatement\" || node.consequent && node.consequent.type === \"BlockStatement\";\n    }\n\n    function blockIndentationCheck(node) {\n      if (isSingleLineNode(node)) {\n        return;\n      }\n\n      if (node.parent && (node.parent.type === \"FunctionExpression\" || node.parent.type === \"FunctionDeclaration\" || node.parent.type === \"ArrowFunctionExpression\")) {\n        checkIndentInFunctionBlock(node);\n        return;\n      }\n\n      let indent;\n      let nodesToCheck = [];\n\n      if (node.parent && [\"IfStatement\", \"WhileStatement\", \"ForStatement\", \"ForInStatement\", \"ForOfStatement\", \"DoWhileStatement\", \"ClassDeclaration\", \"TryStatement\"].indexOf(node.parent.type) !== -1 && isNodeBodyBlock(node)) {\n        indent = getNodeIndent(node.parent).goodChar;\n      } else if (node.parent && node.parent.type === \"CatchClause\") {\n        indent = getNodeIndent(node.parent.parent).goodChar;\n      } else {\n        indent = getNodeIndent(node).goodChar;\n      }\n\n      if (node.type === \"IfStatement\" && node.consequent.type !== \"BlockStatement\") {\n        nodesToCheck = [node.consequent];\n      } else if (Array.isArray(node.body)) {\n        nodesToCheck = node.body;\n      } else {\n        nodesToCheck = [node.body];\n      }\n\n      if (nodesToCheck.length > 0) {\n        checkNodesIndent(nodesToCheck, indent + indentSize);\n      }\n\n      if (node.type === \"BlockStatement\") {\n        checkLastNodeLineIndent(node, indent);\n      }\n    }\n\n    function filterOutSameLineVars(node) {\n      return node.declarations.reduce((finalCollection, elem) => {\n        const lastElem = finalCollection[finalCollection.length - 1];\n\n        if (elem.loc.start.line !== node.loc.start.line && !lastElem || lastElem && lastElem.loc.start.line !== elem.loc.start.line) {\n          finalCollection.push(elem);\n        }\n\n        return finalCollection;\n      }, []);\n    }\n\n    function checkIndentInVariableDeclarations(node) {\n      const elements = filterOutSameLineVars(node);\n      const nodeIndent = getNodeIndent(node).goodChar;\n      const lastElement = elements[elements.length - 1];\n      const elementsIndent = nodeIndent + indentSize * options.VariableDeclarator[node.kind];\n      checkNodesIndent(elements, elementsIndent);\n\n      if (sourceCode.getLastToken(node).loc.end.line <= lastElement.loc.end.line) {\n        return;\n      }\n\n      const tokenBeforeLastElement = sourceCode.getTokenBefore(lastElement);\n\n      if (tokenBeforeLastElement.value === \",\") {\n        checkLastNodeLineIndent(node, getNodeIndent(tokenBeforeLastElement).goodChar);\n      } else {\n        checkLastNodeLineIndent(node, elementsIndent - indentSize);\n      }\n    }\n\n    function blockLessNodes(node) {\n      if (node.body.type !== \"BlockStatement\") {\n        blockIndentationCheck(node);\n      }\n    }\n\n    function expectedCaseIndent(node, providedSwitchIndent) {\n      const switchNode = node.type === \"SwitchStatement\" ? node : node.parent;\n      const switchIndent = typeof providedSwitchIndent === \"undefined\" ? getNodeIndent(switchNode).goodChar : providedSwitchIndent;\n      let caseIndent;\n\n      if (caseIndentStore[switchNode.loc.start.line]) {\n        return caseIndentStore[switchNode.loc.start.line];\n      }\n\n      if (switchNode.cases.length > 0 && options.SwitchCase === 0) {\n        caseIndent = switchIndent;\n      } else {\n        caseIndent = switchIndent + indentSize * options.SwitchCase;\n      }\n\n      caseIndentStore[switchNode.loc.start.line] = caseIndent;\n      return caseIndent;\n    }\n\n    function isWrappedInParenthesis(node) {\n      const statementWithoutArgument = sourceCode.getText(node).replace(sourceCode.getText(node.argument), \"\");\n      return /^return\\s*?\\(\\s*?\\);*?/u.test(statementWithoutArgument);\n    }\n\n    return {\n      Program(node) {\n        if (node.body.length > 0) {\n          checkNodesIndent(node.body, getNodeIndent(node).goodChar);\n        }\n      },\n\n      ClassBody: blockIndentationCheck,\n      BlockStatement: blockIndentationCheck,\n      WhileStatement: blockLessNodes,\n      ForStatement: blockLessNodes,\n      ForInStatement: blockLessNodes,\n      ForOfStatement: blockLessNodes,\n      DoWhileStatement: blockLessNodes,\n\n      IfStatement(node) {\n        if (node.consequent.type !== \"BlockStatement\" && node.consequent.loc.start.line > node.loc.start.line) {\n          blockIndentationCheck(node);\n        }\n      },\n\n      VariableDeclaration(node) {\n        if (node.declarations[node.declarations.length - 1].loc.start.line > node.declarations[0].loc.start.line) {\n          checkIndentInVariableDeclarations(node);\n        }\n      },\n\n      ObjectExpression(node) {\n        checkIndentInArrayOrObjectBlock(node);\n      },\n\n      ArrayExpression(node) {\n        checkIndentInArrayOrObjectBlock(node);\n      },\n\n      MemberExpression(node) {\n        if (typeof options.MemberExpression === \"undefined\") {\n          return;\n        }\n\n        if (isSingleLineNode(node)) {\n          return;\n        }\n\n        if (getParentNodeByType(node, \"VariableDeclarator\", [\"FunctionExpression\", \"ArrowFunctionExpression\"])) {\n          return;\n        }\n\n        if (getParentNodeByType(node, \"AssignmentExpression\", [\"FunctionExpression\"])) {\n          return;\n        }\n\n        const propertyIndent = getNodeIndent(node).goodChar + indentSize * options.MemberExpression;\n        const checkNodes = [node.property];\n        const dot = sourceCode.getTokenBefore(node.property);\n\n        if (dot.type === \"Punctuator\" && dot.value === \".\") {\n          checkNodes.push(dot);\n        }\n\n        checkNodesIndent(checkNodes, propertyIndent);\n      },\n\n      SwitchStatement(node) {\n        const switchIndent = getNodeIndent(node).goodChar;\n        const caseIndent = expectedCaseIndent(node, switchIndent);\n        checkNodesIndent(node.cases, caseIndent);\n        checkLastNodeLineIndent(node, switchIndent);\n      },\n\n      SwitchCase(node) {\n        if (isSingleLineNode(node)) {\n          return;\n        }\n\n        const caseIndent = expectedCaseIndent(node);\n        checkNodesIndent(node.consequent, caseIndent + indentSize);\n      },\n\n      FunctionDeclaration(node) {\n        if (isSingleLineNode(node)) {\n          return;\n        }\n\n        if (options.FunctionDeclaration.parameters === \"first\" && node.params.length) {\n          checkNodesIndent(node.params.slice(1), node.params[0].loc.start.column);\n        } else if (options.FunctionDeclaration.parameters !== null) {\n          checkNodesIndent(node.params, getNodeIndent(node).goodChar + indentSize * options.FunctionDeclaration.parameters);\n        }\n      },\n\n      FunctionExpression(node) {\n        if (isSingleLineNode(node)) {\n          return;\n        }\n\n        if (options.FunctionExpression.parameters === \"first\" && node.params.length) {\n          checkNodesIndent(node.params.slice(1), node.params[0].loc.start.column);\n        } else if (options.FunctionExpression.parameters !== null) {\n          checkNodesIndent(node.params, getNodeIndent(node).goodChar + indentSize * options.FunctionExpression.parameters);\n        }\n      },\n\n      ReturnStatement(node) {\n        if (isSingleLineNode(node)) {\n          return;\n        }\n\n        const firstLineIndent = getNodeIndent(node).goodChar;\n\n        if (isWrappedInParenthesis(node)) {\n          checkLastReturnStatementLineIndent(node, firstLineIndent);\n        } else {\n          checkNodeIndent(node, firstLineIndent);\n        }\n      },\n\n      CallExpression(node) {\n        if (isSingleLineNode(node)) {\n          return;\n        }\n\n        if (options.CallExpression.arguments === \"first\" && node.arguments.length) {\n          checkNodesIndent(node.arguments.slice(1), node.arguments[0].loc.start.column);\n        } else if (options.CallExpression.arguments !== null) {\n          checkNodesIndent(node.arguments, getNodeIndent(node).goodChar + indentSize * options.CallExpression.arguments);\n        }\n      }\n\n    };\n  }\n\n};\nindentLegacy.meta;\nindentLegacy.create;\nconst KNOWN_NODES = new Set([\"AssignmentExpression\", \"AssignmentPattern\", \"ArrayExpression\", \"ArrayPattern\", \"ArrowFunctionExpression\", \"AwaitExpression\", \"BlockStatement\", \"BinaryExpression\", \"BreakStatement\", \"CallExpression\", \"CatchClause\", \"ChainExpression\", \"ClassBody\", \"ClassDeclaration\", \"ClassExpression\", \"ConditionalExpression\", \"ContinueStatement\", \"DoWhileStatement\", \"DebuggerStatement\", \"EmptyStatement\", \"ExperimentalRestProperty\", \"ExperimentalSpreadProperty\", \"ExpressionStatement\", \"ForStatement\", \"ForInStatement\", \"ForOfStatement\", \"FunctionDeclaration\", \"FunctionExpression\", \"Identifier\", \"IfStatement\", \"Literal\", \"LabeledStatement\", \"LogicalExpression\", \"MemberExpression\", \"MetaProperty\", \"MethodDefinition\", \"NewExpression\", \"ObjectExpression\", \"ObjectPattern\", \"Program\", \"Property\", \"RestElement\", \"ReturnStatement\", \"SequenceExpression\", \"SpreadElement\", \"Super\", \"SwitchCase\", \"SwitchStatement\", \"TaggedTemplateExpression\", \"TemplateElement\", \"TemplateLiteral\", \"ThisExpression\", \"ThrowStatement\", \"TryStatement\", \"UnaryExpression\", \"UpdateExpression\", \"VariableDeclaration\", \"VariableDeclarator\", \"WhileStatement\", \"WithStatement\", \"YieldExpression\", \"JSXFragment\", \"JSXOpeningFragment\", \"JSXClosingFragment\", \"JSXIdentifier\", \"JSXNamespacedName\", \"JSXMemberExpression\", \"JSXEmptyExpression\", \"JSXExpressionContainer\", \"JSXElement\", \"JSXClosingElement\", \"JSXOpeningElement\", \"JSXAttribute\", \"JSXSpreadAttribute\", \"JSXText\", \"ExportDefaultDeclaration\", \"ExportNamedDeclaration\", \"ExportAllDeclaration\", \"ExportSpecifier\", \"ImportDeclaration\", \"ImportSpecifier\", \"ImportDefaultSpecifier\", \"ImportNamespaceSpecifier\", \"ImportExpression\"]);\n\nclass BinarySearchTree {\n  constructor() {\n    this._rbTree = functionalRedBlackTree__default['default']();\n  }\n\n  insert(key, value) {\n    const iterator = this._rbTree.find(key);\n\n    if (iterator.valid) {\n      this._rbTree = iterator.update(value);\n    } else {\n      this._rbTree = this._rbTree.insert(key, value);\n    }\n  }\n\n  findLe(key) {\n    const iterator = this._rbTree.le(key);\n\n    return iterator && {\n      key: iterator.key,\n      value: iterator.value\n    };\n  }\n\n  deleteRange(start, end) {\n    if (start === end) {\n      return;\n    }\n\n    const iterator = this._rbTree.ge(start);\n\n    while (iterator.valid && iterator.key < end) {\n      this._rbTree = this._rbTree.remove(iterator.key);\n      iterator.next();\n    }\n  }\n\n}\n\nclass TokenInfo {\n  constructor(sourceCode) {\n    this.sourceCode = sourceCode;\n    this.firstTokensByLineNumber = sourceCode.tokensAndComments.reduce((map, token) => {\n      if (!map.has(token.loc.start.line)) {\n        map.set(token.loc.start.line, token);\n      }\n\n      if (!map.has(token.loc.end.line) && sourceCode.text.slice(token.range[1] - token.loc.end.column, token.range[1]).trim()) {\n        map.set(token.loc.end.line, token);\n      }\n\n      return map;\n    }, new Map());\n  }\n\n  getFirstTokenOfLine(token) {\n    return this.firstTokensByLineNumber.get(token.loc.start.line);\n  }\n\n  isFirstTokenOfLine(token) {\n    return this.getFirstTokenOfLine(token) === token;\n  }\n\n  getTokenIndent(token) {\n    return this.sourceCode.text.slice(token.range[0] - token.loc.start.column, token.range[0]);\n  }\n\n}\n\nclass OffsetStorage {\n  constructor(tokenInfo, indentSize, indentType) {\n    this._tokenInfo = tokenInfo;\n    this._indentSize = indentSize;\n    this._indentType = indentType;\n    this._tree = new BinarySearchTree();\n\n    this._tree.insert(0, {\n      offset: 0,\n      from: null,\n      force: false\n    });\n\n    this._lockedFirstTokens = new WeakMap();\n    this._desiredIndentCache = new WeakMap();\n    this._ignoredTokens = new WeakSet();\n  }\n\n  _getOffsetDescriptor(token) {\n    return this._tree.findLe(token.range[0]).value;\n  }\n\n  matchOffsetOf(baseToken, offsetToken) {\n    this._lockedFirstTokens.set(offsetToken, baseToken);\n  }\n\n  setDesiredOffset(token, fromToken, offset) {\n    return this.setDesiredOffsets(token.range, fromToken, offset);\n  }\n\n  setDesiredOffsets(range, fromToken, offset, force) {\n    const descriptorToInsert = {\n      offset,\n      from: fromToken,\n      force\n    };\n\n    const descriptorAfterRange = this._tree.findLe(range[1]).value;\n\n    const fromTokenIsInRange = fromToken && fromToken.range[0] >= range[0] && fromToken.range[1] <= range[1];\n\n    const fromTokenDescriptor = fromTokenIsInRange && this._getOffsetDescriptor(fromToken);\n\n    this._tree.deleteRange(range[0] + 1, range[1]);\n\n    this._tree.insert(range[0], descriptorToInsert);\n\n    if (fromTokenIsInRange) {\n      this._tree.insert(fromToken.range[0], fromTokenDescriptor);\n\n      this._tree.insert(fromToken.range[1], descriptorToInsert);\n    }\n\n    this._tree.insert(range[1], descriptorAfterRange);\n  }\n\n  getDesiredIndent(token) {\n    if (!this._desiredIndentCache.has(token)) {\n      if (this._ignoredTokens.has(token)) {\n        this._desiredIndentCache.set(token, this._tokenInfo.getTokenIndent(token));\n      } else if (this._lockedFirstTokens.has(token)) {\n        const firstToken = this._lockedFirstTokens.get(token);\n\n        this._desiredIndentCache.set(token, this.getDesiredIndent(this._tokenInfo.getFirstTokenOfLine(firstToken)) + this._indentType.repeat(firstToken.loc.start.column - this._tokenInfo.getFirstTokenOfLine(firstToken).loc.start.column));\n      } else {\n        const offsetInfo = this._getOffsetDescriptor(token);\n\n        const offset = offsetInfo.from && offsetInfo.from.loc.start.line === token.loc.start.line && !/^\\s*?\\n/u.test(token.value) && !offsetInfo.force ? 0 : offsetInfo.offset * this._indentSize;\n\n        this._desiredIndentCache.set(token, (offsetInfo.from ? this.getDesiredIndent(offsetInfo.from) : \"\") + this._indentType.repeat(offset));\n      }\n    }\n\n    return this._desiredIndentCache.get(token);\n  }\n\n  ignoreToken(token) {\n    if (this._tokenInfo.isFirstTokenOfLine(token)) {\n      this._ignoredTokens.add(token);\n    }\n  }\n\n  getFirstDependency(token) {\n    return this._getOffsetDescriptor(token).from;\n  }\n\n}\n\nconst ELEMENT_LIST_SCHEMA = {\n  oneOf: [{\n    type: \"integer\",\n    minimum: 0\n  }, {\n    enum: [\"first\", \"off\"]\n  }]\n};\nvar indent = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"enforce consistent indentation\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/indent\"\n    },\n    fixable: \"whitespace\",\n    schema: [{\n      oneOf: [{\n        enum: [\"tab\"]\n      }, {\n        type: \"integer\",\n        minimum: 0\n      }]\n    }, {\n      type: \"object\",\n      properties: {\n        SwitchCase: {\n          type: \"integer\",\n          minimum: 0,\n          default: 0\n        },\n        VariableDeclarator: {\n          oneOf: [ELEMENT_LIST_SCHEMA, {\n            type: \"object\",\n            properties: {\n              var: ELEMENT_LIST_SCHEMA,\n              let: ELEMENT_LIST_SCHEMA,\n              const: ELEMENT_LIST_SCHEMA\n            },\n            additionalProperties: false\n          }]\n        },\n        outerIIFEBody: {\n          oneOf: [{\n            type: \"integer\",\n            minimum: 0\n          }, {\n            enum: [\"off\"]\n          }]\n        },\n        MemberExpression: {\n          oneOf: [{\n            type: \"integer\",\n            minimum: 0\n          }, {\n            enum: [\"off\"]\n          }]\n        },\n        FunctionDeclaration: {\n          type: \"object\",\n          properties: {\n            parameters: ELEMENT_LIST_SCHEMA,\n            body: {\n              type: \"integer\",\n              minimum: 0\n            }\n          },\n          additionalProperties: false\n        },\n        FunctionExpression: {\n          type: \"object\",\n          properties: {\n            parameters: ELEMENT_LIST_SCHEMA,\n            body: {\n              type: \"integer\",\n              minimum: 0\n            }\n          },\n          additionalProperties: false\n        },\n        CallExpression: {\n          type: \"object\",\n          properties: {\n            arguments: ELEMENT_LIST_SCHEMA\n          },\n          additionalProperties: false\n        },\n        ArrayExpression: ELEMENT_LIST_SCHEMA,\n        ObjectExpression: ELEMENT_LIST_SCHEMA,\n        ImportDeclaration: ELEMENT_LIST_SCHEMA,\n        flatTernaryExpressions: {\n          type: \"boolean\",\n          default: false\n        },\n        offsetTernaryExpressions: {\n          type: \"boolean\",\n          default: false\n        },\n        ignoredNodes: {\n          type: \"array\",\n          items: {\n            type: \"string\",\n            not: {\n              pattern: \":exit$\"\n            }\n          }\n        },\n        ignoreComments: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      wrongIndentation: \"Expected indentation of {{expected}} but found {{actual}}.\"\n    }\n  },\n\n  create(context) {\n    const DEFAULT_VARIABLE_INDENT = 1;\n    let indentType = \"space\";\n    let indentSize = 4;\n    const options = {\n      SwitchCase: 0,\n      VariableDeclarator: {\n        var: 1,\n        let: 1,\n        const: 1\n      },\n      outerIIFEBody: 1,\n      FunctionDeclaration: {\n        parameters: 1,\n        body: 1\n      },\n      FunctionExpression: {\n        parameters: 1,\n        body: 1\n      },\n      CallExpression: {\n        arguments: 1\n      },\n      MemberExpression: 1,\n      ArrayExpression: 1,\n      ObjectExpression: 1,\n      ImportDeclaration: 1,\n      flatTernaryExpressions: false,\n      ignoredNodes: [],\n      ignoreComments: false\n    };\n\n    if (context.options.length) {\n      if (context.options[0] === \"tab\") {\n        indentSize = 1;\n        indentType = \"tab\";\n      } else {\n        indentSize = context.options[0];\n        indentType = \"space\";\n      }\n\n      if (context.options[1]) {\n        Object.assign(options, context.options[1]);\n\n        if (typeof options.VariableDeclarator === \"number\" || options.VariableDeclarator === \"first\") {\n          options.VariableDeclarator = {\n            var: options.VariableDeclarator,\n            let: options.VariableDeclarator,\n            const: options.VariableDeclarator\n          };\n        }\n      }\n    }\n\n    const sourceCode = context.getSourceCode();\n    const tokenInfo = new TokenInfo(sourceCode);\n    const offsets = new OffsetStorage(tokenInfo, indentSize, indentType === \"space\" ? \" \" : \"\\t\");\n    const parameterParens = new WeakSet();\n\n    function createErrorMessageData(expectedAmount, actualSpaces, actualTabs) {\n      const expectedStatement = `${expectedAmount} ${indentType}${expectedAmount === 1 ? \"\" : \"s\"}`;\n      const foundSpacesWord = `space${actualSpaces === 1 ? \"\" : \"s\"}`;\n      const foundTabsWord = `tab${actualTabs === 1 ? \"\" : \"s\"}`;\n      let foundStatement;\n\n      if (actualSpaces > 0) {\n        foundStatement = indentType === \"space\" ? actualSpaces : `${actualSpaces} ${foundSpacesWord}`;\n      } else if (actualTabs > 0) {\n        foundStatement = indentType === \"tab\" ? actualTabs : `${actualTabs} ${foundTabsWord}`;\n      } else {\n        foundStatement = \"0\";\n      }\n\n      return {\n        expected: expectedStatement,\n        actual: foundStatement\n      };\n    }\n\n    function report(token, neededIndent) {\n      const actualIndent = Array.from(tokenInfo.getTokenIndent(token));\n      const numSpaces = actualIndent.filter(char => char === \" \").length;\n      const numTabs = actualIndent.filter(char => char === \"\\t\").length;\n      context.report({\n        node: token,\n        messageId: \"wrongIndentation\",\n        data: createErrorMessageData(neededIndent.length, numSpaces, numTabs),\n        loc: {\n          start: {\n            line: token.loc.start.line,\n            column: 0\n          },\n          end: {\n            line: token.loc.start.line,\n            column: token.loc.start.column\n          }\n        },\n\n        fix(fixer) {\n          const range = [token.range[0] - token.loc.start.column, token.range[0]];\n          return fixer.replaceTextRange(range, neededIndent);\n        }\n\n      });\n    }\n\n    function validateTokenIndent(token, desiredIndent) {\n      const indentation = tokenInfo.getTokenIndent(token);\n      return indentation === desiredIndent || indentation.includes(\" \") && indentation.includes(\"\\t\");\n    }\n\n    function isOuterIIFE(node) {\n      if (!node.parent || node.parent.type !== \"CallExpression\" || node.parent.callee !== node) {\n        return false;\n      }\n\n      let statement = node.parent && node.parent.parent;\n\n      while (statement.type === \"UnaryExpression\" && [\"!\", \"~\", \"+\", \"-\"].indexOf(statement.operator) > -1 || statement.type === \"AssignmentExpression\" || statement.type === \"LogicalExpression\" || statement.type === \"SequenceExpression\" || statement.type === \"VariableDeclarator\") {\n        statement = statement.parent;\n      }\n\n      return (statement.type === \"ExpressionStatement\" || statement.type === \"VariableDeclaration\") && statement.parent.type === \"Program\";\n    }\n\n    function countTrailingLinebreaks(string) {\n      const trailingWhitespace = string.match(/\\s*$/u)[0];\n      const linebreakMatches = trailingWhitespace.match(astUtils.createGlobalLinebreakMatcher());\n      return linebreakMatches === null ? 0 : linebreakMatches.length;\n    }\n\n    function addElementListIndent(elements, startToken, endToken, offset) {\n      function getFirstToken(element) {\n        let token = sourceCode.getTokenBefore(element);\n\n        while (astUtils.isOpeningParenToken(token) && token !== startToken) {\n          token = sourceCode.getTokenBefore(token);\n        }\n\n        return sourceCode.getTokenAfter(token);\n      }\n\n      offsets.setDesiredOffsets([startToken.range[1], endToken.range[0]], startToken, typeof offset === \"number\" ? offset : 1);\n      offsets.setDesiredOffset(endToken, startToken, 0);\n\n      if (offset === \"first\" && elements.length && !elements[0]) {\n        return;\n      }\n\n      elements.forEach((element, index) => {\n        if (!element) {\n          return;\n        }\n\n        if (offset === \"off\") {\n          offsets.ignoreToken(getFirstToken(element));\n        }\n\n        if (index === 0) {\n          return;\n        }\n\n        if (offset === \"first\" && tokenInfo.isFirstTokenOfLine(getFirstToken(element))) {\n          offsets.matchOffsetOf(getFirstToken(elements[0]), getFirstToken(element));\n        } else {\n          const previousElement = elements[index - 1];\n          const firstTokenOfPreviousElement = previousElement && getFirstToken(previousElement);\n          const previousElementLastToken = previousElement && sourceCode.getLastToken(previousElement);\n\n          if (previousElement && previousElementLastToken.loc.end.line - countTrailingLinebreaks(previousElementLastToken.value) > startToken.loc.end.line) {\n            offsets.setDesiredOffsets([previousElement.range[1], element.range[1]], firstTokenOfPreviousElement, 0);\n          }\n        }\n      });\n    }\n\n    function addBlocklessNodeIndent(node) {\n      if (node.type !== \"BlockStatement\") {\n        const lastParentToken = sourceCode.getTokenBefore(node, astUtils.isNotOpeningParenToken);\n        let firstBodyToken = sourceCode.getFirstToken(node);\n        let lastBodyToken = sourceCode.getLastToken(node);\n\n        while (astUtils.isOpeningParenToken(sourceCode.getTokenBefore(firstBodyToken)) && astUtils.isClosingParenToken(sourceCode.getTokenAfter(lastBodyToken))) {\n          firstBodyToken = sourceCode.getTokenBefore(firstBodyToken);\n          lastBodyToken = sourceCode.getTokenAfter(lastBodyToken);\n        }\n\n        offsets.setDesiredOffsets([firstBodyToken.range[0], lastBodyToken.range[1]], lastParentToken, 1);\n        const lastToken = sourceCode.getLastToken(node);\n\n        if (node.type !== \"EmptyStatement\" && astUtils.isSemicolonToken(lastToken)) {\n          offsets.setDesiredOffset(lastToken, lastParentToken, 0);\n        }\n      }\n    }\n\n    function addFunctionCallIndent(node) {\n      let openingParen;\n\n      if (node.arguments.length) {\n        openingParen = sourceCode.getFirstTokenBetween(node.callee, node.arguments[0], astUtils.isOpeningParenToken);\n      } else {\n        openingParen = sourceCode.getLastToken(node, 1);\n      }\n\n      const closingParen = sourceCode.getLastToken(node);\n      parameterParens.add(openingParen);\n      parameterParens.add(closingParen);\n\n      if (node.optional) {\n        const dotToken = sourceCode.getTokenAfter(node.callee, astUtils.isQuestionDotToken);\n        const calleeParenCount = sourceCode.getTokensBetween(node.callee, dotToken, {\n          filter: astUtils.isClosingParenToken\n        }).length;\n        const firstTokenOfCallee = calleeParenCount ? sourceCode.getTokenBefore(node.callee, {\n          skip: calleeParenCount - 1\n        }) : sourceCode.getFirstToken(node.callee);\n        const lastTokenOfCallee = sourceCode.getTokenBefore(dotToken);\n        const offsetBase = lastTokenOfCallee.loc.end.line === openingParen.loc.start.line ? lastTokenOfCallee : firstTokenOfCallee;\n        offsets.setDesiredOffset(dotToken, offsetBase, 1);\n      }\n\n      const offsetAfterToken = node.callee.type === \"TaggedTemplateExpression\" ? sourceCode.getFirstToken(node.callee.quasi) : openingParen;\n      const offsetToken = sourceCode.getTokenBefore(offsetAfterToken);\n      offsets.setDesiredOffset(openingParen, offsetToken, 0);\n      addElementListIndent(node.arguments, openingParen, closingParen, options.CallExpression.arguments);\n    }\n\n    function addParensIndent(tokens) {\n      const parenStack = [];\n      const parenPairs = [];\n      tokens.forEach(nextToken => {\n        if (astUtils.isOpeningParenToken(nextToken)) {\n          parenStack.push(nextToken);\n        } else if (astUtils.isClosingParenToken(nextToken)) {\n          parenPairs.unshift({\n            left: parenStack.pop(),\n            right: nextToken\n          });\n        }\n      });\n      parenPairs.forEach(pair => {\n        const leftParen = pair.left;\n        const rightParen = pair.right;\n\n        if (!parameterParens.has(leftParen) && !parameterParens.has(rightParen)) {\n          const parenthesizedTokens = new Set(sourceCode.getTokensBetween(leftParen, rightParen));\n          parenthesizedTokens.forEach(token => {\n            if (!parenthesizedTokens.has(offsets.getFirstDependency(token))) {\n              offsets.setDesiredOffset(token, leftParen, 1);\n            }\n          });\n        }\n\n        offsets.setDesiredOffset(rightParen, leftParen, 0);\n      });\n    }\n\n    function ignoreNode(node) {\n      const unknownNodeTokens = new Set(sourceCode.getTokens(node, {\n        includeComments: true\n      }));\n      unknownNodeTokens.forEach(token => {\n        if (!unknownNodeTokens.has(offsets.getFirstDependency(token))) {\n          const firstTokenOfLine = tokenInfo.getFirstTokenOfLine(token);\n\n          if (token === firstTokenOfLine) {\n            offsets.ignoreToken(token);\n          } else {\n            offsets.setDesiredOffset(token, firstTokenOfLine, 0);\n          }\n        }\n      });\n    }\n\n    function isOnFirstLineOfStatement(token, leafNode) {\n      let node = leafNode;\n\n      while (node.parent && !node.parent.type.endsWith(\"Statement\") && !node.parent.type.endsWith(\"Declaration\")) {\n        node = node.parent;\n      }\n\n      node = node.parent;\n      return !node || node.loc.start.line === token.loc.start.line;\n    }\n\n    function hasBlankLinesBetween(firstToken, secondToken) {\n      const firstTokenLine = firstToken.loc.end.line;\n      const secondTokenLine = secondToken.loc.start.line;\n\n      if (firstTokenLine === secondTokenLine || firstTokenLine === secondTokenLine - 1) {\n        return false;\n      }\n\n      for (let line = firstTokenLine + 1; line < secondTokenLine; ++line) {\n        if (!tokenInfo.firstTokensByLineNumber.has(line)) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n\n    const ignoredNodeFirstTokens = new Set();\n    const baseOffsetListeners = {\n      \"ArrayExpression, ArrayPattern\"(node) {\n        const openingBracket = sourceCode.getFirstToken(node);\n        const closingBracket = sourceCode.getTokenAfter([...node.elements].reverse().find(_ => _) || openingBracket, astUtils.isClosingBracketToken);\n        addElementListIndent(node.elements, openingBracket, closingBracket, options.ArrayExpression);\n      },\n\n      \"ObjectExpression, ObjectPattern\"(node) {\n        const openingCurly = sourceCode.getFirstToken(node);\n        const closingCurly = sourceCode.getTokenAfter(node.properties.length ? node.properties[node.properties.length - 1] : openingCurly, astUtils.isClosingBraceToken);\n        addElementListIndent(node.properties, openingCurly, closingCurly, options.ObjectExpression);\n      },\n\n      ArrowFunctionExpression(node) {\n        const maybeOpeningParen = sourceCode.getFirstToken(node, {\n          skip: node.async ? 1 : 0\n        });\n\n        if (astUtils.isOpeningParenToken(maybeOpeningParen)) {\n          const openingParen = maybeOpeningParen;\n          const closingParen = sourceCode.getTokenBefore(node.body, astUtils.isClosingParenToken);\n          parameterParens.add(openingParen);\n          parameterParens.add(closingParen);\n          addElementListIndent(node.params, openingParen, closingParen, options.FunctionExpression.parameters);\n        }\n\n        addBlocklessNodeIndent(node.body);\n      },\n\n      AssignmentExpression(node) {\n        const operator = sourceCode.getFirstTokenBetween(node.left, node.right, token => token.value === node.operator);\n        offsets.setDesiredOffsets([operator.range[0], node.range[1]], sourceCode.getLastToken(node.left), 1);\n        offsets.ignoreToken(operator);\n        offsets.ignoreToken(sourceCode.getTokenAfter(operator));\n      },\n\n      \"BinaryExpression, LogicalExpression\"(node) {\n        const operator = sourceCode.getFirstTokenBetween(node.left, node.right, token => token.value === node.operator);\n        const tokenAfterOperator = sourceCode.getTokenAfter(operator);\n        offsets.ignoreToken(operator);\n        offsets.ignoreToken(tokenAfterOperator);\n        offsets.setDesiredOffset(tokenAfterOperator, operator, 0);\n      },\n\n      \"BlockStatement, ClassBody\"(node) {\n        let blockIndentLevel;\n\n        if (node.parent && isOuterIIFE(node.parent)) {\n          blockIndentLevel = options.outerIIFEBody;\n        } else if (node.parent && (node.parent.type === \"FunctionExpression\" || node.parent.type === \"ArrowFunctionExpression\")) {\n          blockIndentLevel = options.FunctionExpression.body;\n        } else if (node.parent && node.parent.type === \"FunctionDeclaration\") {\n          blockIndentLevel = options.FunctionDeclaration.body;\n        } else {\n          blockIndentLevel = 1;\n        }\n\n        if (!astUtils.STATEMENT_LIST_PARENTS.has(node.parent.type)) {\n          offsets.setDesiredOffset(sourceCode.getFirstToken(node), sourceCode.getFirstToken(node.parent), 0);\n        }\n\n        addElementListIndent(node.body, sourceCode.getFirstToken(node), sourceCode.getLastToken(node), blockIndentLevel);\n      },\n\n      CallExpression: addFunctionCallIndent,\n\n      \"ClassDeclaration[superClass], ClassExpression[superClass]\"(node) {\n        const classToken = sourceCode.getFirstToken(node);\n        const extendsToken = sourceCode.getTokenBefore(node.superClass, astUtils.isNotOpeningParenToken);\n        offsets.setDesiredOffsets([extendsToken.range[0], node.body.range[0]], classToken, 1);\n      },\n\n      ConditionalExpression(node) {\n        const firstToken = sourceCode.getFirstToken(node);\n\n        if (!options.flatTernaryExpressions || !astUtils.isTokenOnSameLine(node.test, node.consequent) || isOnFirstLineOfStatement(firstToken, node)) {\n          const questionMarkToken = sourceCode.getFirstTokenBetween(node.test, node.consequent, token => token.type === \"Punctuator\" && token.value === \"?\");\n          const colonToken = sourceCode.getFirstTokenBetween(node.consequent, node.alternate, token => token.type === \"Punctuator\" && token.value === \":\");\n          const firstConsequentToken = sourceCode.getTokenAfter(questionMarkToken);\n          const lastConsequentToken = sourceCode.getTokenBefore(colonToken);\n          const firstAlternateToken = sourceCode.getTokenAfter(colonToken);\n          offsets.setDesiredOffset(questionMarkToken, firstToken, 1);\n          offsets.setDesiredOffset(colonToken, firstToken, 1);\n          offsets.setDesiredOffset(firstConsequentToken, firstToken, firstConsequentToken.type === \"Punctuator\" && options.offsetTernaryExpressions ? 2 : 1);\n\n          if (lastConsequentToken.loc.end.line === firstAlternateToken.loc.start.line) {\n            offsets.setDesiredOffset(firstAlternateToken, firstConsequentToken, 0);\n          } else {\n            offsets.setDesiredOffset(firstAlternateToken, firstToken, firstAlternateToken.type === \"Punctuator\" && options.offsetTernaryExpressions ? 2 : 1);\n          }\n        }\n      },\n\n      \"DoWhileStatement, WhileStatement, ForInStatement, ForOfStatement\": node => addBlocklessNodeIndent(node.body),\n\n      ExportNamedDeclaration(node) {\n        if (node.declaration === null) {\n          const closingCurly = sourceCode.getLastToken(node, astUtils.isClosingBraceToken);\n          addElementListIndent(node.specifiers, sourceCode.getFirstToken(node, {\n            skip: 1\n          }), closingCurly, 1);\n\n          if (node.source) {\n            offsets.setDesiredOffsets([closingCurly.range[1], node.range[1]], sourceCode.getFirstToken(node), 1);\n          }\n        }\n      },\n\n      ForStatement(node) {\n        const forOpeningParen = sourceCode.getFirstToken(node, 1);\n\n        if (node.init) {\n          offsets.setDesiredOffsets(node.init.range, forOpeningParen, 1);\n        }\n\n        if (node.test) {\n          offsets.setDesiredOffsets(node.test.range, forOpeningParen, 1);\n        }\n\n        if (node.update) {\n          offsets.setDesiredOffsets(node.update.range, forOpeningParen, 1);\n        }\n\n        addBlocklessNodeIndent(node.body);\n      },\n\n      \"FunctionDeclaration, FunctionExpression\"(node) {\n        const closingParen = sourceCode.getTokenBefore(node.body);\n        const openingParen = sourceCode.getTokenBefore(node.params.length ? node.params[0] : closingParen);\n        parameterParens.add(openingParen);\n        parameterParens.add(closingParen);\n        addElementListIndent(node.params, openingParen, closingParen, options[node.type].parameters);\n      },\n\n      IfStatement(node) {\n        addBlocklessNodeIndent(node.consequent);\n\n        if (node.alternate && node.alternate.type !== \"IfStatement\") {\n          addBlocklessNodeIndent(node.alternate);\n        }\n      },\n\n      ImportDeclaration(node) {\n        if (node.specifiers.some(specifier => specifier.type === \"ImportSpecifier\")) {\n          const openingCurly = sourceCode.getFirstToken(node, astUtils.isOpeningBraceToken);\n          const closingCurly = sourceCode.getLastToken(node, astUtils.isClosingBraceToken);\n          addElementListIndent(node.specifiers.filter(specifier => specifier.type === \"ImportSpecifier\"), openingCurly, closingCurly, options.ImportDeclaration);\n        }\n\n        const fromToken = sourceCode.getLastToken(node, token => token.type === \"Identifier\" && token.value === \"from\");\n        const sourceToken = sourceCode.getLastToken(node, token => token.type === \"String\");\n        const semiToken = sourceCode.getLastToken(node, token => token.type === \"Punctuator\" && token.value === \";\");\n\n        if (fromToken) {\n          const end = semiToken && semiToken.range[1] === sourceToken.range[1] ? node.range[1] : sourceToken.range[1];\n          offsets.setDesiredOffsets([fromToken.range[0], end], sourceCode.getFirstToken(node), 1);\n        }\n      },\n\n      ImportExpression(node) {\n        const openingParen = sourceCode.getFirstToken(node, 1);\n        const closingParen = sourceCode.getLastToken(node);\n        parameterParens.add(openingParen);\n        parameterParens.add(closingParen);\n        offsets.setDesiredOffset(openingParen, sourceCode.getTokenBefore(openingParen), 0);\n        addElementListIndent([node.source], openingParen, closingParen, options.CallExpression.arguments);\n      },\n\n      \"MemberExpression, JSXMemberExpression, MetaProperty\"(node) {\n        const object = node.type === \"MetaProperty\" ? node.meta : node.object;\n        const firstNonObjectToken = sourceCode.getFirstTokenBetween(object, node.property, astUtils.isNotClosingParenToken);\n        const secondNonObjectToken = sourceCode.getTokenAfter(firstNonObjectToken);\n        const objectParenCount = sourceCode.getTokensBetween(object, node.property, {\n          filter: astUtils.isClosingParenToken\n        }).length;\n        const firstObjectToken = objectParenCount ? sourceCode.getTokenBefore(object, {\n          skip: objectParenCount - 1\n        }) : sourceCode.getFirstToken(object);\n        const lastObjectToken = sourceCode.getTokenBefore(firstNonObjectToken);\n        const firstPropertyToken = node.computed ? firstNonObjectToken : secondNonObjectToken;\n\n        if (node.computed) {\n          offsets.setDesiredOffset(sourceCode.getLastToken(node), firstNonObjectToken, 0);\n          offsets.setDesiredOffsets(node.property.range, firstNonObjectToken, 1);\n        }\n\n        const offsetBase = lastObjectToken.loc.end.line === firstPropertyToken.loc.start.line ? lastObjectToken : firstObjectToken;\n\n        if (typeof options.MemberExpression === \"number\") {\n          offsets.setDesiredOffset(firstNonObjectToken, offsetBase, options.MemberExpression);\n          offsets.setDesiredOffset(secondNonObjectToken, node.computed ? firstNonObjectToken : offsetBase, options.MemberExpression);\n        } else {\n          offsets.ignoreToken(firstNonObjectToken);\n          offsets.ignoreToken(secondNonObjectToken);\n          offsets.setDesiredOffset(firstNonObjectToken, offsetBase, 0);\n          offsets.setDesiredOffset(secondNonObjectToken, firstNonObjectToken, 0);\n        }\n      },\n\n      NewExpression(node) {\n        if (node.arguments.length > 0 || astUtils.isClosingParenToken(sourceCode.getLastToken(node)) && astUtils.isOpeningParenToken(sourceCode.getLastToken(node, 1))) {\n          addFunctionCallIndent(node);\n        }\n      },\n\n      Property(node) {\n        if (!node.shorthand && !node.method && node.kind === \"init\") {\n          const colon = sourceCode.getFirstTokenBetween(node.key, node.value, astUtils.isColonToken);\n          offsets.ignoreToken(sourceCode.getTokenAfter(colon));\n        }\n      },\n\n      SwitchStatement(node) {\n        const openingCurly = sourceCode.getTokenAfter(node.discriminant, astUtils.isOpeningBraceToken);\n        const closingCurly = sourceCode.getLastToken(node);\n        offsets.setDesiredOffsets([openingCurly.range[1], closingCurly.range[0]], openingCurly, options.SwitchCase);\n\n        if (node.cases.length) {\n          sourceCode.getTokensBetween(node.cases[node.cases.length - 1], closingCurly, {\n            includeComments: true,\n            filter: astUtils.isCommentToken\n          }).forEach(token => offsets.ignoreToken(token));\n        }\n      },\n\n      SwitchCase(node) {\n        if (!(node.consequent.length === 1 && node.consequent[0].type === \"BlockStatement\")) {\n          const caseKeyword = sourceCode.getFirstToken(node);\n          const tokenAfterCurrentCase = sourceCode.getTokenAfter(node);\n          offsets.setDesiredOffsets([caseKeyword.range[1], tokenAfterCurrentCase.range[0]], caseKeyword, 1);\n        }\n      },\n\n      TemplateLiteral(node) {\n        node.expressions.forEach((expression, index) => {\n          const previousQuasi = node.quasis[index];\n          const nextQuasi = node.quasis[index + 1];\n          const tokenToAlignFrom = previousQuasi.loc.start.line === previousQuasi.loc.end.line ? sourceCode.getFirstToken(previousQuasi) : null;\n          offsets.setDesiredOffsets([previousQuasi.range[1], nextQuasi.range[0]], tokenToAlignFrom, 1);\n          offsets.setDesiredOffset(sourceCode.getFirstToken(nextQuasi), tokenToAlignFrom, 0);\n        });\n      },\n\n      VariableDeclaration(node) {\n        let variableIndent = Object.prototype.hasOwnProperty.call(options.VariableDeclarator, node.kind) ? options.VariableDeclarator[node.kind] : DEFAULT_VARIABLE_INDENT;\n        const firstToken = sourceCode.getFirstToken(node),\n              lastToken = sourceCode.getLastToken(node);\n\n        if (options.VariableDeclarator[node.kind] === \"first\") {\n          if (node.declarations.length > 1) {\n            addElementListIndent(node.declarations, firstToken, lastToken, \"first\");\n            return;\n          }\n\n          variableIndent = DEFAULT_VARIABLE_INDENT;\n        }\n\n        if (node.declarations[node.declarations.length - 1].loc.start.line > node.loc.start.line) {\n          offsets.setDesiredOffsets(node.range, firstToken, variableIndent, true);\n        } else {\n          offsets.setDesiredOffsets(node.range, firstToken, variableIndent);\n        }\n\n        if (astUtils.isSemicolonToken(lastToken)) {\n          offsets.ignoreToken(lastToken);\n        }\n      },\n\n      VariableDeclarator(node) {\n        if (node.init) {\n          const equalOperator = sourceCode.getTokenBefore(node.init, astUtils.isNotOpeningParenToken);\n          const tokenAfterOperator = sourceCode.getTokenAfter(equalOperator);\n          offsets.ignoreToken(equalOperator);\n          offsets.ignoreToken(tokenAfterOperator);\n          offsets.setDesiredOffsets([tokenAfterOperator.range[0], node.range[1]], equalOperator, 1);\n          offsets.setDesiredOffset(equalOperator, sourceCode.getLastToken(node.id), 0);\n        }\n      },\n\n      \"JSXAttribute[value]\"(node) {\n        const equalsToken = sourceCode.getFirstTokenBetween(node.name, node.value, token => token.type === \"Punctuator\" && token.value === \"=\");\n        offsets.setDesiredOffsets([equalsToken.range[0], node.value.range[1]], sourceCode.getFirstToken(node.name), 1);\n      },\n\n      JSXElement(node) {\n        if (node.closingElement) {\n          addElementListIndent(node.children, sourceCode.getFirstToken(node.openingElement), sourceCode.getFirstToken(node.closingElement), 1);\n        }\n      },\n\n      JSXOpeningElement(node) {\n        const firstToken = sourceCode.getFirstToken(node);\n        let closingToken;\n\n        if (node.selfClosing) {\n          closingToken = sourceCode.getLastToken(node, {\n            skip: 1\n          });\n          offsets.setDesiredOffset(sourceCode.getLastToken(node), closingToken, 0);\n        } else {\n          closingToken = sourceCode.getLastToken(node);\n        }\n\n        offsets.setDesiredOffsets(node.name.range, sourceCode.getFirstToken(node));\n        addElementListIndent(node.attributes, firstToken, closingToken, 1);\n      },\n\n      JSXClosingElement(node) {\n        const firstToken = sourceCode.getFirstToken(node);\n        offsets.setDesiredOffsets(node.name.range, firstToken, 1);\n      },\n\n      JSXFragment(node) {\n        const firstOpeningToken = sourceCode.getFirstToken(node.openingFragment);\n        const firstClosingToken = sourceCode.getFirstToken(node.closingFragment);\n        addElementListIndent(node.children, firstOpeningToken, firstClosingToken, 1);\n      },\n\n      JSXOpeningFragment(node) {\n        const firstToken = sourceCode.getFirstToken(node);\n        const closingToken = sourceCode.getLastToken(node);\n        offsets.setDesiredOffsets(node.range, firstToken, 1);\n        offsets.matchOffsetOf(firstToken, closingToken);\n      },\n\n      JSXClosingFragment(node) {\n        const firstToken = sourceCode.getFirstToken(node);\n        const slashToken = sourceCode.getLastToken(node, {\n          skip: 1\n        });\n        const closingToken = sourceCode.getLastToken(node);\n        const tokenToMatch = astUtils.isTokenOnSameLine(slashToken, closingToken) ? slashToken : closingToken;\n        offsets.setDesiredOffsets(node.range, firstToken, 1);\n        offsets.matchOffsetOf(firstToken, tokenToMatch);\n      },\n\n      JSXExpressionContainer(node) {\n        const openingCurly = sourceCode.getFirstToken(node);\n        const closingCurly = sourceCode.getLastToken(node);\n        offsets.setDesiredOffsets([openingCurly.range[1], closingCurly.range[0]], openingCurly, 1);\n      },\n\n      JSXSpreadAttribute(node) {\n        const openingCurly = sourceCode.getFirstToken(node);\n        const closingCurly = sourceCode.getLastToken(node);\n        offsets.setDesiredOffsets([openingCurly.range[1], closingCurly.range[0]], openingCurly, 1);\n      },\n\n      \"*\"(node) {\n        const firstToken = sourceCode.getFirstToken(node);\n\n        if (firstToken && !ignoredNodeFirstTokens.has(firstToken)) {\n          offsets.setDesiredOffsets(node.range, firstToken, 0);\n        }\n      }\n\n    };\n    const listenerCallQueue = [];\n    const offsetListeners = {};\n\n    for (const [selector, listener] of Object.entries(baseOffsetListeners)) {\n      offsetListeners[selector] = node => listenerCallQueue.push({\n        listener,\n        node\n      });\n    }\n\n    const ignoredNodes = new Set();\n\n    function addToIgnoredNodes(node) {\n      ignoredNodes.add(node);\n      ignoredNodeFirstTokens.add(sourceCode.getFirstToken(node));\n    }\n\n    const ignoredNodeListeners = options.ignoredNodes.reduce((listeners, ignoredSelector) => Object.assign(listeners, {\n      [ignoredSelector]: addToIgnoredNodes\n    }), {});\n    return Object.assign(offsetListeners, ignoredNodeListeners, {\n      \"*:exit\"(node) {\n        if (!KNOWN_NODES.has(node.type)) {\n          addToIgnoredNodes(node);\n        }\n      },\n\n      \"Program:exit\"() {\n        if (options.ignoreComments) {\n          sourceCode.getAllComments().forEach(comment => offsets.ignoreToken(comment));\n        }\n\n        listenerCallQueue.filter(nodeInfo => !ignoredNodes.has(nodeInfo.node)).forEach(nodeInfo => nodeInfo.listener(nodeInfo.node));\n        ignoredNodes.forEach(ignoreNode);\n        addParensIndent(sourceCode.ast.tokens);\n        const precedingTokens = sourceCode.ast.comments.reduce((commentMap, comment) => {\n          const tokenOrCommentBefore = sourceCode.getTokenBefore(comment, {\n            includeComments: true\n          });\n          return commentMap.set(comment, commentMap.has(tokenOrCommentBefore) ? commentMap.get(tokenOrCommentBefore) : tokenOrCommentBefore);\n        }, new WeakMap());\n        sourceCode.lines.forEach((line, lineIndex) => {\n          const lineNumber = lineIndex + 1;\n\n          if (!tokenInfo.firstTokensByLineNumber.has(lineNumber)) {\n            return;\n          }\n\n          const firstTokenOfLine = tokenInfo.firstTokensByLineNumber.get(lineNumber);\n\n          if (firstTokenOfLine.loc.start.line !== lineNumber) {\n            return;\n          }\n\n          if (astUtils.isCommentToken(firstTokenOfLine)) {\n            const tokenBefore = precedingTokens.get(firstTokenOfLine);\n            const tokenAfter = tokenBefore ? sourceCode.getTokenAfter(tokenBefore) : sourceCode.ast.tokens[0];\n            const mayAlignWithBefore = tokenBefore && !hasBlankLinesBetween(tokenBefore, firstTokenOfLine);\n            const mayAlignWithAfter = tokenAfter && !hasBlankLinesBetween(firstTokenOfLine, tokenAfter);\n\n            if (tokenAfter && astUtils.isSemicolonToken(tokenAfter) && !astUtils.isTokenOnSameLine(firstTokenOfLine, tokenAfter)) {\n              offsets.setDesiredOffset(firstTokenOfLine, tokenAfter, 0);\n            }\n\n            if (mayAlignWithBefore && validateTokenIndent(firstTokenOfLine, offsets.getDesiredIndent(tokenBefore)) || mayAlignWithAfter && validateTokenIndent(firstTokenOfLine, offsets.getDesiredIndent(tokenAfter))) {\n              return;\n            }\n          }\n\n          if (validateTokenIndent(firstTokenOfLine, offsets.getDesiredIndent(firstTokenOfLine))) {\n            return;\n          }\n\n          report(firstTokenOfLine, offsets.getDesiredIndent(firstTokenOfLine));\n        });\n      }\n\n    });\n  }\n\n};\nindent.meta;\nindent.create;\n\nfunction isForLoop(block) {\n  return block.type === \"ForInStatement\" || block.type === \"ForOfStatement\" || block.type === \"ForStatement\";\n}\n\nfunction isInitialized$1(node) {\n  const declaration = node.parent;\n  const block = declaration.parent;\n\n  if (isForLoop(block)) {\n    if (block.type === \"ForStatement\") {\n      return block.init === declaration;\n    }\n\n    return block.left === declaration;\n  }\n\n  return Boolean(node.init);\n}\n\nvar initDeclarations = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"require or disallow initialization in variable declarations\",\n      category: \"Variables\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/init-declarations\"\n    },\n    schema: {\n      anyOf: [{\n        type: \"array\",\n        items: [{\n          enum: [\"always\"]\n        }],\n        minItems: 0,\n        maxItems: 1\n      }, {\n        type: \"array\",\n        items: [{\n          enum: [\"never\"]\n        }, {\n          type: \"object\",\n          properties: {\n            ignoreForLoopInit: {\n              type: \"boolean\"\n            }\n          },\n          additionalProperties: false\n        }],\n        minItems: 0,\n        maxItems: 2\n      }]\n    },\n    messages: {\n      initialized: \"Variable '{{idName}}' should be initialized on declaration.\",\n      notInitialized: \"Variable '{{idName}}' should not be initialized on declaration.\"\n    }\n  },\n\n  create(context) {\n    const mode = context.options[0] || \"always\";\n    const params = context.options[1] || {};\n    return {\n      \"VariableDeclaration:exit\"(node) {\n        const kind = node.kind,\n              declarations = node.declarations;\n\n        for (let i = 0; i < declarations.length; ++i) {\n          const declaration = declarations[i],\n                id = declaration.id,\n                initialized = isInitialized$1(declaration),\n                isIgnoredForLoop = params.ignoreForLoopInit && isForLoop(node.parent);\n          let messageId = \"\";\n\n          if (mode === \"always\" && !initialized) {\n            messageId = \"initialized\";\n          } else if (mode === \"never\" && kind !== \"const\" && initialized && !isIgnoredForLoop) {\n            messageId = \"notInitialized\";\n          }\n\n          if (id.type === \"Identifier\" && messageId) {\n            context.report({\n              node: declaration,\n              messageId,\n              data: {\n                idName: id.name\n              }\n            });\n          }\n        }\n      }\n\n    };\n  }\n\n};\ninitDeclarations.meta;\ninitDeclarations.create;\nconst QUOTE_SETTINGS$1 = {\n  \"prefer-double\": {\n    quote: \"\\\"\",\n    description: \"singlequote\",\n\n    convert(str) {\n      return str.replace(/'/gu, \"\\\"\");\n    }\n\n  },\n  \"prefer-single\": {\n    quote: \"'\",\n    description: \"doublequote\",\n\n    convert(str) {\n      return str.replace(/\"/gu, \"'\");\n    }\n\n  }\n};\nvar jsxQuotes = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"enforce the consistent use of either double or single quotes in JSX attributes\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/jsx-quotes\"\n    },\n    fixable: \"whitespace\",\n    schema: [{\n      enum: [\"prefer-single\", \"prefer-double\"]\n    }],\n    messages: {\n      unexpected: \"Unexpected usage of {{description}}.\"\n    }\n  },\n\n  create(context) {\n    const quoteOption = context.options[0] || \"prefer-double\",\n          setting = QUOTE_SETTINGS$1[quoteOption];\n\n    function usesExpectedQuotes(node) {\n      return node.value.indexOf(setting.quote) !== -1 || astUtils.isSurroundedBy(node.raw, setting.quote);\n    }\n\n    return {\n      JSXAttribute(node) {\n        const attributeValue = node.value;\n\n        if (attributeValue && astUtils.isStringLiteral(attributeValue) && !usesExpectedQuotes(attributeValue)) {\n          context.report({\n            node: attributeValue,\n            messageId: \"unexpected\",\n            data: {\n              description: setting.description\n            },\n\n            fix(fixer) {\n              return fixer.replaceText(attributeValue, setting.convert(attributeValue.raw));\n            }\n\n          });\n        }\n      }\n\n    };\n  }\n\n};\njsxQuotes.meta;\njsxQuotes.create;\n\nfunction containsLineTerminator(str) {\n  return astUtils.LINEBREAK_MATCHER.test(str);\n}\n\nfunction last(arr) {\n  return arr[arr.length - 1];\n}\n\nfunction isSingleLine(node) {\n  return node.loc.end.line === node.loc.start.line;\n}\n\nfunction isSingleLineProperties(properties) {\n  const [firstProp] = properties,\n        lastProp = last(properties);\n  return firstProp.loc.start.line === lastProp.loc.end.line;\n}\n\nfunction initOptionProperty(toOptions, fromOptions) {\n  toOptions.mode = fromOptions.mode || \"strict\";\n\n  if (typeof fromOptions.beforeColon !== \"undefined\") {\n    toOptions.beforeColon = +fromOptions.beforeColon;\n  } else {\n    toOptions.beforeColon = 0;\n  }\n\n  if (typeof fromOptions.afterColon !== \"undefined\") {\n    toOptions.afterColon = +fromOptions.afterColon;\n  } else {\n    toOptions.afterColon = 1;\n  }\n\n  if (typeof fromOptions.align !== \"undefined\") {\n    if (typeof fromOptions.align === \"object\") {\n      toOptions.align = fromOptions.align;\n    } else {\n      toOptions.align = {\n        on: fromOptions.align,\n        mode: toOptions.mode,\n        beforeColon: toOptions.beforeColon,\n        afterColon: toOptions.afterColon\n      };\n    }\n  }\n\n  return toOptions;\n}\n\nfunction initOptions(toOptions, fromOptions) {\n  if (typeof fromOptions.align === \"object\") {\n    toOptions.align = initOptionProperty({}, fromOptions.align);\n    toOptions.align.on = fromOptions.align.on || \"colon\";\n    toOptions.align.mode = fromOptions.align.mode || \"strict\";\n    toOptions.multiLine = initOptionProperty({}, fromOptions.multiLine || fromOptions);\n    toOptions.singleLine = initOptionProperty({}, fromOptions.singleLine || fromOptions);\n  } else {\n    toOptions.multiLine = initOptionProperty({}, fromOptions.multiLine || fromOptions);\n    toOptions.singleLine = initOptionProperty({}, fromOptions.singleLine || fromOptions);\n\n    if (toOptions.multiLine.align) {\n      toOptions.align = {\n        on: toOptions.multiLine.align.on,\n        mode: toOptions.multiLine.align.mode || toOptions.multiLine.mode,\n        beforeColon: toOptions.multiLine.align.beforeColon,\n        afterColon: toOptions.multiLine.align.afterColon\n      };\n    }\n  }\n\n  return toOptions;\n}\n\nvar keySpacing = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"enforce consistent spacing between keys and values in object literal properties\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/key-spacing\"\n    },\n    fixable: \"whitespace\",\n    schema: [{\n      anyOf: [{\n        type: \"object\",\n        properties: {\n          align: {\n            anyOf: [{\n              enum: [\"colon\", \"value\"]\n            }, {\n              type: \"object\",\n              properties: {\n                mode: {\n                  enum: [\"strict\", \"minimum\"]\n                },\n                on: {\n                  enum: [\"colon\", \"value\"]\n                },\n                beforeColon: {\n                  type: \"boolean\"\n                },\n                afterColon: {\n                  type: \"boolean\"\n                }\n              },\n              additionalProperties: false\n            }]\n          },\n          mode: {\n            enum: [\"strict\", \"minimum\"]\n          },\n          beforeColon: {\n            type: \"boolean\"\n          },\n          afterColon: {\n            type: \"boolean\"\n          }\n        },\n        additionalProperties: false\n      }, {\n        type: \"object\",\n        properties: {\n          singleLine: {\n            type: \"object\",\n            properties: {\n              mode: {\n                enum: [\"strict\", \"minimum\"]\n              },\n              beforeColon: {\n                type: \"boolean\"\n              },\n              afterColon: {\n                type: \"boolean\"\n              }\n            },\n            additionalProperties: false\n          },\n          multiLine: {\n            type: \"object\",\n            properties: {\n              align: {\n                anyOf: [{\n                  enum: [\"colon\", \"value\"]\n                }, {\n                  type: \"object\",\n                  properties: {\n                    mode: {\n                      enum: [\"strict\", \"minimum\"]\n                    },\n                    on: {\n                      enum: [\"colon\", \"value\"]\n                    },\n                    beforeColon: {\n                      type: \"boolean\"\n                    },\n                    afterColon: {\n                      type: \"boolean\"\n                    }\n                  },\n                  additionalProperties: false\n                }]\n              },\n              mode: {\n                enum: [\"strict\", \"minimum\"]\n              },\n              beforeColon: {\n                type: \"boolean\"\n              },\n              afterColon: {\n                type: \"boolean\"\n              }\n            },\n            additionalProperties: false\n          }\n        },\n        additionalProperties: false\n      }, {\n        type: \"object\",\n        properties: {\n          singleLine: {\n            type: \"object\",\n            properties: {\n              mode: {\n                enum: [\"strict\", \"minimum\"]\n              },\n              beforeColon: {\n                type: \"boolean\"\n              },\n              afterColon: {\n                type: \"boolean\"\n              }\n            },\n            additionalProperties: false\n          },\n          multiLine: {\n            type: \"object\",\n            properties: {\n              mode: {\n                enum: [\"strict\", \"minimum\"]\n              },\n              beforeColon: {\n                type: \"boolean\"\n              },\n              afterColon: {\n                type: \"boolean\"\n              }\n            },\n            additionalProperties: false\n          },\n          align: {\n            type: \"object\",\n            properties: {\n              mode: {\n                enum: [\"strict\", \"minimum\"]\n              },\n              on: {\n                enum: [\"colon\", \"value\"]\n              },\n              beforeColon: {\n                type: \"boolean\"\n              },\n              afterColon: {\n                type: \"boolean\"\n              }\n            },\n            additionalProperties: false\n          }\n        },\n        additionalProperties: false\n      }]\n    }],\n    messages: {\n      extraKey: \"Extra space after {{computed}}key '{{key}}'.\",\n      extraValue: \"Extra space before value for {{computed}}key '{{key}}'.\",\n      missingKey: \"Missing space after {{computed}}key '{{key}}'.\",\n      missingValue: \"Missing space before value for {{computed}}key '{{key}}'.\"\n    }\n  },\n\n  create(context) {\n    const options = context.options[0] || {},\n          ruleOptions = initOptions({}, options),\n          multiLineOptions = ruleOptions.multiLine,\n          singleLineOptions = ruleOptions.singleLine,\n          alignmentOptions = ruleOptions.align || null;\n    const sourceCode = context.getSourceCode();\n\n    function continuesPropertyGroup(lastMember, candidate) {\n      const groupEndLine = lastMember.loc.start.line,\n            candidateStartLine = candidate.loc.start.line;\n\n      if (candidateStartLine - groupEndLine <= 1) {\n        return true;\n      }\n\n      const leadingComments = sourceCode.getCommentsBefore(candidate);\n\n      if (leadingComments.length && leadingComments[0].loc.start.line - groupEndLine <= 1 && candidateStartLine - last(leadingComments).loc.end.line <= 1) {\n        for (let i = 1; i < leadingComments.length; i++) {\n          if (leadingComments[i].loc.start.line - leadingComments[i - 1].loc.end.line > 1) {\n            return false;\n          }\n        }\n\n        return true;\n      }\n\n      return false;\n    }\n\n    function isKeyValueProperty(property) {\n      return !(property.method || property.shorthand || property.kind !== \"init\" || property.type !== \"Property\");\n    }\n\n    function getLastTokenBeforeColon(node) {\n      const colonToken = sourceCode.getTokenAfter(node, astUtils.isColonToken);\n      return sourceCode.getTokenBefore(colonToken);\n    }\n\n    function getNextColon(node) {\n      return sourceCode.getTokenAfter(node, astUtils.isColonToken);\n    }\n\n    function getKey(property) {\n      const key = property.key;\n\n      if (property.computed) {\n        return sourceCode.getText().slice(key.range[0], key.range[1]);\n      }\n\n      return astUtils.getStaticPropertyName(property);\n    }\n\n    function report(property, side, whitespace, expected, mode) {\n      const diff = whitespace.length - expected,\n            nextColon = getNextColon(property.key),\n            tokenBeforeColon = sourceCode.getTokenBefore(nextColon, {\n        includeComments: true\n      }),\n            tokenAfterColon = sourceCode.getTokenAfter(nextColon, {\n        includeComments: true\n      }),\n            isKeySide = side === \"key\",\n            isExtra = diff > 0,\n            diffAbs = Math.abs(diff),\n            spaces = Array(diffAbs + 1).join(\" \");\n      const locStart = isKeySide ? tokenBeforeColon.loc.end : nextColon.loc.start;\n      const locEnd = isKeySide ? nextColon.loc.start : tokenAfterColon.loc.start;\n      const missingLoc = isKeySide ? tokenBeforeColon.loc : tokenAfterColon.loc;\n      const loc = isExtra ? {\n        start: locStart,\n        end: locEnd\n      } : missingLoc;\n\n      if ((diff && mode === \"strict\" || diff < 0 && mode === \"minimum\" || diff > 0 && !expected && mode === \"minimum\") && !(expected && containsLineTerminator(whitespace))) {\n        let fix;\n\n        if (isExtra) {\n          let range;\n\n          if (isKeySide) {\n            range = [tokenBeforeColon.range[1], tokenBeforeColon.range[1] + diffAbs];\n          } else {\n            range = [tokenAfterColon.range[0] - diffAbs, tokenAfterColon.range[0]];\n          }\n\n          fix = function (fixer) {\n            return fixer.removeRange(range);\n          };\n        } else {\n          if (isKeySide) {\n            fix = function (fixer) {\n              return fixer.insertTextAfter(tokenBeforeColon, spaces);\n            };\n          } else {\n            fix = function (fixer) {\n              return fixer.insertTextBefore(tokenAfterColon, spaces);\n            };\n          }\n        }\n\n        let messageId = \"\";\n\n        if (isExtra) {\n          messageId = side === \"key\" ? \"extraKey\" : \"extraValue\";\n        } else {\n          messageId = side === \"key\" ? \"missingKey\" : \"missingValue\";\n        }\n\n        context.report({\n          node: property[side],\n          loc,\n          messageId,\n          data: {\n            computed: property.computed ? \"computed \" : \"\",\n            key: getKey(property)\n          },\n          fix\n        });\n      }\n    }\n\n    function getKeyWidth(property) {\n      const startToken = sourceCode.getFirstToken(property);\n      const endToken = getLastTokenBeforeColon(property.key);\n      return endToken.range[1] - startToken.range[0];\n    }\n\n    function getPropertyWhitespace(property) {\n      const whitespace = /(\\s*):(\\s*)/u.exec(sourceCode.getText().slice(property.key.range[1], property.value.range[0]));\n\n      if (whitespace) {\n        return {\n          beforeColon: whitespace[1],\n          afterColon: whitespace[2]\n        };\n      }\n\n      return null;\n    }\n\n    function createGroups(node) {\n      if (node.properties.length === 1) {\n        return [node.properties];\n      }\n\n      return node.properties.reduce((groups, property) => {\n        const currentGroup = last(groups),\n              prev = last(currentGroup);\n\n        if (!prev || continuesPropertyGroup(prev, property)) {\n          currentGroup.push(property);\n        } else {\n          groups.push([property]);\n        }\n\n        return groups;\n      }, [[]]);\n    }\n\n    function verifyGroupAlignment(properties) {\n      const length = properties.length,\n            widths = properties.map(getKeyWidth),\n            align = alignmentOptions.on;\n      let targetWidth = Math.max(...widths),\n          beforeColon,\n          afterColon,\n          mode;\n\n      if (alignmentOptions && length > 1) {\n        beforeColon = alignmentOptions.beforeColon;\n        afterColon = alignmentOptions.afterColon;\n        mode = alignmentOptions.mode;\n      } else {\n        beforeColon = multiLineOptions.beforeColon;\n        afterColon = multiLineOptions.afterColon;\n        mode = alignmentOptions.mode;\n      }\n\n      targetWidth += align === \"colon\" ? beforeColon : afterColon;\n\n      for (let i = 0; i < length; i++) {\n        const property = properties[i];\n        const whitespace = getPropertyWhitespace(property);\n\n        if (whitespace) {\n          const width = widths[i];\n\n          if (align === \"value\") {\n            report(property, \"key\", whitespace.beforeColon, beforeColon, mode);\n            report(property, \"value\", whitespace.afterColon, targetWidth - width, mode);\n          } else {\n            report(property, \"key\", whitespace.beforeColon, targetWidth - width, mode);\n            report(property, \"value\", whitespace.afterColon, afterColon, mode);\n          }\n        }\n      }\n    }\n\n    function verifySpacing(node, lineOptions) {\n      const actual = getPropertyWhitespace(node);\n\n      if (actual) {\n        report(node, \"key\", actual.beforeColon, lineOptions.beforeColon, lineOptions.mode);\n        report(node, \"value\", actual.afterColon, lineOptions.afterColon, lineOptions.mode);\n      }\n    }\n\n    function verifyListSpacing(properties, lineOptions) {\n      const length = properties.length;\n\n      for (let i = 0; i < length; i++) {\n        verifySpacing(properties[i], lineOptions);\n      }\n    }\n\n    function verifyAlignment(node) {\n      createGroups(node).forEach(group => {\n        const properties = group.filter(isKeyValueProperty);\n\n        if (properties.length > 0 && isSingleLineProperties(properties)) {\n          verifyListSpacing(properties, multiLineOptions);\n        } else {\n          verifyGroupAlignment(properties);\n        }\n      });\n    }\n\n    if (alignmentOptions) {\n      return {\n        ObjectExpression(node) {\n          if (isSingleLine(node)) {\n            verifyListSpacing(node.properties.filter(isKeyValueProperty), singleLineOptions);\n          } else {\n            verifyAlignment(node);\n          }\n        }\n\n      };\n    }\n\n    return {\n      Property(node) {\n        verifySpacing(node, isSingleLine(node.parent) ? singleLineOptions : multiLineOptions);\n      }\n\n    };\n  }\n\n};\nkeySpacing.meta;\nkeySpacing.create;\nconst PREV_TOKEN = /^[)\\]}>]$/u;\nconst NEXT_TOKEN = /^(?:[([{<~!]|\\+\\+?|--?)$/u;\nconst PREV_TOKEN_M = /^[)\\]}>*]$/u;\nconst NEXT_TOKEN_M = /^[{*]$/u;\nconst TEMPLATE_OPEN_PAREN = /\\$\\{$/u;\nconst TEMPLATE_CLOSE_PAREN = /^\\}/u;\nconst CHECK_TYPE = /^(?:JSXElement|RegularExpression|String|Template)$/u;\nconst KEYS = keywords.concat([\"as\", \"async\", \"await\", \"from\", \"get\", \"let\", \"of\", \"set\", \"yield\"]);\n\n(function () {\n  KEYS.sort();\n\n  for (let i = 1; i < KEYS.length; ++i) {\n    if (KEYS[i] === KEYS[i - 1]) {\n      throw new Error(`Duplication was found in the keyword list: ${KEYS[i]}`);\n    }\n  }\n})();\n\nfunction isOpenParenOfTemplate(token) {\n  return token.type === \"Template\" && TEMPLATE_OPEN_PAREN.test(token.value);\n}\n\nfunction isCloseParenOfTemplate(token) {\n  return token.type === \"Template\" && TEMPLATE_CLOSE_PAREN.test(token.value);\n}\n\nvar keywordSpacing = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"enforce consistent spacing before and after keywords\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/keyword-spacing\"\n    },\n    fixable: \"whitespace\",\n    schema: [{\n      type: \"object\",\n      properties: {\n        before: {\n          type: \"boolean\",\n          default: true\n        },\n        after: {\n          type: \"boolean\",\n          default: true\n        },\n        overrides: {\n          type: \"object\",\n          properties: KEYS.reduce((retv, key) => {\n            retv[key] = {\n              type: \"object\",\n              properties: {\n                before: {\n                  type: \"boolean\"\n                },\n                after: {\n                  type: \"boolean\"\n                }\n              },\n              additionalProperties: false\n            };\n            return retv;\n          }, {}),\n          additionalProperties: false\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      expectedBefore: \"Expected space(s) before \\\"{{value}}\\\".\",\n      expectedAfter: \"Expected space(s) after \\\"{{value}}\\\".\",\n      unexpectedBefore: \"Unexpected space(s) before \\\"{{value}}\\\".\",\n      unexpectedAfter: \"Unexpected space(s) after \\\"{{value}}\\\".\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n\n    function expectSpaceBefore(token, pattern) {\n      const prevToken = sourceCode.getTokenBefore(token);\n\n      if (prevToken && (CHECK_TYPE.test(prevToken.type) || pattern.test(prevToken.value)) && !isOpenParenOfTemplate(prevToken) && astUtils.isTokenOnSameLine(prevToken, token) && !sourceCode.isSpaceBetweenTokens(prevToken, token)) {\n        context.report({\n          loc: token.loc,\n          messageId: \"expectedBefore\",\n          data: token,\n\n          fix(fixer) {\n            return fixer.insertTextBefore(token, \" \");\n          }\n\n        });\n      }\n    }\n\n    function unexpectSpaceBefore(token, pattern) {\n      const prevToken = sourceCode.getTokenBefore(token);\n\n      if (prevToken && (CHECK_TYPE.test(prevToken.type) || pattern.test(prevToken.value)) && !isOpenParenOfTemplate(prevToken) && astUtils.isTokenOnSameLine(prevToken, token) && sourceCode.isSpaceBetweenTokens(prevToken, token)) {\n        context.report({\n          loc: {\n            start: prevToken.loc.end,\n            end: token.loc.start\n          },\n          messageId: \"unexpectedBefore\",\n          data: token,\n\n          fix(fixer) {\n            return fixer.removeRange([prevToken.range[1], token.range[0]]);\n          }\n\n        });\n      }\n    }\n\n    function expectSpaceAfter(token, pattern) {\n      const nextToken = sourceCode.getTokenAfter(token);\n\n      if (nextToken && (CHECK_TYPE.test(nextToken.type) || pattern.test(nextToken.value)) && !isCloseParenOfTemplate(nextToken) && astUtils.isTokenOnSameLine(token, nextToken) && !sourceCode.isSpaceBetweenTokens(token, nextToken)) {\n        context.report({\n          loc: token.loc,\n          messageId: \"expectedAfter\",\n          data: token,\n\n          fix(fixer) {\n            return fixer.insertTextAfter(token, \" \");\n          }\n\n        });\n      }\n    }\n\n    function unexpectSpaceAfter(token, pattern) {\n      const nextToken = sourceCode.getTokenAfter(token);\n\n      if (nextToken && (CHECK_TYPE.test(nextToken.type) || pattern.test(nextToken.value)) && !isCloseParenOfTemplate(nextToken) && astUtils.isTokenOnSameLine(token, nextToken) && sourceCode.isSpaceBetweenTokens(token, nextToken)) {\n        context.report({\n          loc: {\n            start: token.loc.end,\n            end: nextToken.loc.start\n          },\n          messageId: \"unexpectedAfter\",\n          data: token,\n\n          fix(fixer) {\n            return fixer.removeRange([token.range[1], nextToken.range[0]]);\n          }\n\n        });\n      }\n    }\n\n    function parseOptions(options = {}) {\n      const before = options.before !== false;\n      const after = options.after !== false;\n      const defaultValue = {\n        before: before ? expectSpaceBefore : unexpectSpaceBefore,\n        after: after ? expectSpaceAfter : unexpectSpaceAfter\n      };\n      const overrides = options && options.overrides || {};\n      const retv = Object.create(null);\n\n      for (let i = 0; i < KEYS.length; ++i) {\n        const key = KEYS[i];\n        const override = overrides[key];\n\n        if (override) {\n          const thisBefore = \"before\" in override ? override.before : before;\n          const thisAfter = \"after\" in override ? override.after : after;\n          retv[key] = {\n            before: thisBefore ? expectSpaceBefore : unexpectSpaceBefore,\n            after: thisAfter ? expectSpaceAfter : unexpectSpaceAfter\n          };\n        } else {\n          retv[key] = defaultValue;\n        }\n      }\n\n      return retv;\n    }\n\n    const checkMethodMap = parseOptions(context.options[0]);\n\n    function checkSpacingBefore(token, pattern) {\n      checkMethodMap[token.value].before(token, pattern || PREV_TOKEN);\n    }\n\n    function checkSpacingAfter(token, pattern) {\n      checkMethodMap[token.value].after(token, pattern || NEXT_TOKEN);\n    }\n\n    function checkSpacingAround(token) {\n      checkSpacingBefore(token);\n      checkSpacingAfter(token);\n    }\n\n    function checkSpacingAroundFirstToken(node) {\n      const firstToken = node && sourceCode.getFirstToken(node);\n\n      if (firstToken && firstToken.type === \"Keyword\") {\n        checkSpacingAround(firstToken);\n      }\n    }\n\n    function checkSpacingBeforeFirstToken(node) {\n      const firstToken = node && sourceCode.getFirstToken(node);\n\n      if (firstToken && firstToken.type === \"Keyword\") {\n        checkSpacingBefore(firstToken);\n      }\n    }\n\n    function checkSpacingAroundTokenBefore(node) {\n      if (node) {\n        const token = sourceCode.getTokenBefore(node, astUtils.isKeywordToken);\n        checkSpacingAround(token);\n      }\n    }\n\n    function checkSpacingForFunction(node) {\n      const firstToken = node && sourceCode.getFirstToken(node);\n\n      if (firstToken && (firstToken.type === \"Keyword\" && firstToken.value === \"function\" || firstToken.value === \"async\")) {\n        checkSpacingBefore(firstToken);\n      }\n    }\n\n    function checkSpacingForClass(node) {\n      checkSpacingAroundFirstToken(node);\n      checkSpacingAroundTokenBefore(node.superClass);\n    }\n\n    function checkSpacingForModuleDeclaration(node) {\n      const firstToken = sourceCode.getFirstToken(node);\n      checkSpacingBefore(firstToken, PREV_TOKEN_M);\n      checkSpacingAfter(firstToken, NEXT_TOKEN_M);\n\n      if (node.type === \"ExportDefaultDeclaration\") {\n        checkSpacingAround(sourceCode.getTokenAfter(firstToken));\n      }\n\n      if (node.type === \"ExportAllDeclaration\" && node.exported) {\n        const asToken = sourceCode.getTokenBefore(node.exported);\n        checkSpacingBefore(asToken, PREV_TOKEN_M);\n      }\n\n      if (node.source) {\n        const fromToken = sourceCode.getTokenBefore(node.source);\n        checkSpacingBefore(fromToken, PREV_TOKEN_M);\n        checkSpacingAfter(fromToken, NEXT_TOKEN_M);\n      }\n    }\n\n    function checkSpacingForProperty(node) {\n      if (node.static) {\n        checkSpacingAroundFirstToken(node);\n      }\n\n      if (node.kind === \"get\" || node.kind === \"set\" || (node.method || node.type === \"MethodDefinition\") && node.value.async) {\n        const token = sourceCode.getTokenBefore(node.key, tok => {\n          switch (tok.value) {\n            case \"get\":\n            case \"set\":\n            case \"async\":\n              return true;\n\n            default:\n              return false;\n          }\n        });\n\n        if (!token) {\n          throw new Error(\"Failed to find token get, set, or async beside method name\");\n        }\n\n        checkSpacingAround(token);\n      }\n    }\n\n    return {\n      DebuggerStatement: checkSpacingAroundFirstToken,\n      WithStatement: checkSpacingAroundFirstToken,\n      BreakStatement: checkSpacingAroundFirstToken,\n      ContinueStatement: checkSpacingAroundFirstToken,\n      ReturnStatement: checkSpacingAroundFirstToken,\n      ThrowStatement: checkSpacingAroundFirstToken,\n      TryStatement: function (node) {\n        checkSpacingAroundFirstToken(node);\n        checkSpacingAroundFirstToken(node.handler);\n        checkSpacingAroundTokenBefore(node.finalizer);\n      },\n      IfStatement: function (node) {\n        checkSpacingAroundFirstToken(node);\n        checkSpacingAroundTokenBefore(node.alternate);\n      },\n      SwitchStatement: checkSpacingAroundFirstToken,\n      SwitchCase: checkSpacingAroundFirstToken,\n      DoWhileStatement: function (node) {\n        checkSpacingAroundFirstToken(node);\n        checkSpacingAroundTokenBefore(node.test);\n      },\n      ForInStatement: function (node) {\n        checkSpacingAroundFirstToken(node);\n        checkSpacingAroundTokenBefore(node.right);\n      },\n      ForOfStatement: function (node) {\n        if (node.await) {\n          checkSpacingBefore(sourceCode.getFirstToken(node, 0));\n          checkSpacingAfter(sourceCode.getFirstToken(node, 1));\n        } else {\n          checkSpacingAroundFirstToken(node);\n        }\n\n        checkSpacingAround(sourceCode.getTokenBefore(node.right, astUtils.isNotOpeningParenToken));\n      },\n      ForStatement: checkSpacingAroundFirstToken,\n      WhileStatement: checkSpacingAroundFirstToken,\n      ClassDeclaration: checkSpacingForClass,\n      ExportNamedDeclaration: checkSpacingForModuleDeclaration,\n      ExportDefaultDeclaration: checkSpacingForModuleDeclaration,\n      ExportAllDeclaration: checkSpacingForModuleDeclaration,\n      FunctionDeclaration: checkSpacingForFunction,\n      ImportDeclaration: checkSpacingForModuleDeclaration,\n      VariableDeclaration: checkSpacingAroundFirstToken,\n      ArrowFunctionExpression: checkSpacingForFunction,\n      AwaitExpression: function (node) {\n        checkSpacingBefore(sourceCode.getFirstToken(node));\n      },\n      ClassExpression: checkSpacingForClass,\n      FunctionExpression: checkSpacingForFunction,\n      NewExpression: checkSpacingBeforeFirstToken,\n      Super: checkSpacingBeforeFirstToken,\n      ThisExpression: checkSpacingBeforeFirstToken,\n      UnaryExpression: checkSpacingBeforeFirstToken,\n      YieldExpression: checkSpacingBeforeFirstToken,\n      ImportNamespaceSpecifier: function (node) {\n        const asToken = sourceCode.getFirstToken(node, 1);\n        checkSpacingBefore(asToken, PREV_TOKEN_M);\n      },\n      MethodDefinition: checkSpacingForProperty,\n      Property: checkSpacingForProperty\n    };\n  }\n\n};\nkeywordSpacing.meta;\nkeywordSpacing.create;\nvar lineCommentPosition = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"enforce position of line comments\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/line-comment-position\"\n    },\n    schema: [{\n      oneOf: [{\n        enum: [\"above\", \"beside\"]\n      }, {\n        type: \"object\",\n        properties: {\n          position: {\n            enum: [\"above\", \"beside\"]\n          },\n          ignorePattern: {\n            type: \"string\"\n          },\n          applyDefaultPatterns: {\n            type: \"boolean\"\n          },\n          applyDefaultIgnorePatterns: {\n            type: \"boolean\"\n          }\n        },\n        additionalProperties: false\n      }]\n    }],\n    messages: {\n      above: \"Expected comment to be above code.\",\n      beside: \"Expected comment to be beside code.\"\n    }\n  },\n\n  create(context) {\n    const options = context.options[0];\n    let above,\n        ignorePattern,\n        applyDefaultIgnorePatterns = true;\n\n    if (!options || typeof options === \"string\") {\n      above = !options || options === \"above\";\n    } else {\n      above = !options.position || options.position === \"above\";\n      ignorePattern = options.ignorePattern;\n\n      if (Object.prototype.hasOwnProperty.call(options, \"applyDefaultIgnorePatterns\")) {\n        applyDefaultIgnorePatterns = options.applyDefaultIgnorePatterns;\n      } else {\n        applyDefaultIgnorePatterns = options.applyDefaultPatterns !== false;\n      }\n    }\n\n    const defaultIgnoreRegExp = astUtils.COMMENTS_IGNORE_PATTERN;\n    const customIgnoreRegExp = new RegExp(ignorePattern, \"u\");\n    const sourceCode = context.getSourceCode();\n    return {\n      Program() {\n        const comments = sourceCode.getAllComments();\n        comments.filter(token => token.type === \"Line\").forEach(node => {\n          if (applyDefaultIgnorePatterns && (defaultIgnoreRegExp.test(node.value) || /^\\s*falls?\\s?through/u.test(node.value))) {\n            return;\n          }\n\n          if (ignorePattern && customIgnoreRegExp.test(node.value)) {\n            return;\n          }\n\n          const previous = sourceCode.getTokenBefore(node, {\n            includeComments: true\n          });\n          const isOnSameLine = previous && previous.loc.end.line === node.loc.start.line;\n\n          if (above) {\n            if (isOnSameLine) {\n              context.report({\n                node,\n                messageId: \"above\"\n              });\n            }\n          } else {\n            if (!isOnSameLine) {\n              context.report({\n                node,\n                messageId: \"beside\"\n              });\n            }\n          }\n        });\n      }\n\n    };\n  }\n\n};\nlineCommentPosition.meta;\nlineCommentPosition.create;\nvar linebreakStyle = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"enforce consistent linebreak style\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/linebreak-style\"\n    },\n    fixable: \"whitespace\",\n    schema: [{\n      enum: [\"unix\", \"windows\"]\n    }],\n    messages: {\n      expectedLF: \"Expected linebreaks to be 'LF' but found 'CRLF'.\",\n      expectedCRLF: \"Expected linebreaks to be 'CRLF' but found 'LF'.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n\n    function createFix(range, text) {\n      return function (fixer) {\n        return fixer.replaceTextRange(range, text);\n      };\n    }\n\n    return {\n      Program: function (node) {\n        const linebreakStyle = context.options[0] || \"unix\",\n              expectedLF = linebreakStyle === \"unix\",\n              expectedLFChars = expectedLF ? \"\\n\" : \"\\r\\n\",\n              source = sourceCode.getText(),\n              pattern = astUtils.createGlobalLinebreakMatcher();\n        let match;\n        let i = 0;\n\n        while ((match = pattern.exec(source)) !== null) {\n          i++;\n\n          if (match[0] === expectedLFChars) {\n            continue;\n          }\n\n          const index = match.index;\n          const range = [index, index + match[0].length];\n          context.report({\n            node,\n            loc: {\n              start: {\n                line: i,\n                column: sourceCode.lines[i - 1].length\n              },\n              end: {\n                line: i + 1,\n                column: 0\n              }\n            },\n            messageId: expectedLF ? \"expectedLF\" : \"expectedCRLF\",\n            fix: createFix(range, expectedLFChars)\n          });\n        }\n      }\n    };\n  }\n\n};\nlinebreakStyle.meta;\nlinebreakStyle.create;\n\nfunction getEmptyLineNums(lines) {\n  const emptyLines = lines.map((line, i) => ({\n    code: line.trim(),\n    num: i + 1\n  })).filter(line => !line.code).map(line => line.num);\n  return emptyLines;\n}\n\nfunction getCommentLineNums(comments) {\n  const lines = [];\n  comments.forEach(token => {\n    const start = token.loc.start.line;\n    const end = token.loc.end.line;\n    lines.push(start, end);\n  });\n  return lines;\n}\n\nvar linesAroundComment = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"require empty lines around comments\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/lines-around-comment\"\n    },\n    fixable: \"whitespace\",\n    schema: [{\n      type: \"object\",\n      properties: {\n        beforeBlockComment: {\n          type: \"boolean\",\n          default: true\n        },\n        afterBlockComment: {\n          type: \"boolean\",\n          default: false\n        },\n        beforeLineComment: {\n          type: \"boolean\",\n          default: false\n        },\n        afterLineComment: {\n          type: \"boolean\",\n          default: false\n        },\n        allowBlockStart: {\n          type: \"boolean\",\n          default: false\n        },\n        allowBlockEnd: {\n          type: \"boolean\",\n          default: false\n        },\n        allowClassStart: {\n          type: \"boolean\"\n        },\n        allowClassEnd: {\n          type: \"boolean\"\n        },\n        allowObjectStart: {\n          type: \"boolean\"\n        },\n        allowObjectEnd: {\n          type: \"boolean\"\n        },\n        allowArrayStart: {\n          type: \"boolean\"\n        },\n        allowArrayEnd: {\n          type: \"boolean\"\n        },\n        ignorePattern: {\n          type: \"string\"\n        },\n        applyDefaultIgnorePatterns: {\n          type: \"boolean\"\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      after: \"Expected line after comment.\",\n      before: \"Expected line before comment.\"\n    }\n  },\n\n  create(context) {\n    const options = Object.assign({}, context.options[0]);\n    const ignorePattern = options.ignorePattern;\n    const defaultIgnoreRegExp = astUtils.COMMENTS_IGNORE_PATTERN;\n    const customIgnoreRegExp = new RegExp(ignorePattern, \"u\");\n    const applyDefaultIgnorePatterns = options.applyDefaultIgnorePatterns !== false;\n    options.beforeBlockComment = typeof options.beforeBlockComment !== \"undefined\" ? options.beforeBlockComment : true;\n    const sourceCode = context.getSourceCode();\n    const lines = sourceCode.lines,\n          numLines = lines.length + 1,\n          comments = sourceCode.getAllComments(),\n          commentLines = getCommentLineNums(comments),\n          emptyLines = getEmptyLineNums(lines),\n          commentAndEmptyLines = commentLines.concat(emptyLines);\n\n    function codeAroundComment(token) {\n      let currentToken = token;\n\n      do {\n        currentToken = sourceCode.getTokenBefore(currentToken, {\n          includeComments: true\n        });\n      } while (currentToken && astUtils.isCommentToken(currentToken));\n\n      if (currentToken && astUtils.isTokenOnSameLine(currentToken, token)) {\n        return true;\n      }\n\n      currentToken = token;\n\n      do {\n        currentToken = sourceCode.getTokenAfter(currentToken, {\n          includeComments: true\n        });\n      } while (currentToken && astUtils.isCommentToken(currentToken));\n\n      if (currentToken && astUtils.isTokenOnSameLine(token, currentToken)) {\n        return true;\n      }\n\n      return false;\n    }\n\n    function isParentNodeType(parent, nodeType) {\n      return parent.type === nodeType || parent.body && parent.body.type === nodeType || parent.consequent && parent.consequent.type === nodeType;\n    }\n\n    function getParentNodeOfToken(token) {\n      return sourceCode.getNodeByRangeIndex(token.range[0]);\n    }\n\n    function isCommentAtParentStart(token, nodeType) {\n      const parent = getParentNodeOfToken(token);\n      return parent && isParentNodeType(parent, nodeType) && token.loc.start.line - parent.loc.start.line === 1;\n    }\n\n    function isCommentAtParentEnd(token, nodeType) {\n      const parent = getParentNodeOfToken(token);\n      return parent && isParentNodeType(parent, nodeType) && parent.loc.end.line - token.loc.end.line === 1;\n    }\n\n    function isCommentAtBlockStart(token) {\n      return isCommentAtParentStart(token, \"ClassBody\") || isCommentAtParentStart(token, \"BlockStatement\") || isCommentAtParentStart(token, \"SwitchCase\");\n    }\n\n    function isCommentAtBlockEnd(token) {\n      return isCommentAtParentEnd(token, \"ClassBody\") || isCommentAtParentEnd(token, \"BlockStatement\") || isCommentAtParentEnd(token, \"SwitchCase\") || isCommentAtParentEnd(token, \"SwitchStatement\");\n    }\n\n    function isCommentAtClassStart(token) {\n      return isCommentAtParentStart(token, \"ClassBody\");\n    }\n\n    function isCommentAtClassEnd(token) {\n      return isCommentAtParentEnd(token, \"ClassBody\");\n    }\n\n    function isCommentAtObjectStart(token) {\n      return isCommentAtParentStart(token, \"ObjectExpression\") || isCommentAtParentStart(token, \"ObjectPattern\");\n    }\n\n    function isCommentAtObjectEnd(token) {\n      return isCommentAtParentEnd(token, \"ObjectExpression\") || isCommentAtParentEnd(token, \"ObjectPattern\");\n    }\n\n    function isCommentAtArrayStart(token) {\n      return isCommentAtParentStart(token, \"ArrayExpression\") || isCommentAtParentStart(token, \"ArrayPattern\");\n    }\n\n    function isCommentAtArrayEnd(token) {\n      return isCommentAtParentEnd(token, \"ArrayExpression\") || isCommentAtParentEnd(token, \"ArrayPattern\");\n    }\n\n    function checkForEmptyLine(token, opts) {\n      if (applyDefaultIgnorePatterns && defaultIgnoreRegExp.test(token.value)) {\n        return;\n      }\n\n      if (ignorePattern && customIgnoreRegExp.test(token.value)) {\n        return;\n      }\n\n      let after = opts.after,\n          before = opts.before;\n      const prevLineNum = token.loc.start.line - 1,\n            nextLineNum = token.loc.end.line + 1,\n            commentIsNotAlone = codeAroundComment(token);\n      const blockStartAllowed = options.allowBlockStart && isCommentAtBlockStart(token) && !(options.allowClassStart === false && isCommentAtClassStart(token)),\n            blockEndAllowed = options.allowBlockEnd && isCommentAtBlockEnd(token) && !(options.allowClassEnd === false && isCommentAtClassEnd(token)),\n            classStartAllowed = options.allowClassStart && isCommentAtClassStart(token),\n            classEndAllowed = options.allowClassEnd && isCommentAtClassEnd(token),\n            objectStartAllowed = options.allowObjectStart && isCommentAtObjectStart(token),\n            objectEndAllowed = options.allowObjectEnd && isCommentAtObjectEnd(token),\n            arrayStartAllowed = options.allowArrayStart && isCommentAtArrayStart(token),\n            arrayEndAllowed = options.allowArrayEnd && isCommentAtArrayEnd(token);\n\n      if (prevLineNum < 1) {\n        before = false;\n      }\n\n      if (nextLineNum >= numLines) {\n        after = false;\n      }\n\n      if (commentIsNotAlone) {\n        return;\n      }\n\n      const previousTokenOrComment = sourceCode.getTokenBefore(token, {\n        includeComments: true\n      });\n      const nextTokenOrComment = sourceCode.getTokenAfter(token, {\n        includeComments: true\n      });\n\n      if (!(blockStartAllowed || classStartAllowed || objectStartAllowed || arrayStartAllowed) && before && !commentAndEmptyLines.includes(prevLineNum) && !(astUtils.isCommentToken(previousTokenOrComment) && astUtils.isTokenOnSameLine(previousTokenOrComment, token))) {\n        const lineStart = token.range[0] - token.loc.start.column;\n        const range = [lineStart, lineStart];\n        context.report({\n          node: token,\n          messageId: \"before\",\n\n          fix(fixer) {\n            return fixer.insertTextBeforeRange(range, \"\\n\");\n          }\n\n        });\n      }\n\n      if (!(blockEndAllowed || classEndAllowed || objectEndAllowed || arrayEndAllowed) && after && !commentAndEmptyLines.includes(nextLineNum) && !(astUtils.isCommentToken(nextTokenOrComment) && astUtils.isTokenOnSameLine(token, nextTokenOrComment))) {\n        context.report({\n          node: token,\n          messageId: \"after\",\n\n          fix(fixer) {\n            return fixer.insertTextAfter(token, \"\\n\");\n          }\n\n        });\n      }\n    }\n\n    return {\n      Program() {\n        comments.forEach(token => {\n          if (token.type === \"Line\") {\n            if (options.beforeLineComment || options.afterLineComment) {\n              checkForEmptyLine(token, {\n                after: options.afterLineComment,\n                before: options.beforeLineComment\n              });\n            }\n          } else if (token.type === \"Block\") {\n            if (options.beforeBlockComment || options.afterBlockComment) {\n              checkForEmptyLine(token, {\n                after: options.afterBlockComment,\n                before: options.beforeBlockComment\n              });\n            }\n          }\n        });\n      }\n\n    };\n  }\n\n};\nlinesAroundComment.meta;\nlinesAroundComment.create;\nvar linesAroundDirective = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"require or disallow newlines around directives\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/lines-around-directive\"\n    },\n    schema: [{\n      oneOf: [{\n        enum: [\"always\", \"never\"]\n      }, {\n        type: \"object\",\n        properties: {\n          before: {\n            enum: [\"always\", \"never\"]\n          },\n          after: {\n            enum: [\"always\", \"never\"]\n          }\n        },\n        additionalProperties: false,\n        minProperties: 2\n      }]\n    }],\n    fixable: \"whitespace\",\n    messages: {\n      expected: \"Expected newline {{location}} \\\"{{value}}\\\" directive.\",\n      unexpected: \"Unexpected newline {{location}} \\\"{{value}}\\\" directive.\"\n    },\n    deprecated: true,\n    replacedBy: [\"padding-line-between-statements\"]\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    const config = context.options[0] || \"always\";\n    const expectLineBefore = typeof config === \"string\" ? config : config.before;\n    const expectLineAfter = typeof config === \"string\" ? config : config.after;\n\n    function hasNewlineBefore(node) {\n      const tokenBefore = sourceCode.getTokenBefore(node, {\n        includeComments: true\n      });\n      const tokenLineBefore = tokenBefore ? tokenBefore.loc.end.line : 0;\n      return node.loc.start.line - tokenLineBefore >= 2;\n    }\n\n    function getLastTokenOnLine(node) {\n      const lastToken = sourceCode.getLastToken(node);\n      const secondToLastToken = sourceCode.getTokenBefore(lastToken);\n      return astUtils.isSemicolonToken(lastToken) && lastToken.loc.start.line > secondToLastToken.loc.end.line ? secondToLastToken : lastToken;\n    }\n\n    function hasNewlineAfter(node) {\n      const lastToken = getLastTokenOnLine(node);\n      const tokenAfter = sourceCode.getTokenAfter(lastToken, {\n        includeComments: true\n      });\n      return tokenAfter.loc.start.line - lastToken.loc.end.line >= 2;\n    }\n\n    function reportError(node, location, expected) {\n      context.report({\n        node,\n        messageId: expected ? \"expected\" : \"unexpected\",\n        data: {\n          value: node.expression.value,\n          location\n        },\n\n        fix(fixer) {\n          const lastToken = getLastTokenOnLine(node);\n\n          if (expected) {\n            return location === \"before\" ? fixer.insertTextBefore(node, \"\\n\") : fixer.insertTextAfter(lastToken, \"\\n\");\n          }\n\n          return fixer.removeRange(location === \"before\" ? [node.range[0] - 1, node.range[0]] : [lastToken.range[1], lastToken.range[1] + 1]);\n        }\n\n      });\n    }\n\n    function checkDirectives(node) {\n      const directives = astUtils.getDirectivePrologue(node);\n\n      if (!directives.length) {\n        return;\n      }\n\n      const firstDirective = directives[0];\n      const leadingComments = sourceCode.getCommentsBefore(firstDirective);\n\n      if (leadingComments.length) {\n        if (expectLineBefore === \"always\" && !hasNewlineBefore(firstDirective)) {\n          reportError(firstDirective, \"before\", true);\n        }\n\n        if (expectLineBefore === \"never\" && hasNewlineBefore(firstDirective)) {\n          reportError(firstDirective, \"before\", false);\n        }\n      } else if (node.type === \"Program\" && expectLineBefore === \"never\" && !leadingComments.length && hasNewlineBefore(firstDirective)) {\n        reportError(firstDirective, \"before\", false);\n      }\n\n      const lastDirective = directives[directives.length - 1];\n      const statements = node.type === \"Program\" ? node.body : node.body.body;\n\n      if (lastDirective === statements[statements.length - 1] && !lastDirective.trailingComments) {\n        return;\n      }\n\n      if (expectLineAfter === \"always\" && !hasNewlineAfter(lastDirective)) {\n        reportError(lastDirective, \"after\", true);\n      }\n\n      if (expectLineAfter === \"never\" && hasNewlineAfter(lastDirective)) {\n        reportError(lastDirective, \"after\", false);\n      }\n    }\n\n    return {\n      Program: checkDirectives,\n      FunctionDeclaration: checkDirectives,\n      FunctionExpression: checkDirectives,\n      ArrowFunctionExpression: checkDirectives\n    };\n  }\n\n};\nlinesAroundDirective.meta;\nlinesAroundDirective.create;\nvar linesBetweenClassMembers = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"require or disallow an empty line between class members\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/lines-between-class-members\"\n    },\n    fixable: \"whitespace\",\n    schema: [{\n      enum: [\"always\", \"never\"]\n    }, {\n      type: \"object\",\n      properties: {\n        exceptAfterSingleLine: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      never: \"Unexpected blank line between class members.\",\n      always: \"Expected blank line between class members.\"\n    }\n  },\n\n  create(context) {\n    const options = [];\n    options[0] = context.options[0] || \"always\";\n    options[1] = context.options[1] || {\n      exceptAfterSingleLine: false\n    };\n    const sourceCode = context.getSourceCode();\n\n    function findLastConsecutiveTokenAfter(prevLastToken, nextFirstToken, maxLine) {\n      const after = sourceCode.getTokenAfter(prevLastToken, {\n        includeComments: true\n      });\n\n      if (after !== nextFirstToken && after.loc.start.line - prevLastToken.loc.end.line <= maxLine) {\n        return findLastConsecutiveTokenAfter(after, nextFirstToken, maxLine);\n      }\n\n      return prevLastToken;\n    }\n\n    function findFirstConsecutiveTokenBefore(nextFirstToken, prevLastToken, maxLine) {\n      const before = sourceCode.getTokenBefore(nextFirstToken, {\n        includeComments: true\n      });\n\n      if (before !== prevLastToken && nextFirstToken.loc.start.line - before.loc.end.line <= maxLine) {\n        return findFirstConsecutiveTokenBefore(before, prevLastToken, maxLine);\n      }\n\n      return nextFirstToken;\n    }\n\n    function hasTokenOrCommentBetween(before, after) {\n      return sourceCode.getTokensBetween(before, after, {\n        includeComments: true\n      }).length !== 0;\n    }\n\n    return {\n      ClassBody(node) {\n        const body = node.body;\n\n        for (let i = 0; i < body.length - 1; i++) {\n          const curFirst = sourceCode.getFirstToken(body[i]);\n          const curLast = sourceCode.getLastToken(body[i]);\n          const nextFirst = sourceCode.getFirstToken(body[i + 1]);\n          const isMulti = !astUtils.isTokenOnSameLine(curFirst, curLast);\n          const skip = !isMulti && options[1].exceptAfterSingleLine;\n          const beforePadding = findLastConsecutiveTokenAfter(curLast, nextFirst, 1);\n          const afterPadding = findFirstConsecutiveTokenBefore(nextFirst, curLast, 1);\n          const isPadded = afterPadding.loc.start.line - beforePadding.loc.end.line > 1;\n          const hasTokenInPadding = hasTokenOrCommentBetween(beforePadding, afterPadding);\n          const curLineLastToken = findLastConsecutiveTokenAfter(curLast, nextFirst, 0);\n\n          if (options[0] === \"always\" && !skip && !isPadded || options[0] === \"never\" && isPadded) {\n            context.report({\n              node: body[i + 1],\n              messageId: isPadded ? \"never\" : \"always\",\n\n              fix(fixer) {\n                if (hasTokenInPadding) {\n                  return null;\n                }\n\n                return isPadded ? fixer.replaceTextRange([beforePadding.range[1], afterPadding.range[0]], \"\\n\") : fixer.insertTextAfter(curLineLastToken, \"\\n\");\n              }\n\n            });\n          }\n        }\n      }\n\n    };\n  }\n\n};\nlinesBetweenClassMembers.meta;\nlinesBetweenClassMembers.create;\nvar maxClassesPerFile = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"enforce a maximum number of classes per file\",\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/max-classes-per-file\"\n    },\n    schema: [{\n      type: \"integer\",\n      minimum: 1\n    }],\n    messages: {\n      maximumExceeded: \"File has too many classes ({{ classCount }}). Maximum allowed is {{ max }}.\"\n    }\n  },\n\n  create(context) {\n    const maxClasses = context.options[0] || 1;\n    let classCount = 0;\n    return {\n      Program() {\n        classCount = 0;\n      },\n\n      \"Program:exit\"(node) {\n        if (classCount > maxClasses) {\n          context.report({\n            node,\n            messageId: \"maximumExceeded\",\n            data: {\n              classCount,\n              max: maxClasses\n            }\n          });\n        }\n      },\n\n      \"ClassDeclaration, ClassExpression\"() {\n        classCount++;\n      }\n\n    };\n  }\n\n};\nmaxClassesPerFile.meta;\nmaxClassesPerFile.create;\nvar maxDepth = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"enforce a maximum depth that blocks can be nested\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/max-depth\"\n    },\n    schema: [{\n      oneOf: [{\n        type: \"integer\",\n        minimum: 0\n      }, {\n        type: \"object\",\n        properties: {\n          maximum: {\n            type: \"integer\",\n            minimum: 0\n          },\n          max: {\n            type: \"integer\",\n            minimum: 0\n          }\n        },\n        additionalProperties: false\n      }]\n    }],\n    messages: {\n      tooDeeply: \"Blocks are nested too deeply ({{depth}}). Maximum allowed is {{maxDepth}}.\"\n    }\n  },\n\n  create(context) {\n    const functionStack = [],\n          option = context.options[0];\n    let maxDepth = 4;\n\n    if (typeof option === \"object\" && (Object.prototype.hasOwnProperty.call(option, \"maximum\") || Object.prototype.hasOwnProperty.call(option, \"max\"))) {\n      maxDepth = option.maximum || option.max;\n    }\n\n    if (typeof option === \"number\") {\n      maxDepth = option;\n    }\n\n    function startFunction() {\n      functionStack.push(0);\n    }\n\n    function endFunction() {\n      functionStack.pop();\n    }\n\n    function pushBlock(node) {\n      const len = ++functionStack[functionStack.length - 1];\n\n      if (len > maxDepth) {\n        context.report({\n          node,\n          messageId: \"tooDeeply\",\n          data: {\n            depth: len,\n            maxDepth\n          }\n        });\n      }\n    }\n\n    function popBlock() {\n      functionStack[functionStack.length - 1]--;\n    }\n\n    return {\n      Program: startFunction,\n      FunctionDeclaration: startFunction,\n      FunctionExpression: startFunction,\n      ArrowFunctionExpression: startFunction,\n\n      IfStatement(node) {\n        if (node.parent.type !== \"IfStatement\") {\n          pushBlock(node);\n        }\n      },\n\n      SwitchStatement: pushBlock,\n      TryStatement: pushBlock,\n      DoWhileStatement: pushBlock,\n      WhileStatement: pushBlock,\n      WithStatement: pushBlock,\n      ForStatement: pushBlock,\n      ForInStatement: pushBlock,\n      ForOfStatement: pushBlock,\n      \"IfStatement:exit\": popBlock,\n      \"SwitchStatement:exit\": popBlock,\n      \"TryStatement:exit\": popBlock,\n      \"DoWhileStatement:exit\": popBlock,\n      \"WhileStatement:exit\": popBlock,\n      \"WithStatement:exit\": popBlock,\n      \"ForStatement:exit\": popBlock,\n      \"ForInStatement:exit\": popBlock,\n      \"ForOfStatement:exit\": popBlock,\n      \"FunctionDeclaration:exit\": endFunction,\n      \"FunctionExpression:exit\": endFunction,\n      \"ArrowFunctionExpression:exit\": endFunction,\n      \"Program:exit\": endFunction\n    };\n  }\n\n};\nmaxDepth.meta;\nmaxDepth.create;\nconst OPTIONS_SCHEMA$1 = {\n  type: \"object\",\n  properties: {\n    code: {\n      type: \"integer\",\n      minimum: 0\n    },\n    comments: {\n      type: \"integer\",\n      minimum: 0\n    },\n    tabWidth: {\n      type: \"integer\",\n      minimum: 0\n    },\n    ignorePattern: {\n      type: \"string\"\n    },\n    ignoreComments: {\n      type: \"boolean\"\n    },\n    ignoreStrings: {\n      type: \"boolean\"\n    },\n    ignoreUrls: {\n      type: \"boolean\"\n    },\n    ignoreTemplateLiterals: {\n      type: \"boolean\"\n    },\n    ignoreRegExpLiterals: {\n      type: \"boolean\"\n    },\n    ignoreTrailingComments: {\n      type: \"boolean\"\n    }\n  },\n  additionalProperties: false\n};\nconst OPTIONS_OR_INTEGER_SCHEMA$1 = {\n  anyOf: [OPTIONS_SCHEMA$1, {\n    type: \"integer\",\n    minimum: 0\n  }]\n};\nvar maxLen = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"enforce a maximum line length\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/max-len\"\n    },\n    schema: [OPTIONS_OR_INTEGER_SCHEMA$1, OPTIONS_OR_INTEGER_SCHEMA$1, OPTIONS_SCHEMA$1],\n    messages: {\n      max: \"This line has a length of {{lineLength}}. Maximum allowed is {{maxLength}}.\",\n      maxComment: \"This line has a comment length of {{lineLength}}. Maximum allowed is {{maxCommentLength}}.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n\n    function computeLineLength(line, tabWidth) {\n      let extraCharacterCount = 0;\n      line.replace(/\\t/gu, (match, offset) => {\n        const totalOffset = offset + extraCharacterCount,\n              previousTabStopOffset = tabWidth ? totalOffset % tabWidth : 0;\n        extraCharacterCount += tabWidth - previousTabStopOffset - 1;\n      });\n      return Array.from(line).length + extraCharacterCount;\n    }\n\n    const options = Object.assign({}, context.options[context.options.length - 1]);\n\n    if (typeof context.options[0] === \"number\") {\n      options.code = context.options[0];\n    }\n\n    if (typeof context.options[1] === \"number\") {\n      options.tabWidth = context.options[1];\n    }\n\n    const maxLength = typeof options.code === \"number\" ? options.code : 80,\n          tabWidth = typeof options.tabWidth === \"number\" ? options.tabWidth : 4,\n          ignoreComments = !!options.ignoreComments,\n          ignoreStrings = !!options.ignoreStrings,\n          ignoreTemplateLiterals = !!options.ignoreTemplateLiterals,\n          ignoreRegExpLiterals = !!options.ignoreRegExpLiterals,\n          ignoreTrailingComments = !!options.ignoreTrailingComments || !!options.ignoreComments,\n          ignoreUrls = !!options.ignoreUrls,\n          maxCommentLength = options.comments;\n    let ignorePattern = options.ignorePattern || null;\n\n    if (ignorePattern) {\n      ignorePattern = new RegExp(ignorePattern, \"u\");\n    }\n\n    function isTrailingComment(line, lineNumber, comment) {\n      return comment && comment.loc.start.line === lineNumber && lineNumber <= comment.loc.end.line && (comment.loc.end.line > lineNumber || comment.loc.end.column === line.length);\n    }\n\n    function isFullLineComment(line, lineNumber, comment) {\n      const start = comment.loc.start,\n            end = comment.loc.end,\n            isFirstTokenOnLine = !line.slice(0, comment.loc.start.column).trim();\n      return comment && (start.line < lineNumber || start.line === lineNumber && isFirstTokenOnLine) && (end.line > lineNumber || end.line === lineNumber && end.column === line.length);\n    }\n\n    function isJSXEmptyExpressionInSingleLineContainer(node) {\n      if (!node || !node.parent || node.type !== \"JSXEmptyExpression\" || node.parent.type !== \"JSXExpressionContainer\") {\n        return false;\n      }\n\n      const parent = node.parent;\n      return parent.loc.start.line === parent.loc.end.line;\n    }\n\n    function stripTrailingComment(line, comment) {\n      return line.slice(0, comment.loc.start.column).replace(/\\s+$/u, \"\");\n    }\n\n    function ensureArrayAndPush(object, key, value) {\n      if (!Array.isArray(object[key])) {\n        object[key] = [];\n      }\n\n      object[key].push(value);\n    }\n\n    function getAllStrings() {\n      return sourceCode.ast.tokens.filter(token => token.type === \"String\" || token.type === \"JSXText\" && sourceCode.getNodeByRangeIndex(token.range[0] - 1).type === \"JSXAttribute\");\n    }\n\n    function getAllTemplateLiterals() {\n      return sourceCode.ast.tokens.filter(token => token.type === \"Template\");\n    }\n\n    function getAllRegExpLiterals() {\n      return sourceCode.ast.tokens.filter(token => token.type === \"RegularExpression\");\n    }\n\n    function groupByLineNumber(acc, node) {\n      for (let i = node.loc.start.line; i <= node.loc.end.line; ++i) {\n        ensureArrayAndPush(acc, i, node);\n      }\n\n      return acc;\n    }\n\n    function getAllComments() {\n      const comments = [];\n      sourceCode.getAllComments().forEach(commentNode => {\n        const containingNode = sourceCode.getNodeByRangeIndex(commentNode.range[0]);\n\n        if (isJSXEmptyExpressionInSingleLineContainer(containingNode)) {\n          if (comments[comments.length - 1] !== containingNode.parent) {\n            comments.push(containingNode.parent);\n          }\n        } else {\n          comments.push(commentNode);\n        }\n      });\n      return comments;\n    }\n\n    return {\n      Program: function (node) {\n        const lines = sourceCode.lines,\n              comments = ignoreComments || maxCommentLength || ignoreTrailingComments ? getAllComments() : [];\n        let commentsIndex = 0;\n        const strings = getAllStrings();\n        const stringsByLine = strings.reduce(groupByLineNumber, {});\n        const templateLiterals = getAllTemplateLiterals();\n        const templateLiteralsByLine = templateLiterals.reduce(groupByLineNumber, {});\n        const regExpLiterals = getAllRegExpLiterals();\n        const regExpLiteralsByLine = regExpLiterals.reduce(groupByLineNumber, {});\n        lines.forEach((line, i) => {\n          const lineNumber = i + 1;\n          let lineIsComment = false;\n          let textToMeasure;\n\n          if (commentsIndex < comments.length) {\n            let comment = null;\n\n            do {\n              comment = comments[++commentsIndex];\n            } while (comment && comment.loc.start.line <= lineNumber);\n\n            comment = comments[--commentsIndex];\n\n            if (isFullLineComment(line, lineNumber, comment)) {\n              lineIsComment = true;\n              textToMeasure = line;\n            } else if (ignoreTrailingComments && isTrailingComment(line, lineNumber, comment)) {\n              textToMeasure = stripTrailingComment(line, comment);\n              let lastIndex = commentsIndex;\n\n              while (isTrailingComment(textToMeasure, lineNumber, comments[--lastIndex])) {\n                textToMeasure = stripTrailingComment(textToMeasure, comments[lastIndex]);\n              }\n            } else {\n              textToMeasure = line;\n            }\n          } else {\n            textToMeasure = line;\n          }\n\n          if (ignorePattern && ignorePattern.test(textToMeasure) || ignoreUrls && /[^:/?#]:\\/\\/[^?#]/u.test(textToMeasure) || ignoreStrings && stringsByLine[lineNumber] || ignoreTemplateLiterals && templateLiteralsByLine[lineNumber] || ignoreRegExpLiterals && regExpLiteralsByLine[lineNumber]) {\n            return;\n          }\n\n          const lineLength = computeLineLength(textToMeasure, tabWidth);\n          const commentLengthApplies = lineIsComment && maxCommentLength;\n\n          if (lineIsComment && ignoreComments) {\n            return;\n          }\n\n          const loc = {\n            start: {\n              line: lineNumber,\n              column: 0\n            },\n            end: {\n              line: lineNumber,\n              column: textToMeasure.length\n            }\n          };\n\n          if (commentLengthApplies) {\n            if (lineLength > maxCommentLength) {\n              context.report({\n                node,\n                loc,\n                messageId: \"maxComment\",\n                data: {\n                  lineLength,\n                  maxCommentLength\n                }\n              });\n            }\n          } else if (lineLength > maxLength) {\n            context.report({\n              node,\n              loc,\n              messageId: \"max\",\n              data: {\n                lineLength,\n                maxLength\n              }\n            });\n          }\n        });\n      }\n    };\n  }\n\n};\nmaxLen.meta;\nmaxLen.create;\nconst {\n  upperCaseFirst: upperCaseFirst$2\n} = stringUtils;\nconst OPTIONS_SCHEMA = {\n  type: \"object\",\n  properties: {\n    max: {\n      type: \"integer\",\n      minimum: 0\n    },\n    skipComments: {\n      type: \"boolean\"\n    },\n    skipBlankLines: {\n      type: \"boolean\"\n    },\n    IIFEs: {\n      type: \"boolean\"\n    }\n  },\n  additionalProperties: false\n};\nconst OPTIONS_OR_INTEGER_SCHEMA = {\n  oneOf: [OPTIONS_SCHEMA, {\n    type: \"integer\",\n    minimum: 1\n  }]\n};\n\nfunction getCommentLineNumbers(comments) {\n  const map = new Map();\n  comments.forEach(comment => {\n    for (let i = comment.loc.start.line; i <= comment.loc.end.line; i++) {\n      map.set(i, comment);\n    }\n  });\n  return map;\n}\n\nvar maxLinesPerFunction = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"enforce a maximum number of lines of code in a function\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/max-lines-per-function\"\n    },\n    schema: [OPTIONS_OR_INTEGER_SCHEMA],\n    messages: {\n      exceed: \"{{name}} has too many lines ({{lineCount}}). Maximum allowed is {{maxLines}}.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    const lines = sourceCode.lines;\n    const option = context.options[0];\n    let maxLines = 50;\n    let skipComments = false;\n    let skipBlankLines = false;\n    let IIFEs = false;\n\n    if (typeof option === \"object\") {\n      maxLines = typeof option.max === \"number\" ? option.max : 50;\n      skipComments = !!option.skipComments;\n      skipBlankLines = !!option.skipBlankLines;\n      IIFEs = !!option.IIFEs;\n    } else if (typeof option === \"number\") {\n      maxLines = option;\n    }\n\n    const commentLineNumbers = getCommentLineNumbers(sourceCode.getAllComments());\n\n    function isFullLineComment(line, lineNumber, comment) {\n      const start = comment.loc.start,\n            end = comment.loc.end,\n            isFirstTokenOnLine = start.line === lineNumber && !line.slice(0, start.column).trim(),\n            isLastTokenOnLine = end.line === lineNumber && !line.slice(end.column).trim();\n      return comment && (start.line < lineNumber || isFirstTokenOnLine) && (end.line > lineNumber || isLastTokenOnLine);\n    }\n\n    function isIIFE(node) {\n      return (node.type === \"FunctionExpression\" || node.type === \"ArrowFunctionExpression\") && node.parent && node.parent.type === \"CallExpression\" && node.parent.callee === node;\n    }\n\n    function isEmbedded(node) {\n      if (!node.parent) {\n        return false;\n      }\n\n      if (node !== node.parent.value) {\n        return false;\n      }\n\n      if (node.parent.type === \"MethodDefinition\") {\n        return true;\n      }\n\n      if (node.parent.type === \"Property\") {\n        return node.parent.method === true || node.parent.kind === \"get\" || node.parent.kind === \"set\";\n      }\n\n      return false;\n    }\n\n    function processFunction(funcNode) {\n      const node = isEmbedded(funcNode) ? funcNode.parent : funcNode;\n\n      if (!IIFEs && isIIFE(node)) {\n        return;\n      }\n\n      let lineCount = 0;\n\n      for (let i = node.loc.start.line - 1; i < node.loc.end.line; ++i) {\n        const line = lines[i];\n\n        if (skipComments) {\n          if (commentLineNumbers.has(i + 1) && isFullLineComment(line, i + 1, commentLineNumbers.get(i + 1))) {\n            continue;\n          }\n        }\n\n        if (skipBlankLines) {\n          if (line.match(/^\\s*$/u)) {\n            continue;\n          }\n        }\n\n        lineCount++;\n      }\n\n      if (lineCount > maxLines) {\n        const name = upperCaseFirst$2(astUtils.getFunctionNameWithKind(funcNode));\n        context.report({\n          node,\n          messageId: \"exceed\",\n          data: {\n            name,\n            lineCount,\n            maxLines\n          }\n        });\n      }\n    }\n\n    return {\n      FunctionDeclaration: processFunction,\n      FunctionExpression: processFunction,\n      ArrowFunctionExpression: processFunction\n    };\n  }\n\n};\nmaxLinesPerFunction.meta;\nmaxLinesPerFunction.create;\n\nfunction range(start, end) {\n  return [...Array(end - start).keys()].map(x => x + start);\n}\n\nvar maxLines = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"enforce a maximum number of lines per file\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/max-lines\"\n    },\n    schema: [{\n      oneOf: [{\n        type: \"integer\",\n        minimum: 0\n      }, {\n        type: \"object\",\n        properties: {\n          max: {\n            type: \"integer\",\n            minimum: 0\n          },\n          skipComments: {\n            type: \"boolean\"\n          },\n          skipBlankLines: {\n            type: \"boolean\"\n          }\n        },\n        additionalProperties: false\n      }]\n    }],\n    messages: {\n      exceed: \"File has too many lines ({{actual}}). Maximum allowed is {{max}}.\"\n    }\n  },\n\n  create(context) {\n    const option = context.options[0];\n    let max = 300;\n\n    if (typeof option === \"object\" && Object.prototype.hasOwnProperty.call(option, \"max\")) {\n      max = option.max;\n    } else if (typeof option === \"number\") {\n      max = option;\n    }\n\n    const skipComments = option && option.skipComments;\n    const skipBlankLines = option && option.skipBlankLines;\n    const sourceCode = context.getSourceCode();\n\n    function isCommentNodeType(token) {\n      return token && (token.type === \"Block\" || token.type === \"Line\");\n    }\n\n    function getLinesWithoutCode(comment) {\n      let start = comment.loc.start.line;\n      let end = comment.loc.end.line;\n      let token = comment;\n\n      do {\n        token = sourceCode.getTokenBefore(token, {\n          includeComments: true\n        });\n      } while (isCommentNodeType(token));\n\n      if (token && astUtils.isTokenOnSameLine(token, comment)) {\n        start += 1;\n      }\n\n      token = comment;\n\n      do {\n        token = sourceCode.getTokenAfter(token, {\n          includeComments: true\n        });\n      } while (isCommentNodeType(token));\n\n      if (token && astUtils.isTokenOnSameLine(comment, token)) {\n        end -= 1;\n      }\n\n      if (start <= end) {\n        return range(start, end + 1);\n      }\n\n      return [];\n    }\n\n    function flatMap(array, fn) {\n      const mapped = array.map(fn);\n      const flattened = [].concat(...mapped);\n      return flattened;\n    }\n\n    return {\n      \"Program:exit\"() {\n        let lines = sourceCode.lines.map((text, i) => ({\n          lineNumber: i + 1,\n          text\n        }));\n\n        if (lines.length > 1 && lines[lines.length - 1].text === \"\") {\n          lines.pop();\n        }\n\n        if (skipBlankLines) {\n          lines = lines.filter(l => l.text.trim() !== \"\");\n        }\n\n        if (skipComments) {\n          const comments = sourceCode.getAllComments();\n          const commentLines = flatMap(comments, comment => getLinesWithoutCode(comment));\n          lines = lines.filter(l => !commentLines.includes(l.lineNumber));\n        }\n\n        if (lines.length > max) {\n          const loc = {\n            start: {\n              line: lines[max].lineNumber,\n              column: 0\n            },\n            end: {\n              line: sourceCode.lines.length,\n              column: sourceCode.lines[sourceCode.lines.length - 1].length\n            }\n          };\n          context.report({\n            loc,\n            messageId: \"exceed\",\n            data: {\n              max,\n              actual: lines.length\n            }\n          });\n        }\n      }\n\n    };\n  }\n\n};\nmaxLines.meta;\nmaxLines.create;\nvar maxNestedCallbacks = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"enforce a maximum depth that callbacks can be nested\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/max-nested-callbacks\"\n    },\n    schema: [{\n      oneOf: [{\n        type: \"integer\",\n        minimum: 0\n      }, {\n        type: \"object\",\n        properties: {\n          maximum: {\n            type: \"integer\",\n            minimum: 0\n          },\n          max: {\n            type: \"integer\",\n            minimum: 0\n          }\n        },\n        additionalProperties: false\n      }]\n    }],\n    messages: {\n      exceed: \"Too many nested callbacks ({{num}}). Maximum allowed is {{max}}.\"\n    }\n  },\n\n  create(context) {\n    const option = context.options[0];\n    let THRESHOLD = 10;\n\n    if (typeof option === \"object\" && (Object.prototype.hasOwnProperty.call(option, \"maximum\") || Object.prototype.hasOwnProperty.call(option, \"max\"))) {\n      THRESHOLD = option.maximum || option.max;\n    } else if (typeof option === \"number\") {\n      THRESHOLD = option;\n    }\n\n    const callbackStack = [];\n\n    function checkFunction(node) {\n      const parent = node.parent;\n\n      if (parent.type === \"CallExpression\") {\n        callbackStack.push(node);\n      }\n\n      if (callbackStack.length > THRESHOLD) {\n        const opts = {\n          num: callbackStack.length,\n          max: THRESHOLD\n        };\n        context.report({\n          node,\n          messageId: \"exceed\",\n          data: opts\n        });\n      }\n    }\n\n    function popStack() {\n      callbackStack.pop();\n    }\n\n    return {\n      ArrowFunctionExpression: checkFunction,\n      \"ArrowFunctionExpression:exit\": popStack,\n      FunctionExpression: checkFunction,\n      \"FunctionExpression:exit\": popStack\n    };\n  }\n\n};\nmaxNestedCallbacks.meta;\nmaxNestedCallbacks.create;\nconst {\n  upperCaseFirst: upperCaseFirst$1\n} = stringUtils;\nvar maxParams = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"enforce a maximum number of parameters in function definitions\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/max-params\"\n    },\n    schema: [{\n      oneOf: [{\n        type: \"integer\",\n        minimum: 0\n      }, {\n        type: \"object\",\n        properties: {\n          maximum: {\n            type: \"integer\",\n            minimum: 0\n          },\n          max: {\n            type: \"integer\",\n            minimum: 0\n          }\n        },\n        additionalProperties: false\n      }]\n    }],\n    messages: {\n      exceed: \"{{name}} has too many parameters ({{count}}). Maximum allowed is {{max}}.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    const option = context.options[0];\n    let numParams = 3;\n\n    if (typeof option === \"object\" && (Object.prototype.hasOwnProperty.call(option, \"maximum\") || Object.prototype.hasOwnProperty.call(option, \"max\"))) {\n      numParams = option.maximum || option.max;\n    }\n\n    if (typeof option === \"number\") {\n      numParams = option;\n    }\n\n    function checkFunction(node) {\n      if (node.params.length > numParams) {\n        context.report({\n          loc: astUtils.getFunctionHeadLoc(node, sourceCode),\n          node,\n          messageId: \"exceed\",\n          data: {\n            name: upperCaseFirst$1(astUtils.getFunctionNameWithKind(node)),\n            count: node.params.length,\n            max: numParams\n          }\n        });\n      }\n    }\n\n    return {\n      FunctionDeclaration: checkFunction,\n      ArrowFunctionExpression: checkFunction,\n      FunctionExpression: checkFunction\n    };\n  }\n\n};\nmaxParams.meta;\nmaxParams.create;\nvar maxStatementsPerLine = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"enforce a maximum number of statements allowed per line\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/max-statements-per-line\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        max: {\n          type: \"integer\",\n          minimum: 1,\n          default: 1\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      exceed: \"This line has {{numberOfStatementsOnThisLine}} {{statements}}. Maximum allowed is {{maxStatementsPerLine}}.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode(),\n          options = context.options[0] || {},\n          maxStatementsPerLine = typeof options.max !== \"undefined\" ? options.max : 1;\n    let lastStatementLine = 0,\n        numberOfStatementsOnThisLine = 0,\n        firstExtraStatement;\n\n    function reportFirstExtraStatementAndClear() {\n      if (firstExtraStatement) {\n        context.report({\n          node: firstExtraStatement,\n          messageId: \"exceed\",\n          data: {\n            numberOfStatementsOnThisLine,\n            maxStatementsPerLine,\n            statements: numberOfStatementsOnThisLine === 1 ? \"statement\" : \"statements\"\n          }\n        });\n      }\n\n      firstExtraStatement = null;\n    }\n\n    function getActualLastToken(node) {\n      return sourceCode.getLastToken(node, astUtils.isNotSemicolonToken);\n    }\n\n    function enterStatement(node) {\n      const line = node.loc.start.line;\n\n      if (/^(?:(?:DoWhile|For|ForIn|ForOf|If|Labeled|While)Statement|Export(?:Default|Named)Declaration)$/u.test(node.parent.type) && node.parent.alternate !== node) {\n        return;\n      }\n\n      if (line === lastStatementLine) {\n        numberOfStatementsOnThisLine += 1;\n      } else {\n        reportFirstExtraStatementAndClear();\n        numberOfStatementsOnThisLine = 1;\n        lastStatementLine = line;\n      }\n\n      if (numberOfStatementsOnThisLine === maxStatementsPerLine + 1) {\n        firstExtraStatement = firstExtraStatement || node;\n      }\n    }\n\n    function leaveStatement(node) {\n      const line = getActualLastToken(node).loc.end.line;\n\n      if (line !== lastStatementLine) {\n        reportFirstExtraStatementAndClear();\n        numberOfStatementsOnThisLine = 1;\n        lastStatementLine = line;\n      }\n    }\n\n    return {\n      BreakStatement: enterStatement,\n      ClassDeclaration: enterStatement,\n      ContinueStatement: enterStatement,\n      DebuggerStatement: enterStatement,\n      DoWhileStatement: enterStatement,\n      ExpressionStatement: enterStatement,\n      ForInStatement: enterStatement,\n      ForOfStatement: enterStatement,\n      ForStatement: enterStatement,\n      FunctionDeclaration: enterStatement,\n      IfStatement: enterStatement,\n      ImportDeclaration: enterStatement,\n      LabeledStatement: enterStatement,\n      ReturnStatement: enterStatement,\n      SwitchStatement: enterStatement,\n      ThrowStatement: enterStatement,\n      TryStatement: enterStatement,\n      VariableDeclaration: enterStatement,\n      WhileStatement: enterStatement,\n      WithStatement: enterStatement,\n      ExportNamedDeclaration: enterStatement,\n      ExportDefaultDeclaration: enterStatement,\n      ExportAllDeclaration: enterStatement,\n      \"BreakStatement:exit\": leaveStatement,\n      \"ClassDeclaration:exit\": leaveStatement,\n      \"ContinueStatement:exit\": leaveStatement,\n      \"DebuggerStatement:exit\": leaveStatement,\n      \"DoWhileStatement:exit\": leaveStatement,\n      \"ExpressionStatement:exit\": leaveStatement,\n      \"ForInStatement:exit\": leaveStatement,\n      \"ForOfStatement:exit\": leaveStatement,\n      \"ForStatement:exit\": leaveStatement,\n      \"FunctionDeclaration:exit\": leaveStatement,\n      \"IfStatement:exit\": leaveStatement,\n      \"ImportDeclaration:exit\": leaveStatement,\n      \"LabeledStatement:exit\": leaveStatement,\n      \"ReturnStatement:exit\": leaveStatement,\n      \"SwitchStatement:exit\": leaveStatement,\n      \"ThrowStatement:exit\": leaveStatement,\n      \"TryStatement:exit\": leaveStatement,\n      \"VariableDeclaration:exit\": leaveStatement,\n      \"WhileStatement:exit\": leaveStatement,\n      \"WithStatement:exit\": leaveStatement,\n      \"ExportNamedDeclaration:exit\": leaveStatement,\n      \"ExportDefaultDeclaration:exit\": leaveStatement,\n      \"ExportAllDeclaration:exit\": leaveStatement,\n      \"Program:exit\": reportFirstExtraStatementAndClear\n    };\n  }\n\n};\nmaxStatementsPerLine.meta;\nmaxStatementsPerLine.create;\nconst {\n  upperCaseFirst\n} = stringUtils;\nvar maxStatements = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"enforce a maximum number of statements allowed in function blocks\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/max-statements\"\n    },\n    schema: [{\n      oneOf: [{\n        type: \"integer\",\n        minimum: 0\n      }, {\n        type: \"object\",\n        properties: {\n          maximum: {\n            type: \"integer\",\n            minimum: 0\n          },\n          max: {\n            type: \"integer\",\n            minimum: 0\n          }\n        },\n        additionalProperties: false\n      }]\n    }, {\n      type: \"object\",\n      properties: {\n        ignoreTopLevelFunctions: {\n          type: \"boolean\"\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      exceed: \"{{name}} has too many statements ({{count}}). Maximum allowed is {{max}}.\"\n    }\n  },\n\n  create(context) {\n    const functionStack = [],\n          option = context.options[0],\n          ignoreTopLevelFunctions = context.options[1] && context.options[1].ignoreTopLevelFunctions || false,\n          topLevelFunctions = [];\n    let maxStatements = 10;\n\n    if (typeof option === \"object\" && (Object.prototype.hasOwnProperty.call(option, \"maximum\") || Object.prototype.hasOwnProperty.call(option, \"max\"))) {\n      maxStatements = option.maximum || option.max;\n    } else if (typeof option === \"number\") {\n      maxStatements = option;\n    }\n\n    function reportIfTooManyStatements(node, count, max) {\n      if (count > max) {\n        const name = upperCaseFirst(astUtils.getFunctionNameWithKind(node));\n        context.report({\n          node,\n          messageId: \"exceed\",\n          data: {\n            name,\n            count,\n            max\n          }\n        });\n      }\n    }\n\n    function startFunction() {\n      functionStack.push(0);\n    }\n\n    function endFunction(node) {\n      const count = functionStack.pop();\n\n      if (ignoreTopLevelFunctions && functionStack.length === 0) {\n        topLevelFunctions.push({\n          node,\n          count\n        });\n      } else {\n        reportIfTooManyStatements(node, count, maxStatements);\n      }\n    }\n\n    return {\n      FunctionDeclaration: startFunction,\n      FunctionExpression: startFunction,\n      ArrowFunctionExpression: startFunction,\n      BlockStatement: function (node) {\n        functionStack[functionStack.length - 1] += node.body.length;\n      },\n      \"FunctionDeclaration:exit\": endFunction,\n      \"FunctionExpression:exit\": endFunction,\n      \"ArrowFunctionExpression:exit\": endFunction,\n\n      \"Program:exit\"() {\n        if (topLevelFunctions.length === 1) {\n          return;\n        }\n\n        topLevelFunctions.forEach(element => {\n          const count = element.count;\n          const node = element.node;\n          reportIfTooManyStatements(node, count, maxStatements);\n        });\n      }\n\n    };\n  }\n\n};\nmaxStatements.meta;\nmaxStatements.create;\nvar multilineCommentStyle = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"enforce a particular style for multiline comments\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/multiline-comment-style\"\n    },\n    fixable: \"whitespace\",\n    schema: [{\n      enum: [\"starred-block\", \"separate-lines\", \"bare-block\"]\n    }],\n    messages: {\n      expectedBlock: \"Expected a block comment instead of consecutive line comments.\",\n      expectedBareBlock: \"Expected a block comment without padding stars.\",\n      startNewline: \"Expected a linebreak after '/*'.\",\n      endNewline: \"Expected a linebreak before '*/'.\",\n      missingStar: \"Expected a '*' at the start of this line.\",\n      alignment: \"Expected this line to be aligned with the start of the comment.\",\n      expectedLines: \"Expected multiple line comments instead of a block comment.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    const option = context.options[0] || \"starred-block\";\n\n    function isStarredCommentLine(line) {\n      return /^\\s*\\*/u.test(line);\n    }\n\n    function isStarredBlockComment([firstComment]) {\n      if (firstComment.type !== \"Block\") {\n        return false;\n      }\n\n      const lines = firstComment.value.split(astUtils.LINEBREAK_MATCHER);\n      return lines.length > 0 && lines.every((line, i) => (i === 0 || i === lines.length - 1 ? /^\\s*$/u : /^\\s*\\*/u).test(line));\n    }\n\n    function isJSDocComment([firstComment]) {\n      if (firstComment.type !== \"Block\") {\n        return false;\n      }\n\n      const lines = firstComment.value.split(astUtils.LINEBREAK_MATCHER);\n      return /^\\*\\s*$/u.test(lines[0]) && lines.slice(1, -1).every(line => /^\\s* /u.test(line)) && /^\\s*$/u.test(lines[lines.length - 1]);\n    }\n\n    function processSeparateLineComments(commentGroup) {\n      const allLinesHaveLeadingSpace = commentGroup.map(({\n        value\n      }) => value).filter(line => line.trim().length).every(line => line.startsWith(\" \"));\n      return commentGroup.map(({\n        value\n      }) => allLinesHaveLeadingSpace ? value.replace(/^ /u, \"\") : value);\n    }\n\n    function processStarredBlockComment(comment) {\n      const lines = comment.value.split(astUtils.LINEBREAK_MATCHER).filter((line, i, linesArr) => !(i === 0 || i === linesArr.length - 1)).map(line => line.replace(/^\\s*$/u, \"\"));\n      const allLinesHaveLeadingSpace = lines.map(line => line.replace(/\\s*\\*/u, \"\")).filter(line => line.trim().length).every(line => line.startsWith(\" \"));\n      return lines.map(line => line.replace(allLinesHaveLeadingSpace ? /\\s*\\* ?/u : /\\s*\\*/u, \"\"));\n    }\n\n    function processBareBlockComment(comment) {\n      const lines = comment.value.split(astUtils.LINEBREAK_MATCHER).map(line => line.replace(/^\\s*$/u, \"\"));\n      const leadingWhitespace = `${sourceCode.text.slice(comment.range[0] - comment.loc.start.column, comment.range[0])}   `;\n      let offset = \"\";\n\n      for (const [i, line] of lines.entries()) {\n        if (!line.trim().length || i === 0) {\n          continue;\n        }\n\n        const [, lineOffset] = line.match(/^(\\s*\\*?\\s*)/u);\n\n        if (lineOffset.length < leadingWhitespace.length) {\n          const newOffset = leadingWhitespace.slice(lineOffset.length - leadingWhitespace.length);\n\n          if (newOffset.length > offset.length) {\n            offset = newOffset;\n          }\n        }\n      }\n\n      return lines.map(line => {\n        const match = line.match(/^(\\s*\\*?\\s*)(.*)/u);\n        const [, lineOffset, lineContents] = match;\n\n        if (lineOffset.length > leadingWhitespace.length) {\n          return `${lineOffset.slice(leadingWhitespace.length - (offset.length + lineOffset.length))}${lineContents}`;\n        }\n\n        if (lineOffset.length < leadingWhitespace.length) {\n          return `${lineOffset.slice(leadingWhitespace.length)}${lineContents}`;\n        }\n\n        return lineContents;\n      });\n    }\n\n    function getCommentLines(commentGroup) {\n      const [firstComment] = commentGroup;\n\n      if (firstComment.type === \"Line\") {\n        return processSeparateLineComments(commentGroup);\n      }\n\n      if (isStarredBlockComment(commentGroup)) {\n        return processStarredBlockComment(firstComment);\n      }\n\n      return processBareBlockComment(firstComment);\n    }\n\n    function getInitialOffset(comment) {\n      return sourceCode.text.slice(comment.range[0] - comment.loc.start.column, comment.range[0]);\n    }\n\n    function convertToStarredBlock(firstComment, commentLinesList) {\n      const initialOffset = getInitialOffset(firstComment);\n      return `/*\\n${commentLinesList.map(line => `${initialOffset} * ${line}`).join(\"\\n\")}\\n${initialOffset} */`;\n    }\n\n    function convertToSeparateLines(firstComment, commentLinesList) {\n      return commentLinesList.map(line => `// ${line}`).join(`\\n${getInitialOffset(firstComment)}`);\n    }\n\n    function convertToBlock(firstComment, commentLinesList) {\n      return `/* ${commentLinesList.join(`\\n${getInitialOffset(firstComment)}   `)} */`;\n    }\n\n    const commentGroupCheckers = {\n      \"starred-block\"(commentGroup) {\n        const [firstComment] = commentGroup;\n        const commentLines = getCommentLines(commentGroup);\n\n        if (commentLines.some(value => value.includes(\"*/\"))) {\n          return;\n        }\n\n        if (commentGroup.length > 1) {\n          context.report({\n            loc: {\n              start: firstComment.loc.start,\n              end: commentGroup[commentGroup.length - 1].loc.end\n            },\n            messageId: \"expectedBlock\",\n\n            fix(fixer) {\n              const range = [firstComment.range[0], commentGroup[commentGroup.length - 1].range[1]];\n              return commentLines.some(value => value.startsWith(\"/\")) ? null : fixer.replaceTextRange(range, convertToStarredBlock(firstComment, commentLines));\n            }\n\n          });\n        } else {\n          const lines = firstComment.value.split(astUtils.LINEBREAK_MATCHER);\n          const expectedLeadingWhitespace = getInitialOffset(firstComment);\n          const expectedLinePrefix = `${expectedLeadingWhitespace} *`;\n\n          if (!/^\\*?\\s*$/u.test(lines[0])) {\n            const start = firstComment.value.startsWith(\"*\") ? firstComment.range[0] + 1 : firstComment.range[0];\n            context.report({\n              loc: {\n                start: firstComment.loc.start,\n                end: {\n                  line: firstComment.loc.start.line,\n                  column: firstComment.loc.start.column + 2\n                }\n              },\n              messageId: \"startNewline\",\n              fix: fixer => fixer.insertTextAfterRange([start, start + 2], `\\n${expectedLinePrefix}`)\n            });\n          }\n\n          if (!/^\\s*$/u.test(lines[lines.length - 1])) {\n            context.report({\n              loc: {\n                start: {\n                  line: firstComment.loc.end.line,\n                  column: firstComment.loc.end.column - 2\n                },\n                end: firstComment.loc.end\n              },\n              messageId: \"endNewline\",\n              fix: fixer => fixer.replaceTextRange([firstComment.range[1] - 2, firstComment.range[1]], `\\n${expectedLinePrefix}/`)\n            });\n          }\n\n          for (let lineNumber = firstComment.loc.start.line + 1; lineNumber <= firstComment.loc.end.line; lineNumber++) {\n            const lineText = sourceCode.lines[lineNumber - 1];\n            const errorType = isStarredCommentLine(lineText) ? \"alignment\" : \"missingStar\";\n\n            if (!lineText.startsWith(expectedLinePrefix)) {\n              context.report({\n                loc: {\n                  start: {\n                    line: lineNumber,\n                    column: 0\n                  },\n                  end: {\n                    line: lineNumber,\n                    column: lineText.length\n                  }\n                },\n                messageId: errorType,\n\n                fix(fixer) {\n                  const lineStartIndex = sourceCode.getIndexFromLoc({\n                    line: lineNumber,\n                    column: 0\n                  });\n\n                  if (errorType === \"alignment\") {\n                    const [, commentTextPrefix = \"\"] = lineText.match(/^(\\s*\\*)/u) || [];\n                    const commentTextStartIndex = lineStartIndex + commentTextPrefix.length;\n                    return fixer.replaceTextRange([lineStartIndex, commentTextStartIndex], expectedLinePrefix);\n                  }\n\n                  const [, commentTextPrefix = \"\"] = lineText.match(/^(\\s*)/u) || [];\n                  const commentTextStartIndex = lineStartIndex + commentTextPrefix.length;\n                  let offset;\n\n                  for (const [idx, line] of lines.entries()) {\n                    if (!/\\S+/u.test(line)) {\n                      continue;\n                    }\n\n                    const lineTextToAlignWith = sourceCode.lines[firstComment.loc.start.line - 1 + idx];\n                    const [, prefix = \"\", initialOffset = \"\"] = lineTextToAlignWith.match(/^(\\s*(?:\\/?\\*)?(\\s*))/u) || [];\n                    offset = `${commentTextPrefix.slice(prefix.length)}${initialOffset}`;\n\n                    if (/^\\s*\\//u.test(lineText) && offset.length === 0) {\n                      offset += \" \";\n                    }\n\n                    break;\n                  }\n\n                  return fixer.replaceTextRange([lineStartIndex, commentTextStartIndex], `${expectedLinePrefix}${offset}`);\n                }\n\n              });\n            }\n          }\n        }\n      },\n\n      \"separate-lines\"(commentGroup) {\n        const [firstComment] = commentGroup;\n\n        if (firstComment.type !== \"Block\" || isJSDocComment(commentGroup)) {\n          return;\n        }\n\n        const commentLines = getCommentLines(commentGroup);\n        const tokenAfter = sourceCode.getTokenAfter(firstComment, {\n          includeComments: true\n        });\n\n        if (tokenAfter && firstComment.loc.end.line === tokenAfter.loc.start.line) {\n          return;\n        }\n\n        context.report({\n          loc: {\n            start: firstComment.loc.start,\n            end: {\n              line: firstComment.loc.start.line,\n              column: firstComment.loc.start.column + 2\n            }\n          },\n          messageId: \"expectedLines\",\n\n          fix(fixer) {\n            return fixer.replaceText(firstComment, convertToSeparateLines(firstComment, commentLines));\n          }\n\n        });\n      },\n\n      \"bare-block\"(commentGroup) {\n        if (isJSDocComment(commentGroup)) {\n          return;\n        }\n\n        const [firstComment] = commentGroup;\n        const commentLines = getCommentLines(commentGroup);\n\n        if (firstComment.type === \"Line\" && commentLines.length > 1 && !commentLines.some(value => value.includes(\"*/\"))) {\n          context.report({\n            loc: {\n              start: firstComment.loc.start,\n              end: commentGroup[commentGroup.length - 1].loc.end\n            },\n            messageId: \"expectedBlock\",\n\n            fix(fixer) {\n              return fixer.replaceTextRange([firstComment.range[0], commentGroup[commentGroup.length - 1].range[1]], convertToBlock(firstComment, commentLines));\n            }\n\n          });\n        }\n\n        if (isStarredBlockComment(commentGroup)) {\n          context.report({\n            loc: {\n              start: firstComment.loc.start,\n              end: {\n                line: firstComment.loc.start.line,\n                column: firstComment.loc.start.column + 2\n              }\n            },\n            messageId: \"expectedBareBlock\",\n\n            fix(fixer) {\n              return fixer.replaceText(firstComment, convertToBlock(firstComment, commentLines));\n            }\n\n          });\n        }\n      }\n\n    };\n    return {\n      Program() {\n        return sourceCode.getAllComments().filter(comment => comment.type !== \"Shebang\").filter(comment => !astUtils.COMMENTS_IGNORE_PATTERN.test(comment.value)).filter(comment => {\n          const tokenBefore = sourceCode.getTokenBefore(comment, {\n            includeComments: true\n          });\n          return !tokenBefore || tokenBefore.loc.end.line < comment.loc.start.line;\n        }).reduce((commentGroups, comment, index, commentList) => {\n          const tokenBefore = sourceCode.getTokenBefore(comment, {\n            includeComments: true\n          });\n\n          if (comment.type === \"Line\" && index && commentList[index - 1].type === \"Line\" && tokenBefore && tokenBefore.loc.end.line === comment.loc.start.line - 1 && tokenBefore === commentList[index - 1]) {\n            commentGroups[commentGroups.length - 1].push(comment);\n          } else {\n            commentGroups.push([comment]);\n          }\n\n          return commentGroups;\n        }, []).filter(commentGroup => !(commentGroup.length === 1 && commentGroup[0].loc.start.line === commentGroup[0].loc.end.line)).forEach(commentGroupCheckers[option]);\n      }\n\n    };\n  }\n\n};\nmultilineCommentStyle.meta;\nmultilineCommentStyle.create;\nvar multilineTernary = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"enforce newlines between operands of ternary expressions\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/multiline-ternary\"\n    },\n    schema: [{\n      enum: [\"always\", \"always-multiline\", \"never\"]\n    }],\n    messages: {\n      expectedTestCons: \"Expected newline between test and consequent of ternary expression.\",\n      expectedConsAlt: \"Expected newline between consequent and alternate of ternary expression.\",\n      unexpectedTestCons: \"Unexpected newline between test and consequent of ternary expression.\",\n      unexpectedConsAlt: \"Unexpected newline between consequent and alternate of ternary expression.\"\n    },\n    fixable: \"whitespace\"\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    const option = context.options[0];\n    return {\n      ConditionalExpression(node) {\n        const questionToken = sourceCode.getTokenAfter(node.test, astUtils.isNotClosingParenToken);\n        const colonToken = sourceCode.getTokenAfter(node.consequent, astUtils.isNotClosingParenToken);\n        const firstTokenOfTest = sourceCode.getFirstToken(node);\n        const lastTokenOfTest = sourceCode.getTokenBefore(questionToken);\n        const firstTokenOfConsequent = sourceCode.getTokenAfter(questionToken);\n        const lastTokenOfConsequent = sourceCode.getTokenBefore(colonToken);\n        const firstTokenOfAlternate = sourceCode.getTokenAfter(colonToken);\n        const areTestAndConsequentOnSameLine = astUtils.isTokenOnSameLine(lastTokenOfTest, firstTokenOfConsequent);\n        const areConsequentAndAlternateOnSameLine = astUtils.isTokenOnSameLine(lastTokenOfConsequent, firstTokenOfAlternate);\n        const hasComments = !!sourceCode.getCommentsInside(node).length;\n\n        if (!(option !== \"never\")) {\n          if (!areTestAndConsequentOnSameLine) {\n            context.report({\n              node: node.test,\n              loc: {\n                start: firstTokenOfTest.loc.start,\n                end: lastTokenOfTest.loc.end\n              },\n              messageId: \"unexpectedTestCons\",\n              fix: fixer => {\n                if (hasComments) {\n                  return null;\n                }\n\n                const fixers = [];\n                const areTestAndQuestionOnSameLine = astUtils.isTokenOnSameLine(lastTokenOfTest, questionToken);\n                const areQuestionAndConsOnSameLine = astUtils.isTokenOnSameLine(questionToken, firstTokenOfConsequent);\n\n                if (!areTestAndQuestionOnSameLine) {\n                  fixers.push(fixer.removeRange([lastTokenOfTest.range[1], questionToken.range[0]]));\n                }\n\n                if (!areQuestionAndConsOnSameLine) {\n                  fixers.push(fixer.removeRange([questionToken.range[1], firstTokenOfConsequent.range[0]]));\n                }\n\n                return fixers;\n              }\n            });\n          }\n\n          if (!areConsequentAndAlternateOnSameLine) {\n            context.report({\n              node: node.consequent,\n              loc: {\n                start: firstTokenOfConsequent.loc.start,\n                end: lastTokenOfConsequent.loc.end\n              },\n              messageId: \"unexpectedConsAlt\",\n              fix: fixer => {\n                if (hasComments) {\n                  return null;\n                }\n\n                const fixers = [];\n                const areConsAndColonOnSameLine = astUtils.isTokenOnSameLine(lastTokenOfConsequent, colonToken);\n                const areColonAndAltOnSameLine = astUtils.isTokenOnSameLine(colonToken, firstTokenOfAlternate);\n\n                if (!areConsAndColonOnSameLine) {\n                  fixers.push(fixer.removeRange([lastTokenOfConsequent.range[1], colonToken.range[0]]));\n                }\n\n                if (!areColonAndAltOnSameLine) {\n                  fixers.push(fixer.removeRange([colonToken.range[1], firstTokenOfAlternate.range[0]]));\n                }\n\n                return fixers;\n              }\n            });\n          }\n        } else {\n          if (option === \"always-multiline\" && node.loc.start.line === node.loc.end.line) {\n            return;\n          }\n\n          if (areTestAndConsequentOnSameLine) {\n            context.report({\n              node: node.test,\n              loc: {\n                start: firstTokenOfTest.loc.start,\n                end: lastTokenOfTest.loc.end\n              },\n              messageId: \"expectedTestCons\",\n              fix: fixer => hasComments ? null : fixer.replaceTextRange([lastTokenOfTest.range[1], questionToken.range[0]], \"\\n\")\n            });\n          }\n\n          if (areConsequentAndAlternateOnSameLine) {\n            context.report({\n              node: node.consequent,\n              loc: {\n                start: firstTokenOfConsequent.loc.start,\n                end: lastTokenOfConsequent.loc.end\n              },\n              messageId: \"expectedConsAlt\",\n              fix: fixer => hasComments ? null : fixer.replaceTextRange([lastTokenOfConsequent.range[1], colonToken.range[0]], \"\\n\")\n            });\n          }\n        }\n      }\n\n    };\n  }\n\n};\nmultilineTernary.meta;\nmultilineTernary.create;\nconst CAPS_ALLOWED = [\"Array\", \"Boolean\", \"Date\", \"Error\", \"Function\", \"Number\", \"Object\", \"RegExp\", \"String\", \"Symbol\", \"BigInt\"];\n\nfunction checkArray(obj, key, fallback) {\n  if (Object.prototype.hasOwnProperty.call(obj, key) && !Array.isArray(obj[key])) {\n    throw new TypeError(`${key}, if provided, must be an Array`);\n  }\n\n  return obj[key] || fallback;\n}\n\nfunction invert(map, key) {\n  map[key] = true;\n  return map;\n}\n\nfunction calculateCapIsNewExceptions(config) {\n  let capIsNewExceptions = checkArray(config, \"capIsNewExceptions\", CAPS_ALLOWED);\n\n  if (capIsNewExceptions !== CAPS_ALLOWED) {\n    capIsNewExceptions = capIsNewExceptions.concat(CAPS_ALLOWED);\n  }\n\n  return capIsNewExceptions.reduce(invert, {});\n}\n\nvar newCap = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"require constructor names to begin with a capital letter\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/new-cap\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        newIsCap: {\n          type: \"boolean\",\n          default: true\n        },\n        capIsNew: {\n          type: \"boolean\",\n          default: true\n        },\n        newIsCapExceptions: {\n          type: \"array\",\n          items: {\n            type: \"string\"\n          }\n        },\n        newIsCapExceptionPattern: {\n          type: \"string\"\n        },\n        capIsNewExceptions: {\n          type: \"array\",\n          items: {\n            type: \"string\"\n          }\n        },\n        capIsNewExceptionPattern: {\n          type: \"string\"\n        },\n        properties: {\n          type: \"boolean\",\n          default: true\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      upper: \"A function with a name starting with an uppercase letter should only be used as a constructor.\",\n      lower: \"A constructor name should not start with a lowercase letter.\"\n    }\n  },\n\n  create(context) {\n    const config = Object.assign({}, context.options[0]);\n    config.newIsCap = config.newIsCap !== false;\n    config.capIsNew = config.capIsNew !== false;\n    const skipProperties = config.properties === false;\n    const newIsCapExceptions = checkArray(config, \"newIsCapExceptions\", []).reduce(invert, {});\n    const newIsCapExceptionPattern = config.newIsCapExceptionPattern ? new RegExp(config.newIsCapExceptionPattern, \"u\") : null;\n    const capIsNewExceptions = calculateCapIsNewExceptions(config);\n    const capIsNewExceptionPattern = config.capIsNewExceptionPattern ? new RegExp(config.capIsNewExceptionPattern, \"u\") : null;\n    const listeners = {};\n    const sourceCode = context.getSourceCode();\n\n    function extractNameFromExpression(node) {\n      return node.callee.type === \"Identifier\" ? node.callee.name : astUtils.getStaticPropertyName(node.callee) || \"\";\n    }\n\n    function getCap(str) {\n      const firstChar = str.charAt(0);\n      const firstCharLower = firstChar.toLowerCase();\n      const firstCharUpper = firstChar.toUpperCase();\n\n      if (firstCharLower === firstCharUpper) {\n        return \"non-alpha\";\n      }\n\n      if (firstChar === firstCharLower) {\n        return \"lower\";\n      }\n\n      return \"upper\";\n    }\n\n    function isCapAllowed(allowedMap, node, calleeName, pattern) {\n      const sourceText = sourceCode.getText(node.callee);\n\n      if (allowedMap[calleeName] || allowedMap[sourceText]) {\n        return true;\n      }\n\n      if (pattern && pattern.test(sourceText)) {\n        return true;\n      }\n\n      const callee = astUtils.skipChainExpression(node.callee);\n\n      if (calleeName === \"UTC\" && callee.type === \"MemberExpression\") {\n        return callee.object.type === \"Identifier\" && callee.object.name === \"Date\";\n      }\n\n      return skipProperties && callee.type === \"MemberExpression\";\n    }\n\n    function report(node, messageId) {\n      let callee = astUtils.skipChainExpression(node.callee);\n\n      if (callee.type === \"MemberExpression\") {\n        callee = callee.property;\n      }\n\n      context.report({\n        node,\n        loc: callee.loc,\n        messageId\n      });\n    }\n\n    if (config.newIsCap) {\n      listeners.NewExpression = function (node) {\n        const constructorName = extractNameFromExpression(node);\n\n        if (constructorName) {\n          const capitalization = getCap(constructorName);\n          const isAllowed = capitalization !== \"lower\" || isCapAllowed(newIsCapExceptions, node, constructorName, newIsCapExceptionPattern);\n\n          if (!isAllowed) {\n            report(node, \"lower\");\n          }\n        }\n      };\n    }\n\n    if (config.capIsNew) {\n      listeners.CallExpression = function (node) {\n        const calleeName = extractNameFromExpression(node);\n\n        if (calleeName) {\n          const capitalization = getCap(calleeName);\n          const isAllowed = capitalization !== \"upper\" || isCapAllowed(capIsNewExceptions, node, calleeName, capIsNewExceptionPattern);\n\n          if (!isAllowed) {\n            report(node, \"upper\");\n          }\n        }\n      };\n    }\n\n    return listeners;\n  }\n\n};\nnewCap.meta;\nnewCap.create;\nvar newParens = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"enforce or disallow parentheses when invoking a constructor with no arguments\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/new-parens\"\n    },\n    fixable: \"code\",\n    schema: {\n      anyOf: [{\n        type: \"array\",\n        items: [{\n          enum: [\"always\", \"never\"]\n        }],\n        minItems: 0,\n        maxItems: 1\n      }]\n    },\n    messages: {\n      missing: \"Missing '()' invoking a constructor.\",\n      unnecessary: \"Unnecessary '()' invoking a constructor with no arguments.\"\n    }\n  },\n\n  create(context) {\n    const options = context.options;\n    const always = options[0] !== \"never\";\n    const sourceCode = context.getSourceCode();\n    return {\n      NewExpression(node) {\n        if (node.arguments.length !== 0) {\n          return;\n        }\n\n        const lastToken = sourceCode.getLastToken(node);\n        const hasLastParen = lastToken && astUtils.isClosingParenToken(lastToken);\n        const hasParens = hasLastParen && astUtils.isOpeningParenToken(sourceCode.getTokenBefore(lastToken)) && node.callee.range[1] < node.range[1];\n\n        if (always) {\n          if (!hasParens) {\n            context.report({\n              node,\n              messageId: \"missing\",\n              fix: fixer => fixer.insertTextAfter(node, \"()\")\n            });\n          }\n        } else {\n          if (hasParens) {\n            context.report({\n              node,\n              messageId: \"unnecessary\",\n              fix: fixer => [fixer.remove(sourceCode.getTokenBefore(lastToken)), fixer.remove(lastToken), fixer.insertTextBefore(node, \"(\"), fixer.insertTextAfter(node, \")\")]\n            });\n          }\n        }\n      }\n\n    };\n  }\n\n};\nnewParens.meta;\nnewParens.create;\nvar newlineAfterVar = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"require or disallow an empty line after variable declarations\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/newline-after-var\"\n    },\n    schema: [{\n      enum: [\"never\", \"always\"]\n    }],\n    fixable: \"whitespace\",\n    messages: {\n      expected: \"Expected blank line after variable declarations.\",\n      unexpected: \"Unexpected blank line after variable declarations.\"\n    },\n    deprecated: true,\n    replacedBy: [\"padding-line-between-statements\"]\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    const mode = context.options[0] === \"never\" ? \"never\" : \"always\";\n    const commentEndLine = sourceCode.getAllComments().reduce((result, token) => {\n      result[token.loc.start.line] = token.loc.end.line;\n      return result;\n    }, {});\n\n    function getLastToken(node) {\n      const lastToken = sourceCode.getLastToken(node);\n\n      if (lastToken.type === \"Punctuator\" && lastToken.value === \";\") {\n        const prevToken = sourceCode.getTokenBefore(lastToken);\n\n        if (prevToken.loc.end.line !== lastToken.loc.start.line) {\n          return prevToken;\n        }\n      }\n\n      return lastToken;\n    }\n\n    function isVar(keyword) {\n      return keyword === \"var\" || keyword === \"let\" || keyword === \"const\";\n    }\n\n    function isForTypeSpecifier(keyword) {\n      return keyword === \"ForStatement\" || keyword === \"ForInStatement\" || keyword === \"ForOfStatement\";\n    }\n\n    function isExportSpecifier(nodeType) {\n      return nodeType === \"ExportNamedDeclaration\" || nodeType === \"ExportSpecifier\" || nodeType === \"ExportDefaultDeclaration\" || nodeType === \"ExportAllDeclaration\";\n    }\n\n    function isLastNode(node) {\n      const token = sourceCode.getTokenAfter(node);\n      return !token || token.type === \"Punctuator\" && token.value === \"}\";\n    }\n\n    function getLastCommentLineOfBlock(commentStartLine) {\n      const currentCommentEnd = commentEndLine[commentStartLine];\n      return commentEndLine[currentCommentEnd + 1] ? getLastCommentLineOfBlock(currentCommentEnd + 1) : currentCommentEnd;\n    }\n\n    function hasBlankLineAfterComment(token, commentStartLine) {\n      return token.loc.start.line > getLastCommentLineOfBlock(commentStartLine) + 1;\n    }\n\n    return {\n      VariableDeclaration: function (node) {\n        const lastToken = getLastToken(node),\n              nextToken = lastToken === sourceCode.getLastToken(node) ? sourceCode.getTokenAfter(node) : sourceCode.getLastToken(node),\n              nextLineNum = lastToken.loc.end.line + 1;\n\n        if (!nextToken) {\n          return;\n        }\n\n        if (isForTypeSpecifier(node.parent.type)) {\n          return;\n        }\n\n        if (isExportSpecifier(node.parent.type)) {\n          return;\n        }\n\n        if (nextToken.type === \"Keyword\" && isVar(nextToken.value)) {\n          return;\n        }\n\n        if (isLastNode(node)) {\n          return;\n        }\n\n        const noNextLineToken = nextToken.loc.start.line > nextLineNum;\n        const hasNextLineComment = typeof commentEndLine[nextLineNum] !== \"undefined\";\n\n        if (mode === \"never\" && noNextLineToken && !hasNextLineComment) {\n          context.report({\n            node,\n            messageId: \"unexpected\",\n            data: {\n              identifier: node.name\n            },\n\n            fix(fixer) {\n              const linesBetween = sourceCode.getText().slice(lastToken.range[1], nextToken.range[0]).split(astUtils.LINEBREAK_MATCHER);\n              return fixer.replaceTextRange([lastToken.range[1], nextToken.range[0]], `${linesBetween.slice(0, -1).join(\"\")}\\n${linesBetween[linesBetween.length - 1]}`);\n            }\n\n          });\n        }\n\n        if (mode === \"always\" && (!noNextLineToken || hasNextLineComment && !hasBlankLineAfterComment(nextToken, nextLineNum))) {\n          context.report({\n            node,\n            messageId: \"expected\",\n            data: {\n              identifier: node.name\n            },\n\n            fix(fixer) {\n              if ((noNextLineToken ? getLastCommentLineOfBlock(nextLineNum) : lastToken.loc.end.line) === nextToken.loc.start.line) {\n                return fixer.insertTextBefore(nextToken, \"\\n\\n\");\n              }\n\n              return fixer.insertTextBeforeRange([nextToken.range[0] - nextToken.loc.start.column, nextToken.range[1]], \"\\n\");\n            }\n\n          });\n        }\n      }\n    };\n  }\n\n};\nnewlineAfterVar.meta;\nnewlineAfterVar.create;\nvar newlineBeforeReturn = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"require an empty line before `return` statements\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/newline-before-return\"\n    },\n    fixable: \"whitespace\",\n    schema: [],\n    messages: {\n      expected: \"Expected newline before return statement.\"\n    },\n    deprecated: true,\n    replacedBy: [\"padding-line-between-statements\"]\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n\n    function isPrecededByTokens(node, testTokens) {\n      const tokenBefore = sourceCode.getTokenBefore(node);\n      return testTokens.some(token => tokenBefore.value === token);\n    }\n\n    function isFirstNode(node) {\n      const parentType = node.parent.type;\n\n      if (node.parent.body) {\n        return Array.isArray(node.parent.body) ? node.parent.body[0] === node : node.parent.body === node;\n      }\n\n      if (parentType === \"IfStatement\") {\n        return isPrecededByTokens(node, [\"else\", \")\"]);\n      }\n\n      if (parentType === \"DoWhileStatement\") {\n        return isPrecededByTokens(node, [\"do\"]);\n      }\n\n      if (parentType === \"SwitchCase\") {\n        return isPrecededByTokens(node, [\":\"]);\n      }\n\n      return isPrecededByTokens(node, [\")\"]);\n    }\n\n    function calcCommentLines(node, lineNumTokenBefore) {\n      const comments = sourceCode.getCommentsBefore(node);\n      let numLinesComments = 0;\n\n      if (!comments.length) {\n        return numLinesComments;\n      }\n\n      comments.forEach(comment => {\n        numLinesComments++;\n\n        if (comment.type === \"Block\") {\n          numLinesComments += comment.loc.end.line - comment.loc.start.line;\n        }\n\n        if (comment.loc.start.line === lineNumTokenBefore) {\n          numLinesComments--;\n        }\n\n        if (comment.loc.end.line === node.loc.start.line) {\n          numLinesComments--;\n        }\n      });\n      return numLinesComments;\n    }\n\n    function getLineNumberOfTokenBefore(node) {\n      const tokenBefore = sourceCode.getTokenBefore(node);\n      let lineNumTokenBefore;\n\n      if (tokenBefore) {\n        lineNumTokenBefore = tokenBefore.loc.end.line;\n      } else {\n        lineNumTokenBefore = 0;\n      }\n\n      return lineNumTokenBefore;\n    }\n\n    function hasNewlineBefore(node) {\n      const lineNumNode = node.loc.start.line;\n      const lineNumTokenBefore = getLineNumberOfTokenBefore(node);\n      const commentLines = calcCommentLines(node, lineNumTokenBefore);\n      return lineNumNode - lineNumTokenBefore - commentLines > 1;\n    }\n\n    function canFix(node) {\n      const leadingComments = sourceCode.getCommentsBefore(node);\n      const lastLeadingComment = leadingComments[leadingComments.length - 1];\n      const tokenBefore = sourceCode.getTokenBefore(node);\n\n      if (leadingComments.length === 0) {\n        return true;\n      }\n\n      if (lastLeadingComment.loc.end.line === tokenBefore.loc.end.line && lastLeadingComment.loc.end.line !== node.loc.start.line) {\n        return true;\n      }\n\n      return false;\n    }\n\n    return {\n      ReturnStatement(node) {\n        if (!isFirstNode(node) && !hasNewlineBefore(node)) {\n          context.report({\n            node,\n            messageId: \"expected\",\n\n            fix(fixer) {\n              if (canFix(node)) {\n                const tokenBefore = sourceCode.getTokenBefore(node);\n                const newlines = node.loc.start.line === tokenBefore.loc.end.line ? \"\\n\\n\" : \"\\n\";\n                return fixer.insertTextBefore(node, newlines);\n              }\n\n              return null;\n            }\n\n          });\n        }\n      }\n\n    };\n  }\n\n};\nnewlineBeforeReturn.meta;\nnewlineBeforeReturn.create;\nvar newlinePerChainedCall = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"require a newline after each call in a method chain\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/newline-per-chained-call\"\n    },\n    fixable: \"whitespace\",\n    schema: [{\n      type: \"object\",\n      properties: {\n        ignoreChainWithDepth: {\n          type: \"integer\",\n          minimum: 1,\n          maximum: 10,\n          default: 2\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      expected: \"Expected line break before `{{callee}}`.\"\n    }\n  },\n\n  create(context) {\n    const options = context.options[0] || {},\n          ignoreChainWithDepth = options.ignoreChainWithDepth || 2;\n    const sourceCode = context.getSourceCode();\n\n    function getPrefix(node) {\n      if (node.computed) {\n        if (node.optional) {\n          return \"?.[\";\n        }\n\n        return \"[\";\n      }\n\n      if (node.optional) {\n        return \"?.\";\n      }\n\n      return \".\";\n    }\n\n    function getPropertyText(node) {\n      const prefix = getPrefix(node);\n      const lines = sourceCode.getText(node.property).split(astUtils.LINEBREAK_MATCHER);\n      const suffix = node.computed && lines.length === 1 ? \"]\" : \"\";\n      return prefix + lines[0] + suffix;\n    }\n\n    return {\n      \"CallExpression:exit\"(node) {\n        const callee = astUtils.skipChainExpression(node.callee);\n\n        if (callee.type !== \"MemberExpression\") {\n          return;\n        }\n\n        let parent = astUtils.skipChainExpression(callee.object);\n        let depth = 1;\n\n        while (parent && parent.callee) {\n          depth += 1;\n          parent = astUtils.skipChainExpression(astUtils.skipChainExpression(parent.callee).object);\n        }\n\n        if (depth > ignoreChainWithDepth && astUtils.isTokenOnSameLine(callee.object, callee.property)) {\n          const firstTokenAfterObject = sourceCode.getTokenAfter(callee.object, astUtils.isNotClosingParenToken);\n          context.report({\n            node: callee.property,\n            loc: {\n              start: firstTokenAfterObject.loc.start,\n              end: callee.loc.end\n            },\n            messageId: \"expected\",\n            data: {\n              callee: getPropertyText(callee)\n            },\n\n            fix(fixer) {\n              return fixer.insertTextBefore(firstTokenAfterObject, \"\\n\");\n            }\n\n          });\n        }\n      }\n\n    };\n  }\n\n};\nnewlinePerChainedCall.meta;\nnewlinePerChainedCall.create;\nconst {\n  getStaticPropertyName: getPropertyName$2,\n  getVariableByName,\n  skipChainExpression\n} = astUtils;\n\nfunction isProhibitedIdentifier(name) {\n  return /^(alert|confirm|prompt)$/u.test(name);\n}\n\nfunction findReference(scope, node) {\n  const references = scope.references.filter(reference => reference.identifier.range[0] === node.range[0] && reference.identifier.range[1] === node.range[1]);\n\n  if (references.length === 1) {\n    return references[0];\n  }\n\n  return null;\n}\n\nfunction isShadowed$1(scope, node) {\n  const reference = findReference(scope, node);\n  return reference && reference.resolved && reference.resolved.defs.length > 0;\n}\n\nfunction isGlobalThisReferenceOrGlobalWindow(scope, node) {\n  if (scope.type === \"global\" && node.type === \"ThisExpression\") {\n    return true;\n  }\n\n  if (node.type === \"Identifier\" && (node.name === \"window\" || node.name === \"globalThis\" && getVariableByName(scope, \"globalThis\"))) {\n    return !isShadowed$1(scope, node);\n  }\n\n  return false;\n}\n\nvar noAlert = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow the use of `alert`, `confirm`, and `prompt`\",\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-alert\"\n    },\n    schema: [],\n    messages: {\n      unexpected: \"Unexpected {{name}}.\"\n    }\n  },\n\n  create(context) {\n    return {\n      CallExpression(node) {\n        const callee = skipChainExpression(node.callee),\n              currentScope = context.getScope();\n\n        if (callee.type === \"Identifier\") {\n          const name = callee.name;\n\n          if (!isShadowed$1(currentScope, callee) && isProhibitedIdentifier(callee.name)) {\n            context.report({\n              node,\n              messageId: \"unexpected\",\n              data: {\n                name\n              }\n            });\n          }\n        } else if (callee.type === \"MemberExpression\" && isGlobalThisReferenceOrGlobalWindow(currentScope, callee.object)) {\n          const name = getPropertyName$2(callee);\n\n          if (isProhibitedIdentifier(name)) {\n            context.report({\n              node,\n              messageId: \"unexpected\",\n              data: {\n                name\n              }\n            });\n          }\n        }\n      }\n\n    };\n  }\n\n};\nnoAlert.meta;\nnoAlert.create;\nvar noArrayConstructor = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow `Array` constructors\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-array-constructor\"\n    },\n    schema: [],\n    messages: {\n      preferLiteral: \"The array literal notation [] is preferable.\"\n    }\n  },\n\n  create(context) {\n    function check(node) {\n      if (node.arguments.length !== 1 && node.callee.type === \"Identifier\" && node.callee.name === \"Array\") {\n        context.report({\n          node,\n          messageId: \"preferLiteral\"\n        });\n      }\n    }\n\n    return {\n      CallExpression: check,\n      NewExpression: check\n    };\n  }\n\n};\nnoArrayConstructor.meta;\nnoArrayConstructor.create;\nvar noAsyncPromiseExecutor = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"disallow using an async function as a Promise executor\",\n      category: \"Possible Errors\",\n      recommended: true,\n      url: \"https://eslint.org/docs/rules/no-async-promise-executor\"\n    },\n    fixable: null,\n    schema: [],\n    messages: {\n      async: \"Promise executor functions should not be async.\"\n    }\n  },\n\n  create(context) {\n    return {\n      \"NewExpression[callee.name='Promise'][arguments.0.async=true]\"(node) {\n        context.report({\n          node: context.getSourceCode().getFirstToken(node.arguments[0], token => token.value === \"async\"),\n          messageId: \"async\"\n        });\n      }\n\n    };\n  }\n\n};\nnoAsyncPromiseExecutor.meta;\nnoAsyncPromiseExecutor.create;\n\nfunction isBoundary(node) {\n  const t = node.type;\n  return t === \"FunctionDeclaration\" || t === \"FunctionExpression\" || t === \"ArrowFunctionExpression\" || t === \"ForOfStatement\" && node.await === true;\n}\n\nfunction isLooped(node, parent) {\n  switch (parent.type) {\n    case \"ForStatement\":\n      return node === parent.test || node === parent.update || node === parent.body;\n\n    case \"ForOfStatement\":\n    case \"ForInStatement\":\n      return node === parent.body;\n\n    case \"WhileStatement\":\n    case \"DoWhileStatement\":\n      return node === parent.test || node === parent.body;\n\n    default:\n      return false;\n  }\n}\n\nvar noAwaitInLoop = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"disallow `await` inside of loops\",\n      category: \"Possible Errors\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-await-in-loop\"\n    },\n    schema: [],\n    messages: {\n      unexpectedAwait: \"Unexpected `await` inside a loop.\"\n    }\n  },\n\n  create(context) {\n    function validate(awaitNode) {\n      if (awaitNode.type === \"ForOfStatement\" && !awaitNode.await) {\n        return;\n      }\n\n      let node = awaitNode;\n      let parent = node.parent;\n\n      while (parent && !isBoundary(parent)) {\n        if (isLooped(node, parent)) {\n          context.report({\n            node: awaitNode,\n            messageId: \"unexpectedAwait\"\n          });\n          return;\n        }\n\n        node = parent;\n        parent = parent.parent;\n      }\n    }\n\n    return {\n      AwaitExpression: validate,\n      ForOfStatement: validate\n    };\n  }\n\n};\nnoAwaitInLoop.meta;\nnoAwaitInLoop.create;\nconst BITWISE_OPERATORS$1 = [\"^\", \"|\", \"&\", \"<<\", \">>\", \">>>\", \"^=\", \"|=\", \"&=\", \"<<=\", \">>=\", \">>>=\", \"~\"];\nvar noBitwise = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow bitwise operators\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-bitwise\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        allow: {\n          type: \"array\",\n          items: {\n            enum: BITWISE_OPERATORS$1\n          },\n          uniqueItems: true\n        },\n        int32Hint: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      unexpected: \"Unexpected use of '{{operator}}'.\"\n    }\n  },\n\n  create(context) {\n    const options = context.options[0] || {};\n    const allowed = options.allow || [];\n    const int32Hint = options.int32Hint === true;\n\n    function report(node) {\n      context.report({\n        node,\n        messageId: \"unexpected\",\n        data: {\n          operator: node.operator\n        }\n      });\n    }\n\n    function hasBitwiseOperator(node) {\n      return BITWISE_OPERATORS$1.indexOf(node.operator) !== -1;\n    }\n\n    function allowedOperator(node) {\n      return allowed.indexOf(node.operator) !== -1;\n    }\n\n    function isInt32Hint(node) {\n      return int32Hint && node.operator === \"|\" && node.right && node.right.type === \"Literal\" && node.right.value === 0;\n    }\n\n    function checkNodeForBitwiseOperator(node) {\n      if (hasBitwiseOperator(node) && !allowedOperator(node) && !isInt32Hint(node)) {\n        report(node);\n      }\n    }\n\n    return {\n      AssignmentExpression: checkNodeForBitwiseOperator,\n      BinaryExpression: checkNodeForBitwiseOperator,\n      UnaryExpression: checkNodeForBitwiseOperator\n    };\n  }\n\n};\nnoBitwise.meta;\nnoBitwise.create;\nvar noBufferConstructor = {\n  meta: {\n    deprecated: true,\n    replacedBy: [],\n    type: \"problem\",\n    docs: {\n      description: \"disallow use of the `Buffer()` constructor\",\n      category: \"Node.js and CommonJS\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-buffer-constructor\"\n    },\n    schema: [],\n    messages: {\n      deprecated: \"{{expr}} is deprecated. Use Buffer.from(), Buffer.alloc(), or Buffer.allocUnsafe() instead.\"\n    }\n  },\n\n  create(context) {\n    return {\n      \"CallExpression[callee.name='Buffer'], NewExpression[callee.name='Buffer']\"(node) {\n        context.report({\n          node,\n          messageId: \"deprecated\",\n          data: {\n            expr: node.type === \"CallExpression\" ? \"Buffer()\" : \"new Buffer()\"\n          }\n        });\n      }\n\n    };\n  }\n\n};\nnoBufferConstructor.meta;\nnoBufferConstructor.create;\nvar noCaller = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow the use of `arguments.caller` or `arguments.callee`\",\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-caller\"\n    },\n    schema: [],\n    messages: {\n      unexpected: \"Avoid arguments.{{prop}}.\"\n    }\n  },\n\n  create(context) {\n    return {\n      MemberExpression(node) {\n        const objectName = node.object.name,\n              propertyName = node.property.name;\n\n        if (objectName === \"arguments\" && !node.computed && propertyName && propertyName.match(/^calle[er]$/u)) {\n          context.report({\n            node,\n            messageId: \"unexpected\",\n            data: {\n              prop: propertyName\n            }\n          });\n        }\n      }\n\n    };\n  }\n\n};\nnoCaller.meta;\nnoCaller.create;\nvar noCaseDeclarations = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow lexical declarations in case clauses\",\n      category: \"Best Practices\",\n      recommended: true,\n      url: \"https://eslint.org/docs/rules/no-case-declarations\"\n    },\n    schema: [],\n    messages: {\n      unexpected: \"Unexpected lexical declaration in case block.\"\n    }\n  },\n\n  create(context) {\n    function isLexicalDeclaration(node) {\n      switch (node.type) {\n        case \"FunctionDeclaration\":\n        case \"ClassDeclaration\":\n          return true;\n\n        case \"VariableDeclaration\":\n          return node.kind !== \"var\";\n\n        default:\n          return false;\n      }\n    }\n\n    return {\n      SwitchCase(node) {\n        for (let i = 0; i < node.consequent.length; i++) {\n          const statement = node.consequent[i];\n\n          if (isLexicalDeclaration(statement)) {\n            context.report({\n              node: statement,\n              messageId: \"unexpected\"\n            });\n          }\n        }\n      }\n\n    };\n  }\n\n};\nnoCaseDeclarations.meta;\nnoCaseDeclarations.create;\nvar noCatchShadow = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow `catch` clause parameters from shadowing variables in the outer scope\",\n      category: \"Variables\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-catch-shadow\"\n    },\n    replacedBy: [\"no-shadow\"],\n    deprecated: true,\n    schema: [],\n    messages: {\n      mutable: \"Value of '{{name}}' may be overwritten in IE 8 and earlier.\"\n    }\n  },\n\n  create(context) {\n    function paramIsShadowing(scope, name) {\n      return astUtils.getVariableByName(scope, name) !== null;\n    }\n\n    return {\n      \"CatchClause[param!=null]\"(node) {\n        let scope = context.getScope();\n\n        if (scope.block === node) {\n          scope = scope.upper;\n        }\n\n        if (paramIsShadowing(scope, node.param.name)) {\n          context.report({\n            node,\n            messageId: \"mutable\",\n            data: {\n              name: node.param.name\n            }\n          });\n        }\n      }\n\n    };\n  }\n\n};\nnoCatchShadow.meta;\nnoCatchShadow.create;\nvar noClassAssign = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"disallow reassigning class members\",\n      category: \"ECMAScript 6\",\n      recommended: true,\n      url: \"https://eslint.org/docs/rules/no-class-assign\"\n    },\n    schema: [],\n    messages: {\n      class: \"'{{name}}' is a class.\"\n    }\n  },\n\n  create(context) {\n    function checkVariable(variable) {\n      astUtils.getModifyingReferences(variable.references).forEach(reference => {\n        context.report({\n          node: reference.identifier,\n          messageId: \"class\",\n          data: {\n            name: reference.identifier.name\n          }\n        });\n      });\n    }\n\n    function checkForClass(node) {\n      context.getDeclaredVariables(node).forEach(checkVariable);\n    }\n\n    return {\n      ClassDeclaration: checkForClass,\n      ClassExpression: checkForClass\n    };\n  }\n\n};\nnoClassAssign.meta;\nnoClassAssign.create;\nvar noCompareNegZero = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"disallow comparing against -0\",\n      category: \"Possible Errors\",\n      recommended: true,\n      url: \"https://eslint.org/docs/rules/no-compare-neg-zero\"\n    },\n    fixable: null,\n    schema: [],\n    messages: {\n      unexpected: \"Do not use the '{{operator}}' operator to compare against -0.\"\n    }\n  },\n\n  create(context) {\n    function isNegZero(node) {\n      return node.type === \"UnaryExpression\" && node.operator === \"-\" && node.argument.type === \"Literal\" && node.argument.value === 0;\n    }\n\n    const OPERATORS_TO_CHECK = new Set([\">\", \">=\", \"<\", \"<=\", \"==\", \"===\", \"!=\", \"!==\"]);\n    return {\n      BinaryExpression(node) {\n        if (OPERATORS_TO_CHECK.has(node.operator)) {\n          if (isNegZero(node.left) || isNegZero(node.right)) {\n            context.report({\n              node,\n              messageId: \"unexpected\",\n              data: {\n                operator: node.operator\n              }\n            });\n          }\n        }\n      }\n\n    };\n  }\n\n};\nnoCompareNegZero.meta;\nnoCompareNegZero.create;\nconst TEST_CONDITION_PARENT_TYPES = new Set([\"IfStatement\", \"WhileStatement\", \"DoWhileStatement\", \"ForStatement\", \"ConditionalExpression\"]);\nconst NODE_DESCRIPTIONS = {\n  DoWhileStatement: \"a 'do...while' statement\",\n  ForStatement: \"a 'for' statement\",\n  IfStatement: \"an 'if' statement\",\n  WhileStatement: \"a 'while' statement\"\n};\nvar noCondAssign = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"disallow assignment operators in conditional expressions\",\n      category: \"Possible Errors\",\n      recommended: true,\n      url: \"https://eslint.org/docs/rules/no-cond-assign\"\n    },\n    schema: [{\n      enum: [\"except-parens\", \"always\"]\n    }],\n    messages: {\n      unexpected: \"Unexpected assignment within {{type}}.\",\n      missing: \"Expected a conditional expression and instead saw an assignment.\"\n    }\n  },\n\n  create(context) {\n    const prohibitAssign = context.options[0] || \"except-parens\";\n    const sourceCode = context.getSourceCode();\n\n    function isConditionalTestExpression(node) {\n      return node.parent && TEST_CONDITION_PARENT_TYPES.has(node.parent.type) && node === node.parent.test;\n    }\n\n    function findConditionalAncestor(node) {\n      let currentAncestor = node;\n\n      do {\n        if (isConditionalTestExpression(currentAncestor)) {\n          return currentAncestor.parent;\n        }\n      } while ((currentAncestor = currentAncestor.parent) && !astUtils.isFunction(currentAncestor));\n\n      return null;\n    }\n\n    function isParenthesisedTwice(node) {\n      const previousToken = sourceCode.getTokenBefore(node, 1),\n            nextToken = sourceCode.getTokenAfter(node, 1);\n      return astUtils.isParenthesised(sourceCode, node) && previousToken && astUtils.isOpeningParenToken(previousToken) && previousToken.range[1] <= node.range[0] && astUtils.isClosingParenToken(nextToken) && nextToken.range[0] >= node.range[1];\n    }\n\n    function testForAssign(node) {\n      if (node.test && node.test.type === \"AssignmentExpression\" && (node.type === \"ForStatement\" ? !astUtils.isParenthesised(sourceCode, node.test) : !isParenthesisedTwice(node.test))) {\n        context.report({\n          node: node.test,\n          messageId: \"missing\"\n        });\n      }\n    }\n\n    function testForConditionalAncestor(node) {\n      const ancestor = findConditionalAncestor(node);\n\n      if (ancestor) {\n        context.report({\n          node,\n          messageId: \"unexpected\",\n          data: {\n            type: NODE_DESCRIPTIONS[ancestor.type] || ancestor.type\n          }\n        });\n      }\n    }\n\n    if (prohibitAssign === \"always\") {\n      return {\n        AssignmentExpression: testForConditionalAncestor\n      };\n    }\n\n    return {\n      DoWhileStatement: testForAssign,\n      ForStatement: testForAssign,\n      IfStatement: testForAssign,\n      WhileStatement: testForAssign,\n      ConditionalExpression: testForAssign\n    };\n  }\n\n};\nnoCondAssign.meta;\nnoCondAssign.create;\n\nfunction isConditional(node) {\n  return node && node.type === \"ConditionalExpression\";\n}\n\nvar noConfusingArrow = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow arrow functions where they could be confused with comparisons\",\n      category: \"ECMAScript 6\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-confusing-arrow\"\n    },\n    fixable: \"code\",\n    schema: [{\n      type: \"object\",\n      properties: {\n        allowParens: {\n          type: \"boolean\",\n          default: true\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      confusing: \"Arrow function used ambiguously with a conditional expression.\"\n    }\n  },\n\n  create(context) {\n    const config = context.options[0] || {};\n    const allowParens = config.allowParens || config.allowParens === void 0;\n    const sourceCode = context.getSourceCode();\n    return {\n      ArrowFunctionExpression: function (node) {\n        const body = node.body;\n\n        if (isConditional(body) && !(allowParens && astUtils.isParenthesised(sourceCode, body))) {\n          context.report({\n            node,\n            messageId: \"confusing\",\n\n            fix(fixer) {\n              return allowParens && fixer.replaceText(node.body, `(${sourceCode.getText(node.body)})`);\n            }\n\n          });\n        }\n      }\n    };\n  }\n\n};\nnoConfusingArrow.meta;\nnoConfusingArrow.create;\nvar noConsole = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow the use of `console`\",\n      category: \"Possible Errors\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-console\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        allow: {\n          type: \"array\",\n          items: {\n            type: \"string\"\n          },\n          minItems: 1,\n          uniqueItems: true\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      unexpected: \"Unexpected console statement.\"\n    }\n  },\n\n  create(context) {\n    const options = context.options[0] || {};\n    const allowed = options.allow || [];\n\n    function isConsole(reference) {\n      const id = reference.identifier;\n      return id && id.name === \"console\";\n    }\n\n    function isAllowed(node) {\n      const propertyName = astUtils.getStaticPropertyName(node);\n      return propertyName && allowed.indexOf(propertyName) !== -1;\n    }\n\n    function isMemberAccessExceptAllowed(reference) {\n      const node = reference.identifier;\n      const parent = node.parent;\n      return parent.type === \"MemberExpression\" && parent.object === node && !isAllowed(parent);\n    }\n\n    function report(reference) {\n      const node = reference.identifier.parent;\n      context.report({\n        node,\n        loc: node.loc,\n        messageId: \"unexpected\"\n      });\n    }\n\n    return {\n      \"Program:exit\"() {\n        const scope = context.getScope();\n        const consoleVar = astUtils.getVariableByName(scope, \"console\");\n        const shadowed = consoleVar && consoleVar.defs.length > 0;\n        const references = consoleVar ? consoleVar.references : scope.through.filter(isConsole);\n\n        if (!shadowed) {\n          references.filter(isMemberAccessExceptAllowed).forEach(report);\n        }\n      }\n\n    };\n  }\n\n};\nnoConsole.meta;\nnoConsole.create;\nvar noConstAssign = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"disallow reassigning `const` variables\",\n      category: \"ECMAScript 6\",\n      recommended: true,\n      url: \"https://eslint.org/docs/rules/no-const-assign\"\n    },\n    schema: [],\n    messages: {\n      const: \"'{{name}}' is constant.\"\n    }\n  },\n\n  create(context) {\n    function checkVariable(variable) {\n      astUtils.getModifyingReferences(variable.references).forEach(reference => {\n        context.report({\n          node: reference.identifier,\n          messageId: \"const\",\n          data: {\n            name: reference.identifier.name\n          }\n        });\n      });\n    }\n\n    return {\n      VariableDeclaration(node) {\n        if (node.kind === \"const\") {\n          context.getDeclaredVariables(node).forEach(checkVariable);\n        }\n      }\n\n    };\n  }\n\n};\nnoConstAssign.meta;\nnoConstAssign.create;\nvar noConstantCondition = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"disallow constant expressions in conditions\",\n      category: \"Possible Errors\",\n      recommended: true,\n      url: \"https://eslint.org/docs/rules/no-constant-condition\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        checkLoops: {\n          type: \"boolean\",\n          default: true\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      unexpected: \"Unexpected constant condition.\"\n    }\n  },\n\n  create(context) {\n    const options = context.options[0] || {},\n          checkLoops = options.checkLoops !== false,\n          loopSetStack = [];\n    let loopsInCurrentScope = new Set();\n\n    function getBooleanValue(node) {\n      if (node.value === null) {\n        if (node.raw === \"null\") {\n          return false;\n        }\n\n        if (typeof node.regex === \"object\") {\n          return true;\n        }\n\n        return null;\n      }\n\n      return !!node.value;\n    }\n\n    function isLogicalIdentity(node, operator) {\n      switch (node.type) {\n        case \"Literal\":\n          return operator === \"||\" && getBooleanValue(node) === true || operator === \"&&\" && getBooleanValue(node) === false;\n\n        case \"UnaryExpression\":\n          return operator === \"&&\" && node.operator === \"void\";\n\n        case \"LogicalExpression\":\n          return operator === node.operator && (isLogicalIdentity(node.left, operator) || isLogicalIdentity(node.right, operator));\n\n        case \"AssignmentExpression\":\n          return [\"||=\", \"&&=\"].includes(node.operator) && operator === node.operator.slice(0, -1) && isLogicalIdentity(node.right, operator);\n      }\n\n      return false;\n    }\n\n    function isConstant(node, inBooleanPosition) {\n      if (!node) {\n        return true;\n      }\n\n      switch (node.type) {\n        case \"Literal\":\n        case \"ArrowFunctionExpression\":\n        case \"FunctionExpression\":\n        case \"ObjectExpression\":\n          return true;\n\n        case \"TemplateLiteral\":\n          return inBooleanPosition && node.quasis.some(quasi => quasi.value.cooked.length) || node.expressions.every(exp => isConstant(exp, inBooleanPosition));\n\n        case \"ArrayExpression\":\n          {\n            if (node.parent.type === \"BinaryExpression\" && node.parent.operator === \"+\") {\n              return node.elements.every(element => isConstant(element, false));\n            }\n\n            return true;\n          }\n\n        case \"UnaryExpression\":\n          if (node.operator === \"void\" || node.operator === \"typeof\" && inBooleanPosition) {\n            return true;\n          }\n\n          if (node.operator === \"!\") {\n            return isConstant(node.argument, true);\n          }\n\n          return isConstant(node.argument, false);\n\n        case \"BinaryExpression\":\n          return isConstant(node.left, false) && isConstant(node.right, false) && node.operator !== \"in\";\n\n        case \"LogicalExpression\":\n          {\n            const isLeftConstant = isConstant(node.left, inBooleanPosition);\n            const isRightConstant = isConstant(node.right, inBooleanPosition);\n            const isLeftShortCircuit = isLeftConstant && isLogicalIdentity(node.left, node.operator);\n            const isRightShortCircuit = inBooleanPosition && isRightConstant && isLogicalIdentity(node.right, node.operator);\n            return isLeftConstant && isRightConstant || isLeftShortCircuit || isRightShortCircuit;\n          }\n\n        case \"AssignmentExpression\":\n          if (node.operator === \"=\") {\n            return isConstant(node.right, inBooleanPosition);\n          }\n\n          if ([\"||=\", \"&&=\"].includes(node.operator) && inBooleanPosition) {\n            return isLogicalIdentity(node.right, node.operator.slice(0, -1));\n          }\n\n          return false;\n\n        case \"SequenceExpression\":\n          return isConstant(node.expressions[node.expressions.length - 1], inBooleanPosition);\n      }\n\n      return false;\n    }\n\n    function trackConstantConditionLoop(node) {\n      if (node.test && isConstant(node.test, true)) {\n        loopsInCurrentScope.add(node);\n      }\n    }\n\n    function checkConstantConditionLoopInSet(node) {\n      if (loopsInCurrentScope.has(node)) {\n        loopsInCurrentScope.delete(node);\n        context.report({\n          node: node.test,\n          messageId: \"unexpected\"\n        });\n      }\n    }\n\n    function reportIfConstant(node) {\n      if (node.test && isConstant(node.test, true)) {\n        context.report({\n          node: node.test,\n          messageId: \"unexpected\"\n        });\n      }\n    }\n\n    function enterFunction() {\n      loopSetStack.push(loopsInCurrentScope);\n      loopsInCurrentScope = new Set();\n    }\n\n    function exitFunction() {\n      loopsInCurrentScope = loopSetStack.pop();\n    }\n\n    function checkLoop(node) {\n      if (checkLoops) {\n        trackConstantConditionLoop(node);\n      }\n    }\n\n    return {\n      ConditionalExpression: reportIfConstant,\n      IfStatement: reportIfConstant,\n      WhileStatement: checkLoop,\n      \"WhileStatement:exit\": checkConstantConditionLoopInSet,\n      DoWhileStatement: checkLoop,\n      \"DoWhileStatement:exit\": checkConstantConditionLoopInSet,\n      ForStatement: checkLoop,\n      \"ForStatement > .test\": node => checkLoop(node.parent),\n      \"ForStatement:exit\": checkConstantConditionLoopInSet,\n      FunctionDeclaration: enterFunction,\n      \"FunctionDeclaration:exit\": exitFunction,\n      FunctionExpression: enterFunction,\n      \"FunctionExpression:exit\": exitFunction,\n      YieldExpression: () => loopsInCurrentScope.clear()\n    };\n  }\n\n};\nnoConstantCondition.meta;\nnoConstantCondition.create;\nvar noConstructorReturn = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"disallow returning value from constructor\",\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-constructor-return\"\n    },\n    schema: {},\n    fixable: null,\n    messages: {\n      unexpected: \"Unexpected return statement in constructor.\"\n    }\n  },\n\n  create(context) {\n    const stack = [];\n    return {\n      onCodePathStart(_, node) {\n        stack.push(node);\n      },\n\n      onCodePathEnd() {\n        stack.pop();\n      },\n\n      ReturnStatement(node) {\n        const last = stack[stack.length - 1];\n\n        if (!last.parent) {\n          return;\n        }\n\n        if (last.parent.type === \"MethodDefinition\" && last.parent.kind === \"constructor\" && (node.parent.parent === last || node.argument)) {\n          context.report({\n            node,\n            messageId: \"unexpected\"\n          });\n        }\n      }\n\n    };\n  }\n\n};\nnoConstructorReturn.meta;\nnoConstructorReturn.create;\nvar noContinue = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow `continue` statements\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-continue\"\n    },\n    schema: [],\n    messages: {\n      unexpected: \"Unexpected use of continue statement.\"\n    }\n  },\n\n  create(context) {\n    return {\n      ContinueStatement(node) {\n        context.report({\n          node,\n          messageId: \"unexpected\"\n        });\n      }\n\n    };\n  }\n\n};\nnoContinue.meta;\nnoContinue.create;\nconst RegExpValidator$1 = regexpp__default['default'].RegExpValidator;\nconst collector = new class {\n  constructor() {\n    this._source = \"\";\n    this._controlChars = [];\n    this._validator = new RegExpValidator$1(this);\n  }\n\n  onPatternEnter() {\n    this._controlChars = [];\n  }\n\n  onCharacter(start, end, cp) {\n    if (cp >= 0x00 && cp <= 0x1F && (this._source.codePointAt(start) === cp || this._source.slice(start, end).startsWith(\"\\\\x\") || this._source.slice(start, end).startsWith(\"\\\\u\"))) {\n      this._controlChars.push(`\\\\x${`0${cp.toString(16)}`.slice(-2)}`);\n    }\n  }\n\n  collectControlChars(regexpStr) {\n    try {\n      this._source = regexpStr;\n\n      this._validator.validatePattern(regexpStr);\n    } catch {}\n\n    return this._controlChars;\n  }\n\n}();\nvar noControlRegex = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"disallow control characters in regular expressions\",\n      category: \"Possible Errors\",\n      recommended: true,\n      url: \"https://eslint.org/docs/rules/no-control-regex\"\n    },\n    schema: [],\n    messages: {\n      unexpected: \"Unexpected control character(s) in regular expression: {{controlChars}}.\"\n    }\n  },\n\n  create(context) {\n    function getRegExpPattern(node) {\n      if (node.regex) {\n        return node.regex.pattern;\n      }\n\n      if (typeof node.value === \"string\" && (node.parent.type === \"NewExpression\" || node.parent.type === \"CallExpression\") && node.parent.callee.type === \"Identifier\" && node.parent.callee.name === \"RegExp\" && node.parent.arguments[0] === node) {\n        return node.value;\n      }\n\n      return null;\n    }\n\n    return {\n      Literal(node) {\n        const pattern = getRegExpPattern(node);\n\n        if (pattern) {\n          const controlCharacters = collector.collectControlChars(pattern);\n\n          if (controlCharacters.length > 0) {\n            context.report({\n              node,\n              messageId: \"unexpected\",\n              data: {\n                controlChars: controlCharacters.join(\", \")\n              }\n            });\n          }\n        }\n      }\n\n    };\n  }\n\n};\nnoControlRegex.meta;\nnoControlRegex.create;\nvar noDebugger = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"disallow the use of `debugger`\",\n      category: \"Possible Errors\",\n      recommended: true,\n      url: \"https://eslint.org/docs/rules/no-debugger\"\n    },\n    fixable: null,\n    schema: [],\n    messages: {\n      unexpected: \"Unexpected 'debugger' statement.\"\n    }\n  },\n\n  create(context) {\n    return {\n      DebuggerStatement(node) {\n        context.report({\n          node,\n          messageId: \"unexpected\"\n        });\n      }\n\n    };\n  }\n\n};\nnoDebugger.meta;\nnoDebugger.create;\nvar noDeleteVar = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow deleting variables\",\n      category: \"Variables\",\n      recommended: true,\n      url: \"https://eslint.org/docs/rules/no-delete-var\"\n    },\n    schema: [],\n    messages: {\n      unexpected: \"Variables should not be deleted.\"\n    }\n  },\n\n  create(context) {\n    return {\n      UnaryExpression(node) {\n        if (node.operator === \"delete\" && node.argument.type === \"Identifier\") {\n          context.report({\n            node,\n            messageId: \"unexpected\"\n          });\n        }\n      }\n\n    };\n  }\n\n};\nnoDeleteVar.meta;\nnoDeleteVar.create;\nvar noDivRegex = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow division operators explicitly at the beginning of regular expressions\",\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-div-regex\"\n    },\n    fixable: \"code\",\n    schema: [],\n    messages: {\n      unexpected: \"A regular expression literal can be confused with '/='.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    return {\n      Literal(node) {\n        const token = sourceCode.getFirstToken(node);\n\n        if (token.type === \"RegularExpression\" && token.value[1] === \"=\") {\n          context.report({\n            node,\n            messageId: \"unexpected\",\n\n            fix(fixer) {\n              return fixer.replaceTextRange([token.range[0] + 1, token.range[0] + 2], \"[=]\");\n            }\n\n          });\n        }\n      }\n\n    };\n  }\n\n};\nnoDivRegex.meta;\nnoDivRegex.create;\nvar noDupeArgs = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"disallow duplicate arguments in `function` definitions\",\n      category: \"Possible Errors\",\n      recommended: true,\n      url: \"https://eslint.org/docs/rules/no-dupe-args\"\n    },\n    schema: [],\n    messages: {\n      unexpected: \"Duplicate param '{{name}}'.\"\n    }\n  },\n\n  create(context) {\n    function isParameter(def) {\n      return def.type === \"Parameter\";\n    }\n\n    function checkParams(node) {\n      const variables = context.getDeclaredVariables(node);\n\n      for (let i = 0; i < variables.length; ++i) {\n        const variable = variables[i];\n        const defs = variable.defs.filter(isParameter);\n\n        if (defs.length >= 2) {\n          context.report({\n            node,\n            messageId: \"unexpected\",\n            data: {\n              name: variable.name\n            }\n          });\n        }\n      }\n    }\n\n    return {\n      FunctionDeclaration: checkParams,\n      FunctionExpression: checkParams\n    };\n  }\n\n};\nnoDupeArgs.meta;\nnoDupeArgs.create;\nvar noDupeClassMembers = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"disallow duplicate class members\",\n      category: \"ECMAScript 6\",\n      recommended: true,\n      url: \"https://eslint.org/docs/rules/no-dupe-class-members\"\n    },\n    schema: [],\n    messages: {\n      unexpected: \"Duplicate name '{{name}}'.\"\n    }\n  },\n\n  create(context) {\n    let stack = [];\n\n    function getState(name, isStatic) {\n      const stateMap = stack[stack.length - 1];\n      const key = `$${name}`;\n\n      if (!stateMap[key]) {\n        stateMap[key] = {\n          nonStatic: {\n            init: false,\n            get: false,\n            set: false\n          },\n          static: {\n            init: false,\n            get: false,\n            set: false\n          }\n        };\n      }\n\n      return stateMap[key][isStatic ? \"static\" : \"nonStatic\"];\n    }\n\n    return {\n      Program() {\n        stack = [];\n      },\n\n      ClassBody() {\n        stack.push(Object.create(null));\n      },\n\n      \"ClassBody:exit\"() {\n        stack.pop();\n      },\n\n      MethodDefinition(node) {\n        const name = astUtils.getStaticPropertyName(node);\n\n        if (name === null || node.kind === \"constructor\") {\n          return;\n        }\n\n        const state = getState(name, node.static);\n        let isDuplicate = false;\n\n        if (node.kind === \"get\") {\n          isDuplicate = state.init || state.get;\n          state.get = true;\n        } else if (node.kind === \"set\") {\n          isDuplicate = state.init || state.set;\n          state.set = true;\n        } else {\n          isDuplicate = state.init || state.get || state.set;\n          state.init = true;\n        }\n\n        if (isDuplicate) {\n          context.report({\n            node,\n            messageId: \"unexpected\",\n            data: {\n              name\n            }\n          });\n        }\n      }\n\n    };\n  }\n\n};\nnoDupeClassMembers.meta;\nnoDupeClassMembers.create;\n\nfunction isSubsetByComparator(comparator, arrA, arrB) {\n  return arrA.every(a => arrB.some(b => comparator(a, b)));\n}\n\nfunction splitByLogicalOperator(operator, node) {\n  if (node.type === \"LogicalExpression\" && node.operator === operator) {\n    return [...splitByLogicalOperator(operator, node.left), ...splitByLogicalOperator(operator, node.right)];\n  }\n\n  return [node];\n}\n\nconst splitByOr = splitByLogicalOperator.bind(null, \"||\");\nconst splitByAnd = splitByLogicalOperator.bind(null, \"&&\");\nvar noDupeElseIf = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"disallow duplicate conditions in if-else-if chains\",\n      category: \"Possible Errors\",\n      recommended: true,\n      url: \"https://eslint.org/docs/rules/no-dupe-else-if\"\n    },\n    schema: [],\n    messages: {\n      unexpected: \"This branch can never execute. Its condition is a duplicate or covered by previous conditions in the if-else-if chain.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n\n    function equal(a, b) {\n      if (a.type !== b.type) {\n        return false;\n      }\n\n      if (a.type === \"LogicalExpression\" && (a.operator === \"||\" || a.operator === \"&&\") && a.operator === b.operator) {\n        return equal(a.left, b.left) && equal(a.right, b.right) || equal(a.left, b.right) && equal(a.right, b.left);\n      }\n\n      return astUtils.equalTokens(a, b, sourceCode);\n    }\n\n    const isSubset = isSubsetByComparator.bind(null, equal);\n    return {\n      IfStatement(node) {\n        const test = node.test,\n              conditionsToCheck = test.type === \"LogicalExpression\" && test.operator === \"&&\" ? [test, ...splitByAnd(test)] : [test];\n        let current = node,\n            listToCheck = conditionsToCheck.map(c => splitByOr(c).map(splitByAnd));\n\n        while (current.parent && current.parent.type === \"IfStatement\" && current.parent.alternate === current) {\n          current = current.parent;\n          const currentOrOperands = splitByOr(current.test).map(splitByAnd);\n          listToCheck = listToCheck.map(orOperands => orOperands.filter(orOperand => !currentOrOperands.some(currentOrOperand => isSubset(currentOrOperand, orOperand))));\n\n          if (listToCheck.some(orOperands => orOperands.length === 0)) {\n            context.report({\n              node: test,\n              messageId: \"unexpected\"\n            });\n            break;\n          }\n        }\n      }\n\n    };\n  }\n\n};\nnoDupeElseIf.meta;\nnoDupeElseIf.create;\nconst GET_KIND = /^(?:init|get)$/u;\nconst SET_KIND = /^(?:init|set)$/u;\n\nclass ObjectInfo {\n  constructor(upper, node) {\n    this.upper = upper;\n    this.node = node;\n    this.properties = new Map();\n  }\n\n  getPropertyInfo(node) {\n    const name = astUtils.getStaticPropertyName(node);\n\n    if (!this.properties.has(name)) {\n      this.properties.set(name, {\n        get: false,\n        set: false\n      });\n    }\n\n    return this.properties.get(name);\n  }\n\n  isPropertyDefined(node) {\n    const entry = this.getPropertyInfo(node);\n    return GET_KIND.test(node.kind) && entry.get || SET_KIND.test(node.kind) && entry.set;\n  }\n\n  defineProperty(node) {\n    const entry = this.getPropertyInfo(node);\n\n    if (GET_KIND.test(node.kind)) {\n      entry.get = true;\n    }\n\n    if (SET_KIND.test(node.kind)) {\n      entry.set = true;\n    }\n  }\n\n}\n\nvar noDupeKeys = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"disallow duplicate keys in object literals\",\n      category: \"Possible Errors\",\n      recommended: true,\n      url: \"https://eslint.org/docs/rules/no-dupe-keys\"\n    },\n    schema: [],\n    messages: {\n      unexpected: \"Duplicate key '{{name}}'.\"\n    }\n  },\n\n  create(context) {\n    let info = null;\n    return {\n      ObjectExpression(node) {\n        info = new ObjectInfo(info, node);\n      },\n\n      \"ObjectExpression:exit\"() {\n        info = info.upper;\n      },\n\n      Property(node) {\n        const name = astUtils.getStaticPropertyName(node);\n\n        if (node.parent.type !== \"ObjectExpression\") {\n          return;\n        }\n\n        if (name === null) {\n          return;\n        }\n\n        if (info.isPropertyDefined(node)) {\n          context.report({\n            node: info.node,\n            loc: node.key.loc,\n            messageId: \"unexpected\",\n            data: {\n              name\n            }\n          });\n        }\n\n        info.defineProperty(node);\n      }\n\n    };\n  }\n\n};\nnoDupeKeys.meta;\nnoDupeKeys.create;\nvar noDuplicateCase = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"disallow duplicate case labels\",\n      category: \"Possible Errors\",\n      recommended: true,\n      url: \"https://eslint.org/docs/rules/no-duplicate-case\"\n    },\n    schema: [],\n    messages: {\n      unexpected: \"Duplicate case label.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n\n    function equal(a, b) {\n      if (a.type !== b.type) {\n        return false;\n      }\n\n      return astUtils.equalTokens(a, b, sourceCode);\n    }\n\n    return {\n      SwitchStatement(node) {\n        const previousTests = [];\n\n        for (const switchCase of node.cases) {\n          if (switchCase.test) {\n            const test = switchCase.test;\n\n            if (previousTests.some(previousTest => equal(previousTest, test))) {\n              context.report({\n                node: switchCase,\n                messageId: \"unexpected\"\n              });\n            } else {\n              previousTests.push(test);\n            }\n          }\n        }\n      }\n\n    };\n  }\n\n};\nnoDuplicateCase.meta;\nnoDuplicateCase.create;\nconst NAMED_TYPES = [\"ImportSpecifier\", \"ExportSpecifier\"];\nconst NAMESPACE_TYPES = [\"ImportNamespaceSpecifier\", \"ExportNamespaceSpecifier\"];\n\nfunction isImportExportSpecifier(importExportType, type) {\n  const arrayToCheck = type === \"named\" ? NAMED_TYPES : NAMESPACE_TYPES;\n  return arrayToCheck.includes(importExportType);\n}\n\nfunction getImportExportType(node) {\n  if (node.specifiers && node.specifiers.length > 0) {\n    const nodeSpecifiers = node.specifiers;\n    const index = nodeSpecifiers.findIndex(({\n      type\n    }) => isImportExportSpecifier(type, \"named\") || isImportExportSpecifier(type, \"namespace\"));\n    const i = index > -1 ? index : 0;\n    return nodeSpecifiers[i].type;\n  }\n\n  if (node.type === \"ExportAllDeclaration\") {\n    if (node.exported) {\n      return \"ExportNamespaceSpecifier\";\n    }\n\n    return \"ExportAll\";\n  }\n\n  return \"SideEffectImport\";\n}\n\nfunction isImportExportCanBeMerged(node1, node2) {\n  const importExportType1 = getImportExportType(node1);\n  const importExportType2 = getImportExportType(node2);\n\n  if (importExportType1 === \"ExportAll\" && importExportType2 !== \"ExportAll\" && importExportType2 !== \"SideEffectImport\" || importExportType1 !== \"ExportAll\" && importExportType1 !== \"SideEffectImport\" && importExportType2 === \"ExportAll\") {\n    return false;\n  }\n\n  if (isImportExportSpecifier(importExportType1, \"namespace\") && isImportExportSpecifier(importExportType2, \"named\") || isImportExportSpecifier(importExportType2, \"namespace\") && isImportExportSpecifier(importExportType1, \"named\")) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction shouldReportImportExport(node, previousNodes) {\n  let i = 0;\n\n  while (i < previousNodes.length) {\n    if (isImportExportCanBeMerged(node, previousNodes[i])) {\n      return true;\n    }\n\n    i++;\n  }\n\n  return false;\n}\n\nfunction getNodesByDeclarationType(nodes, type) {\n  return nodes.filter(({\n    declarationType\n  }) => declarationType === type).map(({\n    node\n  }) => node);\n}\n\nfunction getModule(node) {\n  if (node && node.source && node.source.value) {\n    return node.source.value.trim();\n  }\n\n  return \"\";\n}\n\nfunction checkAndReport(context, node, modules, declarationType, includeExports) {\n  const module = getModule(node);\n\n  if (modules.has(module)) {\n    const previousNodes = modules.get(module);\n    const messagesIds = [];\n    const importNodes = getNodesByDeclarationType(previousNodes, \"import\");\n    let exportNodes;\n\n    if (includeExports) {\n      exportNodes = getNodesByDeclarationType(previousNodes, \"export\");\n    }\n\n    if (declarationType === \"import\") {\n      if (shouldReportImportExport(node, importNodes)) {\n        messagesIds.push(\"import\");\n      }\n\n      if (includeExports) {\n        if (shouldReportImportExport(node, exportNodes)) {\n          messagesIds.push(\"importAs\");\n        }\n      }\n    } else if (declarationType === \"export\") {\n      if (shouldReportImportExport(node, exportNodes)) {\n        messagesIds.push(\"export\");\n      }\n\n      if (shouldReportImportExport(node, importNodes)) {\n        messagesIds.push(\"exportAs\");\n      }\n    }\n\n    messagesIds.forEach(messageId => context.report({\n      node,\n      messageId,\n      data: {\n        module\n      }\n    }));\n  }\n}\n\nfunction handleImportsExports(context, modules, declarationType, includeExports) {\n  return function (node) {\n    const module = getModule(node);\n\n    if (module) {\n      checkAndReport(context, node, modules, declarationType, includeExports);\n      const currentNode = {\n        node,\n        declarationType\n      };\n      let nodes = [currentNode];\n\n      if (modules.has(module)) {\n        const previousNodes = modules.get(module);\n        nodes = [...previousNodes, currentNode];\n      }\n\n      modules.set(module, nodes);\n    }\n  };\n}\n\nvar noDuplicateImports = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"disallow duplicate module imports\",\n      category: \"ECMAScript 6\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-duplicate-imports\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        includeExports: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      import: \"'{{module}}' import is duplicated.\",\n      importAs: \"'{{module}}' import is duplicated as export.\",\n      export: \"'{{module}}' export is duplicated.\",\n      exportAs: \"'{{module}}' export is duplicated as import.\"\n    }\n  },\n\n  create(context) {\n    const includeExports = (context.options[0] || {}).includeExports,\n          modules = new Map();\n    const handlers = {\n      ImportDeclaration: handleImportsExports(context, modules, \"import\", includeExports)\n    };\n\n    if (includeExports) {\n      handlers.ExportNamedDeclaration = handleImportsExports(context, modules, \"export\", includeExports);\n      handlers.ExportAllDeclaration = handleImportsExports(context, modules, \"export\", includeExports);\n    }\n\n    return handlers;\n  }\n\n};\nnoDuplicateImports.meta;\nnoDuplicateImports.create;\n\nclass FixTracker {\n  constructor(fixer, sourceCode) {\n    this.fixer = fixer;\n    this.sourceCode = sourceCode;\n    this.retainedRange = null;\n  }\n\n  retainRange(range) {\n    this.retainedRange = range;\n    return this;\n  }\n\n  retainEnclosingFunction(node) {\n    const functionNode = astUtils.getUpperFunction(node);\n    return this.retainRange(functionNode ? functionNode.range : this.sourceCode.ast.range);\n  }\n\n  retainSurroundingTokens(nodeOrToken) {\n    const tokenBefore = this.sourceCode.getTokenBefore(nodeOrToken) || nodeOrToken;\n    const tokenAfter = this.sourceCode.getTokenAfter(nodeOrToken) || nodeOrToken;\n    return this.retainRange([tokenBefore.range[0], tokenAfter.range[1]]);\n  }\n\n  replaceTextRange(range, text) {\n    let actualRange;\n\n    if (this.retainedRange) {\n      actualRange = [Math.min(this.retainedRange[0], range[0]), Math.max(this.retainedRange[1], range[1])];\n    } else {\n      actualRange = range;\n    }\n\n    return this.fixer.replaceTextRange(actualRange, this.sourceCode.text.slice(actualRange[0], range[0]) + text + this.sourceCode.text.slice(range[1], actualRange[1]));\n  }\n\n  remove(nodeOrToken) {\n    return this.replaceTextRange(nodeOrToken.range, \"\");\n  }\n\n}\n\nvar fixTracker = FixTracker;\nvar noElseReturn = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow `else` blocks after `return` statements in `if` statements\",\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-else-return\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        allowElseIf: {\n          type: \"boolean\",\n          default: true\n        }\n      },\n      additionalProperties: false\n    }],\n    fixable: \"code\",\n    messages: {\n      unexpected: \"Unnecessary 'else' after 'return'.\"\n    }\n  },\n\n  create(context) {\n    function isSafeToDeclare(names, scope) {\n      if (names.length === 0) {\n        return true;\n      }\n\n      const functionScope = scope.variableScope;\n      const declaredVariables = scope.variables.filter(({\n        defs\n      }) => defs.length > 0);\n\n      if (declaredVariables.some(({\n        name\n      }) => names.includes(name))) {\n        return false;\n      }\n\n      if (scope !== functionScope && scope.upper.type === \"catch\") {\n        if (scope.upper.variables.some(({\n          name\n        }) => names.includes(name))) {\n          return false;\n        }\n      }\n\n      const usedImplicitVariables = scope.variables.filter(({\n        defs,\n        references\n      }) => defs.length === 0 && references.length > 0);\n\n      if (usedImplicitVariables.some(({\n        name\n      }) => names.includes(name))) {\n        return false;\n      }\n\n      if (scope.through.some(t => names.includes(t.identifier.name))) {\n        return false;\n      }\n\n      if (scope !== functionScope) {\n        const scopeNodeRange = scope.block.range;\n        const variablesToCheck = functionScope.variables.filter(({\n          name\n        }) => names.includes(name));\n\n        if (variablesToCheck.some(v => v.defs.some(({\n          node: {\n            range\n          }\n        }) => scopeNodeRange[0] <= range[0] && range[1] <= scopeNodeRange[1]))) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n\n    function isSafeFromNameCollisions(node, scope) {\n      if (node.type === \"FunctionDeclaration\") {\n        return false;\n      }\n\n      if (node.type !== \"BlockStatement\") {\n        return true;\n      }\n\n      const elseBlockScope = scope.childScopes.find(({\n        block\n      }) => block === node);\n\n      if (!elseBlockScope) {\n        return true;\n      }\n\n      const namesToCheck = elseBlockScope.variables.map(({\n        name\n      }) => name);\n      return isSafeToDeclare(namesToCheck, scope);\n    }\n\n    function displayReport(node) {\n      const currentScope = context.getScope();\n      context.report({\n        node,\n        messageId: \"unexpected\",\n        fix: fixer => {\n          if (!isSafeFromNameCollisions(node, currentScope)) {\n            return null;\n          }\n\n          const sourceCode = context.getSourceCode();\n          const startToken = sourceCode.getFirstToken(node);\n          const elseToken = sourceCode.getTokenBefore(startToken);\n          const source = sourceCode.getText(node);\n          const lastIfToken = sourceCode.getTokenBefore(elseToken);\n          let fixedSource, firstTokenOfElseBlock;\n\n          if (startToken.type === \"Punctuator\" && startToken.value === \"{\") {\n            firstTokenOfElseBlock = sourceCode.getTokenAfter(startToken);\n          } else {\n            firstTokenOfElseBlock = startToken;\n          }\n\n          const ifBlockMaybeUnsafe = node.parent.consequent.type !== \"BlockStatement\" && lastIfToken.value !== \";\";\n          const elseBlockUnsafe = /^[([/+`-]/u.test(firstTokenOfElseBlock.value);\n\n          if (ifBlockMaybeUnsafe && elseBlockUnsafe) {\n            return null;\n          }\n\n          const endToken = sourceCode.getLastToken(node);\n          const lastTokenOfElseBlock = sourceCode.getTokenBefore(endToken);\n\n          if (lastTokenOfElseBlock.value !== \";\") {\n            const nextToken = sourceCode.getTokenAfter(endToken);\n            const nextTokenUnsafe = nextToken && /^[([/+`-]/u.test(nextToken.value);\n            const nextTokenOnSameLine = nextToken && nextToken.loc.start.line === lastTokenOfElseBlock.loc.start.line;\n\n            if (nextTokenUnsafe || nextTokenOnSameLine && nextToken.value !== \"}\") {\n              return null;\n            }\n          }\n\n          if (startToken.type === \"Punctuator\" && startToken.value === \"{\") {\n            fixedSource = source.slice(1, -1);\n          } else {\n            fixedSource = source;\n          }\n\n          return new fixTracker(fixer, sourceCode).retainEnclosingFunction(node).replaceTextRange([elseToken.range[0], node.range[1]], fixedSource);\n        }\n      });\n    }\n\n    function checkForReturn(node) {\n      return node.type === \"ReturnStatement\";\n    }\n\n    function naiveHasReturn(node) {\n      if (node.type === \"BlockStatement\") {\n        const body = node.body,\n              lastChildNode = body[body.length - 1];\n        return lastChildNode && checkForReturn(lastChildNode);\n      }\n\n      return checkForReturn(node);\n    }\n\n    function hasElse(node) {\n      return node.alternate && node.consequent;\n    }\n\n    function checkForIf(node) {\n      return node.type === \"IfStatement\" && hasElse(node) && naiveHasReturn(node.alternate) && naiveHasReturn(node.consequent);\n    }\n\n    function checkForReturnOrIf(node) {\n      return checkForReturn(node) || checkForIf(node);\n    }\n\n    function alwaysReturns(node) {\n      if (node.type === \"BlockStatement\") {\n        return node.body.some(checkForReturnOrIf);\n      }\n\n      return checkForReturnOrIf(node);\n    }\n\n    const allowElseIf = !(context.options[0] && context.options[0].allowElseIf === false);\n    return {\n      \"IfStatement:exit\": allowElseIf ? function (node) {\n        const parent = node.parent;\n\n        if (!astUtils.STATEMENT_LIST_PARENTS.has(parent.type)) {\n          return;\n        }\n\n        const consequents = [];\n        let alternate;\n\n        for (let currentNode = node; currentNode.type === \"IfStatement\"; currentNode = currentNode.alternate) {\n          if (!currentNode.alternate) {\n            return;\n          }\n\n          consequents.push(currentNode.consequent);\n          alternate = currentNode.alternate;\n        }\n\n        if (consequents.every(alwaysReturns)) {\n          displayReport(alternate);\n        }\n      } : function (node) {\n        const parent = node.parent;\n\n        if (!astUtils.STATEMENT_LIST_PARENTS.has(parent.type)) {\n          return;\n        }\n\n        const alternate = node.alternate;\n\n        if (alternate && alwaysReturns(node.consequent)) {\n          displayReport(alternate);\n        }\n      }\n    };\n  }\n\n};\nnoElseReturn.meta;\nnoElseReturn.create;\nconst regex = /^\\/([^\\\\[]|\\\\.|\\[([^\\\\\\]]|\\\\.)+\\])*\\/[gimuys]*$/u;\nvar noEmptyCharacterClass = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"disallow empty character classes in regular expressions\",\n      category: \"Possible Errors\",\n      recommended: true,\n      url: \"https://eslint.org/docs/rules/no-empty-character-class\"\n    },\n    schema: [],\n    messages: {\n      unexpected: \"Empty class.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    return {\n      Literal(node) {\n        const token = sourceCode.getFirstToken(node);\n\n        if (token.type === \"RegularExpression\" && !regex.test(token.value)) {\n          context.report({\n            node,\n            messageId: \"unexpected\"\n          });\n        }\n      }\n\n    };\n  }\n\n};\nnoEmptyCharacterClass.meta;\nnoEmptyCharacterClass.create;\nconst ALLOW_OPTIONS = Object.freeze([\"functions\", \"arrowFunctions\", \"generatorFunctions\", \"methods\", \"generatorMethods\", \"getters\", \"setters\", \"constructors\", \"asyncFunctions\", \"asyncMethods\"]);\n\nfunction getKind(node) {\n  const parent = node.parent;\n  let kind = \"\";\n\n  if (node.type === \"ArrowFunctionExpression\") {\n    return \"arrowFunctions\";\n  }\n\n  if (parent.type === \"Property\") {\n    if (parent.kind === \"get\") {\n      return \"getters\";\n    }\n\n    if (parent.kind === \"set\") {\n      return \"setters\";\n    }\n\n    kind = parent.method ? \"methods\" : \"functions\";\n  } else if (parent.type === \"MethodDefinition\") {\n    if (parent.kind === \"get\") {\n      return \"getters\";\n    }\n\n    if (parent.kind === \"set\") {\n      return \"setters\";\n    }\n\n    if (parent.kind === \"constructor\") {\n      return \"constructors\";\n    }\n\n    kind = \"methods\";\n  } else {\n    kind = \"functions\";\n  }\n\n  let prefix = \"\";\n\n  if (node.generator) {\n    prefix = \"generator\";\n  } else if (node.async) {\n    prefix = \"async\";\n  } else {\n    return kind;\n  }\n\n  return prefix + kind[0].toUpperCase() + kind.slice(1);\n}\n\nvar noEmptyFunction = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow empty functions\",\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-empty-function\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        allow: {\n          type: \"array\",\n          items: {\n            enum: ALLOW_OPTIONS\n          },\n          uniqueItems: true\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      unexpected: \"Unexpected empty {{name}}.\"\n    }\n  },\n\n  create(context) {\n    const options = context.options[0] || {};\n    const allowed = options.allow || [];\n    const sourceCode = context.getSourceCode();\n\n    function reportIfEmpty(node) {\n      const kind = getKind(node);\n      const name = astUtils.getFunctionNameWithKind(node);\n      const innerComments = sourceCode.getTokens(node.body, {\n        includeComments: true,\n        filter: astUtils.isCommentToken\n      });\n\n      if (allowed.indexOf(kind) === -1 && node.body.type === \"BlockStatement\" && node.body.body.length === 0 && innerComments.length === 0) {\n        context.report({\n          node,\n          loc: node.body.loc,\n          messageId: \"unexpected\",\n          data: {\n            name\n          }\n        });\n      }\n    }\n\n    return {\n      ArrowFunctionExpression: reportIfEmpty,\n      FunctionDeclaration: reportIfEmpty,\n      FunctionExpression: reportIfEmpty\n    };\n  }\n\n};\nnoEmptyFunction.meta;\nnoEmptyFunction.create;\nvar noEmptyPattern = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"disallow empty destructuring patterns\",\n      category: \"Best Practices\",\n      recommended: true,\n      url: \"https://eslint.org/docs/rules/no-empty-pattern\"\n    },\n    schema: [],\n    messages: {\n      unexpected: \"Unexpected empty {{type}} pattern.\"\n    }\n  },\n\n  create(context) {\n    return {\n      ObjectPattern(node) {\n        if (node.properties.length === 0) {\n          context.report({\n            node,\n            messageId: \"unexpected\",\n            data: {\n              type: \"object\"\n            }\n          });\n        }\n      },\n\n      ArrayPattern(node) {\n        if (node.elements.length === 0) {\n          context.report({\n            node,\n            messageId: \"unexpected\",\n            data: {\n              type: \"array\"\n            }\n          });\n        }\n      }\n\n    };\n  }\n\n};\nnoEmptyPattern.meta;\nnoEmptyPattern.create;\nvar noEmpty = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow empty block statements\",\n      category: \"Possible Errors\",\n      recommended: true,\n      url: \"https://eslint.org/docs/rules/no-empty\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        allowEmptyCatch: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      unexpected: \"Empty {{type}} statement.\"\n    }\n  },\n\n  create(context) {\n    const options = context.options[0] || {},\n          allowEmptyCatch = options.allowEmptyCatch || false;\n    const sourceCode = context.getSourceCode();\n    return {\n      BlockStatement(node) {\n        if (node.body.length !== 0) {\n          return;\n        }\n\n        if (astUtils.isFunction(node.parent)) {\n          return;\n        }\n\n        if (allowEmptyCatch && node.parent.type === \"CatchClause\") {\n          return;\n        }\n\n        if (sourceCode.getCommentsInside(node).length > 0) {\n          return;\n        }\n\n        context.report({\n          node,\n          messageId: \"unexpected\",\n          data: {\n            type: \"block\"\n          }\n        });\n      },\n\n      SwitchStatement(node) {\n        if (typeof node.cases === \"undefined\" || node.cases.length === 0) {\n          context.report({\n            node,\n            messageId: \"unexpected\",\n            data: {\n              type: \"switch\"\n            }\n          });\n        }\n      }\n\n    };\n  }\n\n};\nnoEmpty.meta;\nnoEmpty.create;\nvar noEqNull = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow `null` comparisons without type-checking operators\",\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-eq-null\"\n    },\n    schema: [],\n    messages: {\n      unexpected: \"Use '===' to compare with null.\"\n    }\n  },\n\n  create(context) {\n    return {\n      BinaryExpression(node) {\n        const badOperator = node.operator === \"==\" || node.operator === \"!=\";\n\n        if (node.right.type === \"Literal\" && node.right.raw === \"null\" && badOperator || node.left.type === \"Literal\" && node.left.raw === \"null\" && badOperator) {\n          context.report({\n            node,\n            messageId: \"unexpected\"\n          });\n        }\n      }\n\n    };\n  }\n\n};\nnoEqNull.meta;\nnoEqNull.create;\nconst candidatesOfGlobalObject = Object.freeze([\"global\", \"window\", \"globalThis\"]);\n\nfunction isMember(node, name) {\n  return astUtils.isSpecificMemberAccess(node, null, name);\n}\n\nvar noEval = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow the use of `eval()`\",\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-eval\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        allowIndirect: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      unexpected: \"eval can be harmful.\"\n    }\n  },\n\n  create(context) {\n    const allowIndirect = Boolean(context.options[0] && context.options[0].allowIndirect);\n    const sourceCode = context.getSourceCode();\n    let funcInfo = null;\n\n    function enterVarScope(node) {\n      const strict = context.getScope().isStrict;\n      funcInfo = {\n        upper: funcInfo,\n        node,\n        strict,\n        defaultThis: false,\n        initialized: strict\n      };\n    }\n\n    function exitVarScope() {\n      funcInfo = funcInfo.upper;\n    }\n\n    function report(node) {\n      const parent = node.parent;\n      const locationNode = node.type === \"MemberExpression\" ? node.property : node;\n      const reportNode = parent.type === \"CallExpression\" && parent.callee === node ? parent : node;\n      context.report({\n        node: reportNode,\n        loc: locationNode.loc,\n        messageId: \"unexpected\"\n      });\n    }\n\n    function reportAccessingEvalViaGlobalObject(globalScope) {\n      for (let i = 0; i < candidatesOfGlobalObject.length; ++i) {\n        const name = candidatesOfGlobalObject[i];\n        const variable = astUtils.getVariableByName(globalScope, name);\n\n        if (!variable) {\n          continue;\n        }\n\n        const references = variable.references;\n\n        for (let j = 0; j < references.length; ++j) {\n          const identifier = references[j].identifier;\n          let node = identifier.parent;\n\n          while (isMember(node, name)) {\n            node = node.parent;\n          }\n\n          if (isMember(node, \"eval\")) {\n            report(node);\n          }\n        }\n      }\n    }\n\n    function reportAccessingEval(globalScope) {\n      const variable = astUtils.getVariableByName(globalScope, \"eval\");\n\n      if (!variable) {\n        return;\n      }\n\n      const references = variable.references;\n\n      for (let i = 0; i < references.length; ++i) {\n        const reference = references[i];\n        const id = reference.identifier;\n\n        if (id.name === \"eval\" && !astUtils.isCallee(id)) {\n          report(id);\n        }\n      }\n    }\n\n    if (allowIndirect) {\n      return {\n        \"CallExpression:exit\"(node) {\n          const callee = node.callee;\n\n          if (!node.optional && astUtils.isSpecificId(callee, \"eval\")) {\n            report(callee);\n          }\n        }\n\n      };\n    }\n\n    return {\n      \"CallExpression:exit\"(node) {\n        const callee = node.callee;\n\n        if (astUtils.isSpecificId(callee, \"eval\")) {\n          report(callee);\n        }\n      },\n\n      Program(node) {\n        const scope = context.getScope(),\n              features = context.parserOptions.ecmaFeatures || {},\n              strict = scope.isStrict || node.sourceType === \"module\" || features.globalReturn && scope.childScopes[0].isStrict;\n        funcInfo = {\n          upper: null,\n          node,\n          strict,\n          defaultThis: true,\n          initialized: true\n        };\n      },\n\n      \"Program:exit\"() {\n        const globalScope = context.getScope();\n        exitVarScope();\n        reportAccessingEval(globalScope);\n        reportAccessingEvalViaGlobalObject(globalScope);\n      },\n\n      FunctionDeclaration: enterVarScope,\n      \"FunctionDeclaration:exit\": exitVarScope,\n      FunctionExpression: enterVarScope,\n      \"FunctionExpression:exit\": exitVarScope,\n      ArrowFunctionExpression: enterVarScope,\n      \"ArrowFunctionExpression:exit\": exitVarScope,\n\n      ThisExpression(node) {\n        if (!isMember(node.parent, \"eval\")) {\n          return;\n        }\n\n        if (!funcInfo.initialized) {\n          funcInfo.initialized = true;\n          funcInfo.defaultThis = astUtils.isDefaultThisBinding(funcInfo.node, sourceCode);\n        }\n\n        if (!funcInfo.strict && funcInfo.defaultThis) {\n          report(node.parent);\n        }\n      }\n\n    };\n  }\n\n};\nnoEval.meta;\nnoEval.create;\nvar noExAssign = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"disallow reassigning exceptions in `catch` clauses\",\n      category: \"Possible Errors\",\n      recommended: true,\n      url: \"https://eslint.org/docs/rules/no-ex-assign\"\n    },\n    schema: [],\n    messages: {\n      unexpected: \"Do not assign to the exception parameter.\"\n    }\n  },\n\n  create(context) {\n    function checkVariable(variable) {\n      astUtils.getModifyingReferences(variable.references).forEach(reference => {\n        context.report({\n          node: reference.identifier,\n          messageId: \"unexpected\"\n        });\n      });\n    }\n\n    return {\n      CatchClause(node) {\n        context.getDeclaredVariables(node).forEach(checkVariable);\n      }\n\n    };\n  }\n\n};\nnoExAssign.meta;\nnoExAssign.create;\nvar noExtendNative = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow extending native types\",\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-extend-native\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        exceptions: {\n          type: \"array\",\n          items: {\n            type: \"string\"\n          },\n          uniqueItems: true\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      unexpected: \"{{builtin}} prototype is read only, properties should not be added.\"\n    }\n  },\n\n  create(context) {\n    const config = context.options[0] || {};\n    const exceptions = new Set(config.exceptions || []);\n    const modifiedBuiltins = new Set(Object.keys(globals__default['default'].builtin).filter(builtin => builtin[0].toUpperCase() === builtin[0]).filter(builtin => !exceptions.has(builtin)));\n\n    function reportNode(node, builtin) {\n      context.report({\n        node,\n        messageId: \"unexpected\",\n        data: {\n          builtin\n        }\n      });\n    }\n\n    function isPrototypePropertyAccessed(identifierNode) {\n      return Boolean(identifierNode && identifierNode.parent && identifierNode.parent.type === \"MemberExpression\" && identifierNode.parent.object === identifierNode && astUtils.getStaticPropertyName(identifierNode.parent) === \"prototype\");\n    }\n\n    function isAssigningToPropertyOf(node) {\n      return node.parent.type === \"MemberExpression\" && node.parent.object === node && node.parent.parent.type === \"AssignmentExpression\" && node.parent.parent.left === node.parent;\n    }\n\n    function isInDefinePropertyCall(node) {\n      return node.parent.type === \"CallExpression\" && node.parent.arguments[0] === node && astUtils.isSpecificMemberAccess(node.parent.callee, \"Object\", /^definePropert(?:y|ies)$/u);\n    }\n\n    function checkAndReportPrototypeExtension(identifierNode) {\n      if (!isPrototypePropertyAccessed(identifierNode)) {\n        return;\n      }\n\n      const prototypeNode = identifierNode.parent.parent.type === \"ChainExpression\" ? identifierNode.parent.parent : identifierNode.parent;\n\n      if (isAssigningToPropertyOf(prototypeNode)) {\n        reportNode(prototypeNode.parent.parent, identifierNode.name);\n      } else if (isInDefinePropertyCall(prototypeNode)) {\n        reportNode(prototypeNode.parent, identifierNode.name);\n      }\n    }\n\n    return {\n      \"Program:exit\"() {\n        const globalScope = context.getScope();\n        modifiedBuiltins.forEach(builtin => {\n          const builtinVar = globalScope.set.get(builtin);\n\n          if (builtinVar && builtinVar.references) {\n            builtinVar.references.map(ref => ref.identifier).forEach(checkAndReportPrototypeExtension);\n          }\n        });\n      }\n\n    };\n  }\n\n};\nnoExtendNative.meta;\nnoExtendNative.create;\nconst SIDE_EFFECT_FREE_NODE_TYPES = new Set([\"Literal\", \"Identifier\", \"ThisExpression\", \"FunctionExpression\"]);\nvar noExtraBind = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow unnecessary calls to `.bind()`\",\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-extra-bind\"\n    },\n    schema: [],\n    fixable: \"code\",\n    messages: {\n      unexpected: \"The function binding is unnecessary.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    let scopeInfo = null;\n\n    function isSideEffectFree(node) {\n      return SIDE_EFFECT_FREE_NODE_TYPES.has(node.type);\n    }\n\n    function report(node) {\n      const memberNode = node.parent;\n      const callNode = memberNode.parent.type === \"ChainExpression\" ? memberNode.parent.parent : memberNode.parent;\n      context.report({\n        node: callNode,\n        messageId: \"unexpected\",\n        loc: memberNode.property.loc,\n\n        fix(fixer) {\n          if (!isSideEffectFree(callNode.arguments[0])) {\n            return null;\n          }\n\n          const tokenPairs = [[sourceCode.getTokenAfter(memberNode.object, astUtils.isNotClosingParenToken), sourceCode.getLastToken(memberNode)], [sourceCode.getTokenAfter(memberNode, astUtils.isNotClosingParenToken), sourceCode.getLastToken(callNode)]];\n          const firstTokenToRemove = tokenPairs[0][0];\n          const lastTokenToRemove = tokenPairs[1][1];\n\n          if (sourceCode.commentsExistBetween(firstTokenToRemove, lastTokenToRemove)) {\n            return null;\n          }\n\n          return tokenPairs.map(([start, end]) => fixer.removeRange([start.range[0], end.range[1]]));\n        }\n\n      });\n    }\n\n    function isCalleeOfBindMethod(node) {\n      if (!astUtils.isSpecificMemberAccess(node.parent, null, \"bind\")) {\n        return false;\n      }\n\n      const bindNode = node.parent.parent.type === \"ChainExpression\" ? node.parent.parent : node.parent;\n      return bindNode.parent.type === \"CallExpression\" && bindNode.parent.callee === bindNode && bindNode.parent.arguments.length === 1 && bindNode.parent.arguments[0].type !== \"SpreadElement\";\n    }\n\n    function enterFunction(node) {\n      scopeInfo = {\n        isBound: isCalleeOfBindMethod(node),\n        thisFound: false,\n        upper: scopeInfo\n      };\n    }\n\n    function exitFunction(node) {\n      if (scopeInfo.isBound && !scopeInfo.thisFound) {\n        report(node);\n      }\n\n      scopeInfo = scopeInfo.upper;\n    }\n\n    function markAsThisFound() {\n      if (scopeInfo) {\n        scopeInfo.thisFound = true;\n      }\n    }\n\n    return {\n      \"ArrowFunctionExpression:exit\": function (node) {\n        if (isCalleeOfBindMethod(node)) {\n          report(node);\n        }\n      },\n      FunctionDeclaration: enterFunction,\n      \"FunctionDeclaration:exit\": exitFunction,\n      FunctionExpression: enterFunction,\n      \"FunctionExpression:exit\": exitFunction,\n      ThisExpression: markAsThisFound\n    };\n  }\n\n};\nnoExtraBind.meta;\nnoExtraBind.create;\nconst precedence = astUtils.getPrecedence;\nvar noExtraBooleanCast = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow unnecessary boolean casts\",\n      category: \"Possible Errors\",\n      recommended: true,\n      url: \"https://eslint.org/docs/rules/no-extra-boolean-cast\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        enforceForLogicalOperands: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    fixable: \"code\",\n    messages: {\n      unexpectedCall: \"Redundant Boolean call.\",\n      unexpectedNegation: \"Redundant double negation.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    const BOOLEAN_NODE_TYPES = [\"IfStatement\", \"DoWhileStatement\", \"WhileStatement\", \"ConditionalExpression\", \"ForStatement\"];\n\n    function isBooleanFunctionOrConstructorCall(node) {\n      return (node.type === \"CallExpression\" || node.type === \"NewExpression\") && node.callee.type === \"Identifier\" && node.callee.name === \"Boolean\";\n    }\n\n    function isLogicalContext(node) {\n      return node.type === \"LogicalExpression\" && (node.operator === \"||\" || node.operator === \"&&\") && context.options.length && context.options[0].enforceForLogicalOperands === true;\n    }\n\n    function isInBooleanContext(node) {\n      return isBooleanFunctionOrConstructorCall(node.parent) && node === node.parent.arguments[0] || BOOLEAN_NODE_TYPES.indexOf(node.parent.type) !== -1 && node === node.parent.test || node.parent.type === \"UnaryExpression\" && node.parent.operator === \"!\";\n    }\n\n    function isInFlaggedContext(node) {\n      if (node.parent.type === \"ChainExpression\") {\n        return isInFlaggedContext(node.parent);\n      }\n\n      return isInBooleanContext(node) || isLogicalContext(node.parent) && isInFlaggedContext(node.parent);\n    }\n\n    function hasCommentsInside(node) {\n      return Boolean(sourceCode.getCommentsInside(node).length);\n    }\n\n    function isParenthesized(node) {\n      return eslintUtils__default['default'].isParenthesized(1, node, sourceCode);\n    }\n\n    function needsParens(previousNode, node) {\n      if (previousNode.parent.type === \"ChainExpression\") {\n        return needsParens(previousNode.parent, node);\n      }\n\n      if (isParenthesized(previousNode)) {\n        return false;\n      }\n\n      const parent = previousNode.parent;\n\n      switch (parent.type) {\n        case \"CallExpression\":\n        case \"NewExpression\":\n          return node.type === \"SequenceExpression\";\n\n        case \"IfStatement\":\n        case \"DoWhileStatement\":\n        case \"WhileStatement\":\n        case \"ForStatement\":\n          return false;\n\n        case \"ConditionalExpression\":\n          return precedence(node) <= precedence(parent);\n\n        case \"UnaryExpression\":\n          return precedence(node) < precedence(parent);\n\n        case \"LogicalExpression\":\n          if (astUtils.isMixedLogicalAndCoalesceExpressions(node, parent)) {\n            return true;\n          }\n\n          if (previousNode === parent.left) {\n            return precedence(node) < precedence(parent);\n          }\n\n          return precedence(node) <= precedence(parent);\n\n        default:\n          throw new Error(`Unexpected parent type: ${parent.type}`);\n      }\n    }\n\n    return {\n      UnaryExpression(node) {\n        const parent = node.parent;\n\n        if (node.operator !== \"!\" || parent.type !== \"UnaryExpression\" || parent.operator !== \"!\") {\n          return;\n        }\n\n        if (isInFlaggedContext(parent)) {\n          context.report({\n            node: parent,\n            messageId: \"unexpectedNegation\",\n\n            fix(fixer) {\n              if (hasCommentsInside(parent)) {\n                return null;\n              }\n\n              if (needsParens(parent, node.argument)) {\n                return fixer.replaceText(parent, `(${sourceCode.getText(node.argument)})`);\n              }\n\n              let prefix = \"\";\n              const tokenBefore = sourceCode.getTokenBefore(parent);\n              const firstReplacementToken = sourceCode.getFirstToken(node.argument);\n\n              if (tokenBefore && tokenBefore.range[1] === parent.range[0] && !astUtils.canTokensBeAdjacent(tokenBefore, firstReplacementToken)) {\n                prefix = \" \";\n              }\n\n              return fixer.replaceText(parent, prefix + sourceCode.getText(node.argument));\n            }\n\n          });\n        }\n      },\n\n      CallExpression(node) {\n        if (node.callee.type !== \"Identifier\" || node.callee.name !== \"Boolean\") {\n          return;\n        }\n\n        if (isInFlaggedContext(node)) {\n          context.report({\n            node,\n            messageId: \"unexpectedCall\",\n\n            fix(fixer) {\n              const parent = node.parent;\n\n              if (node.arguments.length === 0) {\n                if (parent.type === \"UnaryExpression\" && parent.operator === \"!\") {\n                  if (hasCommentsInside(parent)) {\n                    return null;\n                  }\n\n                  let prefix = \"\";\n                  const tokenBefore = sourceCode.getTokenBefore(parent);\n\n                  if (tokenBefore && tokenBefore.range[1] === parent.range[0] && !astUtils.canTokensBeAdjacent(tokenBefore, \"true\")) {\n                    prefix = \" \";\n                  }\n\n                  return fixer.replaceText(parent, prefix + \"true\");\n                }\n\n                if (hasCommentsInside(node)) {\n                  return null;\n                }\n\n                return fixer.replaceText(node, \"false\");\n              }\n\n              if (node.arguments.length === 1) {\n                const argument = node.arguments[0];\n\n                if (argument.type === \"SpreadElement\" || hasCommentsInside(node)) {\n                  return null;\n                }\n\n                if (needsParens(node, argument)) {\n                  return fixer.replaceText(node, `(${sourceCode.getText(argument)})`);\n                }\n\n                return fixer.replaceText(node, sourceCode.getText(argument));\n              }\n\n              return null;\n            }\n\n          });\n        }\n      }\n\n    };\n  }\n\n};\nnoExtraBooleanCast.meta;\nnoExtraBooleanCast.create;\nvar noExtraLabel = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow unnecessary labels\",\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-extra-label\"\n    },\n    schema: [],\n    fixable: \"code\",\n    messages: {\n      unexpected: \"This label '{{name}}' is unnecessary.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    let scopeInfo = null;\n\n    function enterBreakableStatement(node) {\n      scopeInfo = {\n        label: node.parent.type === \"LabeledStatement\" ? node.parent.label : null,\n        breakable: true,\n        upper: scopeInfo\n      };\n    }\n\n    function exitBreakableStatement() {\n      scopeInfo = scopeInfo.upper;\n    }\n\n    function enterLabeledStatement(node) {\n      if (!astUtils.isBreakableStatement(node.body)) {\n        scopeInfo = {\n          label: node.label,\n          breakable: false,\n          upper: scopeInfo\n        };\n      }\n    }\n\n    function exitLabeledStatement(node) {\n      if (!astUtils.isBreakableStatement(node.body)) {\n        scopeInfo = scopeInfo.upper;\n      }\n    }\n\n    function reportIfUnnecessary(node) {\n      if (!node.label) {\n        return;\n      }\n\n      const labelNode = node.label;\n\n      for (let info = scopeInfo; info !== null; info = info.upper) {\n        if (info.breakable || info.label && info.label.name === labelNode.name) {\n          if (info.breakable && info.label && info.label.name === labelNode.name) {\n            context.report({\n              node: labelNode,\n              messageId: \"unexpected\",\n              data: labelNode,\n\n              fix(fixer) {\n                const breakOrContinueToken = sourceCode.getFirstToken(node);\n\n                if (sourceCode.commentsExistBetween(breakOrContinueToken, labelNode)) {\n                  return null;\n                }\n\n                return fixer.removeRange([breakOrContinueToken.range[1], labelNode.range[1]]);\n              }\n\n            });\n          }\n\n          return;\n        }\n      }\n    }\n\n    return {\n      WhileStatement: enterBreakableStatement,\n      \"WhileStatement:exit\": exitBreakableStatement,\n      DoWhileStatement: enterBreakableStatement,\n      \"DoWhileStatement:exit\": exitBreakableStatement,\n      ForStatement: enterBreakableStatement,\n      \"ForStatement:exit\": exitBreakableStatement,\n      ForInStatement: enterBreakableStatement,\n      \"ForInStatement:exit\": exitBreakableStatement,\n      ForOfStatement: enterBreakableStatement,\n      \"ForOfStatement:exit\": exitBreakableStatement,\n      SwitchStatement: enterBreakableStatement,\n      \"SwitchStatement:exit\": exitBreakableStatement,\n      LabeledStatement: enterLabeledStatement,\n      \"LabeledStatement:exit\": exitLabeledStatement,\n      BreakStatement: reportIfUnnecessary,\n      ContinueStatement: reportIfUnnecessary\n    };\n  }\n\n};\nnoExtraLabel.meta;\nnoExtraLabel.create;\nconst {\n  isParenthesized: isParenthesizedRaw\n} = eslintUtils__default['default'];\nvar noExtraParens = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"disallow unnecessary parentheses\",\n      category: \"Possible Errors\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-extra-parens\"\n    },\n    fixable: \"code\",\n    schema: {\n      anyOf: [{\n        type: \"array\",\n        items: [{\n          enum: [\"functions\"]\n        }],\n        minItems: 0,\n        maxItems: 1\n      }, {\n        type: \"array\",\n        items: [{\n          enum: [\"all\"]\n        }, {\n          type: \"object\",\n          properties: {\n            conditionalAssign: {\n              type: \"boolean\"\n            },\n            nestedBinaryExpressions: {\n              type: \"boolean\"\n            },\n            returnAssign: {\n              type: \"boolean\"\n            },\n            ignoreJSX: {\n              enum: [\"none\", \"all\", \"single-line\", \"multi-line\"]\n            },\n            enforceForArrowConditionals: {\n              type: \"boolean\"\n            },\n            enforceForSequenceExpressions: {\n              type: \"boolean\"\n            },\n            enforceForNewInMemberExpressions: {\n              type: \"boolean\"\n            },\n            enforceForFunctionPrototypeMethods: {\n              type: \"boolean\"\n            }\n          },\n          additionalProperties: false\n        }],\n        minItems: 0,\n        maxItems: 2\n      }]\n    },\n    messages: {\n      unexpected: \"Unnecessary parentheses around expression.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    const tokensToIgnore = new WeakSet();\n    const precedence = astUtils.getPrecedence;\n    const ALL_NODES = context.options[0] !== \"functions\";\n    const EXCEPT_COND_ASSIGN = ALL_NODES && context.options[1] && context.options[1].conditionalAssign === false;\n    const NESTED_BINARY = ALL_NODES && context.options[1] && context.options[1].nestedBinaryExpressions === false;\n    const EXCEPT_RETURN_ASSIGN = ALL_NODES && context.options[1] && context.options[1].returnAssign === false;\n    const IGNORE_JSX = ALL_NODES && context.options[1] && context.options[1].ignoreJSX;\n    const IGNORE_ARROW_CONDITIONALS = ALL_NODES && context.options[1] && context.options[1].enforceForArrowConditionals === false;\n    const IGNORE_SEQUENCE_EXPRESSIONS = ALL_NODES && context.options[1] && context.options[1].enforceForSequenceExpressions === false;\n    const IGNORE_NEW_IN_MEMBER_EXPR = ALL_NODES && context.options[1] && context.options[1].enforceForNewInMemberExpressions === false;\n    const IGNORE_FUNCTION_PROTOTYPE_METHODS = ALL_NODES && context.options[1] && context.options[1].enforceForFunctionPrototypeMethods === false;\n    const PRECEDENCE_OF_ASSIGNMENT_EXPR = precedence({\n      type: \"AssignmentExpression\"\n    });\n    const PRECEDENCE_OF_UPDATE_EXPR = precedence({\n      type: \"UpdateExpression\"\n    });\n    let reportsBuffer;\n\n    function isImmediateFunctionPrototypeMethodCall(node) {\n      const callNode = astUtils.skipChainExpression(node);\n\n      if (callNode.type !== \"CallExpression\") {\n        return false;\n      }\n\n      const callee = astUtils.skipChainExpression(callNode.callee);\n      return callee.type === \"MemberExpression\" && callee.object.type === \"FunctionExpression\" && [\"call\", \"apply\"].includes(astUtils.getStaticPropertyName(callee));\n    }\n\n    function ruleApplies(node) {\n      if (node.type === \"JSXElement\" || node.type === \"JSXFragment\") {\n        const isSingleLine = node.loc.start.line === node.loc.end.line;\n\n        switch (IGNORE_JSX) {\n          case \"all\":\n            return false;\n\n          case \"multi-line\":\n            return isSingleLine;\n\n          case \"single-line\":\n            return !isSingleLine;\n        }\n      }\n\n      if (node.type === \"SequenceExpression\" && IGNORE_SEQUENCE_EXPRESSIONS) {\n        return false;\n      }\n\n      if (isImmediateFunctionPrototypeMethodCall(node) && IGNORE_FUNCTION_PROTOTYPE_METHODS) {\n        return false;\n      }\n\n      return ALL_NODES || node.type === \"FunctionExpression\" || node.type === \"ArrowFunctionExpression\";\n    }\n\n    function isParenthesised(node) {\n      return isParenthesizedRaw(1, node, sourceCode);\n    }\n\n    function isParenthesisedTwice(node) {\n      return isParenthesizedRaw(2, node, sourceCode);\n    }\n\n    function hasExcessParens(node) {\n      return ruleApplies(node) && isParenthesised(node);\n    }\n\n    function hasDoubleExcessParens(node) {\n      return ruleApplies(node) && isParenthesisedTwice(node);\n    }\n\n    function hasExcessParensWithPrecedence(node, precedenceLowerLimit) {\n      if (ruleApplies(node) && isParenthesised(node)) {\n        if (precedence(node) >= precedenceLowerLimit || isParenthesisedTwice(node)) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n\n    function isCondAssignException(node) {\n      return EXCEPT_COND_ASSIGN && node.test.type === \"AssignmentExpression\";\n    }\n\n    function isInReturnStatement(node) {\n      for (let currentNode = node; currentNode; currentNode = currentNode.parent) {\n        if (currentNode.type === \"ReturnStatement\" || currentNode.type === \"ArrowFunctionExpression\" && currentNode.body.type !== \"BlockStatement\") {\n          return true;\n        }\n      }\n\n      return false;\n    }\n\n    function isNewExpressionWithParens(newExpression) {\n      const lastToken = sourceCode.getLastToken(newExpression);\n      const penultimateToken = sourceCode.getTokenBefore(lastToken);\n      return newExpression.arguments.length > 0 || astUtils.isOpeningParenToken(penultimateToken) && astUtils.isClosingParenToken(lastToken) && newExpression.callee.range[1] < newExpression.range[1];\n    }\n\n    function containsAssignment(node) {\n      if (node.type === \"AssignmentExpression\") {\n        return true;\n      }\n\n      if (node.type === \"ConditionalExpression\" && (node.consequent.type === \"AssignmentExpression\" || node.alternate.type === \"AssignmentExpression\")) {\n        return true;\n      }\n\n      if (node.left && node.left.type === \"AssignmentExpression\" || node.right && node.right.type === \"AssignmentExpression\") {\n        return true;\n      }\n\n      return false;\n    }\n\n    function isReturnAssignException(node) {\n      if (!EXCEPT_RETURN_ASSIGN || !isInReturnStatement(node)) {\n        return false;\n      }\n\n      if (node.type === \"ReturnStatement\") {\n        return node.argument && containsAssignment(node.argument);\n      }\n\n      if (node.type === \"ArrowFunctionExpression\" && node.body.type !== \"BlockStatement\") {\n        return containsAssignment(node.body);\n      }\n\n      return containsAssignment(node);\n    }\n\n    function hasExcessParensNoLineTerminator(token, node) {\n      if (token.loc.end.line === node.loc.start.line) {\n        return hasExcessParens(node);\n      }\n\n      return hasDoubleExcessParens(node);\n    }\n\n    function requiresLeadingSpace(node) {\n      const leftParenToken = sourceCode.getTokenBefore(node);\n      const tokenBeforeLeftParen = sourceCode.getTokenBefore(leftParenToken, {\n        includeComments: true\n      });\n      const tokenAfterLeftParen = sourceCode.getTokenAfter(leftParenToken, {\n        includeComments: true\n      });\n      return tokenBeforeLeftParen && tokenBeforeLeftParen.range[1] === leftParenToken.range[0] && leftParenToken.range[1] === tokenAfterLeftParen.range[0] && !astUtils.canTokensBeAdjacent(tokenBeforeLeftParen, tokenAfterLeftParen);\n    }\n\n    function requiresTrailingSpace(node) {\n      const nextTwoTokens = sourceCode.getTokensAfter(node, {\n        count: 2\n      });\n      const rightParenToken = nextTwoTokens[0];\n      const tokenAfterRightParen = nextTwoTokens[1];\n      const tokenBeforeRightParen = sourceCode.getLastToken(node);\n      return rightParenToken && tokenAfterRightParen && !sourceCode.isSpaceBetweenTokens(rightParenToken, tokenAfterRightParen) && !astUtils.canTokensBeAdjacent(tokenBeforeRightParen, tokenAfterRightParen);\n    }\n\n    function isIIFE(node) {\n      const maybeCallNode = astUtils.skipChainExpression(node);\n      return maybeCallNode.type === \"CallExpression\" && maybeCallNode.callee.type === \"FunctionExpression\";\n    }\n\n    function canBeAssignmentTarget(node) {\n      return node && (node.type === \"Identifier\" || node.type === \"MemberExpression\");\n    }\n\n    function report(node) {\n      const leftParenToken = sourceCode.getTokenBefore(node);\n      const rightParenToken = sourceCode.getTokenAfter(node);\n\n      if (!isParenthesisedTwice(node)) {\n        if (tokensToIgnore.has(sourceCode.getFirstToken(node))) {\n          return;\n        }\n\n        if (isIIFE(node) && !isParenthesised(node.callee)) {\n          return;\n        }\n      }\n\n      function finishReport() {\n        context.report({\n          node,\n          loc: leftParenToken.loc,\n          messageId: \"unexpected\",\n\n          fix(fixer) {\n            const parenthesizedSource = sourceCode.text.slice(leftParenToken.range[1], rightParenToken.range[0]);\n            return fixer.replaceTextRange([leftParenToken.range[0], rightParenToken.range[1]], (requiresLeadingSpace(node) ? \" \" : \"\") + parenthesizedSource + (requiresTrailingSpace(node) ? \" \" : \"\"));\n          }\n\n        });\n      }\n\n      if (reportsBuffer) {\n        reportsBuffer.reports.push({\n          node,\n          finishReport\n        });\n        return;\n      }\n\n      finishReport();\n    }\n\n    function checkArgumentWithPrecedence(node) {\n      if (hasExcessParensWithPrecedence(node.argument, precedence(node))) {\n        report(node.argument);\n      }\n    }\n\n    function doesMemberExpressionContainCallExpression(node) {\n      let currentNode = node.object;\n      let currentNodeType = node.object.type;\n\n      while (currentNodeType === \"MemberExpression\") {\n        currentNode = currentNode.object;\n        currentNodeType = currentNode.type;\n      }\n\n      return currentNodeType === \"CallExpression\";\n    }\n\n    function checkCallNew(node) {\n      const callee = node.callee;\n\n      if (hasExcessParensWithPrecedence(callee, precedence(node))) {\n        if (hasDoubleExcessParens(callee) || !(isIIFE(node) || callee.type === \"NewExpression\" && !isNewExpressionWithParens(callee) && !(node.type === \"NewExpression\" && !isNewExpressionWithParens(node)) || node.type === \"NewExpression\" && callee.type === \"MemberExpression\" && doesMemberExpressionContainCallExpression(callee) || !node.optional && callee.type === \"ChainExpression\")) {\n          report(node.callee);\n        }\n      }\n\n      node.arguments.filter(arg => hasExcessParensWithPrecedence(arg, PRECEDENCE_OF_ASSIGNMENT_EXPR)).forEach(report);\n    }\n\n    function checkBinaryLogical(node) {\n      const prec = precedence(node);\n      const leftPrecedence = precedence(node.left);\n      const rightPrecedence = precedence(node.right);\n      const isExponentiation = node.operator === \"**\";\n      const shouldSkipLeft = NESTED_BINARY && (node.left.type === \"BinaryExpression\" || node.left.type === \"LogicalExpression\");\n      const shouldSkipRight = NESTED_BINARY && (node.right.type === \"BinaryExpression\" || node.right.type === \"LogicalExpression\");\n\n      if (!shouldSkipLeft && hasExcessParens(node.left)) {\n        if (!([\"AwaitExpression\", \"UnaryExpression\"].includes(node.left.type) && isExponentiation) && !astUtils.isMixedLogicalAndCoalesceExpressions(node.left, node) && (leftPrecedence > prec || leftPrecedence === prec && !isExponentiation) || isParenthesisedTwice(node.left)) {\n          report(node.left);\n        }\n      }\n\n      if (!shouldSkipRight && hasExcessParens(node.right)) {\n        if (!astUtils.isMixedLogicalAndCoalesceExpressions(node.right, node) && (rightPrecedence > prec || rightPrecedence === prec && isExponentiation) || isParenthesisedTwice(node.right)) {\n          report(node.right);\n        }\n      }\n    }\n\n    function checkClass(node) {\n      if (!node.superClass) {\n        return;\n      }\n\n      const hasExtraParens = precedence(node.superClass) > PRECEDENCE_OF_UPDATE_EXPR ? hasExcessParens(node.superClass) : hasDoubleExcessParens(node.superClass);\n\n      if (hasExtraParens) {\n        report(node.superClass);\n      }\n    }\n\n    function checkSpreadOperator(node) {\n      if (hasExcessParensWithPrecedence(node.argument, PRECEDENCE_OF_ASSIGNMENT_EXPR)) {\n        report(node.argument);\n      }\n    }\n\n    function checkExpressionOrExportStatement(node) {\n      const firstToken = isParenthesised(node) ? sourceCode.getTokenBefore(node) : sourceCode.getFirstToken(node);\n      const secondToken = sourceCode.getTokenAfter(firstToken, astUtils.isNotOpeningParenToken);\n      const thirdToken = secondToken ? sourceCode.getTokenAfter(secondToken) : null;\n      const tokenAfterClosingParens = secondToken ? sourceCode.getTokenAfter(secondToken, astUtils.isNotClosingParenToken) : null;\n\n      if (astUtils.isOpeningParenToken(firstToken) && (astUtils.isOpeningBraceToken(secondToken) || secondToken.type === \"Keyword\" && (secondToken.value === \"function\" || secondToken.value === \"class\" || secondToken.value === \"let\" && tokenAfterClosingParens && (astUtils.isOpeningBracketToken(tokenAfterClosingParens) || tokenAfterClosingParens.type === \"Identifier\")) || secondToken && secondToken.type === \"Identifier\" && secondToken.value === \"async\" && thirdToken && thirdToken.type === \"Keyword\" && thirdToken.value === \"function\")) {\n        tokensToIgnore.add(secondToken);\n      }\n\n      const hasExtraParens = node.parent.type === \"ExportDefaultDeclaration\" ? hasExcessParensWithPrecedence(node, PRECEDENCE_OF_ASSIGNMENT_EXPR) : hasExcessParens(node);\n\n      if (hasExtraParens) {\n        report(node);\n      }\n    }\n\n    function pathToAncestor(node, ancestor) {\n      const path = [node];\n      let currentNode = node;\n\n      while (currentNode !== ancestor) {\n        currentNode = currentNode.parent;\n\n        if (currentNode === null) {\n          throw new Error(\"Nodes are not in the ancestor-descendant relationship.\");\n        }\n\n        path.push(currentNode);\n      }\n\n      return path;\n    }\n\n    function pathToDescendant(node, descendant) {\n      return pathToAncestor(descendant, node).reverse();\n    }\n\n    function isSafelyEnclosingInExpression(node, child) {\n      switch (node.type) {\n        case \"ArrayExpression\":\n        case \"ArrayPattern\":\n        case \"BlockStatement\":\n        case \"ObjectExpression\":\n        case \"ObjectPattern\":\n        case \"TemplateLiteral\":\n          return true;\n\n        case \"ArrowFunctionExpression\":\n        case \"FunctionExpression\":\n          return node.params.includes(child);\n\n        case \"CallExpression\":\n        case \"NewExpression\":\n          return node.arguments.includes(child);\n\n        case \"MemberExpression\":\n          return node.computed && node.property === child;\n\n        case \"ConditionalExpression\":\n          return node.consequent === child;\n\n        default:\n          return false;\n      }\n    }\n\n    function startNewReportsBuffering() {\n      reportsBuffer = {\n        upper: reportsBuffer,\n        inExpressionNodes: [],\n        reports: []\n      };\n    }\n\n    function endCurrentReportsBuffering() {\n      const {\n        upper,\n        inExpressionNodes,\n        reports\n      } = reportsBuffer;\n\n      if (upper) {\n        upper.inExpressionNodes.push(...inExpressionNodes);\n        upper.reports.push(...reports);\n      } else {\n        reports.forEach(({\n          finishReport\n        }) => finishReport());\n      }\n\n      reportsBuffer = upper;\n    }\n\n    function isInCurrentReportsBuffer(node) {\n      return reportsBuffer.reports.some(r => r.node === node);\n    }\n\n    function removeFromCurrentReportsBuffer(node) {\n      reportsBuffer.reports = reportsBuffer.reports.filter(r => r.node !== node);\n    }\n\n    function isMemberExpInNewCallee(node) {\n      if (node.type === \"MemberExpression\") {\n        return node.parent.type === \"NewExpression\" && node.parent.callee === node ? true : node.parent.object === node && isMemberExpInNewCallee(node.parent);\n      }\n\n      return false;\n    }\n\n    return {\n      ArrayExpression(node) {\n        node.elements.filter(e => e && hasExcessParensWithPrecedence(e, PRECEDENCE_OF_ASSIGNMENT_EXPR)).forEach(report);\n      },\n\n      ArrayPattern(node) {\n        node.elements.filter(e => canBeAssignmentTarget(e) && hasExcessParens(e)).forEach(report);\n      },\n\n      ArrowFunctionExpression(node) {\n        if (isReturnAssignException(node)) {\n          return;\n        }\n\n        if (node.body.type === \"ConditionalExpression\" && IGNORE_ARROW_CONDITIONALS) {\n          return;\n        }\n\n        if (node.body.type !== \"BlockStatement\") {\n          const firstBodyToken = sourceCode.getFirstToken(node.body, astUtils.isNotOpeningParenToken);\n          const tokenBeforeFirst = sourceCode.getTokenBefore(firstBodyToken);\n\n          if (astUtils.isOpeningParenToken(tokenBeforeFirst) && astUtils.isOpeningBraceToken(firstBodyToken)) {\n            tokensToIgnore.add(firstBodyToken);\n          }\n\n          if (hasExcessParensWithPrecedence(node.body, PRECEDENCE_OF_ASSIGNMENT_EXPR)) {\n            report(node.body);\n          }\n        }\n      },\n\n      AssignmentExpression(node) {\n        if (canBeAssignmentTarget(node.left) && hasExcessParens(node.left)) {\n          report(node.left);\n        }\n\n        if (!isReturnAssignException(node) && hasExcessParensWithPrecedence(node.right, precedence(node))) {\n          report(node.right);\n        }\n      },\n\n      BinaryExpression(node) {\n        if (reportsBuffer && node.operator === \"in\") {\n          reportsBuffer.inExpressionNodes.push(node);\n        }\n\n        checkBinaryLogical(node);\n      },\n\n      CallExpression: checkCallNew,\n\n      ClassBody(node) {\n        node.body.filter(member => member.type === \"MethodDefinition\" && member.computed && member.key).filter(member => hasExcessParensWithPrecedence(member.key, PRECEDENCE_OF_ASSIGNMENT_EXPR)).forEach(member => report(member.key));\n      },\n\n      ConditionalExpression(node) {\n        if (isReturnAssignException(node)) {\n          return;\n        }\n\n        if (!isCondAssignException(node) && hasExcessParensWithPrecedence(node.test, precedence({\n          type: \"LogicalExpression\",\n          operator: \"||\"\n        }))) {\n          report(node.test);\n        }\n\n        if (hasExcessParensWithPrecedence(node.consequent, PRECEDENCE_OF_ASSIGNMENT_EXPR)) {\n          report(node.consequent);\n        }\n\n        if (hasExcessParensWithPrecedence(node.alternate, PRECEDENCE_OF_ASSIGNMENT_EXPR)) {\n          report(node.alternate);\n        }\n      },\n\n      DoWhileStatement(node) {\n        if (hasExcessParens(node.test) && !isCondAssignException(node)) {\n          report(node.test);\n        }\n      },\n\n      ExportDefaultDeclaration: node => checkExpressionOrExportStatement(node.declaration),\n      ExpressionStatement: node => checkExpressionOrExportStatement(node.expression),\n\n      ForInStatement(node) {\n        if (node.left.type !== \"VariableDeclaration\") {\n          const firstLeftToken = sourceCode.getFirstToken(node.left, astUtils.isNotOpeningParenToken);\n\n          if (firstLeftToken.value === \"let\" && astUtils.isOpeningBracketToken(sourceCode.getTokenAfter(firstLeftToken, astUtils.isNotClosingParenToken))) {\n            tokensToIgnore.add(firstLeftToken);\n          }\n        }\n\n        if (hasExcessParens(node.left)) {\n          report(node.left);\n        }\n\n        if (hasExcessParens(node.right)) {\n          report(node.right);\n        }\n      },\n\n      ForOfStatement(node) {\n        if (node.left.type !== \"VariableDeclaration\") {\n          const firstLeftToken = sourceCode.getFirstToken(node.left, astUtils.isNotOpeningParenToken);\n\n          if (firstLeftToken.value === \"let\") {\n            tokensToIgnore.add(firstLeftToken);\n          }\n        }\n\n        if (hasExcessParens(node.left)) {\n          report(node.left);\n        }\n\n        if (hasExcessParensWithPrecedence(node.right, PRECEDENCE_OF_ASSIGNMENT_EXPR)) {\n          report(node.right);\n        }\n      },\n\n      ForStatement(node) {\n        if (node.test && hasExcessParens(node.test) && !isCondAssignException(node)) {\n          report(node.test);\n        }\n\n        if (node.update && hasExcessParens(node.update)) {\n          report(node.update);\n        }\n\n        if (node.init) {\n          if (node.init.type !== \"VariableDeclaration\") {\n            const firstToken = sourceCode.getFirstToken(node.init, astUtils.isNotOpeningParenToken);\n\n            if (firstToken.value === \"let\" && astUtils.isOpeningBracketToken(sourceCode.getTokenAfter(firstToken, astUtils.isNotClosingParenToken))) {\n              tokensToIgnore.add(firstToken);\n            }\n          }\n\n          startNewReportsBuffering();\n\n          if (hasExcessParens(node.init)) {\n            report(node.init);\n          }\n        }\n      },\n\n      \"ForStatement > *.init:exit\"(node) {\n        if (reportsBuffer.reports.length) {\n          reportsBuffer.inExpressionNodes.forEach(inExpressionNode => {\n            const path = pathToDescendant(node, inExpressionNode);\n            let nodeToExclude;\n\n            for (let i = 0; i < path.length; i++) {\n              const pathNode = path[i];\n\n              if (i < path.length - 1) {\n                const nextPathNode = path[i + 1];\n\n                if (isSafelyEnclosingInExpression(pathNode, nextPathNode)) {\n                  return;\n                }\n              }\n\n              if (isParenthesised(pathNode)) {\n                if (isInCurrentReportsBuffer(pathNode)) {\n                  if (isParenthesisedTwice(pathNode)) {\n                    return;\n                  }\n\n                  if (!nodeToExclude) {\n                    nodeToExclude = pathNode;\n                  }\n                } else {\n                  return;\n                }\n              }\n            }\n\n            removeFromCurrentReportsBuffer(nodeToExclude);\n          });\n        }\n\n        endCurrentReportsBuffering();\n      },\n\n      IfStatement(node) {\n        if (hasExcessParens(node.test) && !isCondAssignException(node)) {\n          report(node.test);\n        }\n      },\n\n      ImportExpression(node) {\n        const {\n          source\n        } = node;\n\n        if (source.type === \"SequenceExpression\") {\n          if (hasDoubleExcessParens(source)) {\n            report(source);\n          }\n        } else if (hasExcessParens(source)) {\n          report(source);\n        }\n      },\n\n      LogicalExpression: checkBinaryLogical,\n\n      MemberExpression(node) {\n        const shouldAllowWrapOnce = isMemberExpInNewCallee(node) && doesMemberExpressionContainCallExpression(node);\n        const nodeObjHasExcessParens = shouldAllowWrapOnce ? hasDoubleExcessParens(node.object) : hasExcessParens(node.object) && !(isImmediateFunctionPrototypeMethodCall(node.parent) && node.parent.callee === node && IGNORE_FUNCTION_PROTOTYPE_METHODS);\n\n        if (nodeObjHasExcessParens && precedence(node.object) >= precedence(node) && (node.computed || !(astUtils.isDecimalInteger(node.object) || node.object.type === \"Literal\" && node.object.regex))) {\n          report(node.object);\n        }\n\n        if (nodeObjHasExcessParens && node.object.type === \"CallExpression\") {\n          report(node.object);\n        }\n\n        if (nodeObjHasExcessParens && !IGNORE_NEW_IN_MEMBER_EXPR && node.object.type === \"NewExpression\" && isNewExpressionWithParens(node.object)) {\n          report(node.object);\n        }\n\n        if (nodeObjHasExcessParens && node.optional && node.object.type === \"ChainExpression\") {\n          report(node.object);\n        }\n\n        if (node.computed && hasExcessParens(node.property)) {\n          report(node.property);\n        }\n      },\n\n      NewExpression: checkCallNew,\n\n      ObjectExpression(node) {\n        node.properties.filter(property => property.value && hasExcessParensWithPrecedence(property.value, PRECEDENCE_OF_ASSIGNMENT_EXPR)).forEach(property => report(property.value));\n      },\n\n      ObjectPattern(node) {\n        node.properties.filter(property => {\n          const value = property.value;\n          return canBeAssignmentTarget(value) && hasExcessParens(value);\n        }).forEach(property => report(property.value));\n      },\n\n      Property(node) {\n        if (node.computed) {\n          const {\n            key\n          } = node;\n\n          if (key && hasExcessParensWithPrecedence(key, PRECEDENCE_OF_ASSIGNMENT_EXPR)) {\n            report(key);\n          }\n        }\n      },\n\n      RestElement(node) {\n        const argument = node.argument;\n\n        if (canBeAssignmentTarget(argument) && hasExcessParens(argument)) {\n          report(argument);\n        }\n      },\n\n      ReturnStatement(node) {\n        const returnToken = sourceCode.getFirstToken(node);\n\n        if (isReturnAssignException(node)) {\n          return;\n        }\n\n        if (node.argument && hasExcessParensNoLineTerminator(returnToken, node.argument) && !(node.argument.type === \"Literal\" && node.argument.regex)) {\n          report(node.argument);\n        }\n      },\n\n      SequenceExpression(node) {\n        const precedenceOfNode = precedence(node);\n        node.expressions.filter(e => hasExcessParensWithPrecedence(e, precedenceOfNode)).forEach(report);\n      },\n\n      SwitchCase(node) {\n        if (node.test && hasExcessParens(node.test)) {\n          report(node.test);\n        }\n      },\n\n      SwitchStatement(node) {\n        if (hasExcessParens(node.discriminant)) {\n          report(node.discriminant);\n        }\n      },\n\n      ThrowStatement(node) {\n        const throwToken = sourceCode.getFirstToken(node);\n\n        if (hasExcessParensNoLineTerminator(throwToken, node.argument)) {\n          report(node.argument);\n        }\n      },\n\n      UnaryExpression: checkArgumentWithPrecedence,\n\n      UpdateExpression(node) {\n        if (node.prefix) {\n          checkArgumentWithPrecedence(node);\n        } else {\n          const {\n            argument\n          } = node;\n          const operatorToken = sourceCode.getLastToken(node);\n\n          if (argument.loc.end.line === operatorToken.loc.start.line) {\n            checkArgumentWithPrecedence(node);\n          } else {\n            if (hasDoubleExcessParens(argument)) {\n              report(argument);\n            }\n          }\n        }\n      },\n\n      AwaitExpression: checkArgumentWithPrecedence,\n\n      VariableDeclarator(node) {\n        if (node.init && hasExcessParensWithPrecedence(node.init, PRECEDENCE_OF_ASSIGNMENT_EXPR) && !(node.init.type === \"Literal\" && node.init.regex)) {\n          report(node.init);\n        }\n      },\n\n      WhileStatement(node) {\n        if (hasExcessParens(node.test) && !isCondAssignException(node)) {\n          report(node.test);\n        }\n      },\n\n      WithStatement(node) {\n        if (hasExcessParens(node.object)) {\n          report(node.object);\n        }\n      },\n\n      YieldExpression(node) {\n        if (node.argument) {\n          const yieldToken = sourceCode.getFirstToken(node);\n\n          if (precedence(node.argument) >= precedence(node) && hasExcessParensNoLineTerminator(yieldToken, node.argument) || hasDoubleExcessParens(node.argument)) {\n            report(node.argument);\n          }\n        }\n      },\n\n      ClassDeclaration: checkClass,\n      ClassExpression: checkClass,\n      SpreadElement: checkSpreadOperator,\n      SpreadProperty: checkSpreadOperator,\n      ExperimentalSpreadProperty: checkSpreadOperator,\n\n      TemplateLiteral(node) {\n        node.expressions.filter(e => e && hasExcessParens(e)).forEach(report);\n      },\n\n      AssignmentPattern(node) {\n        const {\n          left,\n          right\n        } = node;\n\n        if (canBeAssignmentTarget(left) && hasExcessParens(left)) {\n          report(left);\n        }\n\n        if (right && hasExcessParensWithPrecedence(right, PRECEDENCE_OF_ASSIGNMENT_EXPR)) {\n          report(right);\n        }\n      }\n\n    };\n  }\n\n};\nnoExtraParens.meta;\nnoExtraParens.create;\nvar noExtraSemi = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow unnecessary semicolons\",\n      category: \"Possible Errors\",\n      recommended: true,\n      url: \"https://eslint.org/docs/rules/no-extra-semi\"\n    },\n    fixable: \"code\",\n    schema: [],\n    messages: {\n      unexpected: \"Unnecessary semicolon.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n\n    function report(nodeOrToken) {\n      context.report({\n        node: nodeOrToken,\n        messageId: \"unexpected\",\n\n        fix(fixer) {\n          return new fixTracker(fixer, context.getSourceCode()).retainSurroundingTokens(nodeOrToken).remove(nodeOrToken);\n        }\n\n      });\n    }\n\n    function checkForPartOfClassBody(firstToken) {\n      for (let token = firstToken; token.type === \"Punctuator\" && !astUtils.isClosingBraceToken(token); token = sourceCode.getTokenAfter(token)) {\n        if (astUtils.isSemicolonToken(token)) {\n          report(token);\n        }\n      }\n    }\n\n    return {\n      EmptyStatement(node) {\n        const parent = node.parent;\n\n        if ([\"ForStatement\", \"ForInStatement\", \"ForOfStatement\", \"WhileStatement\", \"DoWhileStatement\", \"IfStatement\", \"LabeledStatement\", \"WithStatement\"].indexOf(parent.type) === -1) {\n          report(node);\n        }\n      },\n\n      ClassBody(node) {\n        checkForPartOfClassBody(sourceCode.getFirstToken(node, 1));\n      },\n\n      MethodDefinition(node) {\n        checkForPartOfClassBody(sourceCode.getTokenAfter(node));\n      }\n\n    };\n  }\n\n};\nnoExtraSemi.meta;\nnoExtraSemi.create;\nconst DEFAULT_FALLTHROUGH_COMMENT = /falls?\\s?through/iu;\n\nfunction hasFallthroughComment(caseWhichFallsThrough, subsequentCase, context, fallthroughCommentPattern) {\n  const sourceCode = context.getSourceCode();\n\n  if (caseWhichFallsThrough.consequent.length === 1 && caseWhichFallsThrough.consequent[0].type === \"BlockStatement\") {\n    const trailingCloseBrace = sourceCode.getLastToken(caseWhichFallsThrough.consequent[0]);\n    const commentInBlock = sourceCode.getCommentsBefore(trailingCloseBrace).pop();\n\n    if (commentInBlock && fallthroughCommentPattern.test(commentInBlock.value)) {\n      return true;\n    }\n  }\n\n  const comment = sourceCode.getCommentsBefore(subsequentCase).pop();\n  return Boolean(comment && fallthroughCommentPattern.test(comment.value));\n}\n\nfunction isReachable(segment) {\n  return segment.reachable;\n}\n\nfunction hasBlankLinesBetween(node, token) {\n  return token.loc.start.line > node.loc.end.line + 1;\n}\n\nvar noFallthrough = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"disallow fallthrough of `case` statements\",\n      category: \"Best Practices\",\n      recommended: true,\n      url: \"https://eslint.org/docs/rules/no-fallthrough\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        commentPattern: {\n          type: \"string\",\n          default: \"\"\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      case: \"Expected a 'break' statement before 'case'.\",\n      default: \"Expected a 'break' statement before 'default'.\"\n    }\n  },\n\n  create(context) {\n    const options = context.options[0] || {};\n    let currentCodePath = null;\n    const sourceCode = context.getSourceCode();\n    let fallthroughCase = null;\n    let fallthroughCommentPattern = null;\n\n    if (options.commentPattern) {\n      fallthroughCommentPattern = new RegExp(options.commentPattern, \"u\");\n    } else {\n      fallthroughCommentPattern = DEFAULT_FALLTHROUGH_COMMENT;\n    }\n\n    return {\n      onCodePathStart(codePath) {\n        currentCodePath = codePath;\n      },\n\n      onCodePathEnd() {\n        currentCodePath = currentCodePath.upper;\n      },\n\n      SwitchCase(node) {\n        if (fallthroughCase && !hasFallthroughComment(fallthroughCase, node, context, fallthroughCommentPattern)) {\n          context.report({\n            messageId: node.test ? \"case\" : \"default\",\n            node\n          });\n        }\n\n        fallthroughCase = null;\n      },\n\n      \"SwitchCase:exit\"(node) {\n        const nextToken = sourceCode.getTokenAfter(node);\n\n        if (currentCodePath.currentSegments.some(isReachable) && (node.consequent.length > 0 || hasBlankLinesBetween(node, nextToken)) && node.parent.cases[node.parent.cases.length - 1] !== node) {\n          fallthroughCase = node;\n        }\n      }\n\n    };\n  }\n\n};\nnoFallthrough.meta;\nnoFallthrough.create;\nvar noFloatingDecimal = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow leading or trailing decimal points in numeric literals\",\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-floating-decimal\"\n    },\n    schema: [],\n    fixable: \"code\",\n    messages: {\n      leading: \"A leading decimal point can be confused with a dot.\",\n      trailing: \"A trailing decimal point can be confused with a dot.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    return {\n      Literal(node) {\n        if (typeof node.value === \"number\") {\n          if (node.raw.startsWith(\".\")) {\n            context.report({\n              node,\n              messageId: \"leading\",\n\n              fix(fixer) {\n                const tokenBefore = sourceCode.getTokenBefore(node);\n                const needsSpaceBefore = tokenBefore && tokenBefore.range[1] === node.range[0] && !astUtils.canTokensBeAdjacent(tokenBefore, `0${node.raw}`);\n                return fixer.insertTextBefore(node, needsSpaceBefore ? \" 0\" : \"0\");\n              }\n\n            });\n          }\n\n          if (node.raw.indexOf(\".\") === node.raw.length - 1) {\n            context.report({\n              node,\n              messageId: \"trailing\",\n              fix: fixer => fixer.insertTextAfter(node, \"0\")\n            });\n          }\n        }\n      }\n\n    };\n  }\n\n};\nnoFloatingDecimal.meta;\nnoFloatingDecimal.create;\nvar noFuncAssign = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"disallow reassigning `function` declarations\",\n      category: \"Possible Errors\",\n      recommended: true,\n      url: \"https://eslint.org/docs/rules/no-func-assign\"\n    },\n    schema: [],\n    messages: {\n      isAFunction: \"'{{name}}' is a function.\"\n    }\n  },\n\n  create(context) {\n    function checkReference(references) {\n      astUtils.getModifyingReferences(references).forEach(reference => {\n        context.report({\n          node: reference.identifier,\n          messageId: \"isAFunction\",\n          data: {\n            name: reference.identifier.name\n          }\n        });\n      });\n    }\n\n    function checkVariable(variable) {\n      if (variable.defs[0].type === \"FunctionName\") {\n        checkReference(variable.references);\n      }\n    }\n\n    function checkForFunction(node) {\n      context.getDeclaredVariables(node).forEach(checkVariable);\n    }\n\n    return {\n      FunctionDeclaration: checkForFunction,\n      FunctionExpression: checkForFunction\n    };\n  }\n\n};\nnoFuncAssign.meta;\nnoFuncAssign.create;\nvar noGlobalAssign = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow assignments to native objects or read-only global variables\",\n      category: \"Best Practices\",\n      recommended: true,\n      url: \"https://eslint.org/docs/rules/no-global-assign\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        exceptions: {\n          type: \"array\",\n          items: {\n            type: \"string\"\n          },\n          uniqueItems: true\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      globalShouldNotBeModified: \"Read-only global '{{name}}' should not be modified.\"\n    }\n  },\n\n  create(context) {\n    const config = context.options[0];\n    const exceptions = config && config.exceptions || [];\n\n    function checkReference(reference, index, references) {\n      const identifier = reference.identifier;\n\n      if (reference.init === false && reference.isWrite() && (index === 0 || references[index - 1].identifier !== identifier)) {\n        context.report({\n          node: identifier,\n          messageId: \"globalShouldNotBeModified\",\n          data: {\n            name: identifier.name\n          }\n        });\n      }\n    }\n\n    function checkVariable(variable) {\n      if (variable.writeable === false && exceptions.indexOf(variable.name) === -1) {\n        variable.references.forEach(checkReference);\n      }\n    }\n\n    return {\n      Program() {\n        const globalScope = context.getScope();\n        globalScope.variables.forEach(checkVariable);\n      }\n\n    };\n  }\n\n};\nnoGlobalAssign.meta;\nnoGlobalAssign.create;\nconst INDEX_OF_PATTERN = /^(?:i|lastI)ndexOf$/u;\nconst ALLOWABLE_OPERATORS = [\"~\", \"!!\", \"+\", \"*\"];\n\nfunction parseOptions$1(options) {\n  return {\n    boolean: \"boolean\" in options ? options.boolean : true,\n    number: \"number\" in options ? options.number : true,\n    string: \"string\" in options ? options.string : true,\n    disallowTemplateShorthand: \"disallowTemplateShorthand\" in options ? options.disallowTemplateShorthand : false,\n    allow: options.allow || []\n  };\n}\n\nfunction isDoubleLogicalNegating(node) {\n  return node.operator === \"!\" && node.argument.type === \"UnaryExpression\" && node.argument.operator === \"!\";\n}\n\nfunction isBinaryNegatingOfIndexOf(node) {\n  if (node.operator !== \"~\") {\n    return false;\n  }\n\n  const callNode = astUtils.skipChainExpression(node.argument);\n  return callNode.type === \"CallExpression\" && astUtils.isSpecificMemberAccess(callNode.callee, null, INDEX_OF_PATTERN);\n}\n\nfunction isMultiplyByOne(node) {\n  return node.operator === \"*\" && (node.left.type === \"Literal\" && node.left.value === 1 || node.right.type === \"Literal\" && node.right.value === 1);\n}\n\nfunction isNumeric(node) {\n  return node.type === \"Literal\" && typeof node.value === \"number\" || node.type === \"CallExpression\" && (node.callee.name === \"Number\" || node.callee.name === \"parseInt\" || node.callee.name === \"parseFloat\");\n}\n\nfunction getNonNumericOperand(node) {\n  const left = node.left,\n        right = node.right;\n\n  if (right.type !== \"BinaryExpression\" && !isNumeric(right)) {\n    return right;\n  }\n\n  if (left.type !== \"BinaryExpression\" && !isNumeric(left)) {\n    return left;\n  }\n\n  return null;\n}\n\nfunction isStringType(node) {\n  return astUtils.isStringLiteral(node) || node.type === \"CallExpression\" && node.callee.type === \"Identifier\" && node.callee.name === \"String\";\n}\n\nfunction isEmptyString(node) {\n  return astUtils.isStringLiteral(node) && (node.value === \"\" || node.type === \"TemplateLiteral\" && node.quasis.length === 1 && node.quasis[0].value.cooked === \"\");\n}\n\nfunction isConcatWithEmptyString(node) {\n  return node.operator === \"+\" && (isEmptyString(node.left) && !isStringType(node.right) || isEmptyString(node.right) && !isStringType(node.left));\n}\n\nfunction isAppendEmptyString(node) {\n  return node.operator === \"+=\" && isEmptyString(node.right);\n}\n\nfunction getNonEmptyOperand(node) {\n  return isEmptyString(node.left) ? node.right : node.left;\n}\n\nvar noImplicitCoercion = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow shorthand type conversions\",\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-implicit-coercion\"\n    },\n    fixable: \"code\",\n    schema: [{\n      type: \"object\",\n      properties: {\n        boolean: {\n          type: \"boolean\",\n          default: true\n        },\n        number: {\n          type: \"boolean\",\n          default: true\n        },\n        string: {\n          type: \"boolean\",\n          default: true\n        },\n        disallowTemplateShorthand: {\n          type: \"boolean\",\n          default: false\n        },\n        allow: {\n          type: \"array\",\n          items: {\n            enum: ALLOWABLE_OPERATORS\n          },\n          uniqueItems: true\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      useRecommendation: \"use `{{recommendation}}` instead.\"\n    }\n  },\n\n  create(context) {\n    const options = parseOptions$1(context.options[0] || {});\n    const sourceCode = context.getSourceCode();\n\n    function report(node, recommendation, shouldFix) {\n      context.report({\n        node,\n        messageId: \"useRecommendation\",\n        data: {\n          recommendation\n        },\n\n        fix(fixer) {\n          if (!shouldFix) {\n            return null;\n          }\n\n          const tokenBefore = sourceCode.getTokenBefore(node);\n\n          if (tokenBefore && tokenBefore.range[1] === node.range[0] && !astUtils.canTokensBeAdjacent(tokenBefore, recommendation)) {\n            return fixer.replaceText(node, ` ${recommendation}`);\n          }\n\n          return fixer.replaceText(node, recommendation);\n        }\n\n      });\n    }\n\n    return {\n      UnaryExpression(node) {\n        let operatorAllowed = options.allow.indexOf(\"!!\") >= 0;\n\n        if (!operatorAllowed && options.boolean && isDoubleLogicalNegating(node)) {\n          const recommendation = `Boolean(${sourceCode.getText(node.argument.argument)})`;\n          report(node, recommendation, true);\n        }\n\n        operatorAllowed = options.allow.indexOf(\"~\") >= 0;\n\n        if (!operatorAllowed && options.boolean && isBinaryNegatingOfIndexOf(node)) {\n          const comparison = node.argument.type === \"ChainExpression\" ? \">= 0\" : \"!== -1\";\n          const recommendation = `${sourceCode.getText(node.argument)} ${comparison}`;\n          report(node, recommendation, false);\n        }\n\n        operatorAllowed = options.allow.indexOf(\"+\") >= 0;\n\n        if (!operatorAllowed && options.number && node.operator === \"+\" && !isNumeric(node.argument)) {\n          const recommendation = `Number(${sourceCode.getText(node.argument)})`;\n          report(node, recommendation, true);\n        }\n      },\n\n      \"BinaryExpression:exit\"(node) {\n        let operatorAllowed = options.allow.indexOf(\"*\") >= 0;\n        const nonNumericOperand = !operatorAllowed && options.number && isMultiplyByOne(node) && getNonNumericOperand(node);\n\n        if (nonNumericOperand) {\n          const recommendation = `Number(${sourceCode.getText(nonNumericOperand)})`;\n          report(node, recommendation, true);\n        }\n\n        operatorAllowed = options.allow.indexOf(\"+\") >= 0;\n\n        if (!operatorAllowed && options.string && isConcatWithEmptyString(node)) {\n          const recommendation = `String(${sourceCode.getText(getNonEmptyOperand(node))})`;\n          report(node, recommendation, true);\n        }\n      },\n\n      AssignmentExpression(node) {\n        const operatorAllowed = options.allow.indexOf(\"+\") >= 0;\n\n        if (!operatorAllowed && options.string && isAppendEmptyString(node)) {\n          const code = sourceCode.getText(getNonEmptyOperand(node));\n          report(node, `${code} = String(${code})`, true);\n        }\n      },\n\n      TemplateLiteral(node) {\n        if (!options.disallowTemplateShorthand) {\n          return;\n        }\n\n        if (node.parent.type === \"TaggedTemplateExpression\") {\n          return;\n        }\n\n        if (node.expressions.length !== 1) {\n          return;\n        }\n\n        if (node.quasis[0].value.cooked !== \"\") {\n          return;\n        }\n\n        if (node.quasis[1].value.cooked !== \"\") {\n          return;\n        }\n\n        if (isStringType(node.expressions[0])) {\n          return;\n        }\n\n        const code = sourceCode.getText(node.expressions[0]);\n        report(node, `String(${code})`, true);\n      }\n\n    };\n  }\n\n};\nnoImplicitCoercion.meta;\nnoImplicitCoercion.create;\nvar noImplicitGlobals = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow declarations in the global scope\",\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-implicit-globals\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        lexicalBindings: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      globalNonLexicalBinding: \"Unexpected {{kind}} declaration in the global scope, wrap in an IIFE for a local variable, assign as global property for a global variable.\",\n      globalLexicalBinding: \"Unexpected {{kind}} declaration in the global scope, wrap in a block or in an IIFE.\",\n      globalVariableLeak: \"Global variable leak, declare the variable if it is intended to be local.\",\n      assignmentToReadonlyGlobal: \"Unexpected assignment to read-only global variable.\",\n      redeclarationOfReadonlyGlobal: \"Unexpected redeclaration of read-only global variable.\"\n    }\n  },\n\n  create(context) {\n    const checkLexicalBindings = context.options[0] && context.options[0].lexicalBindings === true;\n\n    function report(node, messageId, kind) {\n      context.report({\n        node,\n        messageId,\n        data: {\n          kind\n        }\n      });\n    }\n\n    return {\n      Program() {\n        const scope = context.getScope();\n        scope.variables.forEach(variable => {\n          const isReadonlyEslintGlobalVariable = variable.writeable === false;\n          const isWritableEslintGlobalVariable = variable.writeable === true;\n\n          if (isWritableEslintGlobalVariable) {\n            return;\n          }\n\n          variable.defs.forEach(def => {\n            const defNode = def.node;\n\n            if (def.type === \"FunctionName\" || def.type === \"Variable\" && def.parent.kind === \"var\") {\n              if (isReadonlyEslintGlobalVariable) {\n                report(defNode, \"redeclarationOfReadonlyGlobal\");\n              } else {\n                report(defNode, \"globalNonLexicalBinding\", def.type === \"FunctionName\" ? \"function\" : `'${def.parent.kind}'`);\n              }\n            }\n\n            if (checkLexicalBindings) {\n              if (def.type === \"ClassName\" || def.type === \"Variable\" && (def.parent.kind === \"let\" || def.parent.kind === \"const\")) {\n                if (isReadonlyEslintGlobalVariable) {\n                  report(defNode, \"redeclarationOfReadonlyGlobal\");\n                } else {\n                  report(defNode, \"globalLexicalBinding\", def.type === \"ClassName\" ? \"class\" : `'${def.parent.kind}'`);\n                }\n              }\n            }\n          });\n        });\n        scope.implicit.variables.forEach(variable => {\n          const scopeVariable = scope.set.get(variable.name);\n          let messageId;\n\n          if (scopeVariable) {\n            if (scopeVariable.writeable) {\n              return;\n            }\n\n            messageId = \"assignmentToReadonlyGlobal\";\n          } else {\n            messageId = \"globalVariableLeak\";\n          }\n\n          variable.defs.forEach(def => {\n            report(def.node, messageId);\n          });\n        });\n      }\n\n    };\n  }\n\n};\nnoImplicitGlobals.meta;\nnoImplicitGlobals.create;\nconst {\n  getStaticValue\n} = eslintUtils__default['default'];\nvar noImpliedEval = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow the use of `eval()`-like methods\",\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-implied-eval\"\n    },\n    schema: [],\n    messages: {\n      impliedEval: \"Implied eval. Consider passing a function instead of a string.\"\n    }\n  },\n\n  create(context) {\n    const GLOBAL_CANDIDATES = Object.freeze([\"global\", \"window\", \"globalThis\"]);\n    const EVAL_LIKE_FUNC_PATTERN = /^(?:set(?:Interval|Timeout)|execScript)$/u;\n\n    function isEvaluatedString(node) {\n      if (node.type === \"Literal\" && typeof node.value === \"string\" || node.type === \"TemplateLiteral\") {\n        return true;\n      }\n\n      if (node.type === \"BinaryExpression\" && node.operator === \"+\") {\n        return isEvaluatedString(node.left) || isEvaluatedString(node.right);\n      }\n\n      return false;\n    }\n\n    function reportImpliedEvalCallExpression(node) {\n      const [firstArgument] = node.arguments;\n\n      if (firstArgument) {\n        const staticValue = getStaticValue(firstArgument, context.getScope());\n        const isStaticString = staticValue && typeof staticValue.value === \"string\";\n        const isString = isStaticString || isEvaluatedString(firstArgument);\n\n        if (isString) {\n          context.report({\n            node,\n            messageId: \"impliedEval\"\n          });\n        }\n      }\n    }\n\n    function reportImpliedEvalViaGlobal(globalVar) {\n      const {\n        references,\n        name\n      } = globalVar;\n      references.forEach(ref => {\n        const identifier = ref.identifier;\n        let node = identifier.parent;\n\n        while (astUtils.isSpecificMemberAccess(node, null, name)) {\n          node = node.parent;\n        }\n\n        if (astUtils.isSpecificMemberAccess(node, null, EVAL_LIKE_FUNC_PATTERN)) {\n          const calleeNode = node.parent.type === \"ChainExpression\" ? node.parent : node;\n          const parent = calleeNode.parent;\n\n          if (parent.type === \"CallExpression\" && parent.callee === calleeNode) {\n            reportImpliedEvalCallExpression(parent);\n          }\n        }\n      });\n    }\n\n    return {\n      CallExpression(node) {\n        if (astUtils.isSpecificId(node.callee, EVAL_LIKE_FUNC_PATTERN)) {\n          reportImpliedEvalCallExpression(node);\n        }\n      },\n\n      \"Program:exit\"() {\n        const globalScope = context.getScope();\n        GLOBAL_CANDIDATES.map(candidate => astUtils.getVariableByName(globalScope, candidate)).filter(globalVar => !!globalVar && globalVar.defs.length === 0).forEach(reportImpliedEvalViaGlobal);\n      }\n\n    };\n  }\n\n};\nnoImpliedEval.meta;\nnoImpliedEval.create;\nconst {\n  findVariable: findVariable$3\n} = eslintUtils__default['default'];\nconst WellKnownMutationFunctions = {\n  Object: /^(?:assign|definePropert(?:y|ies)|freeze|setPrototypeOf)$/u,\n  Reflect: /^(?:(?:define|delete)Property|set(?:PrototypeOf)?)$/u\n};\n\nfunction isAssignmentLeft(node) {\n  const {\n    parent\n  } = node;\n  return parent.type === \"AssignmentExpression\" && parent.left === node || parent.type === \"ArrayPattern\" || parent.type === \"Property\" && parent.value === node && parent.parent.type === \"ObjectPattern\" || parent.type === \"RestElement\" || parent.type === \"AssignmentPattern\" && parent.left === node;\n}\n\nfunction isOperandOfMutationUnaryOperator(node) {\n  const argumentNode = node.parent.type === \"ChainExpression\" ? node.parent : node;\n  const {\n    parent\n  } = argumentNode;\n  return parent.type === \"UpdateExpression\" && parent.argument === argumentNode || parent.type === \"UnaryExpression\" && parent.operator === \"delete\" && parent.argument === argumentNode;\n}\n\nfunction isIterationVariable(node) {\n  const {\n    parent\n  } = node;\n  return parent.type === \"ForInStatement\" && parent.left === node || parent.type === \"ForOfStatement\" && parent.left === node;\n}\n\nfunction isArgumentOfWellKnownMutationFunction(node, scope) {\n  const {\n    parent\n  } = node;\n\n  if (parent.type !== \"CallExpression\" || parent.arguments[0] !== node) {\n    return false;\n  }\n\n  const callee = astUtils.skipChainExpression(parent.callee);\n\n  if (!astUtils.isSpecificMemberAccess(callee, \"Object\", WellKnownMutationFunctions.Object) && !astUtils.isSpecificMemberAccess(callee, \"Reflect\", WellKnownMutationFunctions.Reflect)) {\n    return false;\n  }\n\n  const variable = findVariable$3(scope, callee.object);\n  return variable !== null && variable.scope.type === \"global\";\n}\n\nfunction isMemberWrite(id, scope) {\n  const {\n    parent\n  } = id;\n  return parent.type === \"MemberExpression\" && parent.object === id && (isAssignmentLeft(parent) || isOperandOfMutationUnaryOperator(parent) || isIterationVariable(parent)) || isArgumentOfWellKnownMutationFunction(id, scope);\n}\n\nfunction getWriteNode(id) {\n  let node = id.parent;\n\n  while (node && node.type !== \"AssignmentExpression\" && node.type !== \"UpdateExpression\" && node.type !== \"UnaryExpression\" && node.type !== \"CallExpression\" && node.type !== \"ForInStatement\" && node.type !== \"ForOfStatement\") {\n    node = node.parent;\n  }\n\n  return node || id;\n}\n\nvar noImportAssign = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"disallow assigning to imported bindings\",\n      category: \"Possible Errors\",\n      recommended: true,\n      url: \"https://eslint.org/docs/rules/no-import-assign\"\n    },\n    schema: [],\n    messages: {\n      readonly: \"'{{name}}' is read-only.\",\n      readonlyMember: \"The members of '{{name}}' are read-only.\"\n    }\n  },\n\n  create(context) {\n    return {\n      ImportDeclaration(node) {\n        const scope = context.getScope();\n\n        for (const variable of context.getDeclaredVariables(node)) {\n          const shouldCheckMembers = variable.defs.some(d => d.node.type === \"ImportNamespaceSpecifier\");\n          let prevIdNode = null;\n\n          for (const reference of variable.references) {\n            const idNode = reference.identifier;\n\n            if (idNode === prevIdNode) {\n              continue;\n            }\n\n            prevIdNode = idNode;\n\n            if (reference.isWrite()) {\n              context.report({\n                node: getWriteNode(idNode),\n                messageId: \"readonly\",\n                data: {\n                  name: idNode.name\n                }\n              });\n            } else if (shouldCheckMembers && isMemberWrite(idNode, scope)) {\n              context.report({\n                node: getWriteNode(idNode),\n                messageId: \"readonlyMember\",\n                data: {\n                  name: idNode.name\n                }\n              });\n            }\n          }\n        }\n      }\n\n    };\n  }\n\n};\nnoImportAssign.meta;\nnoImportAssign.create;\nvar noInlineComments = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow inline comments after code\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-inline-comments\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        ignorePattern: {\n          type: \"string\"\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      unexpectedInlineComment: \"Unexpected comment inline with code.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    const options = context.options[0];\n    let customIgnoreRegExp;\n\n    if (options && options.ignorePattern) {\n      customIgnoreRegExp = new RegExp(options.ignorePattern, \"u\");\n    }\n\n    function testCodeAroundComment(node) {\n      const startLine = String(sourceCode.lines[node.loc.start.line - 1]),\n            endLine = String(sourceCode.lines[node.loc.end.line - 1]),\n            preamble = startLine.slice(0, node.loc.start.column).trim(),\n            postamble = endLine.slice(node.loc.end.column).trim(),\n            isPreambleEmpty = !preamble,\n            isPostambleEmpty = !postamble;\n\n      if (isPreambleEmpty && isPostambleEmpty) {\n        return;\n      }\n\n      if (customIgnoreRegExp && customIgnoreRegExp.test(node.value)) {\n        return;\n      }\n\n      if ((isPreambleEmpty || preamble === \"{\") && (isPostambleEmpty || postamble === \"}\")) {\n        const enclosingNode = sourceCode.getNodeByRangeIndex(node.range[0]);\n\n        if (enclosingNode && enclosingNode.type === \"JSXEmptyExpression\") {\n          return;\n        }\n      }\n\n      if (astUtils.isDirectiveComment(node)) {\n        return;\n      }\n\n      context.report({\n        node,\n        messageId: \"unexpectedInlineComment\"\n      });\n    }\n\n    return {\n      Program() {\n        sourceCode.getAllComments().filter(token => token.type !== \"Shebang\").forEach(testCodeAroundComment);\n      }\n\n    };\n  }\n\n};\nnoInlineComments.meta;\nnoInlineComments.create;\nconst validParent = new Set([\"Program\", \"ExportNamedDeclaration\", \"ExportDefaultDeclaration\"]);\nconst validBlockStatementParent = new Set([\"FunctionDeclaration\", \"FunctionExpression\", \"ArrowFunctionExpression\"]);\nvar noInnerDeclarations = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"disallow variable or `function` declarations in nested blocks\",\n      category: \"Possible Errors\",\n      recommended: true,\n      url: \"https://eslint.org/docs/rules/no-inner-declarations\"\n    },\n    schema: [{\n      enum: [\"functions\", \"both\"]\n    }],\n    messages: {\n      moveDeclToRoot: \"Move {{type}} declaration to {{body}} root.\"\n    }\n  },\n\n  create(context) {\n    function check(node) {\n      const parent = node.parent;\n\n      if (parent.type === \"BlockStatement\" && validBlockStatementParent.has(parent.parent.type)) {\n        return;\n      }\n\n      if (validParent.has(parent.type)) {\n        return;\n      }\n\n      const upperFunction = astUtils.getUpperFunction(parent);\n      context.report({\n        node,\n        messageId: \"moveDeclToRoot\",\n        data: {\n          type: node.type === \"FunctionDeclaration\" ? \"function\" : \"variable\",\n          body: upperFunction === null ? \"program\" : \"function body\"\n        }\n      });\n    }\n\n    return {\n      FunctionDeclaration: check,\n\n      VariableDeclaration(node) {\n        if (context.options[0] === \"both\" && node.kind === \"var\") {\n          check(node);\n        }\n      }\n\n    };\n  }\n\n};\nnoInnerDeclarations.meta;\nnoInnerDeclarations.create;\nconst RegExpValidator = regexpp__default['default'].RegExpValidator;\nconst validator = new RegExpValidator();\nconst validFlags = /[gimuys]/gu;\nconst undefined1 = void 0;\nvar noInvalidRegexp = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"disallow invalid regular expression strings in `RegExp` constructors\",\n      category: \"Possible Errors\",\n      recommended: true,\n      url: \"https://eslint.org/docs/rules/no-invalid-regexp\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        allowConstructorFlags: {\n          type: \"array\",\n          items: {\n            type: \"string\"\n          }\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      regexMessage: \"{{message}}.\"\n    }\n  },\n\n  create(context) {\n    const options = context.options[0];\n    let allowedFlags = null;\n\n    if (options && options.allowConstructorFlags) {\n      const temp = options.allowConstructorFlags.join(\"\").replace(validFlags, \"\");\n\n      if (temp) {\n        allowedFlags = new RegExp(`[${temp}]`, \"giu\");\n      }\n    }\n\n    function isString(node) {\n      return node && node.type === \"Literal\" && typeof node.value === \"string\";\n    }\n\n    function getFlags(node) {\n      if (node.arguments.length < 2) {\n        return \"\";\n      }\n\n      if (isString(node.arguments[1])) {\n        return node.arguments[1].value;\n      }\n\n      return null;\n    }\n\n    function validateRegExpPattern(pattern, uFlag) {\n      try {\n        validator.validatePattern(pattern, undefined1, undefined1, uFlag);\n        return null;\n      } catch (err) {\n        return err.message;\n      }\n    }\n\n    function validateRegExpFlags(flags) {\n      try {\n        validator.validateFlags(flags);\n        return null;\n      } catch {\n        return `Invalid flags supplied to RegExp constructor '${flags}'`;\n      }\n    }\n\n    return {\n      \"CallExpression, NewExpression\"(node) {\n        if (node.callee.type !== \"Identifier\" || node.callee.name !== \"RegExp\" || !isString(node.arguments[0])) {\n          return;\n        }\n\n        const pattern = node.arguments[0].value;\n        let flags = getFlags(node);\n\n        if (flags && allowedFlags) {\n          flags = flags.replace(allowedFlags, \"\");\n        }\n\n        const message = flags && validateRegExpFlags(flags) || (flags === null ? validateRegExpPattern(pattern, true) && validateRegExpPattern(pattern, false) : validateRegExpPattern(pattern, flags.includes(\"u\")));\n\n        if (message) {\n          context.report({\n            node,\n            messageId: \"regexMessage\",\n            data: {\n              message\n            }\n          });\n        }\n      }\n\n    };\n  }\n\n};\nnoInvalidRegexp.meta;\nnoInvalidRegexp.create;\nvar noInvalidThis = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow `this` keywords outside of classes or class-like objects\",\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-invalid-this\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        capIsConstructor: {\n          type: \"boolean\",\n          default: true\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      unexpectedThis: \"Unexpected 'this'.\"\n    }\n  },\n\n  create(context) {\n    const options = context.options[0] || {};\n    const capIsConstructor = options.capIsConstructor !== false;\n    const stack = [],\n          sourceCode = context.getSourceCode();\n\n    stack.getCurrent = function () {\n      const current = this[this.length - 1];\n\n      if (!current.init) {\n        current.init = true;\n        current.valid = !astUtils.isDefaultThisBinding(current.node, sourceCode, {\n          capIsConstructor\n        });\n      }\n\n      return current;\n    };\n\n    function enterFunction(node) {\n      stack.push({\n        init: !context.getScope().isStrict,\n        node,\n        valid: true\n      });\n    }\n\n    function exitFunction() {\n      stack.pop();\n    }\n\n    return {\n      Program(node) {\n        const scope = context.getScope(),\n              features = context.parserOptions.ecmaFeatures || {};\n        stack.push({\n          init: true,\n          node,\n          valid: !(scope.isStrict || node.sourceType === \"module\" || features.globalReturn && scope.childScopes[0].isStrict)\n        });\n      },\n\n      \"Program:exit\"() {\n        stack.pop();\n      },\n\n      FunctionDeclaration: enterFunction,\n      \"FunctionDeclaration:exit\": exitFunction,\n      FunctionExpression: enterFunction,\n      \"FunctionExpression:exit\": exitFunction,\n\n      ThisExpression(node) {\n        const current = stack.getCurrent();\n\n        if (current && !current.valid) {\n          context.report({\n            node,\n            messageId: \"unexpectedThis\"\n          });\n        }\n      }\n\n    };\n  }\n\n};\nnoInvalidThis.meta;\nnoInvalidThis.create;\nconst ALL_IRREGULARS = /[\\f\\v\\u0085\\ufeff\\u00a0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u200b\\u202f\\u205f\\u3000\\u2028\\u2029]/u;\nconst IRREGULAR_WHITESPACE = /[\\f\\v\\u0085\\ufeff\\u00a0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u200b\\u202f\\u205f\\u3000]+/mgu;\nconst IRREGULAR_LINE_TERMINATORS = /[\\u2028\\u2029]/mgu;\nconst LINE_BREAK = astUtils.createGlobalLinebreakMatcher();\nvar noIrregularWhitespace = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"disallow irregular whitespace\",\n      category: \"Possible Errors\",\n      recommended: true,\n      url: \"https://eslint.org/docs/rules/no-irregular-whitespace\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        skipComments: {\n          type: \"boolean\",\n          default: false\n        },\n        skipStrings: {\n          type: \"boolean\",\n          default: true\n        },\n        skipTemplates: {\n          type: \"boolean\",\n          default: false\n        },\n        skipRegExps: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      noIrregularWhitespace: \"Irregular whitespace not allowed.\"\n    }\n  },\n\n  create(context) {\n    let errors = [];\n    const options = context.options[0] || {};\n    const skipComments = !!options.skipComments;\n    const skipStrings = options.skipStrings !== false;\n    const skipRegExps = !!options.skipRegExps;\n    const skipTemplates = !!options.skipTemplates;\n    const sourceCode = context.getSourceCode();\n    const commentNodes = sourceCode.getAllComments();\n\n    function removeWhitespaceError(node) {\n      const locStart = node.loc.start;\n      const locEnd = node.loc.end;\n      errors = errors.filter(({\n        loc: {\n          start: errorLocStart\n        }\n      }) => errorLocStart.line < locStart.line || errorLocStart.line === locStart.line && errorLocStart.column < locStart.column || errorLocStart.line === locEnd.line && errorLocStart.column >= locEnd.column || errorLocStart.line > locEnd.line);\n    }\n\n    function removeInvalidNodeErrorsInIdentifierOrLiteral(node) {\n      const shouldCheckStrings = skipStrings && typeof node.value === \"string\";\n      const shouldCheckRegExps = skipRegExps && Boolean(node.regex);\n\n      if (shouldCheckStrings || shouldCheckRegExps) {\n        if (ALL_IRREGULARS.test(node.raw)) {\n          removeWhitespaceError(node);\n        }\n      }\n    }\n\n    function removeInvalidNodeErrorsInTemplateLiteral(node) {\n      if (typeof node.value.raw === \"string\") {\n        if (ALL_IRREGULARS.test(node.value.raw)) {\n          removeWhitespaceError(node);\n        }\n      }\n    }\n\n    function removeInvalidNodeErrorsInComment(node) {\n      if (ALL_IRREGULARS.test(node.value)) {\n        removeWhitespaceError(node);\n      }\n    }\n\n    function checkForIrregularWhitespace(node) {\n      const sourceLines = sourceCode.lines;\n      sourceLines.forEach((sourceLine, lineIndex) => {\n        const lineNumber = lineIndex + 1;\n        let match;\n\n        while ((match = IRREGULAR_WHITESPACE.exec(sourceLine)) !== null) {\n          errors.push({\n            node,\n            messageId: \"noIrregularWhitespace\",\n            loc: {\n              start: {\n                line: lineNumber,\n                column: match.index\n              },\n              end: {\n                line: lineNumber,\n                column: match.index + match[0].length\n              }\n            }\n          });\n        }\n      });\n    }\n\n    function checkForIrregularLineTerminators(node) {\n      const source = sourceCode.getText(),\n            sourceLines = sourceCode.lines,\n            linebreaks = source.match(LINE_BREAK);\n      let lastLineIndex = -1,\n          match;\n\n      while ((match = IRREGULAR_LINE_TERMINATORS.exec(source)) !== null) {\n        const lineIndex = linebreaks.indexOf(match[0], lastLineIndex + 1) || 0;\n        errors.push({\n          node,\n          messageId: \"noIrregularWhitespace\",\n          loc: {\n            start: {\n              line: lineIndex + 1,\n              column: sourceLines[lineIndex].length\n            },\n            end: {\n              line: lineIndex + 2,\n              column: 0\n            }\n          }\n        });\n        lastLineIndex = lineIndex;\n      }\n    }\n\n    function noop() {}\n\n    const nodes = {};\n\n    if (ALL_IRREGULARS.test(sourceCode.getText())) {\n      nodes.Program = function (node) {\n        checkForIrregularWhitespace(node);\n        checkForIrregularLineTerminators(node);\n      };\n\n      nodes.Identifier = removeInvalidNodeErrorsInIdentifierOrLiteral;\n      nodes.Literal = removeInvalidNodeErrorsInIdentifierOrLiteral;\n      nodes.TemplateElement = skipTemplates ? removeInvalidNodeErrorsInTemplateLiteral : noop;\n\n      nodes[\"Program:exit\"] = function () {\n        if (skipComments) {\n          commentNodes.forEach(removeInvalidNodeErrorsInComment);\n        }\n\n        errors.forEach(error => context.report(error));\n      };\n    } else {\n      nodes.Program = noop;\n    }\n\n    return nodes;\n  }\n\n};\nnoIrregularWhitespace.meta;\nnoIrregularWhitespace.create;\nconst {\n  getStaticPropertyName: getStaticPropertyName$1\n} = astUtils;\nvar noIterator = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow the use of the `__iterator__` property\",\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-iterator\"\n    },\n    schema: [],\n    messages: {\n      noIterator: \"Reserved name '__iterator__'.\"\n    }\n  },\n\n  create(context) {\n    return {\n      MemberExpression(node) {\n        if (getStaticPropertyName$1(node) === \"__iterator__\") {\n          context.report({\n            node,\n            messageId: \"noIterator\"\n          });\n        }\n      }\n\n    };\n  }\n\n};\nnoIterator.meta;\nnoIterator.create;\nvar noLabelVar = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow labels that share a name with a variable\",\n      category: \"Variables\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-label-var\"\n    },\n    schema: [],\n    messages: {\n      identifierClashWithLabel: \"Found identifier with same name as label.\"\n    }\n  },\n\n  create(context) {\n    function findIdentifier(scope, name) {\n      return astUtils.getVariableByName(scope, name) !== null;\n    }\n\n    return {\n      LabeledStatement(node) {\n        const scope = context.getScope();\n\n        if (findIdentifier(scope, node.label.name)) {\n          context.report({\n            node,\n            messageId: \"identifierClashWithLabel\"\n          });\n        }\n      }\n\n    };\n  }\n\n};\nnoLabelVar.meta;\nnoLabelVar.create;\nvar noLabels = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow labeled statements\",\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-labels\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        allowLoop: {\n          type: \"boolean\",\n          default: false\n        },\n        allowSwitch: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      unexpectedLabel: \"Unexpected labeled statement.\",\n      unexpectedLabelInBreak: \"Unexpected label in break statement.\",\n      unexpectedLabelInContinue: \"Unexpected label in continue statement.\"\n    }\n  },\n\n  create(context) {\n    const options = context.options[0];\n    const allowLoop = options && options.allowLoop;\n    const allowSwitch = options && options.allowSwitch;\n    let scopeInfo = null;\n\n    function getBodyKind(node) {\n      if (astUtils.isLoop(node)) {\n        return \"loop\";\n      }\n\n      if (node.type === \"SwitchStatement\") {\n        return \"switch\";\n      }\n\n      return \"other\";\n    }\n\n    function isAllowed(kind) {\n      switch (kind) {\n        case \"loop\":\n          return allowLoop;\n\n        case \"switch\":\n          return allowSwitch;\n\n        default:\n          return false;\n      }\n    }\n\n    function getKind(label) {\n      let info = scopeInfo;\n\n      while (info) {\n        if (info.label === label) {\n          return info.kind;\n        }\n\n        info = info.upper;\n      }\n\n      return \"other\";\n    }\n\n    return {\n      LabeledStatement(node) {\n        scopeInfo = {\n          label: node.label.name,\n          kind: getBodyKind(node.body),\n          upper: scopeInfo\n        };\n      },\n\n      \"LabeledStatement:exit\"(node) {\n        if (!isAllowed(scopeInfo.kind)) {\n          context.report({\n            node,\n            messageId: \"unexpectedLabel\"\n          });\n        }\n\n        scopeInfo = scopeInfo.upper;\n      },\n\n      BreakStatement(node) {\n        if (node.label && !isAllowed(getKind(node.label.name))) {\n          context.report({\n            node,\n            messageId: \"unexpectedLabelInBreak\"\n          });\n        }\n      },\n\n      ContinueStatement(node) {\n        if (node.label && !isAllowed(getKind(node.label.name))) {\n          context.report({\n            node,\n            messageId: \"unexpectedLabelInContinue\"\n          });\n        }\n      }\n\n    };\n  }\n\n};\nnoLabels.meta;\nnoLabels.create;\nvar noLoneBlocks = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow unnecessary nested blocks\",\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-lone-blocks\"\n    },\n    schema: [],\n    messages: {\n      redundantBlock: \"Block is redundant.\",\n      redundantNestedBlock: \"Nested block is redundant.\"\n    }\n  },\n\n  create(context) {\n    const loneBlocks = [];\n    let ruleDef;\n\n    function report(node) {\n      const messageId = node.parent.type === \"BlockStatement\" ? \"redundantNestedBlock\" : \"redundantBlock\";\n      context.report({\n        node,\n        messageId\n      });\n    }\n\n    function isLoneBlock(node) {\n      return node.parent.type === \"BlockStatement\" || node.parent.type === \"Program\" || node.parent.type === \"SwitchCase\" && !(node.parent.consequent[0] === node && node.parent.consequent.length === 1);\n    }\n\n    function markLoneBlock() {\n      if (loneBlocks.length === 0) {\n        return;\n      }\n\n      const block = context.getAncestors().pop();\n\n      if (loneBlocks[loneBlocks.length - 1] === block) {\n        loneBlocks.pop();\n      }\n    }\n\n    ruleDef = {\n      BlockStatement(node) {\n        if (isLoneBlock(node)) {\n          report(node);\n        }\n      }\n\n    };\n\n    if (context.parserOptions.ecmaVersion >= 6) {\n      ruleDef = {\n        BlockStatement(node) {\n          if (isLoneBlock(node)) {\n            loneBlocks.push(node);\n          }\n        },\n\n        \"BlockStatement:exit\"(node) {\n          if (loneBlocks.length > 0 && loneBlocks[loneBlocks.length - 1] === node) {\n            loneBlocks.pop();\n            report(node);\n          } else if (node.parent.type === \"BlockStatement\" && node.parent.body.length === 1) {\n            report(node);\n          }\n        }\n\n      };\n\n      ruleDef.VariableDeclaration = function (node) {\n        if (node.kind === \"let\" || node.kind === \"const\") {\n          markLoneBlock();\n        }\n      };\n\n      ruleDef.FunctionDeclaration = function () {\n        if (context.getScope().isStrict) {\n          markLoneBlock();\n        }\n      };\n\n      ruleDef.ClassDeclaration = markLoneBlock;\n    }\n\n    return ruleDef;\n  }\n\n};\nnoLoneBlocks.meta;\nnoLoneBlocks.create;\nvar noLonelyIf = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow `if` statements as the only statement in `else` blocks\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-lonely-if\"\n    },\n    schema: [],\n    fixable: \"code\",\n    messages: {\n      unexpectedLonelyIf: \"Unexpected if as the only statement in an else block.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    return {\n      IfStatement(node) {\n        const ancestors = context.getAncestors(),\n              parent = ancestors.pop(),\n              grandparent = ancestors.pop();\n\n        if (parent && parent.type === \"BlockStatement\" && parent.body.length === 1 && grandparent && grandparent.type === \"IfStatement\" && parent === grandparent.alternate) {\n          context.report({\n            node,\n            messageId: \"unexpectedLonelyIf\",\n\n            fix(fixer) {\n              const openingElseCurly = sourceCode.getFirstToken(parent);\n              const closingElseCurly = sourceCode.getLastToken(parent);\n              const elseKeyword = sourceCode.getTokenBefore(openingElseCurly);\n              const tokenAfterElseBlock = sourceCode.getTokenAfter(closingElseCurly);\n              const lastIfToken = sourceCode.getLastToken(node.consequent);\n              const sourceText = sourceCode.getText();\n\n              if (sourceText.slice(openingElseCurly.range[1], node.range[0]).trim() || sourceText.slice(node.range[1], closingElseCurly.range[0]).trim()) {\n                return null;\n              }\n\n              if (node.consequent.type !== \"BlockStatement\" && lastIfToken.value !== \";\" && tokenAfterElseBlock && (node.consequent.loc.end.line === tokenAfterElseBlock.loc.start.line || /^[([/+`-]/u.test(tokenAfterElseBlock.value) || lastIfToken.value === \"++\" || lastIfToken.value === \"--\")) {\n                return null;\n              }\n\n              return fixer.replaceTextRange([openingElseCurly.range[0], closingElseCurly.range[1]], (elseKeyword.range[1] === openingElseCurly.range[0] ? \" \" : \"\") + sourceCode.getText(node));\n            }\n\n          });\n        }\n      }\n\n    };\n  }\n\n};\nnoLonelyIf.meta;\nnoLonelyIf.create;\n\nfunction getContainingLoopNode(node) {\n  for (let currentNode = node; currentNode.parent; currentNode = currentNode.parent) {\n    const parent = currentNode.parent;\n\n    switch (parent.type) {\n      case \"WhileStatement\":\n      case \"DoWhileStatement\":\n        return parent;\n\n      case \"ForStatement\":\n        if (parent.init !== currentNode) {\n          return parent;\n        }\n\n        break;\n\n      case \"ForInStatement\":\n      case \"ForOfStatement\":\n        if (parent.right !== currentNode) {\n          return parent;\n        }\n\n        break;\n\n      case \"ArrowFunctionExpression\":\n      case \"FunctionExpression\":\n      case \"FunctionDeclaration\":\n        return null;\n    }\n  }\n\n  return null;\n}\n\nfunction getTopLoopNode(node, excludedNode) {\n  const border = excludedNode ? excludedNode.range[1] : 0;\n  let retv = node;\n  let containingLoopNode = node;\n\n  while (containingLoopNode && containingLoopNode.range[0] >= border) {\n    retv = containingLoopNode;\n    containingLoopNode = getContainingLoopNode(containingLoopNode);\n  }\n\n  return retv;\n}\n\nfunction isSafe(loopNode, reference) {\n  const variable = reference.resolved;\n  const definition = variable && variable.defs[0];\n  const declaration = definition && definition.parent;\n  const kind = declaration && declaration.type === \"VariableDeclaration\" ? declaration.kind : \"\";\n\n  if (kind === \"const\") {\n    return true;\n  }\n\n  if (kind === \"let\" && declaration.range[0] > loopNode.range[0] && declaration.range[1] < loopNode.range[1]) {\n    return true;\n  }\n\n  const border = getTopLoopNode(loopNode, kind === \"let\" ? declaration : null).range[0];\n  return Boolean(variable) && variable.references.every(function (upperRef) {\n    const id = upperRef.identifier;\n    return !upperRef.isWrite() || variable.scope.variableScope === upperRef.from.variableScope && id.range[0] < border;\n  });\n}\n\nvar noLoopFunc = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow function declarations that contain unsafe references inside loop statements\",\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-loop-func\"\n    },\n    schema: [],\n    messages: {\n      unsafeRefs: \"Function declared in a loop contains unsafe references to variable(s) {{ varNames }}.\"\n    }\n  },\n\n  create(context) {\n    function checkForLoops(node) {\n      const loopNode = getContainingLoopNode(node);\n\n      if (!loopNode) {\n        return;\n      }\n\n      const references = context.getScope().through;\n      const unsafeRefs = references.filter(r => !isSafe(loopNode, r)).map(r => r.identifier.name);\n\n      if (unsafeRefs.length > 0) {\n        context.report({\n          node,\n          messageId: \"unsafeRefs\",\n          data: {\n            varNames: `'${unsafeRefs.join(\"', '\")}'`\n          }\n        });\n      }\n    }\n\n    return {\n      ArrowFunctionExpression: checkForLoops,\n      FunctionExpression: checkForLoops,\n      FunctionDeclaration: checkForLoops\n    };\n  }\n\n};\nnoLoopFunc.meta;\nnoLoopFunc.create;\nvar noLossOfPrecision = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"disallow literal numbers that lose precision\",\n      category: \"Possible Errors\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-loss-of-precision\"\n    },\n    schema: [],\n    messages: {\n      noLossOfPrecision: \"This number literal will lose precision at runtime.\"\n    }\n  },\n\n  create(context) {\n    function isNumber(node) {\n      return typeof node.value === \"number\";\n    }\n\n    function getRaw(node) {\n      return node.raw.replace(/_/gu, \"\");\n    }\n\n    function isBaseTen(node) {\n      return [\"0x\", \"0X\", \"0b\", \"0B\", \"0o\", \"0O\"].every(prefix => !node.raw.startsWith(prefix)) && !/^0[0-7]+$/u.test(node.raw);\n    }\n\n    function notBaseTenLosesPrecision(node) {\n      const rawString = getRaw(node).toUpperCase();\n      let base = 0;\n\n      if (rawString.startsWith(\"0B\")) {\n        base = 2;\n      } else if (rawString.startsWith(\"0X\")) {\n        base = 16;\n      } else {\n        base = 8;\n      }\n\n      return !rawString.endsWith(node.value.toString(base).toUpperCase());\n    }\n\n    function addDecimalPointToNumber(stringNumber) {\n      return `${stringNumber.slice(0, 1)}.${stringNumber.slice(1)}`;\n    }\n\n    function removeLeadingZeros(numberAsString) {\n      return numberAsString.replace(/^0*/u, \"\");\n    }\n\n    function removeTrailingZeros(numberAsString) {\n      return numberAsString.replace(/0*$/u, \"\");\n    }\n\n    function normalizeInteger(stringInteger) {\n      const significantDigits = removeTrailingZeros(removeLeadingZeros(stringInteger));\n      return {\n        magnitude: stringInteger.startsWith(\"0\") ? stringInteger.length - 2 : stringInteger.length - 1,\n        coefficient: addDecimalPointToNumber(significantDigits)\n      };\n    }\n\n    function normalizeFloat(stringFloat) {\n      const trimmedFloat = removeLeadingZeros(stringFloat);\n\n      if (trimmedFloat.startsWith(\".\")) {\n        const decimalDigits = trimmedFloat.split(\".\").pop();\n        const significantDigits = removeLeadingZeros(decimalDigits);\n        return {\n          magnitude: significantDigits.length - decimalDigits.length - 1,\n          coefficient: addDecimalPointToNumber(significantDigits)\n        };\n      }\n\n      return {\n        magnitude: trimmedFloat.indexOf(\".\") - 1,\n        coefficient: addDecimalPointToNumber(trimmedFloat.replace(\".\", \"\"))\n      };\n    }\n\n    function convertNumberToScientificNotation(stringNumber) {\n      const splitNumber = stringNumber.replace(\"E\", \"e\").split(\"e\");\n      const originalCoefficient = splitNumber[0];\n      const normalizedNumber = stringNumber.includes(\".\") ? normalizeFloat(originalCoefficient) : normalizeInteger(originalCoefficient);\n      const normalizedCoefficient = normalizedNumber.coefficient;\n      const magnitude = splitNumber.length > 1 ? parseInt(splitNumber[1], 10) + normalizedNumber.magnitude : normalizedNumber.magnitude;\n      return `${normalizedCoefficient}e${magnitude}`;\n    }\n\n    function baseTenLosesPrecision(node) {\n      const normalizedRawNumber = convertNumberToScientificNotation(getRaw(node));\n      const requestedPrecision = normalizedRawNumber.split(\"e\")[0].replace(\".\", \"\").length;\n\n      if (requestedPrecision > 100) {\n        return true;\n      }\n\n      const storedNumber = node.value.toPrecision(requestedPrecision);\n      const normalizedStoredNumber = convertNumberToScientificNotation(storedNumber);\n      return normalizedRawNumber !== normalizedStoredNumber;\n    }\n\n    function losesPrecision(node) {\n      return isBaseTen(node) ? baseTenLosesPrecision(node) : notBaseTenLosesPrecision(node);\n    }\n\n    return {\n      Literal(node) {\n        if (node.value && isNumber(node) && losesPrecision(node)) {\n          context.report({\n            messageId: \"noLossOfPrecision\",\n            node\n          });\n        }\n      }\n\n    };\n  }\n\n};\nnoLossOfPrecision.meta;\nnoLossOfPrecision.create;\nconst MAX_ARRAY_LENGTH = 4294967295;\n\nfunction normalizeIgnoreValue(x) {\n  if (typeof x === \"string\") {\n    return BigInt(x.slice(0, -1));\n  }\n\n  return x;\n}\n\nvar noMagicNumbers = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow magic numbers\",\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-magic-numbers\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        detectObjects: {\n          type: \"boolean\",\n          default: false\n        },\n        enforceConst: {\n          type: \"boolean\",\n          default: false\n        },\n        ignore: {\n          type: \"array\",\n          items: {\n            anyOf: [{\n              type: \"number\"\n            }, {\n              type: \"string\",\n              pattern: \"^[+-]?(?:0|[1-9][0-9]*)n$\"\n            }]\n          },\n          uniqueItems: true\n        },\n        ignoreArrayIndexes: {\n          type: \"boolean\",\n          default: false\n        },\n        ignoreDefaultValues: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      useConst: \"Number constants declarations must use 'const'.\",\n      noMagic: \"No magic number: {{raw}}.\"\n    }\n  },\n\n  create(context) {\n    const config = context.options[0] || {},\n          detectObjects = !!config.detectObjects,\n          enforceConst = !!config.enforceConst,\n          ignore = (config.ignore || []).map(normalizeIgnoreValue),\n          ignoreArrayIndexes = !!config.ignoreArrayIndexes,\n          ignoreDefaultValues = !!config.ignoreDefaultValues;\n    const okTypes = detectObjects ? [] : [\"ObjectExpression\", \"Property\", \"AssignmentExpression\"];\n\n    function isIgnoredValue(value) {\n      return ignore.indexOf(value) !== -1;\n    }\n\n    function isDefaultValue(fullNumberNode) {\n      const parent = fullNumberNode.parent;\n      return parent.type === \"AssignmentPattern\" && parent.right === fullNumberNode;\n    }\n\n    function isParseIntRadix(fullNumberNode) {\n      const parent = fullNumberNode.parent;\n      return parent.type === \"CallExpression\" && fullNumberNode === parent.arguments[1] && (astUtils.isSpecificId(parent.callee, \"parseInt\") || astUtils.isSpecificMemberAccess(parent.callee, \"Number\", \"parseInt\"));\n    }\n\n    function isJSXNumber(fullNumberNode) {\n      return fullNumberNode.parent.type.indexOf(\"JSX\") === 0;\n    }\n\n    function isArrayIndex(fullNumberNode, value) {\n      const parent = fullNumberNode.parent;\n      return parent.type === \"MemberExpression\" && parent.property === fullNumberNode && (Number.isInteger(value) || typeof value === \"bigint\") && value >= 0 && value < MAX_ARRAY_LENGTH;\n    }\n\n    return {\n      Literal(node) {\n        if (!astUtils.isNumericLiteral(node)) {\n          return;\n        }\n\n        let fullNumberNode;\n        let value;\n        let raw;\n\n        if (node.parent.type === \"UnaryExpression\" && node.parent.operator === \"-\") {\n          fullNumberNode = node.parent;\n          value = -node.value;\n          raw = `-${node.raw}`;\n        } else {\n          fullNumberNode = node;\n          value = node.value;\n          raw = node.raw;\n        }\n\n        const parent = fullNumberNode.parent;\n\n        if (isIgnoredValue(value) || ignoreDefaultValues && isDefaultValue(fullNumberNode) || isParseIntRadix(fullNumberNode) || isJSXNumber(fullNumberNode) || ignoreArrayIndexes && isArrayIndex(fullNumberNode, value)) {\n          return;\n        }\n\n        if (parent.type === \"VariableDeclarator\") {\n          if (enforceConst && parent.parent.kind !== \"const\") {\n            context.report({\n              node: fullNumberNode,\n              messageId: \"useConst\"\n            });\n          }\n        } else if (okTypes.indexOf(parent.type) === -1 || parent.type === \"AssignmentExpression\" && parent.left.type === \"Identifier\") {\n          context.report({\n            node: fullNumberNode,\n            messageId: \"noMagic\",\n            data: {\n              raw\n            }\n          });\n        }\n      }\n\n    };\n  }\n\n};\nnoMagicNumbers.meta;\nnoMagicNumbers.create;\n\nvar isCombiningCharacter$1 = function (codePoint) {\n  return /^[\\p{Mc}\\p{Me}\\p{Mn}]$/u.test(String.fromCodePoint(codePoint));\n};\n\nvar isEmojiModifier$1 = function (code) {\n  return code >= 0x1F3FB && code <= 0x1F3FF;\n};\n\nvar isRegionalIndicatorSymbol$1 = function (code) {\n  return code >= 0x1F1E6 && code <= 0x1F1FF;\n};\n\nvar isSurrogatePair$1 = function (lead, tail) {\n  return lead >= 0xD800 && lead < 0xDC00 && tail >= 0xDC00 && tail < 0xE000;\n};\n\nvar unicode = {\n  isCombiningCharacter: isCombiningCharacter$1,\n  isEmojiModifier: isEmojiModifier$1,\n  isRegionalIndicatorSymbol: isRegionalIndicatorSymbol$1,\n  isSurrogatePair: isSurrogatePair$1\n};\nconst {\n  CALL: CALL$7,\n  CONSTRUCT: CONSTRUCT$5,\n  ReferenceTracker: ReferenceTracker$7,\n  getStringIfConstant: getStringIfConstant$3\n} = eslintUtils__default['default'];\nconst {\n  RegExpParser: RegExpParser$1,\n  visitRegExpAST: visitRegExpAST$1\n} = regexpp__default['default'];\nconst {\n  isCombiningCharacter,\n  isEmojiModifier,\n  isRegionalIndicatorSymbol,\n  isSurrogatePair\n} = unicode;\n\nfunction* iterateCharacterSequence(nodes) {\n  let seq = [];\n\n  for (const node of nodes) {\n    switch (node.type) {\n      case \"Character\":\n        seq.push(node.value);\n        break;\n\n      case \"CharacterClassRange\":\n        seq.push(node.min.value);\n        yield seq;\n        seq = [node.max.value];\n        break;\n\n      case \"CharacterSet\":\n        if (seq.length > 0) {\n          yield seq;\n          seq = [];\n        }\n\n        break;\n    }\n  }\n\n  if (seq.length > 0) {\n    yield seq;\n  }\n}\n\nconst hasCharacterSequence = {\n  surrogatePairWithoutUFlag(chars) {\n    return chars.some((c, i) => i !== 0 && isSurrogatePair(chars[i - 1], c));\n  },\n\n  combiningClass(chars) {\n    return chars.some((c, i) => i !== 0 && isCombiningCharacter(c) && !isCombiningCharacter(chars[i - 1]));\n  },\n\n  emojiModifier(chars) {\n    return chars.some((c, i) => i !== 0 && isEmojiModifier(c) && !isEmojiModifier(chars[i - 1]));\n  },\n\n  regionalIndicatorSymbol(chars) {\n    return chars.some((c, i) => i !== 0 && isRegionalIndicatorSymbol(c) && isRegionalIndicatorSymbol(chars[i - 1]));\n  },\n\n  zwj(chars) {\n    const lastIndex = chars.length - 1;\n    return chars.some((c, i) => i !== 0 && i !== lastIndex && c === 0x200d && chars[i - 1] !== 0x200d && chars[i + 1] !== 0x200d);\n  }\n\n};\nconst kinds = Object.keys(hasCharacterSequence);\nvar noMisleadingCharacterClass = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"disallow characters which are made with multiple code points in character class syntax\",\n      category: \"Possible Errors\",\n      recommended: true,\n      url: \"https://eslint.org/docs/rules/no-misleading-character-class\"\n    },\n    schema: [],\n    messages: {\n      surrogatePairWithoutUFlag: \"Unexpected surrogate pair in character class. Use 'u' flag.\",\n      combiningClass: \"Unexpected combined character in character class.\",\n      emojiModifier: \"Unexpected modified Emoji in character class.\",\n      regionalIndicatorSymbol: \"Unexpected national flag in character class.\",\n      zwj: \"Unexpected joined character sequence in character class.\"\n    }\n  },\n\n  create(context) {\n    const parser = new RegExpParser$1();\n\n    function verify(node, pattern, flags) {\n      const has = {\n        surrogatePairWithoutUFlag: false,\n        combiningClass: false,\n        variationSelector: false,\n        emojiModifier: false,\n        regionalIndicatorSymbol: false,\n        zwj: false\n      };\n      let patternNode;\n\n      try {\n        patternNode = parser.parsePattern(pattern, 0, pattern.length, flags.includes(\"u\"));\n      } catch {\n        return;\n      }\n\n      visitRegExpAST$1(patternNode, {\n        onCharacterClassEnter(ccNode) {\n          for (const chars of iterateCharacterSequence(ccNode.elements)) {\n            for (const kind of kinds) {\n              has[kind] = has[kind] || hasCharacterSequence[kind](chars);\n            }\n          }\n        }\n\n      });\n\n      for (const kind of kinds) {\n        if (has[kind]) {\n          context.report({\n            node,\n            messageId: kind\n          });\n        }\n      }\n    }\n\n    return {\n      \"Literal[regex]\"(node) {\n        verify(node, node.regex.pattern, node.regex.flags);\n      },\n\n      \"Program\"() {\n        const scope = context.getScope();\n        const tracker = new ReferenceTracker$7(scope);\n\n        for (const {\n          node\n        } of tracker.iterateGlobalReferences({\n          RegExp: {\n            [CALL$7]: true,\n            [CONSTRUCT$5]: true\n          }\n        })) {\n          const [patternNode, flagsNode] = node.arguments;\n          const pattern = getStringIfConstant$3(patternNode, scope);\n          const flags = getStringIfConstant$3(flagsNode, scope);\n\n          if (typeof pattern === \"string\") {\n            verify(node, pattern, flags || \"\");\n          }\n        }\n      }\n\n    };\n  }\n\n};\nnoMisleadingCharacterClass.meta;\nnoMisleadingCharacterClass.create;\nconst ARITHMETIC_OPERATORS = [\"+\", \"-\", \"*\", \"/\", \"%\", \"**\"];\nconst BITWISE_OPERATORS = [\"&\", \"|\", \"^\", \"~\", \"<<\", \">>\", \">>>\"];\nconst COMPARISON_OPERATORS = [\"==\", \"!=\", \"===\", \"!==\", \">\", \">=\", \"<\", \"<=\"];\nconst LOGICAL_OPERATORS = [\"&&\", \"||\"];\nconst RELATIONAL_OPERATORS = [\"in\", \"instanceof\"];\nconst TERNARY_OPERATOR = [\"?:\"];\nconst COALESCE_OPERATOR = [\"??\"];\nconst ALL_OPERATORS = [].concat(ARITHMETIC_OPERATORS, BITWISE_OPERATORS, COMPARISON_OPERATORS, LOGICAL_OPERATORS, RELATIONAL_OPERATORS, TERNARY_OPERATOR, COALESCE_OPERATOR);\nconst DEFAULT_GROUPS = [ARITHMETIC_OPERATORS, BITWISE_OPERATORS, COMPARISON_OPERATORS, LOGICAL_OPERATORS, RELATIONAL_OPERATORS];\nconst TARGET_NODE_TYPE = /^(?:Binary|Logical|Conditional)Expression$/u;\n\nfunction normalizeOptions$1(options = {}) {\n  const hasGroups = options.groups && options.groups.length > 0;\n  const groups = hasGroups ? options.groups : DEFAULT_GROUPS;\n  const allowSamePrecedence = options.allowSamePrecedence !== false;\n  return {\n    groups,\n    allowSamePrecedence\n  };\n}\n\nfunction includesBothInAGroup(groups, left, right) {\n  return groups.some(group => group.indexOf(left) !== -1 && group.indexOf(right) !== -1);\n}\n\nfunction getChildNode(node) {\n  return node.type === \"ConditionalExpression\" ? node.test : node.left;\n}\n\nvar noMixedOperators = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow mixed binary operators\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-mixed-operators\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        groups: {\n          type: \"array\",\n          items: {\n            type: \"array\",\n            items: {\n              enum: ALL_OPERATORS\n            },\n            minItems: 2,\n            uniqueItems: true\n          },\n          uniqueItems: true\n        },\n        allowSamePrecedence: {\n          type: \"boolean\",\n          default: true\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      unexpectedMixedOperator: \"Unexpected mix of '{{leftOperator}}' and '{{rightOperator}}'. Use parentheses to clarify the intended order of operations.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    const options = normalizeOptions$1(context.options[0]);\n\n    function shouldIgnore(node) {\n      const a = node;\n      const b = node.parent;\n      return !includesBothInAGroup(options.groups, a.operator, b.type === \"ConditionalExpression\" ? \"?:\" : b.operator) || options.allowSamePrecedence && astUtils.getPrecedence(a) === astUtils.getPrecedence(b);\n    }\n\n    function isMixedWithParent(node) {\n      return node.operator !== node.parent.operator && !astUtils.isParenthesised(sourceCode, node);\n    }\n\n    function getOperatorToken(node) {\n      return sourceCode.getTokenAfter(getChildNode(node), astUtils.isNotClosingParenToken);\n    }\n\n    function reportBothOperators(node) {\n      const parent = node.parent;\n      const left = getChildNode(parent) === node ? node : parent;\n      const right = getChildNode(parent) !== node ? node : parent;\n      const data = {\n        leftOperator: left.operator || \"?:\",\n        rightOperator: right.operator || \"?:\"\n      };\n      context.report({\n        node: left,\n        loc: getOperatorToken(left).loc,\n        messageId: \"unexpectedMixedOperator\",\n        data\n      });\n      context.report({\n        node: right,\n        loc: getOperatorToken(right).loc,\n        messageId: \"unexpectedMixedOperator\",\n        data\n      });\n    }\n\n    function check(node) {\n      if (TARGET_NODE_TYPE.test(node.parent.type) && isMixedWithParent(node) && !shouldIgnore(node)) {\n        reportBothOperators(node);\n      }\n    }\n\n    return {\n      BinaryExpression: check,\n      LogicalExpression: check\n    };\n  }\n\n};\nnoMixedOperators.meta;\nnoMixedOperators.create;\nvar noMixedRequires = {\n  meta: {\n    deprecated: true,\n    replacedBy: [],\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow `require` calls to be mixed with regular variable declarations\",\n      category: \"Node.js and CommonJS\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-mixed-requires\"\n    },\n    schema: [{\n      oneOf: [{\n        type: \"boolean\"\n      }, {\n        type: \"object\",\n        properties: {\n          grouping: {\n            type: \"boolean\"\n          },\n          allowCall: {\n            type: \"boolean\"\n          }\n        },\n        additionalProperties: false\n      }]\n    }],\n    messages: {\n      noMixRequire: \"Do not mix 'require' and other declarations.\",\n      noMixCoreModuleFileComputed: \"Do not mix core, module, file and computed requires.\"\n    }\n  },\n\n  create(context) {\n    const options = context.options[0];\n    let grouping = false,\n        allowCall = false;\n\n    if (typeof options === \"object\") {\n      grouping = options.grouping;\n      allowCall = options.allowCall;\n    } else {\n      grouping = !!options;\n    }\n\n    const BUILTIN_MODULES = function () {\n      return [\"assert\", \"buffer\", \"child_process\", \"cluster\", \"crypto\", \"dgram\", \"dns\", \"domain\", \"events\", \"fs\", \"http\", \"https\", \"net\", \"os\", \"path\", \"punycode\", \"querystring\", \"readline\", \"repl\", \"smalloc\", \"stream\", \"string_decoder\", \"tls\", \"tty\", \"url\", \"util\", \"v8\", \"vm\", \"zlib\"];\n    }();\n\n    const DECL_REQUIRE = \"require\",\n          DECL_UNINITIALIZED = \"uninitialized\",\n          DECL_OTHER = \"other\";\n    const REQ_COMPUTED = \"computed\";\n\n    function getDeclarationType(initExpression) {\n      if (!initExpression) {\n        return DECL_UNINITIALIZED;\n      }\n\n      if (initExpression.type === \"CallExpression\" && initExpression.callee.type === \"Identifier\" && initExpression.callee.name === \"require\") {\n        return DECL_REQUIRE;\n      }\n\n      if (allowCall && initExpression.type === \"CallExpression\" && initExpression.callee.type === \"CallExpression\") {\n        return getDeclarationType(initExpression.callee);\n      }\n\n      if (initExpression.type === \"MemberExpression\") {\n        return getDeclarationType(initExpression.object);\n      }\n\n      return DECL_OTHER;\n    }\n\n    function inferModuleType(initExpression) {\n      if (initExpression.type === \"MemberExpression\") {\n        return inferModuleType(initExpression.object);\n      }\n\n      if (initExpression.arguments.length === 0) {\n        return REQ_COMPUTED;\n      }\n\n      const arg = initExpression.arguments[0];\n\n      if (arg.type !== \"Literal\" || typeof arg.value !== \"string\") {\n        return REQ_COMPUTED;\n      }\n\n      if (BUILTIN_MODULES.indexOf(arg.value) !== -1) {\n        return \"core\";\n      }\n\n      if (/^\\.{0,2}\\//u.test(arg.value)) {\n        return \"file\";\n      }\n\n      return \"module\";\n    }\n\n    function isMixed(declarations) {\n      const contains = {};\n      declarations.forEach(declaration => {\n        const type = getDeclarationType(declaration.init);\n        contains[type] = true;\n      });\n      return !!(contains[DECL_REQUIRE] && (contains[DECL_UNINITIALIZED] || contains[DECL_OTHER]));\n    }\n\n    function isGrouped(declarations) {\n      const found = {};\n      declarations.forEach(declaration => {\n        if (getDeclarationType(declaration.init) === DECL_REQUIRE) {\n          found[inferModuleType(declaration.init)] = true;\n        }\n      });\n      return Object.keys(found).length <= 1;\n    }\n\n    return {\n      VariableDeclaration(node) {\n        if (isMixed(node.declarations)) {\n          context.report({\n            node,\n            messageId: \"noMixRequire\"\n          });\n        } else if (grouping && !isGrouped(node.declarations)) {\n          context.report({\n            node,\n            messageId: \"noMixCoreModuleFileComputed\"\n          });\n        }\n      }\n\n    };\n  }\n\n};\nnoMixedRequires.meta;\nnoMixedRequires.create;\nvar noMixedSpacesAndTabs = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"disallow mixed spaces and tabs for indentation\",\n      category: \"Stylistic Issues\",\n      recommended: true,\n      url: \"https://eslint.org/docs/rules/no-mixed-spaces-and-tabs\"\n    },\n    schema: [{\n      enum: [\"smart-tabs\", true, false]\n    }],\n    messages: {\n      mixedSpacesAndTabs: \"Mixed spaces and tabs.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    let smartTabs;\n\n    switch (context.options[0]) {\n      case true:\n      case \"smart-tabs\":\n        smartTabs = true;\n        break;\n\n      default:\n        smartTabs = false;\n    }\n\n    return {\n      \"Program:exit\"(node) {\n        const lines = sourceCode.lines,\n              comments = sourceCode.getAllComments(),\n              ignoredCommentLines = new Set();\n        comments.forEach(comment => {\n          for (let i = comment.loc.start.line + 1; i <= comment.loc.end.line; i++) {\n            ignoredCommentLines.add(i);\n          }\n        });\n        let regex = /^(?=( +|\\t+))\\1(?:\\t| )/u;\n\n        if (smartTabs) {\n          regex = /^(?=(\\t*))\\1(?=( +))\\2\\t/u;\n        }\n\n        lines.forEach((line, i) => {\n          const match = regex.exec(line);\n\n          if (match) {\n            const lineNumber = i + 1;\n            const loc = {\n              start: {\n                line: lineNumber,\n                column: match[0].length - 2\n              },\n              end: {\n                line: lineNumber,\n                column: match[0].length\n              }\n            };\n\n            if (!ignoredCommentLines.has(lineNumber)) {\n              const containingNode = sourceCode.getNodeByRangeIndex(sourceCode.getIndexFromLoc(loc.start));\n\n              if (!(containingNode && [\"Literal\", \"TemplateElement\"].includes(containingNode.type))) {\n                context.report({\n                  node,\n                  loc,\n                  messageId: \"mixedSpacesAndTabs\"\n                });\n              }\n            }\n          }\n        });\n      }\n\n    };\n  }\n\n};\nnoMixedSpacesAndTabs.meta;\nnoMixedSpacesAndTabs.create;\nvar noMultiAssign = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow use of chained assignment expressions\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-multi-assign\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        ignoreNonDeclaration: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      unexpectedChain: \"Unexpected chained assignment.\"\n    }\n  },\n\n  create(context) {\n    const options = context.options[0] || {\n      ignoreNonDeclaration: false\n    };\n    const targetParent = options.ignoreNonDeclaration ? [\"VariableDeclarator\"] : [\"AssignmentExpression\", \"VariableDeclarator\"];\n    return {\n      AssignmentExpression(node) {\n        if (targetParent.indexOf(node.parent.type) !== -1) {\n          context.report({\n            node,\n            messageId: \"unexpectedChain\"\n          });\n        }\n      }\n\n    };\n  }\n\n};\nnoMultiAssign.meta;\nnoMultiAssign.create;\nvar noMultiSpaces = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"disallow multiple spaces\",\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-multi-spaces\"\n    },\n    fixable: \"whitespace\",\n    schema: [{\n      type: \"object\",\n      properties: {\n        exceptions: {\n          type: \"object\",\n          patternProperties: {\n            \"^([A-Z][a-z]*)+$\": {\n              type: \"boolean\"\n            }\n          },\n          additionalProperties: false\n        },\n        ignoreEOLComments: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      multipleSpaces: \"Multiple spaces found before '{{displayValue}}'.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    const options = context.options[0] || {};\n    const ignoreEOLComments = options.ignoreEOLComments;\n    const exceptions = Object.assign({\n      Property: true\n    }, options.exceptions);\n    const hasExceptions = Object.keys(exceptions).filter(key => exceptions[key]).length > 0;\n\n    function formatReportedCommentValue(token) {\n      const valueLines = token.value.split(\"\\n\");\n      const value = valueLines[0];\n      const formattedValue = `${value.slice(0, 12)}...`;\n      return valueLines.length === 1 && value.length <= 12 ? value : formattedValue;\n    }\n\n    return {\n      Program() {\n        sourceCode.tokensAndComments.forEach((leftToken, leftIndex, tokensAndComments) => {\n          if (leftIndex === tokensAndComments.length - 1) {\n            return;\n          }\n\n          const rightToken = tokensAndComments[leftIndex + 1];\n\n          if (!sourceCode.text.slice(leftToken.range[1], rightToken.range[0]).includes(\"  \") || leftToken.loc.end.line < rightToken.loc.start.line) {\n            return;\n          }\n\n          if (ignoreEOLComments && astUtils.isCommentToken(rightToken) && (leftIndex === tokensAndComments.length - 2 || rightToken.loc.end.line < tokensAndComments[leftIndex + 2].loc.start.line)) {\n            return;\n          }\n\n          if (hasExceptions) {\n            const parentNode = sourceCode.getNodeByRangeIndex(rightToken.range[0] - 1);\n\n            if (parentNode && exceptions[parentNode.type]) {\n              return;\n            }\n          }\n\n          let displayValue;\n\n          if (rightToken.type === \"Block\") {\n            displayValue = `/*${formatReportedCommentValue(rightToken)}*/`;\n          } else if (rightToken.type === \"Line\") {\n            displayValue = `//${formatReportedCommentValue(rightToken)}`;\n          } else {\n            displayValue = rightToken.value;\n          }\n\n          context.report({\n            node: rightToken,\n            loc: {\n              start: leftToken.loc.end,\n              end: rightToken.loc.start\n            },\n            messageId: \"multipleSpaces\",\n            data: {\n              displayValue\n            },\n            fix: fixer => fixer.replaceTextRange([leftToken.range[1], rightToken.range[0]], \" \")\n          });\n        });\n      }\n\n    };\n  }\n\n};\nnoMultiSpaces.meta;\nnoMultiSpaces.create;\nvar noMultiStr = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow multiline strings\",\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-multi-str\"\n    },\n    schema: [],\n    messages: {\n      multilineString: \"Multiline support is limited to browsers supporting ES5 only.\"\n    }\n  },\n\n  create(context) {\n    function isJSXElement(node) {\n      return node.type.indexOf(\"JSX\") === 0;\n    }\n\n    return {\n      Literal(node) {\n        if (astUtils.LINEBREAK_MATCHER.test(node.raw) && !isJSXElement(node.parent)) {\n          context.report({\n            node,\n            messageId: \"multilineString\"\n          });\n        }\n      }\n\n    };\n  }\n\n};\nnoMultiStr.meta;\nnoMultiStr.create;\nvar noMultipleEmptyLines = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"disallow multiple empty lines\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-multiple-empty-lines\"\n    },\n    fixable: \"whitespace\",\n    schema: [{\n      type: \"object\",\n      properties: {\n        max: {\n          type: \"integer\",\n          minimum: 0\n        },\n        maxEOF: {\n          type: \"integer\",\n          minimum: 0\n        },\n        maxBOF: {\n          type: \"integer\",\n          minimum: 0\n        }\n      },\n      required: [\"max\"],\n      additionalProperties: false\n    }],\n    messages: {\n      blankBeginningOfFile: \"Too many blank lines at the beginning of file. Max of {{max}} allowed.\",\n      blankEndOfFile: \"Too many blank lines at the end of file. Max of {{max}} allowed.\",\n      consecutiveBlank: \"More than {{max}} blank {{pluralizedLines}} not allowed.\"\n    }\n  },\n\n  create(context) {\n    let max = 2,\n        maxEOF = max,\n        maxBOF = max;\n\n    if (context.options.length) {\n      max = context.options[0].max;\n      maxEOF = typeof context.options[0].maxEOF !== \"undefined\" ? context.options[0].maxEOF : max;\n      maxBOF = typeof context.options[0].maxBOF !== \"undefined\" ? context.options[0].maxBOF : max;\n    }\n\n    const sourceCode = context.getSourceCode();\n    const allLines = sourceCode.lines[sourceCode.lines.length - 1] === \"\" ? sourceCode.lines.slice(0, -1) : sourceCode.lines;\n    const templateLiteralLines = new Set();\n    return {\n      TemplateLiteral(node) {\n        node.quasis.forEach(literalPart => {\n          for (let ignoredLine = literalPart.loc.start.line; ignoredLine < literalPart.loc.end.line; ignoredLine++) {\n            templateLiteralLines.add(ignoredLine);\n          }\n        });\n      },\n\n      \"Program:exit\"(node) {\n        return allLines.reduce((nonEmptyLineNumbers, line, index) => {\n          if (line.trim() || templateLiteralLines.has(index + 1)) {\n            nonEmptyLineNumbers.push(index + 1);\n          }\n\n          return nonEmptyLineNumbers;\n        }, []).concat(allLines.length + 1).reduce((lastLineNumber, lineNumber) => {\n          let messageId, maxAllowed;\n\n          if (lastLineNumber === 0) {\n            messageId = \"blankBeginningOfFile\";\n            maxAllowed = maxBOF;\n          } else if (lineNumber === allLines.length + 1) {\n            messageId = \"blankEndOfFile\";\n            maxAllowed = maxEOF;\n          } else {\n            messageId = \"consecutiveBlank\";\n            maxAllowed = max;\n          }\n\n          if (lineNumber - lastLineNumber - 1 > maxAllowed) {\n            context.report({\n              node,\n              loc: {\n                start: {\n                  line: lastLineNumber + maxAllowed + 1,\n                  column: 0\n                },\n                end: {\n                  line: lineNumber,\n                  column: 0\n                }\n              },\n              messageId,\n              data: {\n                max: maxAllowed,\n                pluralizedLines: maxAllowed === 1 ? \"line\" : \"lines\"\n              },\n\n              fix(fixer) {\n                const rangeStart = sourceCode.getIndexFromLoc({\n                  line: lastLineNumber + 1,\n                  column: 0\n                });\n                const lineNumberAfterRemovedLines = lineNumber - maxAllowed;\n                const rangeEnd = lineNumberAfterRemovedLines <= allLines.length ? sourceCode.getIndexFromLoc({\n                  line: lineNumberAfterRemovedLines,\n                  column: 0\n                }) : sourceCode.text.length;\n                return fixer.removeRange([rangeStart, rangeEnd]);\n              }\n\n            });\n          }\n\n          return lineNumber;\n        }, 0);\n      }\n\n    };\n  }\n\n};\nnoMultipleEmptyLines.meta;\nnoMultipleEmptyLines.create;\nvar noNativeReassign = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow assignments to native objects or read-only global variables\",\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-native-reassign\"\n    },\n    deprecated: true,\n    replacedBy: [\"no-global-assign\"],\n    schema: [{\n      type: \"object\",\n      properties: {\n        exceptions: {\n          type: \"array\",\n          items: {\n            type: \"string\"\n          },\n          uniqueItems: true\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      nativeReassign: \"Read-only global '{{name}}' should not be modified.\"\n    }\n  },\n\n  create(context) {\n    const config = context.options[0];\n    const exceptions = config && config.exceptions || [];\n\n    function checkReference(reference, index, references) {\n      const identifier = reference.identifier;\n\n      if (reference.init === false && reference.isWrite() && (index === 0 || references[index - 1].identifier !== identifier)) {\n        context.report({\n          node: identifier,\n          messageId: \"nativeReassign\",\n          data: identifier\n        });\n      }\n    }\n\n    function checkVariable(variable) {\n      if (variable.writeable === false && exceptions.indexOf(variable.name) === -1) {\n        variable.references.forEach(checkReference);\n      }\n    }\n\n    return {\n      Program() {\n        const globalScope = context.getScope();\n        globalScope.variables.forEach(checkVariable);\n      }\n\n    };\n  }\n\n};\nnoNativeReassign.meta;\nnoNativeReassign.create;\nvar noNegatedCondition = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow negated conditions\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-negated-condition\"\n    },\n    schema: [],\n    messages: {\n      unexpectedNegated: \"Unexpected negated condition.\"\n    }\n  },\n\n  create(context) {\n    function hasElseWithoutCondition(node) {\n      return node.alternate && node.alternate.type !== \"IfStatement\";\n    }\n\n    function isNegatedUnaryExpression(test) {\n      return test.type === \"UnaryExpression\" && test.operator === \"!\";\n    }\n\n    function isNegatedBinaryExpression(test) {\n      return test.type === \"BinaryExpression\" && (test.operator === \"!=\" || test.operator === \"!==\");\n    }\n\n    function isNegatedIf(node) {\n      return isNegatedUnaryExpression(node.test) || isNegatedBinaryExpression(node.test);\n    }\n\n    return {\n      IfStatement(node) {\n        if (!hasElseWithoutCondition(node)) {\n          return;\n        }\n\n        if (isNegatedIf(node)) {\n          context.report({\n            node,\n            messageId: \"unexpectedNegated\"\n          });\n        }\n      },\n\n      ConditionalExpression(node) {\n        if (isNegatedIf(node)) {\n          context.report({\n            node,\n            messageId: \"unexpectedNegated\"\n          });\n        }\n      }\n\n    };\n  }\n\n};\nnoNegatedCondition.meta;\nnoNegatedCondition.create;\nvar noNegatedInLhs = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"disallow negating the left operand in `in` expressions\",\n      category: \"Possible Errors\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-negated-in-lhs\"\n    },\n    replacedBy: [\"no-unsafe-negation\"],\n    deprecated: true,\n    schema: [],\n    messages: {\n      negatedLHS: \"The 'in' expression's left operand is negated.\"\n    }\n  },\n\n  create(context) {\n    return {\n      BinaryExpression(node) {\n        if (node.operator === \"in\" && node.left.type === \"UnaryExpression\" && node.left.operator === \"!\") {\n          context.report({\n            node,\n            messageId: \"negatedLHS\"\n          });\n        }\n      }\n\n    };\n  }\n\n};\nnoNegatedInLhs.meta;\nnoNegatedInLhs.create;\nvar noNestedTernary = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow nested ternary expressions\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-nested-ternary\"\n    },\n    schema: [],\n    messages: {\n      noNestedTernary: \"Do not nest ternary expressions.\"\n    }\n  },\n\n  create(context) {\n    return {\n      ConditionalExpression(node) {\n        if (node.alternate.type === \"ConditionalExpression\" || node.consequent.type === \"ConditionalExpression\") {\n          context.report({\n            node,\n            messageId: \"noNestedTernary\"\n          });\n        }\n      }\n\n    };\n  }\n\n};\nnoNestedTernary.meta;\nnoNestedTernary.create;\nvar noNewFunc = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow `new` operators with the `Function` object\",\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-new-func\"\n    },\n    schema: [],\n    messages: {\n      noFunctionConstructor: \"The Function constructor is eval.\"\n    }\n  },\n\n  create(context) {\n    return {\n      \"Program:exit\"() {\n        const globalScope = context.getScope();\n        const variable = globalScope.set.get(\"Function\");\n\n        if (variable && variable.defs.length === 0) {\n          variable.references.forEach(ref => {\n            const node = ref.identifier;\n            const {\n              parent\n            } = node;\n\n            if (parent && (parent.type === \"NewExpression\" || parent.type === \"CallExpression\") && node === parent.callee) {\n              context.report({\n                node: parent,\n                messageId: \"noFunctionConstructor\"\n              });\n            }\n          });\n        }\n      }\n\n    };\n  }\n\n};\nnoNewFunc.meta;\nnoNewFunc.create;\nvar noNewObject = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow `Object` constructors\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-new-object\"\n    },\n    schema: [],\n    messages: {\n      preferLiteral: \"The object literal notation {} is preferrable.\"\n    }\n  },\n\n  create(context) {\n    return {\n      NewExpression(node) {\n        const variable = astUtils.getVariableByName(context.getScope(), node.callee.name);\n\n        if (variable && variable.identifiers.length > 0) {\n          return;\n        }\n\n        if (node.callee.name === \"Object\") {\n          context.report({\n            node,\n            messageId: \"preferLiteral\"\n          });\n        }\n      }\n\n    };\n  }\n\n};\nnoNewObject.meta;\nnoNewObject.create;\nvar noNewRequire = {\n  meta: {\n    deprecated: true,\n    replacedBy: [],\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow `new` operators with calls to `require`\",\n      category: \"Node.js and CommonJS\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-new-require\"\n    },\n    schema: [],\n    messages: {\n      noNewRequire: \"Unexpected use of new with require.\"\n    }\n  },\n\n  create(context) {\n    return {\n      NewExpression(node) {\n        if (node.callee.type === \"Identifier\" && node.callee.name === \"require\") {\n          context.report({\n            node,\n            messageId: \"noNewRequire\"\n          });\n        }\n      }\n\n    };\n  }\n\n};\nnoNewRequire.meta;\nnoNewRequire.create;\nvar noNewSymbol = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"disallow `new` operators with the `Symbol` object\",\n      category: \"ECMAScript 6\",\n      recommended: true,\n      url: \"https://eslint.org/docs/rules/no-new-symbol\"\n    },\n    schema: [],\n    messages: {\n      noNewSymbol: \"`Symbol` cannot be called as a constructor.\"\n    }\n  },\n\n  create(context) {\n    return {\n      \"Program:exit\"() {\n        const globalScope = context.getScope();\n        const variable = globalScope.set.get(\"Symbol\");\n\n        if (variable && variable.defs.length === 0) {\n          variable.references.forEach(ref => {\n            const node = ref.identifier;\n            const parent = node.parent;\n\n            if (parent && parent.type === \"NewExpression\" && parent.callee === node) {\n              context.report({\n                node,\n                messageId: \"noNewSymbol\"\n              });\n            }\n          });\n        }\n      }\n\n    };\n  }\n\n};\nnoNewSymbol.meta;\nnoNewSymbol.create;\nvar noNewWrappers = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow `new` operators with the `String`, `Number`, and `Boolean` objects\",\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-new-wrappers\"\n    },\n    schema: [],\n    messages: {\n      noConstructor: \"Do not use {{fn}} as a constructor.\"\n    }\n  },\n\n  create(context) {\n    return {\n      NewExpression(node) {\n        if ([\"String\", \"Number\", \"Boolean\"].indexOf(node.callee.name) > -1) {\n          context.report({\n            node,\n            messageId: \"noConstructor\",\n            data: {\n              fn: node.callee.name\n            }\n          });\n        }\n      }\n\n    };\n  }\n\n};\nnoNewWrappers.meta;\nnoNewWrappers.create;\nvar noNew = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow `new` operators outside of assignments or comparisons\",\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-new\"\n    },\n    schema: [],\n    messages: {\n      noNewStatement: \"Do not use 'new' for side effects.\"\n    }\n  },\n\n  create(context) {\n    return {\n      \"ExpressionStatement > NewExpression\"(node) {\n        context.report({\n          node: node.parent,\n          messageId: \"noNewStatement\"\n        });\n      }\n\n    };\n  }\n\n};\nnoNew.meta;\nnoNew.create;\nconst QUICK_TEST_REGEX = /\\\\[89]/u;\n\nfunction getUnicodeEscape(character) {\n  return `\\\\u${character.charCodeAt(0).toString(16).padStart(4, \"0\")}`;\n}\n\nvar noNonoctalDecimalEscape = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow `\\\\8` and `\\\\9` escape sequences in string literals\",\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-nonoctal-decimal-escape\",\n      suggestion: true\n    },\n    schema: [],\n    messages: {\n      decimalEscape: \"Don't use '{{decimalEscape}}' escape sequence.\",\n      refactor: \"Replace '{{original}}' with '{{replacement}}'. This maintains the current functionality.\",\n      escapeBackslash: \"Replace '{{original}}' with '{{replacement}}' to include the actual backslash character.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n\n    function createSuggestion(messageId, range, replacement) {\n      return {\n        messageId,\n        data: {\n          original: sourceCode.getText().slice(...range),\n          replacement\n        },\n\n        fix(fixer) {\n          return fixer.replaceTextRange(range, replacement);\n        }\n\n      };\n    }\n\n    return {\n      Literal(node) {\n        if (typeof node.value !== \"string\") {\n          return;\n        }\n\n        if (!QUICK_TEST_REGEX.test(node.raw)) {\n          return;\n        }\n\n        let match;\n\n        while (match = /(?:[^\\\\]|(?<previousEscape>\\\\.))*?(?<decimalEscape>\\\\[89])/suy.exec(node.raw)) {\n          const {\n            previousEscape,\n            decimalEscape\n          } = match.groups;\n          const decimalEscapeRangeEnd = node.range[0] + match.index + match[0].length;\n          const decimalEscapeRangeStart = decimalEscapeRangeEnd - decimalEscape.length;\n          const decimalEscapeRange = [decimalEscapeRangeStart, decimalEscapeRangeEnd];\n          const suggest = [];\n\n          if (previousEscape === \"\\\\0\") {\n            suggest.push(createSuggestion(\"refactor\", [decimalEscapeRangeStart - previousEscape.length, decimalEscapeRangeEnd], `${getUnicodeEscape(\"\\0\")}${decimalEscape[1]}`), createSuggestion(\"refactor\", decimalEscapeRange, getUnicodeEscape(decimalEscape[1])));\n          } else {\n            suggest.push(createSuggestion(\"refactor\", decimalEscapeRange, decimalEscape[1]));\n          }\n\n          suggest.push(createSuggestion(\"escapeBackslash\", decimalEscapeRange, `\\\\${decimalEscape}`));\n          context.report({\n            node,\n            loc: {\n              start: sourceCode.getLocFromIndex(decimalEscapeRangeStart),\n              end: sourceCode.getLocFromIndex(decimalEscapeRangeEnd)\n            },\n            messageId: \"decimalEscape\",\n            data: {\n              decimalEscape\n            },\n            suggest\n          });\n        }\n      }\n\n    };\n  }\n\n};\nnoNonoctalDecimalEscape.meta;\nnoNonoctalDecimalEscape.create;\nconst {\n  CALL: CALL$6,\n  CONSTRUCT: CONSTRUCT$4,\n  ReferenceTracker: ReferenceTracker$6\n} = eslintUtils__default['default'];\nconst getPropertyName$1 = astUtils.getStaticPropertyName;\nconst nonCallableGlobals = [\"Atomics\", \"JSON\", \"Math\", \"Reflect\"];\n\nfunction getReportNodeName(node) {\n  if (node.type === \"ChainExpression\") {\n    return getReportNodeName(node.expression);\n  }\n\n  if (node.type === \"MemberExpression\") {\n    return getPropertyName$1(node);\n  }\n\n  return node.name;\n}\n\nvar noObjCalls = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"disallow calling global object properties as functions\",\n      category: \"Possible Errors\",\n      recommended: true,\n      url: \"https://eslint.org/docs/rules/no-obj-calls\"\n    },\n    schema: [],\n    messages: {\n      unexpectedCall: \"'{{name}}' is not a function.\",\n      unexpectedRefCall: \"'{{name}}' is reference to '{{ref}}', which is not a function.\"\n    }\n  },\n\n  create(context) {\n    return {\n      Program() {\n        const scope = context.getScope();\n        const tracker = new ReferenceTracker$6(scope);\n        const traceMap = {};\n\n        for (const g of nonCallableGlobals) {\n          traceMap[g] = {\n            [CALL$6]: true,\n            [CONSTRUCT$4]: true\n          };\n        }\n\n        for (const {\n          node,\n          path\n        } of tracker.iterateGlobalReferences(traceMap)) {\n          const name = getReportNodeName(node.callee);\n          const ref = path[0];\n          const messageId = name === ref ? \"unexpectedCall\" : \"unexpectedRefCall\";\n          context.report({\n            node,\n            messageId,\n            data: {\n              name,\n              ref\n            }\n          });\n        }\n      }\n\n    };\n  }\n\n};\nnoObjCalls.meta;\nnoObjCalls.create;\nvar noOctalEscape = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow octal escape sequences in string literals\",\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-octal-escape\"\n    },\n    schema: [],\n    messages: {\n      octalEscapeSequence: \"Don't use octal: '\\\\{{sequence}}'. Use '\\\\u....' instead.\"\n    }\n  },\n\n  create(context) {\n    return {\n      Literal(node) {\n        if (typeof node.value !== \"string\") {\n          return;\n        }\n\n        const match = node.raw.match(/^(?:[^\\\\]|\\\\.)*?\\\\([0-3][0-7]{1,2}|[4-7][0-7]|0(?=[89])|[1-7])/su);\n\n        if (match) {\n          context.report({\n            node,\n            messageId: \"octalEscapeSequence\",\n            data: {\n              sequence: match[1]\n            }\n          });\n        }\n      }\n\n    };\n  }\n\n};\nnoOctalEscape.meta;\nnoOctalEscape.create;\nvar noOctal = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow octal literals\",\n      category: \"Best Practices\",\n      recommended: true,\n      url: \"https://eslint.org/docs/rules/no-octal\"\n    },\n    schema: [],\n    messages: {\n      noOcatal: \"Octal literals should not be used.\"\n    }\n  },\n\n  create(context) {\n    return {\n      Literal(node) {\n        if (typeof node.value === \"number\" && /^0[0-9]/u.test(node.raw)) {\n          context.report({\n            node,\n            messageId: \"noOcatal\"\n          });\n        }\n      }\n\n    };\n  }\n\n};\nnoOctal.meta;\nnoOctal.create;\nconst stopNodePattern = /(?:Statement|Declaration|Function(?:Expression)?|Program)$/u;\nvar noParamReassign = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow reassigning `function` parameters\",\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-param-reassign\"\n    },\n    schema: [{\n      oneOf: [{\n        type: \"object\",\n        properties: {\n          props: {\n            enum: [false]\n          }\n        },\n        additionalProperties: false\n      }, {\n        type: \"object\",\n        properties: {\n          props: {\n            enum: [true]\n          },\n          ignorePropertyModificationsFor: {\n            type: \"array\",\n            items: {\n              type: \"string\"\n            },\n            uniqueItems: true\n          },\n          ignorePropertyModificationsForRegex: {\n            type: \"array\",\n            items: {\n              type: \"string\"\n            },\n            uniqueItems: true\n          }\n        },\n        additionalProperties: false\n      }]\n    }],\n    messages: {\n      assignmentToFunctionParam: \"Assignment to function parameter '{{name}}'.\",\n      assignmentToFunctionParamProp: \"Assignment to property of function parameter '{{name}}'.\"\n    }\n  },\n\n  create(context) {\n    const props = context.options[0] && context.options[0].props;\n    const ignoredPropertyAssignmentsFor = context.options[0] && context.options[0].ignorePropertyModificationsFor || [];\n    const ignoredPropertyAssignmentsForRegex = context.options[0] && context.options[0].ignorePropertyModificationsForRegex || [];\n\n    function isModifyingProp(reference) {\n      let node = reference.identifier;\n      let parent = node.parent;\n\n      while (parent && (!stopNodePattern.test(parent.type) || parent.type === \"ForInStatement\" || parent.type === \"ForOfStatement\")) {\n        switch (parent.type) {\n          case \"AssignmentExpression\":\n            return parent.left === node;\n\n          case \"UpdateExpression\":\n            return true;\n\n          case \"UnaryExpression\":\n            if (parent.operator === \"delete\") {\n              return true;\n            }\n\n            break;\n\n          case \"ForInStatement\":\n          case \"ForOfStatement\":\n            if (parent.left === node) {\n              return true;\n            }\n\n            return false;\n\n          case \"CallExpression\":\n            if (parent.callee !== node) {\n              return false;\n            }\n\n            break;\n\n          case \"MemberExpression\":\n            if (parent.property === node) {\n              return false;\n            }\n\n            break;\n\n          case \"Property\":\n            if (parent.key === node) {\n              return false;\n            }\n\n            break;\n\n          case \"ConditionalExpression\":\n            if (parent.test === node) {\n              return false;\n            }\n\n            break;\n        }\n\n        node = parent;\n        parent = node.parent;\n      }\n\n      return false;\n    }\n\n    function isIgnoredPropertyAssignment(identifierName) {\n      return ignoredPropertyAssignmentsFor.includes(identifierName) || ignoredPropertyAssignmentsForRegex.some(ignored => new RegExp(ignored, \"u\").test(identifierName));\n    }\n\n    function checkReference(reference, index, references) {\n      const identifier = reference.identifier;\n\n      if (identifier && !reference.init && (index === 0 || references[index - 1].identifier !== identifier)) {\n        if (reference.isWrite()) {\n          context.report({\n            node: identifier,\n            messageId: \"assignmentToFunctionParam\",\n            data: {\n              name: identifier.name\n            }\n          });\n        } else if (props && isModifyingProp(reference) && !isIgnoredPropertyAssignment(identifier.name)) {\n          context.report({\n            node: identifier,\n            messageId: \"assignmentToFunctionParamProp\",\n            data: {\n              name: identifier.name\n            }\n          });\n        }\n      }\n    }\n\n    function checkVariable(variable) {\n      if (variable.defs[0].type === \"Parameter\") {\n        variable.references.forEach(checkReference);\n      }\n    }\n\n    function checkForFunction(node) {\n      context.getDeclaredVariables(node).forEach(checkVariable);\n    }\n\n    return {\n      \"FunctionDeclaration:exit\": checkForFunction,\n      \"FunctionExpression:exit\": checkForFunction,\n      \"ArrowFunctionExpression:exit\": checkForFunction\n    };\n  }\n\n};\nnoParamReassign.meta;\nnoParamReassign.create;\nvar noPathConcat = {\n  meta: {\n    deprecated: true,\n    replacedBy: [],\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow string concatenation with `__dirname` and `__filename`\",\n      category: \"Node.js and CommonJS\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-path-concat\"\n    },\n    schema: [],\n    messages: {\n      usePathFunctions: \"Use path.join() or path.resolve() instead of + to create paths.\"\n    }\n  },\n\n  create(context) {\n    const MATCHER = /^__(?:dir|file)name$/u;\n    return {\n      BinaryExpression(node) {\n        const left = node.left,\n              right = node.right;\n\n        if (node.operator === \"+\" && (left.type === \"Identifier\" && MATCHER.test(left.name) || right.type === \"Identifier\" && MATCHER.test(right.name))) {\n          context.report({\n            node,\n            messageId: \"usePathFunctions\"\n          });\n        }\n      }\n\n    };\n  }\n\n};\nnoPathConcat.meta;\nnoPathConcat.create;\n\nfunction isForStatementUpdate(node) {\n  const parent = node.parent;\n  return parent.type === \"ForStatement\" && parent.update === node;\n}\n\nfunction isForLoopAfterthought(node) {\n  const parent = node.parent;\n\n  if (parent.type === \"SequenceExpression\") {\n    return isForLoopAfterthought(parent);\n  }\n\n  return isForStatementUpdate(node);\n}\n\nvar noPlusplus = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow the unary operators `++` and `--`\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-plusplus\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        allowForLoopAfterthoughts: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      unexpectedUnaryOp: \"Unary operator '{{operator}}' used.\"\n    }\n  },\n\n  create(context) {\n    const config = context.options[0];\n    let allowForLoopAfterthoughts = false;\n\n    if (typeof config === \"object\") {\n      allowForLoopAfterthoughts = config.allowForLoopAfterthoughts === true;\n    }\n\n    return {\n      UpdateExpression(node) {\n        if (allowForLoopAfterthoughts && isForLoopAfterthought(node)) {\n          return;\n        }\n\n        context.report({\n          node,\n          messageId: \"unexpectedUnaryOp\",\n          data: {\n            operator: node.operator\n          }\n        });\n      }\n\n    };\n  }\n\n};\nnoPlusplus.meta;\nnoPlusplus.create;\nvar noProcessEnv = {\n  meta: {\n    deprecated: true,\n    replacedBy: [],\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow the use of `process.env`\",\n      category: \"Node.js and CommonJS\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-process-env\"\n    },\n    schema: [],\n    messages: {\n      unexpectedProcessEnv: \"Unexpected use of process.env.\"\n    }\n  },\n\n  create(context) {\n    return {\n      MemberExpression(node) {\n        const objectName = node.object.name,\n              propertyName = node.property.name;\n\n        if (objectName === \"process\" && !node.computed && propertyName && propertyName === \"env\") {\n          context.report({\n            node,\n            messageId: \"unexpectedProcessEnv\"\n          });\n        }\n      }\n\n    };\n  }\n\n};\nnoProcessEnv.meta;\nnoProcessEnv.create;\nvar noProcessExit = {\n  meta: {\n    deprecated: true,\n    replacedBy: [],\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow the use of `process.exit()`\",\n      category: \"Node.js and CommonJS\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-process-exit\"\n    },\n    schema: [],\n    messages: {\n      noProcessExit: \"Don't use process.exit(); throw an error instead.\"\n    }\n  },\n\n  create(context) {\n    return {\n      \"CallExpression > MemberExpression.callee[object.name = 'process'][property.name = 'exit']\"(node) {\n        context.report({\n          node: node.parent,\n          messageId: \"noProcessExit\"\n        });\n      }\n\n    };\n  }\n\n};\nnoProcessExit.meta;\nnoProcessExit.create;\nconst {\n  findVariable: findVariable$2\n} = eslintUtils__default['default'];\nconst functionTypesToCheck = new Set([\"ArrowFunctionExpression\", \"FunctionExpression\"]);\n\nfunction isGlobalReference$1(node, scope) {\n  const variable = findVariable$2(scope, node);\n  return variable !== null && variable.scope.type === \"global\" && variable.defs.length === 0;\n}\n\nfunction getOuterScope$1(scope) {\n  const upper = scope.upper;\n\n  if (upper.type === \"function-expression-name\") {\n    return upper.upper;\n  }\n\n  return upper;\n}\n\nfunction isPromiseExecutor(node, scope) {\n  const parent = node.parent;\n  return parent.type === \"NewExpression\" && parent.arguments[0] === node && parent.callee.type === \"Identifier\" && parent.callee.name === \"Promise\" && isGlobalReference$1(parent.callee, getOuterScope$1(scope));\n}\n\nvar noPromiseExecutorReturn = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"disallow returning values from Promise executor functions\",\n      category: \"Possible Errors\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-promise-executor-return\"\n    },\n    schema: [],\n    messages: {\n      returnsValue: \"Return values from promise executor functions cannot be read.\"\n    }\n  },\n\n  create(context) {\n    let funcInfo = null;\n\n    function report(node) {\n      context.report({\n        node,\n        messageId: \"returnsValue\"\n      });\n    }\n\n    return {\n      onCodePathStart(_, node) {\n        funcInfo = {\n          upper: funcInfo,\n          shouldCheck: functionTypesToCheck.has(node.type) && isPromiseExecutor(node, context.getScope())\n        };\n\n        if (funcInfo.shouldCheck && node.type === \"ArrowFunctionExpression\" && node.expression) {\n          report(node.body);\n        }\n      },\n\n      onCodePathEnd() {\n        funcInfo = funcInfo.upper;\n      },\n\n      ReturnStatement(node) {\n        if (funcInfo.shouldCheck && node.argument) {\n          report(node);\n        }\n      }\n\n    };\n  }\n\n};\nnoPromiseExecutorReturn.meta;\nnoPromiseExecutorReturn.create;\nconst {\n  getStaticPropertyName\n} = astUtils;\nvar noProto = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow the use of the `__proto__` property\",\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-proto\"\n    },\n    schema: [],\n    messages: {\n      unexpectedProto: \"The '__proto__' property is deprecated.\"\n    }\n  },\n\n  create(context) {\n    return {\n      MemberExpression(node) {\n        if (getStaticPropertyName(node) === \"__proto__\") {\n          context.report({\n            node,\n            messageId: \"unexpectedProto\"\n          });\n        }\n      }\n\n    };\n  }\n\n};\nnoProto.meta;\nnoProto.create;\nvar noPrototypeBuiltins = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"disallow calling some `Object.prototype` methods directly on objects\",\n      category: \"Possible Errors\",\n      recommended: true,\n      url: \"https://eslint.org/docs/rules/no-prototype-builtins\"\n    },\n    schema: [],\n    messages: {\n      prototypeBuildIn: \"Do not access Object.prototype method '{{prop}}' from target object.\"\n    }\n  },\n\n  create(context) {\n    const DISALLOWED_PROPS = [\"hasOwnProperty\", \"isPrototypeOf\", \"propertyIsEnumerable\"];\n    return {\n      CallExpression: function (node) {\n        const callee = astUtils.skipChainExpression(node.callee);\n\n        if (callee.type !== \"MemberExpression\") {\n          return;\n        }\n\n        const propName = astUtils.getStaticPropertyName(callee);\n\n        if (propName !== null && DISALLOWED_PROPS.indexOf(propName) > -1) {\n          context.report({\n            messageId: \"prototypeBuildIn\",\n            loc: callee.property.loc,\n            data: {\n              prop: propName\n            },\n            node\n          });\n        }\n      }\n    };\n  }\n\n};\nnoPrototypeBuiltins.meta;\nnoPrototypeBuiltins.create;\nvar noRedeclare = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow variable redeclaration\",\n      category: \"Best Practices\",\n      recommended: true,\n      url: \"https://eslint.org/docs/rules/no-redeclare\"\n    },\n    messages: {\n      redeclared: \"'{{id}}' is already defined.\",\n      redeclaredAsBuiltin: \"'{{id}}' is already defined as a built-in global variable.\",\n      redeclaredBySyntax: \"'{{id}}' is already defined by a variable declaration.\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        builtinGlobals: {\n          type: \"boolean\",\n          default: true\n        }\n      },\n      additionalProperties: false\n    }]\n  },\n\n  create(context) {\n    const options = {\n      builtinGlobals: Boolean(context.options.length === 0 || context.options[0].builtinGlobals)\n    };\n    const sourceCode = context.getSourceCode();\n\n    function* iterateDeclarations(variable) {\n      if (options.builtinGlobals && (variable.eslintImplicitGlobalSetting === \"readonly\" || variable.eslintImplicitGlobalSetting === \"writable\")) {\n        yield {\n          type: \"builtin\"\n        };\n      }\n\n      for (const id of variable.identifiers) {\n        yield {\n          type: \"syntax\",\n          node: id,\n          loc: id.loc\n        };\n      }\n\n      if (variable.eslintExplicitGlobalComments) {\n        for (const comment of variable.eslintExplicitGlobalComments) {\n          yield {\n            type: \"comment\",\n            node: comment,\n            loc: astUtils.getNameLocationInGlobalDirectiveComment(sourceCode, comment, variable.name)\n          };\n        }\n      }\n    }\n\n    function findVariablesInScope(scope) {\n      for (const variable of scope.variables) {\n        const [declaration, ...extraDeclarations] = iterateDeclarations(variable);\n\n        if (extraDeclarations.length === 0) {\n          continue;\n        }\n\n        const detailMessageId = declaration.type === \"builtin\" ? \"redeclaredAsBuiltin\" : \"redeclaredBySyntax\";\n        const data = {\n          id: variable.name\n        };\n\n        for (const {\n          type,\n          node,\n          loc\n        } of extraDeclarations) {\n          const messageId = type === declaration.type ? \"redeclared\" : detailMessageId;\n          context.report({\n            node,\n            loc,\n            messageId,\n            data\n          });\n        }\n      }\n    }\n\n    function checkForBlock(node) {\n      const scope = context.getScope();\n\n      if (scope.block === node) {\n        findVariablesInScope(scope);\n      }\n    }\n\n    return {\n      Program() {\n        const scope = context.getScope();\n        findVariablesInScope(scope);\n\n        if (scope.type === \"global\" && scope.childScopes[0] && scope.block === scope.childScopes[0].block) {\n          findVariablesInScope(scope.childScopes[0]);\n        }\n      },\n\n      FunctionDeclaration: checkForBlock,\n      FunctionExpression: checkForBlock,\n      ArrowFunctionExpression: checkForBlock,\n      BlockStatement: checkForBlock,\n      ForStatement: checkForBlock,\n      ForInStatement: checkForBlock,\n      ForOfStatement: checkForBlock,\n      SwitchStatement: checkForBlock\n    };\n  }\n\n};\nnoRedeclare.meta;\nnoRedeclare.create;\nconst regExpParser = new regexpp__default['default'].RegExpParser();\nconst DOUBLE_SPACE = / {2}/u;\n\nfunction isString(node) {\n  return node && node.type === \"Literal\" && typeof node.value === \"string\";\n}\n\nvar noRegexSpaces = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow multiple spaces in regular expressions\",\n      category: \"Possible Errors\",\n      recommended: true,\n      url: \"https://eslint.org/docs/rules/no-regex-spaces\"\n    },\n    schema: [],\n    fixable: \"code\",\n    messages: {\n      multipleSpaces: \"Spaces are hard to count. Use {{{length}}}.\"\n    }\n  },\n\n  create(context) {\n    function checkRegex(nodeToReport, pattern, rawPattern, rawPatternStartRange, flags) {\n      if (!DOUBLE_SPACE.test(rawPattern)) {\n        return;\n      }\n\n      const characterClassNodes = [];\n      let regExpAST;\n\n      try {\n        regExpAST = regExpParser.parsePattern(pattern, 0, pattern.length, flags.includes(\"u\"));\n      } catch {\n        return;\n      }\n\n      regexpp__default['default'].visitRegExpAST(regExpAST, {\n        onCharacterClassEnter(ccNode) {\n          characterClassNodes.push(ccNode);\n        }\n\n      });\n      let match;\n\n      while (match = /( {2,})(?: [+*{?]|[^+*{?]|$)/gu.exec(pattern)) {\n        const {\n          1: {\n            length\n          },\n          index\n        } = match;\n\n        if (characterClassNodes.every(({\n          start,\n          end\n        }) => index < start || end <= index)) {\n          context.report({\n            node: nodeToReport,\n            messageId: \"multipleSpaces\",\n            data: {\n              length\n            },\n\n            fix(fixer) {\n              if (pattern !== rawPattern) {\n                return null;\n              }\n\n              return fixer.replaceTextRange([rawPatternStartRange + index, rawPatternStartRange + index + length], ` {${length}}`);\n            }\n\n          });\n          return;\n        }\n      }\n    }\n\n    function checkFunction(node) {\n      const scope = context.getScope();\n      const regExpVar = astUtils.getVariableByName(scope, \"RegExp\");\n      const shadowed = regExpVar && regExpVar.defs.length > 0;\n      const patternNode = node.arguments[0];\n      const flagsNode = node.arguments[1];\n\n      if (node.callee.type === \"Identifier\" && node.callee.name === \"RegExp\" && isString(patternNode) && !shadowed) {\n        const pattern = patternNode.value;\n        const rawPattern = patternNode.raw.slice(1, -1);\n        const rawPatternStartRange = patternNode.range[0] + 1;\n        const flags = isString(flagsNode) ? flagsNode.value : \"\";\n        checkRegex(node, pattern, rawPattern, rawPatternStartRange, flags);\n      }\n    }\n\n    return {\n      Literal: function (node) {\n        if (node.regex) {\n          const pattern = node.regex.pattern;\n          const rawPattern = node.raw.slice(1, node.raw.lastIndexOf(\"/\"));\n          const rawPatternStartRange = node.range[0] + 1;\n          const flags = node.regex.flags;\n          checkRegex(node, pattern, rawPattern, rawPatternStartRange, flags);\n        }\n      },\n      CallExpression: checkFunction,\n      NewExpression: checkFunction\n    };\n  }\n\n};\nnoRegexSpaces.meta;\nnoRegexSpaces.create;\nvar noRestrictedExports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow specified names in exports\",\n      category: \"ECMAScript 6\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-restricted-exports\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        restrictedNamedExports: {\n          type: \"array\",\n          items: {\n            type: \"string\"\n          },\n          uniqueItems: true\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      restrictedNamed: \"'{{name}}' is restricted from being used as an exported name.\"\n    }\n  },\n\n  create(context) {\n    const restrictedNames = new Set(context.options[0] && context.options[0].restrictedNamedExports);\n\n    function checkExportedName(node) {\n      const name = node.name;\n\n      if (restrictedNames.has(name)) {\n        context.report({\n          node,\n          messageId: \"restrictedNamed\",\n          data: {\n            name\n          }\n        });\n      }\n    }\n\n    return {\n      ExportAllDeclaration(node) {\n        if (node.exported) {\n          checkExportedName(node.exported);\n        }\n      },\n\n      ExportNamedDeclaration(node) {\n        const declaration = node.declaration;\n\n        if (declaration) {\n          if (declaration.type === \"FunctionDeclaration\" || declaration.type === \"ClassDeclaration\") {\n            checkExportedName(declaration.id);\n          } else if (declaration.type === \"VariableDeclaration\") {\n            context.getDeclaredVariables(declaration).map(v => v.defs.find(d => d.parent === declaration)).map(d => d.name).forEach(checkExportedName);\n          }\n        } else {\n          node.specifiers.map(s => s.exported).forEach(checkExportedName);\n        }\n      }\n\n    };\n  }\n\n};\nnoRestrictedExports.meta;\nnoRestrictedExports.create;\nvar noRestrictedGlobals = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow specified global variables\",\n      category: \"Variables\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-restricted-globals\"\n    },\n    schema: {\n      type: \"array\",\n      items: {\n        oneOf: [{\n          type: \"string\"\n        }, {\n          type: \"object\",\n          properties: {\n            name: {\n              type: \"string\"\n            },\n            message: {\n              type: \"string\"\n            }\n          },\n          required: [\"name\"],\n          additionalProperties: false\n        }]\n      },\n      uniqueItems: true,\n      minItems: 0\n    },\n    messages: {\n      defaultMessage: \"Unexpected use of '{{name}}'.\",\n      customMessage: \"Unexpected use of '{{name}}'. {{customMessage}}\"\n    }\n  },\n\n  create(context) {\n    if (context.options.length === 0) {\n      return {};\n    }\n\n    const restrictedGlobalMessages = context.options.reduce((memo, option) => {\n      if (typeof option === \"string\") {\n        memo[option] = null;\n      } else {\n        memo[option.name] = option.message;\n      }\n\n      return memo;\n    }, {});\n\n    function reportReference(reference) {\n      const name = reference.identifier.name,\n            customMessage = restrictedGlobalMessages[name],\n            messageId = customMessage ? \"customMessage\" : \"defaultMessage\";\n      context.report({\n        node: reference.identifier,\n        messageId,\n        data: {\n          name,\n          customMessage\n        }\n      });\n    }\n\n    function isRestricted(name) {\n      return Object.prototype.hasOwnProperty.call(restrictedGlobalMessages, name);\n    }\n\n    return {\n      Program() {\n        const scope = context.getScope();\n        scope.variables.forEach(variable => {\n          if (!variable.defs.length && isRestricted(variable.name)) {\n            variable.references.forEach(reportReference);\n          }\n        });\n        scope.through.forEach(reference => {\n          if (isRestricted(reference.identifier.name)) {\n            reportReference(reference);\n          }\n        });\n      }\n\n    };\n  }\n\n};\nnoRestrictedGlobals.meta;\nnoRestrictedGlobals.create;\nconst arrayOfStringsOrObjects$1 = {\n  type: \"array\",\n  items: {\n    anyOf: [{\n      type: \"string\"\n    }, {\n      type: \"object\",\n      properties: {\n        name: {\n          type: \"string\"\n        },\n        message: {\n          type: \"string\",\n          minLength: 1\n        },\n        importNames: {\n          type: \"array\",\n          items: {\n            type: \"string\"\n          }\n        }\n      },\n      additionalProperties: false,\n      required: [\"name\"]\n    }]\n  },\n  uniqueItems: true\n};\nconst arrayOfStringsOrObjectPatterns = {\n  anyOf: [{\n    type: \"array\",\n    items: {\n      type: \"string\"\n    },\n    uniqueItems: true\n  }, {\n    type: \"array\",\n    items: {\n      type: \"object\",\n      properties: {\n        group: {\n          type: \"array\",\n          items: {\n            type: \"string\"\n          },\n          minItems: 1,\n          uniqueItems: true\n        },\n        message: {\n          type: \"string\",\n          minLength: 1\n        }\n      },\n      additionalProperties: false,\n      required: [\"group\"]\n    },\n    uniqueItems: true\n  }]\n};\nvar noRestrictedImports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow specified modules when loaded by `import`\",\n      category: \"ECMAScript 6\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-restricted-imports\"\n    },\n    messages: {\n      path: \"'{{importSource}}' import is restricted from being used.\",\n      pathWithCustomMessage: \"'{{importSource}}' import is restricted from being used. {{customMessage}}\",\n      patterns: \"'{{importSource}}' import is restricted from being used by a pattern.\",\n      patternWithCustomMessage: \"'{{importSource}}' import is restricted from being used by a pattern. {{customMessage}}\",\n      everything: \"* import is invalid because '{{importNames}}' from '{{importSource}}' is restricted.\",\n      everythingWithCustomMessage: \"* import is invalid because '{{importNames}}' from '{{importSource}}' is restricted. {{customMessage}}\",\n      importName: \"'{{importName}}' import from '{{importSource}}' is restricted.\",\n      importNameWithCustomMessage: \"'{{importName}}' import from '{{importSource}}' is restricted. {{customMessage}}\"\n    },\n    schema: {\n      anyOf: [arrayOfStringsOrObjects$1, {\n        type: \"array\",\n        items: [{\n          type: \"object\",\n          properties: {\n            paths: arrayOfStringsOrObjects$1,\n            patterns: arrayOfStringsOrObjectPatterns\n          },\n          additionalProperties: false\n        }],\n        additionalItems: false\n      }]\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    const options = Array.isArray(context.options) ? context.options : [];\n    const isPathAndPatternsObject = typeof options[0] === \"object\" && (Object.prototype.hasOwnProperty.call(options[0], \"paths\") || Object.prototype.hasOwnProperty.call(options[0], \"patterns\"));\n    const restrictedPaths = (isPathAndPatternsObject ? options[0].paths : context.options) || [];\n    const restrictedPathMessages = restrictedPaths.reduce((memo, importSource) => {\n      if (typeof importSource === \"string\") {\n        memo[importSource] = {\n          message: null\n        };\n      } else {\n        memo[importSource.name] = {\n          message: importSource.message,\n          importNames: importSource.importNames\n        };\n      }\n\n      return memo;\n    }, {});\n    const restrictedPatterns = (isPathAndPatternsObject ? options[0].patterns : []) || [];\n    const restrictedPatternGroups = restrictedPatterns.length > 0 && typeof restrictedPatterns[0] === \"string\" ? [{\n      matcher: ignore__default['default']().add(restrictedPatterns)\n    }] : restrictedPatterns.map(({\n      group,\n      message\n    }) => ({\n      matcher: ignore__default['default']().add(group),\n      customMessage: message\n    }));\n\n    if (Object.keys(restrictedPaths).length === 0 && restrictedPatternGroups.length === 0) {\n      return {};\n    }\n\n    function checkRestrictedPathAndReport(importSource, importNames, node) {\n      if (!Object.prototype.hasOwnProperty.call(restrictedPathMessages, importSource)) {\n        return;\n      }\n\n      const customMessage = restrictedPathMessages[importSource].message;\n      const restrictedImportNames = restrictedPathMessages[importSource].importNames;\n\n      if (restrictedImportNames) {\n        if (importNames.has(\"*\")) {\n          const specifierData = importNames.get(\"*\")[0];\n          context.report({\n            node,\n            messageId: customMessage ? \"everythingWithCustomMessage\" : \"everything\",\n            loc: specifierData.loc,\n            data: {\n              importSource,\n              importNames: restrictedImportNames,\n              customMessage\n            }\n          });\n        }\n\n        restrictedImportNames.forEach(importName => {\n          if (importNames.has(importName)) {\n            const specifiers = importNames.get(importName);\n            specifiers.forEach(specifier => {\n              context.report({\n                node,\n                messageId: customMessage ? \"importNameWithCustomMessage\" : \"importName\",\n                loc: specifier.loc,\n                data: {\n                  importSource,\n                  customMessage,\n                  importName\n                }\n              });\n            });\n          }\n        });\n      } else {\n        context.report({\n          node,\n          messageId: customMessage ? \"pathWithCustomMessage\" : \"path\",\n          data: {\n            importSource,\n            customMessage\n          }\n        });\n      }\n    }\n\n    function reportPathForPatterns(node, group) {\n      const importSource = node.source.value.trim();\n      context.report({\n        node,\n        messageId: group.customMessage ? \"patternWithCustomMessage\" : \"patterns\",\n        data: {\n          importSource,\n          customMessage: group.customMessage\n        }\n      });\n    }\n\n    function isRestrictedPattern(importSource, group) {\n      return group.matcher.ignores(importSource);\n    }\n\n    function checkNode(node) {\n      const importSource = node.source.value.trim();\n      const importNames = new Map();\n\n      if (node.type === \"ExportAllDeclaration\") {\n        const starToken = sourceCode.getFirstToken(node, 1);\n        importNames.set(\"*\", [{\n          loc: starToken.loc\n        }]);\n      } else if (node.specifiers) {\n        for (const specifier of node.specifiers) {\n          let name;\n          const specifierData = {\n            loc: specifier.loc\n          };\n\n          if (specifier.type === \"ImportDefaultSpecifier\") {\n            name = \"default\";\n          } else if (specifier.type === \"ImportNamespaceSpecifier\") {\n            name = \"*\";\n          } else if (specifier.imported) {\n            name = specifier.imported.name;\n          } else if (specifier.local) {\n            name = specifier.local.name;\n          }\n\n          if (name) {\n            if (importNames.has(name)) {\n              importNames.get(name).push(specifierData);\n            } else {\n              importNames.set(name, [specifierData]);\n            }\n          }\n        }\n      }\n\n      checkRestrictedPathAndReport(importSource, importNames, node);\n      restrictedPatternGroups.forEach(group => {\n        if (isRestrictedPattern(importSource, group)) {\n          reportPathForPatterns(node, group);\n        }\n      });\n    }\n\n    return {\n      ImportDeclaration: checkNode,\n\n      ExportNamedDeclaration(node) {\n        if (node.source) {\n          checkNode(node);\n        }\n      },\n\n      ExportAllDeclaration: checkNode\n    };\n  }\n\n};\nnoRestrictedImports.meta;\nnoRestrictedImports.create;\nconst arrayOfStrings = {\n  type: \"array\",\n  items: {\n    type: \"string\"\n  },\n  uniqueItems: true\n};\nconst arrayOfStringsOrObjects = {\n  type: \"array\",\n  items: {\n    anyOf: [{\n      type: \"string\"\n    }, {\n      type: \"object\",\n      properties: {\n        name: {\n          type: \"string\"\n        },\n        message: {\n          type: \"string\",\n          minLength: 1\n        }\n      },\n      additionalProperties: false,\n      required: [\"name\"]\n    }]\n  },\n  uniqueItems: true\n};\nvar noRestrictedModules = {\n  meta: {\n    deprecated: true,\n    replacedBy: [],\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow specified modules when loaded by `require`\",\n      category: \"Node.js and CommonJS\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-restricted-modules\"\n    },\n    schema: {\n      anyOf: [arrayOfStringsOrObjects, {\n        type: \"array\",\n        items: {\n          type: \"object\",\n          properties: {\n            paths: arrayOfStringsOrObjects,\n            patterns: arrayOfStrings\n          },\n          additionalProperties: false\n        },\n        additionalItems: false\n      }]\n    },\n    messages: {\n      defaultMessage: \"'{{name}}' module is restricted from being used.\",\n      customMessage: \"'{{name}}' module is restricted from being used. {{customMessage}}\",\n      patternMessage: \"'{{name}}' module is restricted from being used by a pattern.\"\n    }\n  },\n\n  create(context) {\n    const options = Array.isArray(context.options) ? context.options : [];\n    const isPathAndPatternsObject = typeof options[0] === \"object\" && (Object.prototype.hasOwnProperty.call(options[0], \"paths\") || Object.prototype.hasOwnProperty.call(options[0], \"patterns\"));\n    const restrictedPaths = (isPathAndPatternsObject ? options[0].paths : context.options) || [];\n    const restrictedPatterns = (isPathAndPatternsObject ? options[0].patterns : []) || [];\n    const restrictedPathMessages = restrictedPaths.reduce((memo, importName) => {\n      if (typeof importName === \"string\") {\n        memo[importName] = null;\n      } else {\n        memo[importName.name] = importName.message;\n      }\n\n      return memo;\n    }, {});\n\n    if (Object.keys(restrictedPaths).length === 0 && restrictedPatterns.length === 0) {\n      return {};\n    }\n\n    const ig = ignore__default['default']().add(restrictedPatterns);\n\n    function isStringLiteral(node) {\n      return node && node.type === \"Literal\" && typeof node.value === \"string\";\n    }\n\n    function isStaticTemplateLiteral(node) {\n      return node && node.type === \"TemplateLiteral\" && node.expressions.length === 0;\n    }\n\n    function isRequireCall(node) {\n      return node.callee.type === \"Identifier\" && node.callee.name === \"require\";\n    }\n\n    function getFirstArgumentString(node) {\n      if (isStringLiteral(node)) {\n        return node.value.trim();\n      }\n\n      if (isStaticTemplateLiteral(node)) {\n        return node.quasis[0].value.cooked.trim();\n      }\n\n      return null;\n    }\n\n    function reportPath(node, name) {\n      const customMessage = restrictedPathMessages[name];\n      const messageId = customMessage ? \"customMessage\" : \"defaultMessage\";\n      context.report({\n        node,\n        messageId,\n        data: {\n          name,\n          customMessage\n        }\n      });\n    }\n\n    function isRestrictedPath(name) {\n      return Object.prototype.hasOwnProperty.call(restrictedPathMessages, name);\n    }\n\n    return {\n      CallExpression(node) {\n        if (isRequireCall(node)) {\n          if (node.arguments.length) {\n            const name = getFirstArgumentString(node.arguments[0]);\n\n            if (name) {\n              if (isRestrictedPath(name)) {\n                reportPath(node, name);\n              }\n\n              if (restrictedPatterns.length > 0 && ig.ignores(name)) {\n                context.report({\n                  node,\n                  messageId: \"patternMessage\",\n                  data: {\n                    name\n                  }\n                });\n              }\n            }\n          }\n        }\n      }\n\n    };\n  }\n\n};\nnoRestrictedModules.meta;\nnoRestrictedModules.create;\nvar noRestrictedProperties = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow certain properties on certain objects\",\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-restricted-properties\"\n    },\n    schema: {\n      type: \"array\",\n      items: {\n        anyOf: [{\n          type: \"object\",\n          properties: {\n            object: {\n              type: \"string\"\n            },\n            property: {\n              type: \"string\"\n            },\n            message: {\n              type: \"string\"\n            }\n          },\n          additionalProperties: false,\n          required: [\"object\"]\n        }, {\n          type: \"object\",\n          properties: {\n            object: {\n              type: \"string\"\n            },\n            property: {\n              type: \"string\"\n            },\n            message: {\n              type: \"string\"\n            }\n          },\n          additionalProperties: false,\n          required: [\"property\"]\n        }]\n      },\n      uniqueItems: true\n    },\n    messages: {\n      restrictedObjectProperty: \"'{{objectName}}.{{propertyName}}' is restricted from being used.{{message}}\",\n      restrictedProperty: \"'{{propertyName}}' is restricted from being used.{{message}}\"\n    }\n  },\n\n  create(context) {\n    const restrictedCalls = context.options;\n\n    if (restrictedCalls.length === 0) {\n      return {};\n    }\n\n    const restrictedProperties = new Map();\n    const globallyRestrictedObjects = new Map();\n    const globallyRestrictedProperties = new Map();\n    restrictedCalls.forEach(option => {\n      const objectName = option.object;\n      const propertyName = option.property;\n\n      if (typeof objectName === \"undefined\") {\n        globallyRestrictedProperties.set(propertyName, {\n          message: option.message\n        });\n      } else if (typeof propertyName === \"undefined\") {\n        globallyRestrictedObjects.set(objectName, {\n          message: option.message\n        });\n      } else {\n        if (!restrictedProperties.has(objectName)) {\n          restrictedProperties.set(objectName, new Map());\n        }\n\n        restrictedProperties.get(objectName).set(propertyName, {\n          message: option.message\n        });\n      }\n    });\n\n    function checkPropertyAccess(node, objectName, propertyName) {\n      if (propertyName === null) {\n        return;\n      }\n\n      const matchedObject = restrictedProperties.get(objectName);\n      const matchedObjectProperty = matchedObject ? matchedObject.get(propertyName) : globallyRestrictedObjects.get(objectName);\n      const globalMatchedProperty = globallyRestrictedProperties.get(propertyName);\n\n      if (matchedObjectProperty) {\n        const message = matchedObjectProperty.message ? ` ${matchedObjectProperty.message}` : \"\";\n        context.report({\n          node,\n          messageId: \"restrictedObjectProperty\",\n          data: {\n            objectName,\n            propertyName,\n            message\n          }\n        });\n      } else if (globalMatchedProperty) {\n        const message = globalMatchedProperty.message ? ` ${globalMatchedProperty.message}` : \"\";\n        context.report({\n          node,\n          messageId: \"restrictedProperty\",\n          data: {\n            propertyName,\n            message\n          }\n        });\n      }\n    }\n\n    function checkDestructuringAssignment(node) {\n      if (node.right.type === \"Identifier\") {\n        const objectName = node.right.name;\n\n        if (node.left.type === \"ObjectPattern\") {\n          node.left.properties.forEach(property => {\n            checkPropertyAccess(node.left, objectName, astUtils.getStaticPropertyName(property));\n          });\n        }\n      }\n    }\n\n    return {\n      MemberExpression(node) {\n        checkPropertyAccess(node, node.object && node.object.name, astUtils.getStaticPropertyName(node));\n      },\n\n      VariableDeclarator(node) {\n        if (node.init && node.init.type === \"Identifier\") {\n          const objectName = node.init.name;\n\n          if (node.id.type === \"ObjectPattern\") {\n            node.id.properties.forEach(property => {\n              checkPropertyAccess(node.id, objectName, astUtils.getStaticPropertyName(property));\n            });\n          }\n        }\n      },\n\n      AssignmentExpression: checkDestructuringAssignment,\n      AssignmentPattern: checkDestructuringAssignment\n    };\n  }\n\n};\nnoRestrictedProperties.meta;\nnoRestrictedProperties.create;\nvar noRestrictedSyntax = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow specified syntax\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-restricted-syntax\"\n    },\n    schema: {\n      type: \"array\",\n      items: {\n        oneOf: [{\n          type: \"string\"\n        }, {\n          type: \"object\",\n          properties: {\n            selector: {\n              type: \"string\"\n            },\n            message: {\n              type: \"string\"\n            }\n          },\n          required: [\"selector\"],\n          additionalProperties: false\n        }]\n      },\n      uniqueItems: true,\n      minItems: 0\n    },\n    messages: {\n      restrictedSyntax: \"{{message}}\"\n    }\n  },\n\n  create(context) {\n    return context.options.reduce((result, selectorOrObject) => {\n      const isStringFormat = typeof selectorOrObject === \"string\";\n      const hasCustomMessage = !isStringFormat && Boolean(selectorOrObject.message);\n      const selector = isStringFormat ? selectorOrObject : selectorOrObject.selector;\n      const message = hasCustomMessage ? selectorOrObject.message : `Using '${selector}' is not allowed.`;\n      return Object.assign(result, {\n        [selector](node) {\n          context.report({\n            node,\n            messageId: \"restrictedSyntax\",\n            data: {\n              message\n            }\n          });\n        }\n\n      });\n    }, {});\n  }\n\n};\nnoRestrictedSyntax.meta;\nnoRestrictedSyntax.create;\nconst SENTINEL_TYPE$1 = /^(?:[a-zA-Z]+?Statement|ArrowFunctionExpression|FunctionExpression|ClassExpression)$/u;\nvar noReturnAssign = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow assignment operators in `return` statements\",\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-return-assign\"\n    },\n    schema: [{\n      enum: [\"except-parens\", \"always\"]\n    }],\n    messages: {\n      returnAssignment: \"Return statement should not contain assignment.\",\n      arrowAssignment: \"Arrow function should not return assignment.\"\n    }\n  },\n\n  create(context) {\n    const always = (context.options[0] || \"except-parens\") !== \"except-parens\";\n    const sourceCode = context.getSourceCode();\n    return {\n      AssignmentExpression(node) {\n        if (!always && astUtils.isParenthesised(sourceCode, node)) {\n          return;\n        }\n\n        let currentChild = node;\n        let parent = currentChild.parent;\n\n        while (parent && !SENTINEL_TYPE$1.test(parent.type)) {\n          currentChild = parent;\n          parent = parent.parent;\n        }\n\n        if (parent && parent.type === \"ReturnStatement\") {\n          context.report({\n            node: parent,\n            messageId: \"returnAssignment\"\n          });\n        } else if (parent && parent.type === \"ArrowFunctionExpression\" && parent.body === currentChild) {\n          context.report({\n            node: parent,\n            messageId: \"arrowAssignment\"\n          });\n        }\n      }\n\n    };\n  }\n\n};\nnoReturnAssign.meta;\nnoReturnAssign.create;\nvar noReturnAwait = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow unnecessary `return await`\",\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-return-await\"\n    },\n    fixable: null,\n    schema: [],\n    messages: {\n      redundantUseOfAwait: \"Redundant use of `await` on a return value.\"\n    }\n  },\n\n  create(context) {\n    function reportUnnecessaryAwait(node) {\n      context.report({\n        node: context.getSourceCode().getFirstToken(node),\n        loc: node.loc,\n        messageId: \"redundantUseOfAwait\"\n      });\n    }\n\n    function hasErrorHandler(node) {\n      let ancestor = node;\n\n      while (!astUtils.isFunction(ancestor) && ancestor.type !== \"Program\") {\n        if (ancestor.parent.type === \"TryStatement\" && (ancestor === ancestor.parent.block || ancestor === ancestor.parent.handler && ancestor.parent.finalizer)) {\n          return true;\n        }\n\n        ancestor = ancestor.parent;\n      }\n\n      return false;\n    }\n\n    function isInTailCallPosition(node) {\n      if (node.parent.type === \"ArrowFunctionExpression\") {\n        return true;\n      }\n\n      if (node.parent.type === \"ReturnStatement\") {\n        return !hasErrorHandler(node.parent);\n      }\n\n      if (node.parent.type === \"ConditionalExpression\" && (node === node.parent.consequent || node === node.parent.alternate)) {\n        return isInTailCallPosition(node.parent);\n      }\n\n      if (node.parent.type === \"LogicalExpression\" && node === node.parent.right) {\n        return isInTailCallPosition(node.parent);\n      }\n\n      if (node.parent.type === \"SequenceExpression\" && node === node.parent.expressions[node.parent.expressions.length - 1]) {\n        return isInTailCallPosition(node.parent);\n      }\n\n      return false;\n    }\n\n    return {\n      AwaitExpression(node) {\n        if (isInTailCallPosition(node) && !hasErrorHandler(node)) {\n          reportUnnecessaryAwait(node);\n        }\n      }\n\n    };\n  }\n\n};\nnoReturnAwait.meta;\nnoReturnAwait.create;\nvar noScriptUrl = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow `javascript:` urls\",\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-script-url\"\n    },\n    schema: [],\n    messages: {\n      unexpectedScriptURL: \"Script URL is a form of eval.\"\n    }\n  },\n\n  create(context) {\n    function check(node) {\n      const value = astUtils.getStaticStringValue(node);\n\n      if (typeof value === \"string\" && value.toLowerCase().indexOf(\"javascript:\") === 0) {\n        context.report({\n          node,\n          messageId: \"unexpectedScriptURL\"\n        });\n      }\n    }\n\n    return {\n      Literal(node) {\n        if (node.value && typeof node.value === \"string\") {\n          check(node);\n        }\n      },\n\n      TemplateLiteral(node) {\n        if (!(node.parent && node.parent.type === \"TaggedTemplateExpression\")) {\n          check(node);\n        }\n      }\n\n    };\n  }\n\n};\nnoScriptUrl.meta;\nnoScriptUrl.create;\nconst SPACES = /\\s+/gu;\n\nfunction eachSelfAssignment(left, right, props, report) {\n  if (!left || !right) ;else if (left.type === \"Identifier\" && right.type === \"Identifier\" && left.name === right.name) {\n    report(right);\n  } else if (left.type === \"ArrayPattern\" && right.type === \"ArrayExpression\") {\n    const end = Math.min(left.elements.length, right.elements.length);\n\n    for (let i = 0; i < end; ++i) {\n      const leftElement = left.elements[i];\n      const rightElement = right.elements[i];\n\n      if (leftElement && leftElement.type === \"RestElement\" && i < right.elements.length - 1) {\n        break;\n      }\n\n      eachSelfAssignment(leftElement, rightElement, props, report);\n\n      if (rightElement && rightElement.type === \"SpreadElement\") {\n        break;\n      }\n    }\n  } else if (left.type === \"RestElement\" && right.type === \"SpreadElement\") {\n    eachSelfAssignment(left.argument, right.argument, props, report);\n  } else if (left.type === \"ObjectPattern\" && right.type === \"ObjectExpression\" && right.properties.length >= 1) {\n    let startJ = 0;\n\n    for (let i = right.properties.length - 1; i >= 0; --i) {\n      const propType = right.properties[i].type;\n\n      if (propType === \"SpreadElement\" || propType === \"ExperimentalSpreadProperty\") {\n        startJ = i + 1;\n        break;\n      }\n    }\n\n    for (let i = 0; i < left.properties.length; ++i) {\n      for (let j = startJ; j < right.properties.length; ++j) {\n        eachSelfAssignment(left.properties[i], right.properties[j], props, report);\n      }\n    }\n  } else if (left.type === \"Property\" && right.type === \"Property\" && right.kind === \"init\" && !right.method) {\n    const leftName = astUtils.getStaticPropertyName(left);\n\n    if (leftName !== null && leftName === astUtils.getStaticPropertyName(right)) {\n      eachSelfAssignment(left.value, right.value, props, report);\n    }\n  } else if (props && astUtils.skipChainExpression(left).type === \"MemberExpression\" && astUtils.skipChainExpression(right).type === \"MemberExpression\" && astUtils.isSameReference(left, right)) {\n    report(right);\n  }\n}\n\nvar noSelfAssign = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"disallow assignments where both sides are exactly the same\",\n      category: \"Best Practices\",\n      recommended: true,\n      url: \"https://eslint.org/docs/rules/no-self-assign\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        props: {\n          type: \"boolean\",\n          default: true\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      selfAssignment: \"'{{name}}' is assigned to itself.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    const [{\n      props = true\n    } = {}] = context.options;\n\n    function report(node) {\n      context.report({\n        node,\n        messageId: \"selfAssignment\",\n        data: {\n          name: sourceCode.getText(node).replace(SPACES, \"\")\n        }\n      });\n    }\n\n    return {\n      AssignmentExpression(node) {\n        if (node.operator === \"=\") {\n          eachSelfAssignment(node.left, node.right, props, report);\n        }\n      }\n\n    };\n  }\n\n};\nnoSelfAssign.meta;\nnoSelfAssign.create;\nvar noSelfCompare = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"disallow comparisons where both sides are exactly the same\",\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-self-compare\"\n    },\n    schema: [],\n    messages: {\n      comparingToSelf: \"Comparing to itself is potentially pointless.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n\n    function hasSameTokens(nodeA, nodeB) {\n      const tokensA = sourceCode.getTokens(nodeA);\n      const tokensB = sourceCode.getTokens(nodeB);\n      return tokensA.length === tokensB.length && tokensA.every((token, index) => token.type === tokensB[index].type && token.value === tokensB[index].value);\n    }\n\n    return {\n      BinaryExpression(node) {\n        const operators = new Set([\"===\", \"==\", \"!==\", \"!=\", \">\", \"<\", \">=\", \"<=\"]);\n\n        if (operators.has(node.operator) && hasSameTokens(node.left, node.right)) {\n          context.report({\n            node,\n            messageId: \"comparingToSelf\"\n          });\n        }\n      }\n\n    };\n  }\n\n};\nnoSelfCompare.meta;\nnoSelfCompare.create;\nconst DEFAULT_OPTIONS = {\n  allowInParentheses: true\n};\nvar noSequences = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow comma operators\",\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-sequences\"\n    },\n    schema: [{\n      properties: {\n        allowInParentheses: {\n          type: \"boolean\",\n          default: true\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      unexpectedCommaExpression: \"Unexpected use of comma operator.\"\n    }\n  },\n\n  create(context) {\n    const options = Object.assign({}, DEFAULT_OPTIONS, context.options[0]);\n    const sourceCode = context.getSourceCode();\n    const parenthesized = {\n      DoWhileStatement: \"test\",\n      IfStatement: \"test\",\n      SwitchStatement: \"discriminant\",\n      WhileStatement: \"test\",\n      WithStatement: \"object\",\n      ArrowFunctionExpression: \"body\"\n    };\n\n    function requiresExtraParens(node) {\n      return node.parent && parenthesized[node.parent.type] && node === node.parent[parenthesized[node.parent.type]];\n    }\n\n    function isParenthesised(node) {\n      return astUtils.isParenthesised(sourceCode, node);\n    }\n\n    function isParenthesisedTwice(node) {\n      const previousToken = sourceCode.getTokenBefore(node, 1),\n            nextToken = sourceCode.getTokenAfter(node, 1);\n      return isParenthesised(node) && previousToken && nextToken && astUtils.isOpeningParenToken(previousToken) && previousToken.range[1] <= node.range[0] && astUtils.isClosingParenToken(nextToken) && nextToken.range[0] >= node.range[1];\n    }\n\n    return {\n      SequenceExpression(node) {\n        if (node.parent.type === \"ForStatement\" && (node === node.parent.init || node === node.parent.update)) {\n          return;\n        }\n\n        if (options.allowInParentheses) {\n          if (requiresExtraParens(node)) {\n            if (isParenthesisedTwice(node)) {\n              return;\n            }\n          } else {\n            if (isParenthesised(node)) {\n              return;\n            }\n          }\n        }\n\n        const firstCommaToken = sourceCode.getTokenAfter(node.expressions[0], astUtils.isCommaToken);\n        context.report({\n          node,\n          loc: firstCommaToken.loc,\n          messageId: \"unexpectedCommaExpression\"\n        });\n      }\n\n    };\n  }\n\n};\nnoSequences.meta;\nnoSequences.create;\nconst {\n  findVariable: findVariable$1\n} = eslintUtils__default['default'];\n\nfunction isGlobalReference(node, scope) {\n  const variable = findVariable$1(scope, node);\n  return variable !== null && variable.scope.type === \"global\" && variable.defs.length === 0;\n}\n\nfunction isArgumentOfGlobalMethodCall(node, scope, objectName, methodName, index) {\n  const callNode = node.parent;\n  return callNode.type === \"CallExpression\" && callNode.arguments[index] === node && astUtils.isSpecificMemberAccess(callNode.callee, objectName, methodName) && isGlobalReference(astUtils.skipChainExpression(callNode.callee).object, scope);\n}\n\nfunction isPropertyDescriptor(node, scope) {\n  if (isArgumentOfGlobalMethodCall(node, scope, \"Object\", \"defineProperty\", 2) || isArgumentOfGlobalMethodCall(node, scope, \"Reflect\", \"defineProperty\", 2)) {\n    return true;\n  }\n\n  const parent = node.parent;\n\n  if (parent.type === \"Property\" && parent.value === node) {\n    const grandparent = parent.parent;\n\n    if (grandparent.type === \"ObjectExpression\" && (isArgumentOfGlobalMethodCall(grandparent, scope, \"Object\", \"create\", 1) || isArgumentOfGlobalMethodCall(grandparent, scope, \"Object\", \"defineProperties\", 1))) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction isSetter(node, scope) {\n  const parent = node.parent;\n\n  if (parent.kind === \"set\" && parent.value === node) {\n    return true;\n  }\n\n  if (parent.type === \"Property\" && parent.value === node && astUtils.getStaticPropertyName(parent) === \"set\" && parent.parent.type === \"ObjectExpression\" && isPropertyDescriptor(parent.parent, scope)) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction getOuterScope(scope) {\n  const upper = scope.upper;\n\n  if (upper.type === \"function-expression-name\") {\n    return upper.upper;\n  }\n\n  return upper;\n}\n\nvar noSetterReturn = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"disallow returning values from setters\",\n      category: \"Possible Errors\",\n      recommended: true,\n      url: \"https://eslint.org/docs/rules/no-setter-return\"\n    },\n    schema: [],\n    messages: {\n      returnsValue: \"Setter cannot return a value.\"\n    }\n  },\n\n  create(context) {\n    let funcInfo = null;\n\n    function enterFunction(node) {\n      const outerScope = getOuterScope(context.getScope());\n      funcInfo = {\n        upper: funcInfo,\n        isSetter: isSetter(node, outerScope)\n      };\n    }\n\n    function exitFunction() {\n      funcInfo = funcInfo.upper;\n    }\n\n    function report(node) {\n      context.report({\n        node,\n        messageId: \"returnsValue\"\n      });\n    }\n\n    return {\n      FunctionDeclaration: enterFunction,\n      FunctionExpression: enterFunction,\n\n      ArrowFunctionExpression(node) {\n        enterFunction(node);\n\n        if (funcInfo.isSetter && node.expression) {\n          report(node.body);\n        }\n      },\n\n      \"FunctionDeclaration:exit\": exitFunction,\n      \"FunctionExpression:exit\": exitFunction,\n      \"ArrowFunctionExpression:exit\": exitFunction,\n\n      ReturnStatement(node) {\n        if (funcInfo && funcInfo.isSetter && node.argument) {\n          report(node);\n        }\n      }\n\n    };\n  }\n\n};\nnoSetterReturn.meta;\nnoSetterReturn.create;\n\nfunction safelyShadowsUndefined(variable) {\n  return variable.name === \"undefined\" && variable.references.every(ref => !ref.isWrite()) && variable.defs.every(def => def.node.type === \"VariableDeclarator\" && def.node.init === null);\n}\n\nvar noShadowRestrictedNames = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow identifiers from shadowing restricted names\",\n      category: \"Variables\",\n      recommended: true,\n      url: \"https://eslint.org/docs/rules/no-shadow-restricted-names\"\n    },\n    schema: [],\n    messages: {\n      shadowingRestrictedName: \"Shadowing of global property '{{name}}'.\"\n    }\n  },\n\n  create(context) {\n    const RESTRICTED = new Set([\"undefined\", \"NaN\", \"Infinity\", \"arguments\", \"eval\"]);\n    return {\n      \"VariableDeclaration, :function, CatchClause\"(node) {\n        for (const variable of context.getDeclaredVariables(node)) {\n          if (variable.defs.length > 0 && RESTRICTED.has(variable.name) && !safelyShadowsUndefined(variable)) {\n            context.report({\n              node: variable.defs[0].name,\n              messageId: \"shadowingRestrictedName\",\n              data: {\n                name: variable.name\n              }\n            });\n          }\n        }\n      }\n\n    };\n  }\n\n};\nnoShadowRestrictedNames.meta;\nnoShadowRestrictedNames.create;\nvar noShadow = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow variable declarations from shadowing variables declared in the outer scope\",\n      category: \"Variables\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-shadow\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        builtinGlobals: {\n          type: \"boolean\",\n          default: false\n        },\n        hoist: {\n          enum: [\"all\", \"functions\", \"never\"],\n          default: \"functions\"\n        },\n        allow: {\n          type: \"array\",\n          items: {\n            type: \"string\"\n          }\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      noShadow: \"'{{name}}' is already declared in the upper scope on line {{shadowedLine}} column {{shadowedColumn}}.\",\n      noShadowGlobal: \"'{{name}}' is already a global variable.\"\n    }\n  },\n\n  create(context) {\n    const options = {\n      builtinGlobals: context.options[0] && context.options[0].builtinGlobals,\n      hoist: context.options[0] && context.options[0].hoist || \"functions\",\n      allow: context.options[0] && context.options[0].allow || []\n    };\n\n    function isAllowed(variable) {\n      return options.allow.indexOf(variable.name) !== -1;\n    }\n\n    function isDuplicatedClassNameVariable(variable) {\n      const block = variable.scope.block;\n      return block.type === \"ClassDeclaration\" && block.id === variable.identifiers[0];\n    }\n\n    function isOnInitializer(variable, scopeVar) {\n      const outerScope = scopeVar.scope;\n      const outerDef = scopeVar.defs[0];\n      const outer = outerDef && outerDef.parent && outerDef.parent.range;\n      const innerScope = variable.scope;\n      const innerDef = variable.defs[0];\n      const inner = innerDef && innerDef.name.range;\n      return outer && inner && outer[0] < inner[0] && inner[1] < outer[1] && (innerDef.type === \"FunctionName\" && innerDef.node.type === \"FunctionExpression\" || innerDef.node.type === \"ClassExpression\") && outerScope === innerScope.upper;\n    }\n\n    function getNameRange(variable) {\n      const def = variable.defs[0];\n      return def && def.name.range;\n    }\n\n    function getDeclaredLocation(variable) {\n      const identifier = variable.identifiers[0];\n      let obj;\n\n      if (identifier) {\n        obj = {\n          global: false,\n          line: identifier.loc.start.line,\n          column: identifier.loc.start.column + 1\n        };\n      } else {\n        obj = {\n          global: true\n        };\n      }\n\n      return obj;\n    }\n\n    function isInTdz(variable, scopeVar) {\n      const outerDef = scopeVar.defs[0];\n      const inner = getNameRange(variable);\n      const outer = getNameRange(scopeVar);\n      return inner && outer && inner[1] < outer[0] && (options.hoist !== \"functions\" || !outerDef || outerDef.node.type !== \"FunctionDeclaration\");\n    }\n\n    function checkForShadows(scope) {\n      const variables = scope.variables;\n\n      for (let i = 0; i < variables.length; ++i) {\n        const variable = variables[i];\n\n        if (variable.identifiers.length === 0 || isDuplicatedClassNameVariable(variable) || isAllowed(variable)) {\n          continue;\n        }\n\n        const shadowed = astUtils.getVariableByName(scope.upper, variable.name);\n\n        if (shadowed && (shadowed.identifiers.length > 0 || options.builtinGlobals && \"writeable\" in shadowed) && !isOnInitializer(variable, shadowed) && !(options.hoist !== \"all\" && isInTdz(variable, shadowed))) {\n          const location = getDeclaredLocation(shadowed);\n          const messageId = location.global ? \"noShadowGlobal\" : \"noShadow\";\n          const data = {\n            name: variable.name\n          };\n\n          if (!location.global) {\n            data.shadowedLine = location.line;\n            data.shadowedColumn = location.column;\n          }\n\n          context.report({\n            node: variable.identifiers[0],\n            messageId,\n            data\n          });\n        }\n      }\n    }\n\n    return {\n      \"Program:exit\"() {\n        const globalScope = context.getScope();\n        const stack = globalScope.childScopes.slice();\n\n        while (stack.length) {\n          const scope = stack.pop();\n          stack.push(...scope.childScopes);\n          checkForShadows(scope);\n        }\n      }\n\n    };\n  }\n\n};\nnoShadow.meta;\nnoShadow.create;\nvar noSpacedFunc = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"disallow spacing between function identifiers and their applications (deprecated)\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-spaced-func\"\n    },\n    deprecated: true,\n    replacedBy: [\"func-call-spacing\"],\n    fixable: \"whitespace\",\n    schema: [],\n    messages: {\n      noSpacedFunction: \"Unexpected space between function name and paren.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n\n    function detectOpenSpaces(node) {\n      const lastCalleeToken = sourceCode.getLastToken(node.callee);\n      let prevToken = lastCalleeToken,\n          parenToken = sourceCode.getTokenAfter(lastCalleeToken);\n\n      while (parenToken && parenToken.range[1] < node.range[1] && parenToken.value !== \"(\") {\n        prevToken = parenToken;\n        parenToken = sourceCode.getTokenAfter(parenToken);\n      }\n\n      if (parenToken && parenToken.range[1] < node.range[1] && sourceCode.isSpaceBetweenTokens(prevToken, parenToken)) {\n        context.report({\n          node,\n          loc: lastCalleeToken.loc.start,\n          messageId: \"noSpacedFunction\",\n\n          fix(fixer) {\n            return fixer.removeRange([prevToken.range[1], parenToken.range[0]]);\n          }\n\n        });\n      }\n    }\n\n    return {\n      CallExpression: detectOpenSpaces,\n      NewExpression: detectOpenSpaces\n    };\n  }\n\n};\nnoSpacedFunc.meta;\nnoSpacedFunc.create;\nvar noSparseArrays = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"disallow sparse arrays\",\n      category: \"Possible Errors\",\n      recommended: true,\n      url: \"https://eslint.org/docs/rules/no-sparse-arrays\"\n    },\n    schema: [],\n    messages: {\n      unexpectedSparseArray: \"Unexpected comma in middle of array.\"\n    }\n  },\n\n  create(context) {\n    return {\n      ArrayExpression(node) {\n        const emptySpot = node.elements.indexOf(null) > -1;\n\n        if (emptySpot) {\n          context.report({\n            node,\n            messageId: \"unexpectedSparseArray\"\n          });\n        }\n      }\n\n    };\n  }\n\n};\nnoSparseArrays.meta;\nnoSparseArrays.create;\nvar noSync = {\n  meta: {\n    deprecated: true,\n    replacedBy: [],\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow synchronous methods\",\n      category: \"Node.js and CommonJS\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-sync\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        allowAtRootLevel: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      noSync: \"Unexpected sync method: '{{propertyName}}'.\"\n    }\n  },\n\n  create(context) {\n    const selector = context.options[0] && context.options[0].allowAtRootLevel ? \":function MemberExpression[property.name=/.*Sync$/]\" : \"MemberExpression[property.name=/.*Sync$/]\";\n    return {\n      [selector](node) {\n        context.report({\n          node,\n          messageId: \"noSync\",\n          data: {\n            propertyName: node.property.name\n          }\n        });\n      }\n\n    };\n  }\n\n};\nnoSync.meta;\nnoSync.create;\nconst tabRegex = /\\t+/gu;\nconst anyNonWhitespaceRegex = /\\S/u;\nvar noTabs = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"disallow all tabs\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-tabs\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        allowIndentationTabs: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      unexpectedTab: \"Unexpected tab character.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    const allowIndentationTabs = context.options && context.options[0] && context.options[0].allowIndentationTabs;\n    return {\n      Program(node) {\n        sourceCode.getLines().forEach((line, index) => {\n          let match;\n\n          while ((match = tabRegex.exec(line)) !== null) {\n            if (allowIndentationTabs && !anyNonWhitespaceRegex.test(line.slice(0, match.index))) {\n              continue;\n            }\n\n            context.report({\n              node,\n              loc: {\n                start: {\n                  line: index + 1,\n                  column: match.index\n                },\n                end: {\n                  line: index + 1,\n                  column: match.index + match[0].length\n                }\n              },\n              messageId: \"unexpectedTab\"\n            });\n          }\n        });\n      }\n\n    };\n  }\n\n};\nnoTabs.meta;\nnoTabs.create;\nvar noTemplateCurlyInString = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"disallow template literal placeholder syntax in regular strings\",\n      category: \"Possible Errors\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-template-curly-in-string\"\n    },\n    schema: [],\n    messages: {\n      unexpectedTemplateExpression: \"Unexpected template string expression.\"\n    }\n  },\n\n  create(context) {\n    return {\n      Literal(node) {\n        if (typeof node.value === \"string\" && /\\$\\{[^}]+\\}/u.test(node.value)) {\n          context.report({\n            node,\n            messageId: \"unexpectedTemplateExpression\"\n          });\n        }\n      }\n\n    };\n  }\n\n};\nnoTemplateCurlyInString.meta;\nnoTemplateCurlyInString.create;\nvar noTernary = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow ternary operators\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-ternary\"\n    },\n    schema: [],\n    messages: {\n      noTernaryOperator: \"Ternary operator used.\"\n    }\n  },\n\n  create(context) {\n    return {\n      ConditionalExpression(node) {\n        context.report({\n          node,\n          messageId: \"noTernaryOperator\"\n        });\n      }\n\n    };\n  }\n\n};\nnoTernary.meta;\nnoTernary.create;\n\nfunction isConstructorFunction(node) {\n  return node.type === \"FunctionExpression\" && node.parent.type === \"MethodDefinition\" && node.parent.kind === \"constructor\";\n}\n\nvar noThisBeforeSuper = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"disallow `this`/`super` before calling `super()` in constructors\",\n      category: \"ECMAScript 6\",\n      recommended: true,\n      url: \"https://eslint.org/docs/rules/no-this-before-super\"\n    },\n    schema: [],\n    messages: {\n      noBeforeSuper: \"'{{kind}}' is not allowed before 'super()'.\"\n    }\n  },\n\n  create(context) {\n    let funcInfo = null;\n    let segInfoMap = Object.create(null);\n\n    function isCalled(segment) {\n      return !segment.reachable || segInfoMap[segment.id].superCalled;\n    }\n\n    function isInConstructorOfDerivedClass() {\n      return Boolean(funcInfo && funcInfo.isConstructor && funcInfo.hasExtends);\n    }\n\n    function isBeforeCallOfSuper() {\n      return isInConstructorOfDerivedClass() && !funcInfo.codePath.currentSegments.every(isCalled);\n    }\n\n    function setInvalid(node) {\n      const segments = funcInfo.codePath.currentSegments;\n\n      for (let i = 0; i < segments.length; ++i) {\n        const segment = segments[i];\n\n        if (segment.reachable) {\n          segInfoMap[segment.id].invalidNodes.push(node);\n        }\n      }\n    }\n\n    function setSuperCalled() {\n      const segments = funcInfo.codePath.currentSegments;\n\n      for (let i = 0; i < segments.length; ++i) {\n        const segment = segments[i];\n\n        if (segment.reachable) {\n          segInfoMap[segment.id].superCalled = true;\n        }\n      }\n    }\n\n    return {\n      onCodePathStart(codePath, node) {\n        if (isConstructorFunction(node)) {\n          const classNode = node.parent.parent.parent;\n          funcInfo = {\n            upper: funcInfo,\n            isConstructor: true,\n            hasExtends: Boolean(classNode.superClass && !astUtils.isNullOrUndefined(classNode.superClass)),\n            codePath\n          };\n        } else {\n          funcInfo = {\n            upper: funcInfo,\n            isConstructor: false,\n            hasExtends: false,\n            codePath\n          };\n        }\n      },\n\n      onCodePathEnd(codePath) {\n        const isDerivedClass = funcInfo.hasExtends;\n        funcInfo = funcInfo.upper;\n\n        if (!isDerivedClass) {\n          return;\n        }\n\n        codePath.traverseSegments((segment, controller) => {\n          const info = segInfoMap[segment.id];\n\n          for (let i = 0; i < info.invalidNodes.length; ++i) {\n            const invalidNode = info.invalidNodes[i];\n            context.report({\n              messageId: \"noBeforeSuper\",\n              node: invalidNode,\n              data: {\n                kind: invalidNode.type === \"Super\" ? \"super\" : \"this\"\n              }\n            });\n          }\n\n          if (info.superCalled) {\n            controller.skip();\n          }\n        });\n      },\n\n      onCodePathSegmentStart(segment) {\n        if (!isInConstructorOfDerivedClass()) {\n          return;\n        }\n\n        segInfoMap[segment.id] = {\n          superCalled: segment.prevSegments.length > 0 && segment.prevSegments.every(isCalled),\n          invalidNodes: []\n        };\n      },\n\n      onCodePathSegmentLoop(fromSegment, toSegment) {\n        if (!isInConstructorOfDerivedClass()) {\n          return;\n        }\n\n        funcInfo.codePath.traverseSegments({\n          first: toSegment,\n          last: fromSegment\n        }, (segment, controller) => {\n          const info = segInfoMap[segment.id];\n\n          if (info.superCalled) {\n            info.invalidNodes = [];\n            controller.skip();\n          } else if (segment.prevSegments.length > 0 && segment.prevSegments.every(isCalled)) {\n            info.superCalled = true;\n            info.invalidNodes = [];\n          }\n        });\n      },\n\n      ThisExpression(node) {\n        if (isBeforeCallOfSuper()) {\n          setInvalid(node);\n        }\n      },\n\n      Super(node) {\n        if (!astUtils.isCallee(node) && isBeforeCallOfSuper()) {\n          setInvalid(node);\n        }\n      },\n\n      \"CallExpression:exit\"(node) {\n        if (node.callee.type === \"Super\" && isBeforeCallOfSuper()) {\n          setSuperCalled();\n        }\n      },\n\n      \"Program:exit\"() {\n        segInfoMap = Object.create(null);\n      }\n\n    };\n  }\n\n};\nnoThisBeforeSuper.meta;\nnoThisBeforeSuper.create;\nvar noThrowLiteral = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow throwing literals as exceptions\",\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-throw-literal\"\n    },\n    schema: [],\n    messages: {\n      object: \"Expected an error object to be thrown.\",\n      undef: \"Do not throw undefined.\"\n    }\n  },\n\n  create(context) {\n    return {\n      ThrowStatement(node) {\n        if (!astUtils.couldBeError(node.argument)) {\n          context.report({\n            node,\n            messageId: \"object\"\n          });\n        } else if (node.argument.type === \"Identifier\") {\n          if (node.argument.name === \"undefined\") {\n            context.report({\n              node,\n              messageId: \"undef\"\n            });\n          }\n        }\n      }\n\n    };\n  }\n\n};\nnoThrowLiteral.meta;\nnoThrowLiteral.create;\nvar noTrailingSpaces = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"disallow trailing whitespace at the end of lines\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-trailing-spaces\"\n    },\n    fixable: \"whitespace\",\n    schema: [{\n      type: \"object\",\n      properties: {\n        skipBlankLines: {\n          type: \"boolean\",\n          default: false\n        },\n        ignoreComments: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      trailingSpace: \"Trailing spaces not allowed.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    const options = context.options[0] || {},\n          skipBlankLines = options.skipBlankLines || false,\n          ignoreComments = options.ignoreComments || false;\n\n    function report(node, location, fixRange) {\n      context.report({\n        node,\n        loc: location,\n        messageId: \"trailingSpace\",\n\n        fix(fixer) {\n          return fixer.removeRange(fixRange);\n        }\n\n      });\n    }\n\n    function getCommentLineNumbers(comments) {\n      const lines = new Set();\n      comments.forEach(comment => {\n        const endLine = comment.type === \"Block\" ? comment.loc.end.line - 1 : comment.loc.end.line;\n\n        for (let i = comment.loc.start.line; i <= endLine; i++) {\n          lines.add(i);\n        }\n      });\n      return lines;\n    }\n\n    return {\n      Program: function (node) {\n        const re = new RegExp(`${\"[ \\t\\xA0\\u2000-\\u200B\\u3000]\"}+$`, \"u\"),\n              skipMatch = new RegExp(`^${\"[ \\t\\xA0\\u2000-\\u200B\\u3000]\"}*$`, \"u\"),\n              lines = sourceCode.lines,\n              linebreaks = sourceCode.getText().match(astUtils.createGlobalLinebreakMatcher()),\n              comments = sourceCode.getAllComments(),\n              commentLineNumbers = getCommentLineNumbers(comments);\n        let totalLength = 0,\n            fixRange = [];\n\n        for (let i = 0, ii = lines.length; i < ii; i++) {\n          const lineNumber = i + 1;\n          const linebreakLength = linebreaks && linebreaks[i] ? linebreaks[i].length : 1;\n          const lineLength = lines[i].length + linebreakLength;\n          const matches = re.exec(lines[i]);\n\n          if (matches) {\n            const location = {\n              start: {\n                line: lineNumber,\n                column: matches.index\n              },\n              end: {\n                line: lineNumber,\n                column: lineLength - linebreakLength\n              }\n            };\n            const rangeStart = totalLength + location.start.column;\n            const rangeEnd = totalLength + location.end.column;\n            const containingNode = sourceCode.getNodeByRangeIndex(rangeStart);\n\n            if (containingNode && containingNode.type === \"TemplateElement\" && rangeStart > containingNode.parent.range[0] && rangeEnd < containingNode.parent.range[1]) {\n              totalLength += lineLength;\n              continue;\n            }\n\n            if (skipBlankLines && skipMatch.test(lines[i])) {\n              totalLength += lineLength;\n              continue;\n            }\n\n            fixRange = [rangeStart, rangeEnd];\n\n            if (!ignoreComments || !commentLineNumbers.has(lineNumber)) {\n              report(node, location, fixRange);\n            }\n          }\n\n          totalLength += lineLength;\n        }\n      }\n    };\n  }\n\n};\nnoTrailingSpaces.meta;\nnoTrailingSpaces.create;\nvar noUndefInit = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow initializing variables to `undefined`\",\n      category: \"Variables\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-undef-init\"\n    },\n    schema: [],\n    fixable: \"code\",\n    messages: {\n      unnecessaryUndefinedInit: \"It's not necessary to initialize '{{name}}' to undefined.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    return {\n      VariableDeclarator(node) {\n        const name = sourceCode.getText(node.id),\n              init = node.init && node.init.name,\n              scope = context.getScope(),\n              undefinedVar = astUtils.getVariableByName(scope, \"undefined\"),\n              shadowed = undefinedVar && undefinedVar.defs.length > 0,\n              lastToken = sourceCode.getLastToken(node);\n\n        if (init === \"undefined\" && node.parent.kind !== \"const\" && !shadowed) {\n          context.report({\n            node,\n            messageId: \"unnecessaryUndefinedInit\",\n            data: {\n              name\n            },\n\n            fix(fixer) {\n              if (node.parent.kind === \"var\") {\n                return null;\n              }\n\n              if (node.id.type === \"ArrayPattern\" || node.id.type === \"ObjectPattern\") {\n                return null;\n              }\n\n              if (sourceCode.commentsExistBetween(node.id, lastToken)) {\n                return null;\n              }\n\n              return fixer.removeRange([node.id.range[1], node.range[1]]);\n            }\n\n          });\n        }\n      }\n\n    };\n  }\n\n};\nnoUndefInit.meta;\nnoUndefInit.create;\n\nfunction hasTypeOfOperator(node) {\n  const parent = node.parent;\n  return parent.type === \"UnaryExpression\" && parent.operator === \"typeof\";\n}\n\nvar noUndef = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"disallow the use of undeclared variables unless mentioned in `/*global */` comments\",\n      category: \"Variables\",\n      recommended: true,\n      url: \"https://eslint.org/docs/rules/no-undef\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        typeof: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      undef: \"'{{name}}' is not defined.\"\n    }\n  },\n\n  create(context) {\n    const options = context.options[0];\n    const considerTypeOf = options && options.typeof === true || false;\n    return {\n      \"Program:exit\"() {\n        const globalScope = context.getScope();\n        globalScope.through.forEach(ref => {\n          const identifier = ref.identifier;\n\n          if (!considerTypeOf && hasTypeOfOperator(identifier)) {\n            return;\n          }\n\n          context.report({\n            node: identifier,\n            messageId: \"undef\",\n            data: identifier\n          });\n        });\n      }\n\n    };\n  }\n\n};\nnoUndef.meta;\nnoUndef.create;\nvar noUndefined = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow the use of `undefined` as an identifier\",\n      category: \"Variables\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-undefined\"\n    },\n    schema: [],\n    messages: {\n      unexpectedUndefined: \"Unexpected use of undefined.\"\n    }\n  },\n\n  create(context) {\n    function report(node) {\n      context.report({\n        node,\n        messageId: \"unexpectedUndefined\"\n      });\n    }\n\n    function checkScope(scope) {\n      const undefinedVar = scope.set.get(\"undefined\");\n\n      if (!undefinedVar) {\n        return;\n      }\n\n      const references = undefinedVar.references;\n      const defs = undefinedVar.defs;\n      references.filter(ref => !ref.init).forEach(ref => report(ref.identifier));\n      defs.forEach(def => report(def.name));\n    }\n\n    return {\n      \"Program:exit\"() {\n        const globalScope = context.getScope();\n        const stack = [globalScope];\n\n        while (stack.length) {\n          const scope = stack.pop();\n          stack.push(...scope.childScopes);\n          checkScope(scope);\n        }\n      }\n\n    };\n  }\n\n};\nnoUndefined.meta;\nnoUndefined.create;\nvar noUnderscoreDangle = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow dangling underscores in identifiers\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-underscore-dangle\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        allow: {\n          type: \"array\",\n          items: {\n            type: \"string\"\n          }\n        },\n        allowAfterThis: {\n          type: \"boolean\",\n          default: false\n        },\n        allowAfterSuper: {\n          type: \"boolean\",\n          default: false\n        },\n        allowAfterThisConstructor: {\n          type: \"boolean\",\n          default: false\n        },\n        enforceInMethodNames: {\n          type: \"boolean\",\n          default: false\n        },\n        allowFunctionParams: {\n          type: \"boolean\",\n          default: true\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      unexpectedUnderscore: \"Unexpected dangling '_' in '{{identifier}}'.\"\n    }\n  },\n\n  create(context) {\n    const options = context.options[0] || {};\n    const ALLOWED_VARIABLES = options.allow ? options.allow : [];\n    const allowAfterThis = typeof options.allowAfterThis !== \"undefined\" ? options.allowAfterThis : false;\n    const allowAfterSuper = typeof options.allowAfterSuper !== \"undefined\" ? options.allowAfterSuper : false;\n    const allowAfterThisConstructor = typeof options.allowAfterThisConstructor !== \"undefined\" ? options.allowAfterThisConstructor : false;\n    const enforceInMethodNames = typeof options.enforceInMethodNames !== \"undefined\" ? options.enforceInMethodNames : false;\n    const allowFunctionParams = typeof options.allowFunctionParams !== \"undefined\" ? options.allowFunctionParams : true;\n\n    function isAllowed(identifier) {\n      return ALLOWED_VARIABLES.some(ident => ident === identifier);\n    }\n\n    function hasDanglingUnderscore(identifier) {\n      const len = identifier.length;\n      return identifier !== \"_\" && (identifier[0] === \"_\" || identifier[len - 1] === \"_\");\n    }\n\n    function isSpecialCaseIdentifierForMemberExpression(identifier) {\n      return identifier === \"__proto__\";\n    }\n\n    function isSpecialCaseIdentifierInVariableExpression(identifier) {\n      return identifier === \"_\";\n    }\n\n    function isThisConstructorReference(node) {\n      return node.object.type === \"MemberExpression\" && node.object.property.name === \"constructor\" && node.object.object.type === \"ThisExpression\";\n    }\n\n    function checkForDanglingUnderscoreInFunctionParameters(node) {\n      if (!allowFunctionParams) {\n        node.params.forEach(param => {\n          const {\n            type\n          } = param;\n          let nodeToCheck;\n\n          if (type === \"RestElement\") {\n            nodeToCheck = param.argument;\n          } else if (type === \"AssignmentPattern\") {\n            nodeToCheck = param.left;\n          } else {\n            nodeToCheck = param;\n          }\n\n          if (nodeToCheck.type === \"Identifier\") {\n            const identifier = nodeToCheck.name;\n\n            if (hasDanglingUnderscore(identifier) && !isAllowed(identifier)) {\n              context.report({\n                node: param,\n                messageId: \"unexpectedUnderscore\",\n                data: {\n                  identifier\n                }\n              });\n            }\n          }\n        });\n      }\n    }\n\n    function checkForDanglingUnderscoreInFunction(node) {\n      if (node.type === \"FunctionDeclaration\" && node.id) {\n        const identifier = node.id.name;\n\n        if (typeof identifier !== \"undefined\" && hasDanglingUnderscore(identifier) && !isAllowed(identifier)) {\n          context.report({\n            node,\n            messageId: \"unexpectedUnderscore\",\n            data: {\n              identifier\n            }\n          });\n        }\n      }\n\n      checkForDanglingUnderscoreInFunctionParameters(node);\n    }\n\n    function checkForDanglingUnderscoreInMethod(node) {\n      const identifier = node.key.name;\n      const isMethod = node.type === \"MethodDefinition\" || node.type === \"Property\" && node.method;\n\n      if (typeof identifier !== \"undefined\" && enforceInMethodNames && isMethod && hasDanglingUnderscore(identifier) && !isAllowed(identifier)) {\n        context.report({\n          node,\n          messageId: \"unexpectedUnderscore\",\n          data: {\n            identifier\n          }\n        });\n      }\n    }\n\n    return {\n      FunctionDeclaration: checkForDanglingUnderscoreInFunction,\n      VariableDeclarator: function (node) {\n        const identifier = node.id.name;\n\n        if (typeof identifier !== \"undefined\" && hasDanglingUnderscore(identifier) && !isSpecialCaseIdentifierInVariableExpression(identifier) && !isAllowed(identifier)) {\n          context.report({\n            node,\n            messageId: \"unexpectedUnderscore\",\n            data: {\n              identifier\n            }\n          });\n        }\n      },\n      MemberExpression: function (node) {\n        const identifier = node.property.name,\n              isMemberOfThis = node.object.type === \"ThisExpression\",\n              isMemberOfSuper = node.object.type === \"Super\",\n              isMemberOfThisConstructor = isThisConstructorReference(node);\n\n        if (typeof identifier !== \"undefined\" && hasDanglingUnderscore(identifier) && !(isMemberOfThis && allowAfterThis) && !(isMemberOfSuper && allowAfterSuper) && !(isMemberOfThisConstructor && allowAfterThisConstructor) && !isSpecialCaseIdentifierForMemberExpression(identifier) && !isAllowed(identifier)) {\n          context.report({\n            node,\n            messageId: \"unexpectedUnderscore\",\n            data: {\n              identifier\n            }\n          });\n        }\n      },\n      MethodDefinition: checkForDanglingUnderscoreInMethod,\n      Property: checkForDanglingUnderscoreInMethod,\n      FunctionExpression: checkForDanglingUnderscoreInFunction,\n      ArrowFunctionExpression: checkForDanglingUnderscoreInFunction\n    };\n  }\n\n};\nnoUnderscoreDangle.meta;\nnoUnderscoreDangle.create;\nvar noUnexpectedMultiline = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"disallow confusing multiline expressions\",\n      category: \"Possible Errors\",\n      recommended: true,\n      url: \"https://eslint.org/docs/rules/no-unexpected-multiline\"\n    },\n    schema: [],\n    messages: {\n      function: \"Unexpected newline between function and ( of function call.\",\n      property: \"Unexpected newline between object and [ of property access.\",\n      taggedTemplate: \"Unexpected newline between template tag and template literal.\",\n      division: \"Unexpected newline between numerator and division operator.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n\n    function checkForBreakAfter(node, messageId) {\n      const openParen = sourceCode.getTokenAfter(node, astUtils.isNotClosingParenToken);\n      const nodeExpressionEnd = sourceCode.getTokenBefore(openParen);\n\n      if (openParen.loc.start.line !== nodeExpressionEnd.loc.end.line) {\n        context.report({\n          node,\n          loc: openParen.loc,\n          messageId\n        });\n      }\n    }\n\n    return {\n      MemberExpression(node) {\n        if (!node.computed || node.optional) {\n          return;\n        }\n\n        checkForBreakAfter(node.object, \"property\");\n      },\n\n      TaggedTemplateExpression(node) {\n        const {\n          quasi\n        } = node;\n        const tokenBefore = sourceCode.getTokenBefore(quasi);\n\n        if (tokenBefore.loc.end.line !== quasi.loc.start.line) {\n          context.report({\n            node,\n            loc: {\n              start: quasi.loc.start,\n              end: {\n                line: quasi.loc.start.line,\n                column: quasi.loc.start.column + 1\n              }\n            },\n            messageId: \"taggedTemplate\"\n          });\n        }\n      },\n\n      CallExpression(node) {\n        if (node.arguments.length === 0 || node.optional) {\n          return;\n        }\n\n        checkForBreakAfter(node.callee, \"function\");\n      },\n\n      \"BinaryExpression[operator='/'] > BinaryExpression[operator='/'].left\"(node) {\n        const secondSlash = sourceCode.getTokenAfter(node, token => token.value === \"/\");\n        const tokenAfterOperator = sourceCode.getTokenAfter(secondSlash);\n\n        if (tokenAfterOperator.type === \"Identifier\" && /^[gimsuy]+$/u.test(tokenAfterOperator.value) && secondSlash.range[1] === tokenAfterOperator.range[0]) {\n          checkForBreakAfter(node.left, \"division\");\n        }\n      }\n\n    };\n  }\n\n};\nnoUnexpectedMultiline.meta;\nnoUnexpectedMultiline.create;\nconst SENTINEL_PATTERN = /(?:(?:Call|Class|Function|Member|New|Yield)Expression|Statement|Declaration)$/u;\nconst LOOP_PATTERN = /^(?:DoWhile|For|While)Statement$/u;\nconst GROUP_PATTERN = /^(?:BinaryExpression|ConditionalExpression)$/u;\nconst SKIP_PATTERN = /^(?:ArrowFunction|Class|Function)Expression$/u;\nconst DYNAMIC_PATTERN = /^(?:Call|Member|New|TaggedTemplate|Yield)Expression$/u;\n\nfunction isWriteReference(reference) {\n  if (reference.init) {\n    const def = reference.resolved && reference.resolved.defs[0];\n\n    if (!def || def.type !== \"Variable\" || def.parent.kind !== \"var\") {\n      return false;\n    }\n  }\n\n  return reference.isWrite();\n}\n\nfunction isUnmodified(condition) {\n  return !condition.modified;\n}\n\nfunction isUnmodifiedAndNotBelongToGroup(condition) {\n  return !(condition.modified || condition.group);\n}\n\nfunction isInRange$1(node, reference) {\n  const or = node.range;\n  const ir = reference.identifier.range;\n  return or[0] <= ir[0] && ir[1] <= or[1];\n}\n\nconst isInLoop = {\n  WhileStatement: isInRange$1,\n  DoWhileStatement: isInRange$1,\n\n  ForStatement(node, reference) {\n    return isInRange$1(node, reference) && !(node.init && isInRange$1(node.init, reference));\n  }\n\n};\n\nfunction getEncloseFunctionDeclaration(reference) {\n  let node = reference.identifier;\n\n  while (node) {\n    if (node.type === \"FunctionDeclaration\") {\n      return node.id ? node : null;\n    }\n\n    node = node.parent;\n  }\n\n  return null;\n}\n\nfunction updateModifiedFlag(conditions, modifiers) {\n  for (let i = 0; i < conditions.length; ++i) {\n    const condition = conditions[i];\n\n    for (let j = 0; !condition.modified && j < modifiers.length; ++j) {\n      const modifier = modifiers[j];\n      let funcNode, funcVar;\n      const inLoop = condition.isInLoop(modifier) || Boolean((funcNode = getEncloseFunctionDeclaration(modifier)) && (funcVar = astUtils.getVariableByName(modifier.from.upper, funcNode.id.name)) && funcVar.references.some(condition.isInLoop));\n      condition.modified = inLoop;\n    }\n  }\n}\n\nvar noUnmodifiedLoopCondition = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"disallow unmodified loop conditions\",\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-unmodified-loop-condition\"\n    },\n    schema: [],\n    messages: {\n      loopConditionNotModified: \"'{{name}}' is not modified in this loop.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    let groupMap = null;\n\n    function report(condition) {\n      const node = condition.reference.identifier;\n      context.report({\n        node,\n        messageId: \"loopConditionNotModified\",\n        data: node\n      });\n    }\n\n    function registerConditionsToGroup(conditions) {\n      for (let i = 0; i < conditions.length; ++i) {\n        const condition = conditions[i];\n\n        if (condition.group) {\n          let group = groupMap.get(condition.group);\n\n          if (!group) {\n            group = [];\n            groupMap.set(condition.group, group);\n          }\n\n          group.push(condition);\n        }\n      }\n    }\n\n    function checkConditionsInGroup(conditions) {\n      if (conditions.every(isUnmodified)) {\n        conditions.forEach(report);\n      }\n    }\n\n    function hasDynamicExpressions(root) {\n      let retv = false;\n\n      _commonjsHelpers.traverser.traverse(root, {\n        visitorKeys: sourceCode.visitorKeys,\n\n        enter(node) {\n          if (DYNAMIC_PATTERN.test(node.type)) {\n            retv = true;\n            this.break();\n          } else if (SKIP_PATTERN.test(node.type)) {\n            this.skip();\n          }\n        }\n\n      });\n\n      return retv;\n    }\n\n    function toLoopCondition(reference) {\n      if (reference.init) {\n        return null;\n      }\n\n      let group = null;\n      let child = reference.identifier;\n      let node = child.parent;\n\n      while (node) {\n        if (SENTINEL_PATTERN.test(node.type)) {\n          if (LOOP_PATTERN.test(node.type) && node.test === child) {\n            return {\n              reference,\n              group,\n              isInLoop: isInLoop[node.type].bind(null, node),\n              modified: false\n            };\n          }\n\n          break;\n        }\n\n        if (GROUP_PATTERN.test(node.type)) {\n          if (hasDynamicExpressions(node)) {\n            break;\n          } else {\n            group = node;\n          }\n        }\n\n        child = node;\n        node = node.parent;\n      }\n\n      return null;\n    }\n\n    function checkReferences(variable) {\n      const conditions = variable.references.map(toLoopCondition).filter(Boolean);\n\n      if (conditions.length === 0) {\n        return;\n      }\n\n      registerConditionsToGroup(conditions);\n      const modifiers = variable.references.filter(isWriteReference);\n\n      if (modifiers.length > 0) {\n        updateModifiedFlag(conditions, modifiers);\n      }\n\n      conditions.filter(isUnmodifiedAndNotBelongToGroup).forEach(report);\n    }\n\n    return {\n      \"Program:exit\"() {\n        const queue = [context.getScope()];\n        groupMap = new Map();\n        let scope;\n\n        while (scope = queue.pop()) {\n          queue.push(...scope.childScopes);\n          scope.variables.forEach(checkReferences);\n        }\n\n        groupMap.forEach(checkConditionsInGroup);\n        groupMap = null;\n      }\n\n    };\n  }\n\n};\nnoUnmodifiedLoopCondition.meta;\nnoUnmodifiedLoopCondition.create;\nconst BOOLEAN_OPERATORS = new Set([\"==\", \"===\", \"!=\", \"!==\", \">\", \">=\", \"<\", \"<=\", \"in\", \"instanceof\"]);\nconst OPERATOR_INVERSES = {\n  \"==\": \"!=\",\n  \"!=\": \"==\",\n  \"===\": \"!==\",\n  \"!==\": \"===\"\n};\nconst OR_PRECEDENCE = astUtils.getPrecedence({\n  type: \"LogicalExpression\",\n  operator: \"||\"\n});\nvar noUnneededTernary = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow ternary operators when simpler alternatives exist\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-unneeded-ternary\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        defaultAssignment: {\n          type: \"boolean\",\n          default: true\n        }\n      },\n      additionalProperties: false\n    }],\n    fixable: \"code\",\n    messages: {\n      unnecessaryConditionalExpression: \"Unnecessary use of boolean literals in conditional expression.\",\n      unnecessaryConditionalAssignment: \"Unnecessary use of conditional expression for default assignment.\"\n    }\n  },\n\n  create(context) {\n    const options = context.options[0] || {};\n    const defaultAssignment = options.defaultAssignment !== false;\n    const sourceCode = context.getSourceCode();\n\n    function isBooleanLiteral(node) {\n      return node.type === \"Literal\" && typeof node.value === \"boolean\";\n    }\n\n    function invertExpression(node) {\n      if (node.type === \"BinaryExpression\" && Object.prototype.hasOwnProperty.call(OPERATOR_INVERSES, node.operator)) {\n        const operatorToken = sourceCode.getFirstTokenBetween(node.left, node.right, token => token.value === node.operator);\n        const text = sourceCode.getText();\n        return text.slice(node.range[0], operatorToken.range[0]) + OPERATOR_INVERSES[node.operator] + text.slice(operatorToken.range[1], node.range[1]);\n      }\n\n      if (astUtils.getPrecedence(node) < astUtils.getPrecedence({\n        type: \"UnaryExpression\"\n      })) {\n        return `!(${astUtils.getParenthesisedText(sourceCode, node)})`;\n      }\n\n      return `!${astUtils.getParenthesisedText(sourceCode, node)}`;\n    }\n\n    function isBooleanExpression(node) {\n      return node.type === \"BinaryExpression\" && BOOLEAN_OPERATORS.has(node.operator) || node.type === \"UnaryExpression\" && node.operator === \"!\";\n    }\n\n    function matchesDefaultAssignment(node) {\n      return node.test.type === \"Identifier\" && node.consequent.type === \"Identifier\" && node.test.name === node.consequent.name;\n    }\n\n    return {\n      ConditionalExpression(node) {\n        if (isBooleanLiteral(node.alternate) && isBooleanLiteral(node.consequent)) {\n          context.report({\n            node,\n            messageId: \"unnecessaryConditionalExpression\",\n\n            fix(fixer) {\n              if (node.consequent.value === node.alternate.value) {\n                return node.test.type === \"Identifier\" ? fixer.replaceText(node, node.consequent.value.toString()) : null;\n              }\n\n              if (node.alternate.value) {\n                return fixer.replaceText(node, invertExpression(node.test));\n              }\n\n              return fixer.replaceText(node, isBooleanExpression(node.test) ? astUtils.getParenthesisedText(sourceCode, node.test) : `!${invertExpression(node.test)}`);\n            }\n\n          });\n        } else if (!defaultAssignment && matchesDefaultAssignment(node)) {\n          context.report({\n            node,\n            messageId: \"unnecessaryConditionalAssignment\",\n            fix: fixer => {\n              const shouldParenthesizeAlternate = (astUtils.getPrecedence(node.alternate) < OR_PRECEDENCE || astUtils.isCoalesceExpression(node.alternate)) && !astUtils.isParenthesised(sourceCode, node.alternate);\n              const alternateText = shouldParenthesizeAlternate ? `(${sourceCode.getText(node.alternate)})` : astUtils.getParenthesisedText(sourceCode, node.alternate);\n              const testText = astUtils.getParenthesisedText(sourceCode, node.test);\n              return fixer.replaceText(node, `${testText} || ${alternateText}`);\n            }\n          });\n        }\n      }\n\n    };\n  }\n\n};\nnoUnneededTernary.meta;\nnoUnneededTernary.create;\nconst allLoopTypes = [\"WhileStatement\", \"DoWhileStatement\", \"ForStatement\", \"ForInStatement\", \"ForOfStatement\"];\n\nfunction isLoopingTarget(node) {\n  const parent = node.parent;\n\n  if (parent) {\n    switch (parent.type) {\n      case \"WhileStatement\":\n        return node === parent.test;\n\n      case \"DoWhileStatement\":\n        return node === parent.body;\n\n      case \"ForStatement\":\n        return node === (parent.update || parent.test || parent.body);\n\n      case \"ForInStatement\":\n      case \"ForOfStatement\":\n        return node === parent.left;\n    }\n  }\n\n  return false;\n}\n\nfunction getDifference(arrA, arrB) {\n  return arrA.filter(a => !arrB.includes(a));\n}\n\nvar noUnreachableLoop = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"disallow loops with a body that allows only one iteration\",\n      category: \"Possible Errors\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-unreachable-loop\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        ignore: {\n          type: \"array\",\n          items: {\n            enum: allLoopTypes\n          },\n          uniqueItems: true\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      invalid: \"Invalid loop. Its body allows only one iteration.\"\n    }\n  },\n\n  create(context) {\n    const ignoredLoopTypes = context.options[0] && context.options[0].ignore || [],\n          loopTypesToCheck = getDifference(allLoopTypes, ignoredLoopTypes),\n          loopSelector = loopTypesToCheck.join(\",\"),\n          loopsByTargetSegments = new Map(),\n          loopsToReport = new Set();\n    let currentCodePath = null;\n    return {\n      onCodePathStart(codePath) {\n        currentCodePath = codePath;\n      },\n\n      onCodePathEnd() {\n        currentCodePath = currentCodePath.upper;\n      },\n\n      [loopSelector](node) {\n        if (currentCodePath.currentSegments.some(segment => segment.reachable)) {\n          loopsToReport.add(node);\n        }\n      },\n\n      onCodePathSegmentStart(segment, node) {\n        if (isLoopingTarget(node)) {\n          const loop = node.parent;\n          loopsByTargetSegments.set(segment, loop);\n        }\n      },\n\n      onCodePathSegmentLoop(_, toSegment, node) {\n        const loop = loopsByTargetSegments.get(toSegment);\n\n        if (node === loop || node.type === \"ContinueStatement\") {\n          loopsToReport.delete(loop);\n        }\n      },\n\n      \"Program:exit\"() {\n        loopsToReport.forEach(node => context.report({\n          node,\n          messageId: \"invalid\"\n        }));\n      }\n\n    };\n  }\n\n};\nnoUnreachableLoop.meta;\nnoUnreachableLoop.create;\n\nfunction isInitialized(node) {\n  return Boolean(node.init);\n}\n\nfunction isUnreachable(segment) {\n  return !segment.reachable;\n}\n\nclass ConsecutiveRange {\n  constructor(sourceCode) {\n    this.sourceCode = sourceCode;\n    this.startNode = null;\n    this.endNode = null;\n  }\n\n  get location() {\n    return {\n      start: this.startNode.loc.start,\n      end: this.endNode.loc.end\n    };\n  }\n\n  get isEmpty() {\n    return !(this.startNode && this.endNode);\n  }\n\n  contains(node) {\n    return node.range[0] >= this.startNode.range[0] && node.range[1] <= this.endNode.range[1];\n  }\n\n  isConsecutive(node) {\n    return this.contains(this.sourceCode.getTokenBefore(node));\n  }\n\n  merge(node) {\n    this.endNode = node;\n  }\n\n  reset(node) {\n    this.startNode = this.endNode = node;\n  }\n\n}\n\nvar noUnreachable = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"disallow unreachable code after `return`, `throw`, `continue`, and `break` statements\",\n      category: \"Possible Errors\",\n      recommended: true,\n      url: \"https://eslint.org/docs/rules/no-unreachable\"\n    },\n    schema: [],\n    messages: {\n      unreachableCode: \"Unreachable code.\"\n    }\n  },\n\n  create(context) {\n    let currentCodePath = null;\n    const range = new ConsecutiveRange(context.getSourceCode());\n\n    function reportIfUnreachable(node) {\n      let nextNode = null;\n\n      if (node && currentCodePath.currentSegments.every(isUnreachable)) {\n        if (range.isEmpty) {\n          range.reset(node);\n          return;\n        }\n\n        if (range.contains(node)) {\n          return;\n        }\n\n        if (range.isConsecutive(node)) {\n          range.merge(node);\n          return;\n        }\n\n        nextNode = node;\n      }\n\n      if (!range.isEmpty) {\n        context.report({\n          messageId: \"unreachableCode\",\n          loc: range.location,\n          node: range.startNode\n        });\n      }\n\n      range.reset(nextNode);\n    }\n\n    return {\n      onCodePathStart(codePath) {\n        currentCodePath = codePath;\n      },\n\n      onCodePathEnd() {\n        currentCodePath = currentCodePath.upper;\n      },\n\n      BlockStatement: reportIfUnreachable,\n      BreakStatement: reportIfUnreachable,\n      ClassDeclaration: reportIfUnreachable,\n      ContinueStatement: reportIfUnreachable,\n      DebuggerStatement: reportIfUnreachable,\n      DoWhileStatement: reportIfUnreachable,\n      ExpressionStatement: reportIfUnreachable,\n      ForInStatement: reportIfUnreachable,\n      ForOfStatement: reportIfUnreachable,\n      ForStatement: reportIfUnreachable,\n      IfStatement: reportIfUnreachable,\n      ImportDeclaration: reportIfUnreachable,\n      LabeledStatement: reportIfUnreachable,\n      ReturnStatement: reportIfUnreachable,\n      SwitchStatement: reportIfUnreachable,\n      ThrowStatement: reportIfUnreachable,\n      TryStatement: reportIfUnreachable,\n\n      VariableDeclaration(node) {\n        if (node.kind !== \"var\" || node.declarations.some(isInitialized)) {\n          reportIfUnreachable(node);\n        }\n      },\n\n      WhileStatement: reportIfUnreachable,\n      WithStatement: reportIfUnreachable,\n      ExportNamedDeclaration: reportIfUnreachable,\n      ExportDefaultDeclaration: reportIfUnreachable,\n      ExportAllDeclaration: reportIfUnreachable,\n\n      \"Program:exit\"() {\n        reportIfUnreachable();\n      }\n\n    };\n  }\n\n};\nnoUnreachable.meta;\nnoUnreachable.create;\nconst SENTINEL_NODE_TYPE_RETURN_THROW = /^(?:Program|(?:Function|Class)(?:Declaration|Expression)|ArrowFunctionExpression)$/u;\nconst SENTINEL_NODE_TYPE_BREAK = /^(?:Program|(?:Function|Class)(?:Declaration|Expression)|ArrowFunctionExpression|DoWhileStatement|WhileStatement|ForOfStatement|ForInStatement|ForStatement|SwitchStatement)$/u;\nconst SENTINEL_NODE_TYPE_CONTINUE = /^(?:Program|(?:Function|Class)(?:Declaration|Expression)|ArrowFunctionExpression|DoWhileStatement|WhileStatement|ForOfStatement|ForInStatement|ForStatement)$/u;\nvar noUnsafeFinally = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"disallow control flow statements in `finally` blocks\",\n      category: \"Possible Errors\",\n      recommended: true,\n      url: \"https://eslint.org/docs/rules/no-unsafe-finally\"\n    },\n    schema: [],\n    messages: {\n      unsafeUsage: \"Unsafe usage of {{nodeType}}.\"\n    }\n  },\n\n  create(context) {\n    function isFinallyBlock(node) {\n      return node.parent.type === \"TryStatement\" && node.parent.finalizer === node;\n    }\n\n    function isInFinallyBlock(node, label) {\n      let labelInside = false;\n      let sentinelNodeType;\n\n      if (node.type === \"BreakStatement\" && !node.label) {\n        sentinelNodeType = SENTINEL_NODE_TYPE_BREAK;\n      } else if (node.type === \"ContinueStatement\") {\n        sentinelNodeType = SENTINEL_NODE_TYPE_CONTINUE;\n      } else {\n        sentinelNodeType = SENTINEL_NODE_TYPE_RETURN_THROW;\n      }\n\n      for (let currentNode = node; currentNode && !sentinelNodeType.test(currentNode.type); currentNode = currentNode.parent) {\n        if (currentNode.parent.label && label && currentNode.parent.label.name === label.name) {\n          labelInside = true;\n        }\n\n        if (isFinallyBlock(currentNode)) {\n          if (label && labelInside) {\n            return false;\n          }\n\n          return true;\n        }\n      }\n\n      return false;\n    }\n\n    function check(node) {\n      if (isInFinallyBlock(node, node.label)) {\n        context.report({\n          messageId: \"unsafeUsage\",\n          data: {\n            nodeType: node.type\n          },\n          node,\n          line: node.loc.line,\n          column: node.loc.column\n        });\n      }\n    }\n\n    return {\n      ReturnStatement: check,\n      ThrowStatement: check,\n      BreakStatement: check,\n      ContinueStatement: check\n    };\n  }\n\n};\nnoUnsafeFinally.meta;\nnoUnsafeFinally.create;\n\nfunction isInOrInstanceOfOperator(op) {\n  return op === \"in\" || op === \"instanceof\";\n}\n\nfunction isOrderingRelationalOperator(op) {\n  return op === \"<\" || op === \">\" || op === \">=\" || op === \"<=\";\n}\n\nfunction isNegation(node) {\n  return node.type === \"UnaryExpression\" && node.operator === \"!\";\n}\n\nvar noUnsafeNegation = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"disallow negating the left operand of relational operators\",\n      category: \"Possible Errors\",\n      recommended: true,\n      url: \"https://eslint.org/docs/rules/no-unsafe-negation\",\n      suggestion: true\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        enforceForOrderingRelations: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    fixable: null,\n    messages: {\n      unexpected: \"Unexpected negating the left operand of '{{operator}}' operator.\",\n      suggestNegatedExpression: \"Negate '{{operator}}' expression instead of its left operand. This changes the current behavior.\",\n      suggestParenthesisedNegation: \"Wrap negation in '()' to make the intention explicit. This preserves the current behavior.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    const options = context.options[0] || {};\n    const enforceForOrderingRelations = options.enforceForOrderingRelations === true;\n    return {\n      BinaryExpression(node) {\n        const operator = node.operator;\n        const orderingRelationRuleApplies = enforceForOrderingRelations && isOrderingRelationalOperator(operator);\n\n        if ((isInOrInstanceOfOperator(operator) || orderingRelationRuleApplies) && isNegation(node.left) && !astUtils.isParenthesised(sourceCode, node.left)) {\n          context.report({\n            node,\n            loc: node.left.loc,\n            messageId: \"unexpected\",\n            data: {\n              operator\n            },\n            suggest: [{\n              messageId: \"suggestNegatedExpression\",\n              data: {\n                operator\n              },\n\n              fix(fixer) {\n                const negationToken = sourceCode.getFirstToken(node.left);\n                const fixRange = [negationToken.range[1], node.range[1]];\n                const text = sourceCode.text.slice(fixRange[0], fixRange[1]);\n                return fixer.replaceTextRange(fixRange, `(${text})`);\n              }\n\n            }, {\n              messageId: \"suggestParenthesisedNegation\",\n\n              fix(fixer) {\n                return fixer.replaceText(node.left, `(${sourceCode.getText(node.left)})`);\n              }\n\n            }]\n          });\n        }\n      }\n\n    };\n  }\n\n};\nnoUnsafeNegation.meta;\nnoUnsafeNegation.create;\nconst UNSAFE_ARITHMETIC_OPERATORS = new Set([\"+\", \"-\", \"/\", \"*\", \"%\", \"**\"]);\nconst UNSAFE_ASSIGNMENT_OPERATORS = new Set([\"+=\", \"-=\", \"/=\", \"*=\", \"%=\", \"**=\"]);\nconst UNSAFE_RELATIONAL_OPERATORS = new Set([\"in\", \"instanceof\"]);\n\nfunction isDestructuringPattern(node) {\n  return node.type === \"ObjectPattern\" || node.type === \"ArrayPattern\";\n}\n\nvar noUnsafeOptionalChaining = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"disallow use of optional chaining in contexts where the `undefined` value is not allowed\",\n      category: \"Possible Errors\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-unsafe-optional-chaining\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        disallowArithmeticOperators: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    fixable: null,\n    messages: {\n      unsafeOptionalChain: \"Unsafe usage of optional chaining. If it short-circuits with 'undefined' the evaluation will throw TypeError.\",\n      unsafeArithmetic: \"Unsafe arithmetic operation on optional chaining. It can result in NaN.\"\n    }\n  },\n\n  create(context) {\n    const options = context.options[0] || {};\n    const disallowArithmeticOperators = options.disallowArithmeticOperators || false;\n\n    function reportUnsafeUsage(node) {\n      context.report({\n        messageId: \"unsafeOptionalChain\",\n        node\n      });\n    }\n\n    function reportUnsafeArithmetic(node) {\n      context.report({\n        messageId: \"unsafeArithmetic\",\n        node\n      });\n    }\n\n    function checkUndefinedShortCircuit(node, reportFunc) {\n      if (!node) {\n        return;\n      }\n\n      switch (node.type) {\n        case \"LogicalExpression\":\n          if (node.operator === \"||\" || node.operator === \"??\") {\n            checkUndefinedShortCircuit(node.right, reportFunc);\n          } else if (node.operator === \"&&\") {\n            checkUndefinedShortCircuit(node.left, reportFunc);\n            checkUndefinedShortCircuit(node.right, reportFunc);\n          }\n\n          break;\n\n        case \"SequenceExpression\":\n          checkUndefinedShortCircuit(node.expressions[node.expressions.length - 1], reportFunc);\n          break;\n\n        case \"ConditionalExpression\":\n          checkUndefinedShortCircuit(node.consequent, reportFunc);\n          checkUndefinedShortCircuit(node.alternate, reportFunc);\n          break;\n\n        case \"AwaitExpression\":\n          checkUndefinedShortCircuit(node.argument, reportFunc);\n          break;\n\n        case \"ChainExpression\":\n          reportFunc(node);\n          break;\n      }\n    }\n\n    function checkUnsafeUsage(node) {\n      checkUndefinedShortCircuit(node, reportUnsafeUsage);\n    }\n\n    function checkUnsafeArithmetic(node) {\n      checkUndefinedShortCircuit(node, reportUnsafeArithmetic);\n    }\n\n    return {\n      \"AssignmentExpression, AssignmentPattern\"(node) {\n        if (isDestructuringPattern(node.left)) {\n          checkUnsafeUsage(node.right);\n        }\n      },\n\n      \"ClassDeclaration, ClassExpression\"(node) {\n        checkUnsafeUsage(node.superClass);\n      },\n\n      CallExpression(node) {\n        if (!node.optional) {\n          checkUnsafeUsage(node.callee);\n        }\n      },\n\n      NewExpression(node) {\n        checkUnsafeUsage(node.callee);\n      },\n\n      VariableDeclarator(node) {\n        if (isDestructuringPattern(node.id)) {\n          checkUnsafeUsage(node.init);\n        }\n      },\n\n      MemberExpression(node) {\n        if (!node.optional) {\n          checkUnsafeUsage(node.object);\n        }\n      },\n\n      TaggedTemplateExpression(node) {\n        checkUnsafeUsage(node.tag);\n      },\n\n      ForOfStatement(node) {\n        checkUnsafeUsage(node.right);\n      },\n\n      SpreadElement(node) {\n        if (node.parent && node.parent.type !== \"ObjectExpression\") {\n          checkUnsafeUsage(node.argument);\n        }\n      },\n\n      BinaryExpression(node) {\n        if (UNSAFE_RELATIONAL_OPERATORS.has(node.operator)) {\n          checkUnsafeUsage(node.right);\n        }\n\n        if (disallowArithmeticOperators && UNSAFE_ARITHMETIC_OPERATORS.has(node.operator)) {\n          checkUnsafeArithmetic(node.right);\n          checkUnsafeArithmetic(node.left);\n        }\n      },\n\n      WithStatement(node) {\n        checkUnsafeUsage(node.object);\n      },\n\n      UnaryExpression(node) {\n        if (disallowArithmeticOperators && UNSAFE_ARITHMETIC_OPERATORS.has(node.operator)) {\n          checkUnsafeArithmetic(node.argument);\n        }\n      },\n\n      AssignmentExpression(node) {\n        if (disallowArithmeticOperators && UNSAFE_ASSIGNMENT_OPERATORS.has(node.operator)) {\n          checkUnsafeArithmetic(node.right);\n        }\n      }\n\n    };\n  }\n\n};\nnoUnsafeOptionalChaining.meta;\nnoUnsafeOptionalChaining.create;\n\nfunction alwaysTrue() {\n  return true;\n}\n\nfunction alwaysFalse() {\n  return false;\n}\n\nvar noUnusedExpressions = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow unused expressions\",\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-unused-expressions\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        allowShortCircuit: {\n          type: \"boolean\",\n          default: false\n        },\n        allowTernary: {\n          type: \"boolean\",\n          default: false\n        },\n        allowTaggedTemplates: {\n          type: \"boolean\",\n          default: false\n        },\n        enforceForJSX: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      unusedExpression: \"Expected an assignment or function call and instead saw an expression.\"\n    }\n  },\n\n  create(context) {\n    const config = context.options[0] || {},\n          allowShortCircuit = config.allowShortCircuit || false,\n          allowTernary = config.allowTernary || false,\n          allowTaggedTemplates = config.allowTaggedTemplates || false,\n          enforceForJSX = config.enforceForJSX || false;\n\n    function looksLikeDirective(node) {\n      return node.type === \"ExpressionStatement\" && node.expression.type === \"Literal\" && typeof node.expression.value === \"string\";\n    }\n\n    function takeWhile(predicate, list) {\n      for (let i = 0; i < list.length; ++i) {\n        if (!predicate(list[i])) {\n          return list.slice(0, i);\n        }\n      }\n\n      return list.slice();\n    }\n\n    function directives(node) {\n      return takeWhile(looksLikeDirective, node.body);\n    }\n\n    function isDirective(node, ancestors) {\n      const parent = ancestors[ancestors.length - 1],\n            grandparent = ancestors[ancestors.length - 2];\n      return (parent.type === \"Program\" || parent.type === \"BlockStatement\" && /Function/u.test(grandparent.type)) && directives(parent).indexOf(node) >= 0;\n    }\n\n    const Checker = Object.assign(Object.create(null), {\n      isDisallowed(node) {\n        return (Checker[node.type] || alwaysFalse)(node);\n      },\n\n      ArrayExpression: alwaysTrue,\n      ArrowFunctionExpression: alwaysTrue,\n      BinaryExpression: alwaysTrue,\n\n      ChainExpression(node) {\n        return Checker.isDisallowed(node.expression);\n      },\n\n      ClassExpression: alwaysTrue,\n\n      ConditionalExpression(node) {\n        if (allowTernary) {\n          return Checker.isDisallowed(node.consequent) || Checker.isDisallowed(node.alternate);\n        }\n\n        return true;\n      },\n\n      FunctionExpression: alwaysTrue,\n      Identifier: alwaysTrue,\n\n      JSXElement() {\n        return enforceForJSX;\n      },\n\n      JSXFragment() {\n        return enforceForJSX;\n      },\n\n      Literal: alwaysTrue,\n\n      LogicalExpression(node) {\n        if (allowShortCircuit) {\n          return Checker.isDisallowed(node.right);\n        }\n\n        return true;\n      },\n\n      MemberExpression: alwaysTrue,\n      MetaProperty: alwaysTrue,\n      ObjectExpression: alwaysTrue,\n      SequenceExpression: alwaysTrue,\n\n      TaggedTemplateExpression() {\n        return !allowTaggedTemplates;\n      },\n\n      TemplateLiteral: alwaysTrue,\n      ThisExpression: alwaysTrue,\n\n      UnaryExpression(node) {\n        return node.operator !== \"void\" && node.operator !== \"delete\";\n      }\n\n    });\n    return {\n      ExpressionStatement(node) {\n        if (Checker.isDisallowed(node.expression) && !isDirective(node, context.getAncestors())) {\n          context.report({\n            node,\n            messageId: \"unusedExpression\"\n          });\n        }\n      }\n\n    };\n  }\n\n};\nnoUnusedExpressions.meta;\nnoUnusedExpressions.create;\nvar noUnusedLabels = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow unused labels\",\n      category: \"Best Practices\",\n      recommended: true,\n      url: \"https://eslint.org/docs/rules/no-unused-labels\"\n    },\n    schema: [],\n    fixable: \"code\",\n    messages: {\n      unused: \"'{{name}}:' is defined but never used.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    let scopeInfo = null;\n\n    function enterLabeledScope(node) {\n      scopeInfo = {\n        label: node.label.name,\n        used: false,\n        upper: scopeInfo\n      };\n    }\n\n    function exitLabeledScope(node) {\n      if (!scopeInfo.used) {\n        context.report({\n          node: node.label,\n          messageId: \"unused\",\n          data: node.label,\n\n          fix(fixer) {\n            if (sourceCode.getTokenAfter(node.label, {\n              includeComments: true\n            }) === sourceCode.getTokenBefore(node.body, {\n              includeComments: true\n            })) {\n              return fixer.removeRange([node.range[0], node.body.range[0]]);\n            }\n\n            return null;\n          }\n\n        });\n      }\n\n      scopeInfo = scopeInfo.upper;\n    }\n\n    function markAsUsed(node) {\n      if (!node.label) {\n        return;\n      }\n\n      const label = node.label.name;\n      let info = scopeInfo;\n\n      while (info) {\n        if (info.label === label) {\n          info.used = true;\n          break;\n        }\n\n        info = info.upper;\n      }\n    }\n\n    return {\n      LabeledStatement: enterLabeledScope,\n      \"LabeledStatement:exit\": exitLabeledScope,\n      BreakStatement: markAsUsed,\n      ContinueStatement: markAsUsed\n    };\n  }\n\n};\nnoUnusedLabels.meta;\nnoUnusedLabels.create;\nvar noUnusedVars = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"disallow unused variables\",\n      category: \"Variables\",\n      recommended: true,\n      url: \"https://eslint.org/docs/rules/no-unused-vars\"\n    },\n    schema: [{\n      oneOf: [{\n        enum: [\"all\", \"local\"]\n      }, {\n        type: \"object\",\n        properties: {\n          vars: {\n            enum: [\"all\", \"local\"]\n          },\n          varsIgnorePattern: {\n            type: \"string\"\n          },\n          args: {\n            enum: [\"all\", \"after-used\", \"none\"]\n          },\n          ignoreRestSiblings: {\n            type: \"boolean\"\n          },\n          argsIgnorePattern: {\n            type: \"string\"\n          },\n          caughtErrors: {\n            enum: [\"all\", \"none\"]\n          },\n          caughtErrorsIgnorePattern: {\n            type: \"string\"\n          }\n        },\n        additionalProperties: false\n      }]\n    }],\n    messages: {\n      unusedVar: \"'{{varName}}' is {{action}} but never used{{additional}}.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    const config = {\n      vars: \"all\",\n      args: \"after-used\",\n      ignoreRestSiblings: false,\n      caughtErrors: \"none\"\n    };\n    const firstOption = context.options[0];\n\n    if (firstOption) {\n      if (typeof firstOption === \"string\") {\n        config.vars = firstOption;\n      } else {\n        config.vars = firstOption.vars || config.vars;\n        config.args = firstOption.args || config.args;\n        config.ignoreRestSiblings = firstOption.ignoreRestSiblings || config.ignoreRestSiblings;\n        config.caughtErrors = firstOption.caughtErrors || config.caughtErrors;\n\n        if (firstOption.varsIgnorePattern) {\n          config.varsIgnorePattern = new RegExp(firstOption.varsIgnorePattern, \"u\");\n        }\n\n        if (firstOption.argsIgnorePattern) {\n          config.argsIgnorePattern = new RegExp(firstOption.argsIgnorePattern, \"u\");\n        }\n\n        if (firstOption.caughtErrorsIgnorePattern) {\n          config.caughtErrorsIgnorePattern = new RegExp(firstOption.caughtErrorsIgnorePattern, \"u\");\n        }\n      }\n    }\n\n    function getDefinedMessageData(unusedVar) {\n      const defType = unusedVar.defs && unusedVar.defs[0] && unusedVar.defs[0].type;\n      let type;\n      let pattern;\n\n      if (defType === \"CatchClause\" && config.caughtErrorsIgnorePattern) {\n        type = \"args\";\n        pattern = config.caughtErrorsIgnorePattern.toString();\n      } else if (defType === \"Parameter\" && config.argsIgnorePattern) {\n        type = \"args\";\n        pattern = config.argsIgnorePattern.toString();\n      } else if (defType !== \"Parameter\" && config.varsIgnorePattern) {\n        type = \"vars\";\n        pattern = config.varsIgnorePattern.toString();\n      }\n\n      const additional = type ? `. Allowed unused ${type} must match ${pattern}` : \"\";\n      return {\n        varName: unusedVar.name,\n        action: \"defined\",\n        additional\n      };\n    }\n\n    function getAssignedMessageData(unusedVar) {\n      const additional = config.varsIgnorePattern ? `. Allowed unused vars must match ${config.varsIgnorePattern.toString()}` : \"\";\n      return {\n        varName: unusedVar.name,\n        action: \"assigned a value\",\n        additional\n      };\n    }\n\n    function isExported(variable) {\n      const definition = variable.defs[0];\n\n      if (definition) {\n        let node = definition.node;\n\n        if (node.type === \"VariableDeclarator\") {\n          node = node.parent;\n        } else if (definition.type === \"Parameter\") {\n          return false;\n        }\n\n        return node.parent.type.indexOf(\"Export\") === 0;\n      }\n\n      return false;\n    }\n\n    function hasRestSibling(node) {\n      return node.type === \"Property\" && node.parent.type === \"ObjectPattern\" && /^(?:RestElement|(?:Experimental)?RestProperty)$/u.test(node.parent.properties[node.parent.properties.length - 1].type);\n    }\n\n    function hasRestSpreadSibling(variable) {\n      if (config.ignoreRestSiblings) {\n        const hasRestSiblingDefinition = variable.defs.some(def => hasRestSibling(def.name.parent));\n        const hasRestSiblingReference = variable.references.some(ref => hasRestSibling(ref.identifier.parent));\n        return hasRestSiblingDefinition || hasRestSiblingReference;\n      }\n\n      return false;\n    }\n\n    function isReadRef(ref) {\n      return ref.isRead();\n    }\n\n    function isSelfReference(ref, nodes) {\n      let scope = ref.from;\n\n      while (scope) {\n        if (nodes.indexOf(scope.block) >= 0) {\n          return true;\n        }\n\n        scope = scope.upper;\n      }\n\n      return false;\n    }\n\n    function getFunctionDefinitions(variable) {\n      const functionDefinitions = [];\n      variable.defs.forEach(def => {\n        const {\n          type,\n          node\n        } = def;\n\n        if (type === \"FunctionName\") {\n          functionDefinitions.push(node);\n        }\n\n        if (type === \"Variable\" && node.init && (node.init.type === \"FunctionExpression\" || node.init.type === \"ArrowFunctionExpression\")) {\n          functionDefinitions.push(node.init);\n        }\n      });\n      return functionDefinitions;\n    }\n\n    function isInside(inner, outer) {\n      return inner.range[0] >= outer.range[0] && inner.range[1] <= outer.range[1];\n    }\n\n    function getRhsNode(ref, prevRhsNode) {\n      const id = ref.identifier;\n      const parent = id.parent;\n      const grandparent = parent.parent;\n      const refScope = ref.from.variableScope;\n      const varScope = ref.resolved.scope.variableScope;\n      const canBeUsedLater = refScope !== varScope || astUtils.isInLoop(id);\n\n      if (prevRhsNode && isInside(id, prevRhsNode)) {\n        return prevRhsNode;\n      }\n\n      if (parent.type === \"AssignmentExpression\" && grandparent.type === \"ExpressionStatement\" && id === parent.left && !canBeUsedLater) {\n        return parent.right;\n      }\n\n      return null;\n    }\n\n    function isStorableFunction(funcNode, rhsNode) {\n      let node = funcNode;\n      let parent = funcNode.parent;\n\n      while (parent && isInside(parent, rhsNode)) {\n        switch (parent.type) {\n          case \"SequenceExpression\":\n            if (parent.expressions[parent.expressions.length - 1] !== node) {\n              return false;\n            }\n\n            break;\n\n          case \"CallExpression\":\n          case \"NewExpression\":\n            return parent.callee !== node;\n\n          case \"AssignmentExpression\":\n          case \"TaggedTemplateExpression\":\n          case \"YieldExpression\":\n            return true;\n\n          default:\n            if (/(?:Statement|Declaration)$/u.test(parent.type)) {\n              return true;\n            }\n\n        }\n\n        node = parent;\n        parent = parent.parent;\n      }\n\n      return false;\n    }\n\n    function isInsideOfStorableFunction(id, rhsNode) {\n      const funcNode = astUtils.getUpperFunction(id);\n      return funcNode && isInside(funcNode, rhsNode) && isStorableFunction(funcNode, rhsNode);\n    }\n\n    function isUnusedExpression(node) {\n      const parent = node.parent;\n\n      if (parent.type === \"ExpressionStatement\") {\n        return true;\n      }\n\n      if (parent.type === \"SequenceExpression\") {\n        const isLastExpression = parent.expressions[parent.expressions.length - 1] === node;\n\n        if (!isLastExpression) {\n          return true;\n        }\n\n        return isUnusedExpression(parent);\n      }\n\n      return false;\n    }\n\n    function isReadForItself(ref, rhsNode) {\n      const id = ref.identifier;\n      const parent = id.parent;\n      return ref.isRead() && (parent.type === \"AssignmentExpression\" && parent.left === id && isUnusedExpression(parent) || parent.type === \"UpdateExpression\" && isUnusedExpression(parent) || rhsNode && isInside(id, rhsNode) && !isInsideOfStorableFunction(id, rhsNode));\n    }\n\n    function isForInRef(ref) {\n      let target = ref.identifier.parent;\n\n      if (target.type === \"VariableDeclarator\") {\n        target = target.parent.parent;\n      }\n\n      if (target.type !== \"ForInStatement\") {\n        return false;\n      }\n\n      if (target.body.type === \"BlockStatement\") {\n        target = target.body.body[0];\n      } else {\n        target = target.body;\n      }\n\n      if (!target) {\n        return false;\n      }\n\n      return target.type === \"ReturnStatement\";\n    }\n\n    function isUsedVariable(variable) {\n      const functionNodes = getFunctionDefinitions(variable),\n            isFunctionDefinition = functionNodes.length > 0;\n      let rhsNode = null;\n      return variable.references.some(ref => {\n        if (isForInRef(ref)) {\n          return true;\n        }\n\n        const forItself = isReadForItself(ref, rhsNode);\n        rhsNode = getRhsNode(ref, rhsNode);\n        return isReadRef(ref) && !forItself && !(isFunctionDefinition && isSelfReference(ref, functionNodes));\n      });\n    }\n\n    function isAfterLastUsedArg(variable) {\n      const def = variable.defs[0];\n      const params = context.getDeclaredVariables(def.node);\n      const posteriorParams = params.slice(params.indexOf(variable) + 1);\n      return !posteriorParams.some(v => v.references.length > 0 || v.eslintUsed);\n    }\n\n    function collectUnusedVariables(scope, unusedVars) {\n      const variables = scope.variables;\n      const childScopes = scope.childScopes;\n      let i, l;\n\n      if (scope.type !== \"global\" || config.vars === \"all\") {\n        for (i = 0, l = variables.length; i < l; ++i) {\n          const variable = variables[i];\n\n          if (scope.type === \"class\" && scope.block.id === variable.identifiers[0]) {\n            continue;\n          }\n\n          if (scope.functionExpressionScope || variable.eslintUsed) {\n            continue;\n          }\n\n          if (scope.type === \"function\" && variable.name === \"arguments\" && variable.identifiers.length === 0) {\n            continue;\n          }\n\n          const def = variable.defs[0];\n\n          if (def) {\n            const type = def.type;\n\n            if (type === \"CatchClause\") {\n              if (config.caughtErrors === \"none\") {\n                continue;\n              }\n\n              if (config.caughtErrorsIgnorePattern && config.caughtErrorsIgnorePattern.test(def.name.name)) {\n                continue;\n              }\n            }\n\n            if (type === \"Parameter\") {\n              if ((def.node.parent.type === \"Property\" || def.node.parent.type === \"MethodDefinition\") && def.node.parent.kind === \"set\") {\n                continue;\n              }\n\n              if (config.args === \"none\") {\n                continue;\n              }\n\n              if (config.argsIgnorePattern && config.argsIgnorePattern.test(def.name.name)) {\n                continue;\n              }\n\n              if (config.args === \"after-used\" && astUtils.isFunction(def.name.parent) && !isAfterLastUsedArg(variable)) {\n                continue;\n              }\n            } else {\n              if (config.varsIgnorePattern && config.varsIgnorePattern.test(def.name.name)) {\n                continue;\n              }\n            }\n          }\n\n          if (!isUsedVariable(variable) && !isExported(variable) && !hasRestSpreadSibling(variable)) {\n            unusedVars.push(variable);\n          }\n        }\n      }\n\n      for (i = 0, l = childScopes.length; i < l; ++i) {\n        collectUnusedVariables(childScopes[i], unusedVars);\n      }\n\n      return unusedVars;\n    }\n\n    return {\n      \"Program:exit\"(programNode) {\n        const unusedVars = collectUnusedVariables(context.getScope(), []);\n\n        for (let i = 0, l = unusedVars.length; i < l; ++i) {\n          const unusedVar = unusedVars[i];\n\n          if (unusedVar.defs.length > 0) {\n            const writeReferences = unusedVar.references.filter(ref => ref.isWrite() && ref.from.variableScope === unusedVar.scope.variableScope);\n            let referenceToReport;\n\n            if (writeReferences.length > 0) {\n              referenceToReport = writeReferences[writeReferences.length - 1];\n            }\n\n            context.report({\n              node: referenceToReport ? referenceToReport.identifier : unusedVar.identifiers[0],\n              messageId: \"unusedVar\",\n              data: unusedVar.references.some(ref => ref.isWrite()) ? getAssignedMessageData(unusedVar) : getDefinedMessageData(unusedVar)\n            });\n          } else if (unusedVar.eslintExplicitGlobalComments) {\n            const directiveComment = unusedVar.eslintExplicitGlobalComments[0];\n            context.report({\n              node: programNode,\n              loc: astUtils.getNameLocationInGlobalDirectiveComment(sourceCode, directiveComment, unusedVar.name),\n              messageId: \"unusedVar\",\n              data: getDefinedMessageData(unusedVar)\n            });\n          }\n        }\n      }\n\n    };\n  }\n\n};\nnoUnusedVars.meta;\nnoUnusedVars.create;\nconst SENTINEL_TYPE = /^(?:(?:Function|Class)(?:Declaration|Expression)|ArrowFunctionExpression|CatchClause|ImportDeclaration|ExportNamedDeclaration)$/u;\nconst FOR_IN_OF_TYPE = /^For(?:In|Of)Statement$/u;\n\nfunction parseOptions(options) {\n  let functions = true;\n  let classes = true;\n  let variables = true;\n\n  if (typeof options === \"string\") {\n    functions = options !== \"nofunc\";\n  } else if (typeof options === \"object\" && options !== null) {\n    functions = options.functions !== false;\n    classes = options.classes !== false;\n    variables = options.variables !== false;\n  }\n\n  return {\n    functions,\n    classes,\n    variables\n  };\n}\n\nfunction isFunction(variable) {\n  return variable.defs[0].type === \"FunctionName\";\n}\n\nfunction isOuterClass(variable, reference) {\n  return variable.defs[0].type === \"ClassName\" && variable.scope.variableScope !== reference.from.variableScope;\n}\n\nfunction isOuterVariable(variable, reference) {\n  return variable.defs[0].type === \"Variable\" && variable.scope.variableScope !== reference.from.variableScope;\n}\n\nfunction isInRange(node, location) {\n  return node && node.range[0] <= location && location <= node.range[1];\n}\n\nfunction isInInitializer(variable, reference) {\n  if (variable.scope !== reference.from) {\n    return false;\n  }\n\n  let node = variable.identifiers[0].parent;\n  const location = reference.identifier.range[1];\n\n  while (node) {\n    if (node.type === \"VariableDeclarator\") {\n      if (isInRange(node.init, location)) {\n        return true;\n      }\n\n      if (FOR_IN_OF_TYPE.test(node.parent.parent.type) && isInRange(node.parent.parent.right, location)) {\n        return true;\n      }\n\n      break;\n    } else if (node.type === \"AssignmentPattern\") {\n      if (isInRange(node.right, location)) {\n        return true;\n      }\n    } else if (SENTINEL_TYPE.test(node.type)) {\n      break;\n    }\n\n    node = node.parent;\n  }\n\n  return false;\n}\n\nvar noUseBeforeDefine = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"disallow the use of variables before they are defined\",\n      category: \"Variables\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-use-before-define\"\n    },\n    schema: [{\n      oneOf: [{\n        enum: [\"nofunc\"]\n      }, {\n        type: \"object\",\n        properties: {\n          functions: {\n            type: \"boolean\"\n          },\n          classes: {\n            type: \"boolean\"\n          },\n          variables: {\n            type: \"boolean\"\n          }\n        },\n        additionalProperties: false\n      }]\n    }],\n    messages: {\n      usedBeforeDefined: \"'{{name}}' was used before it was defined.\"\n    }\n  },\n\n  create(context) {\n    const options = parseOptions(context.options[0]);\n\n    function isForbidden(variable, reference) {\n      if (isFunction(variable)) {\n        return options.functions;\n      }\n\n      if (isOuterClass(variable, reference)) {\n        return options.classes;\n      }\n\n      if (isOuterVariable(variable, reference)) {\n        return options.variables;\n      }\n\n      return true;\n    }\n\n    function findVariablesInScope(scope) {\n      scope.references.forEach(reference => {\n        const variable = reference.resolved;\n\n        if (reference.init || !variable || variable.identifiers.length === 0 || variable.identifiers[0].range[1] < reference.identifier.range[1] && !isInInitializer(variable, reference) || !isForbidden(variable, reference)) {\n          return;\n        }\n\n        context.report({\n          node: reference.identifier,\n          messageId: \"usedBeforeDefined\",\n          data: reference.identifier\n        });\n      });\n      scope.childScopes.forEach(findVariablesInScope);\n    }\n\n    return {\n      Program() {\n        findVariablesInScope(context.getScope());\n      }\n\n    };\n  }\n\n};\nnoUseBeforeDefine.meta;\nnoUseBeforeDefine.create;\nconst {\n  CALL: CALL$5,\n  CONSTRUCT: CONSTRUCT$3,\n  ReferenceTracker: ReferenceTracker$5,\n  getStringIfConstant: getStringIfConstant$2\n} = eslintUtils__default['default'];\nconst {\n  RegExpParser,\n  visitRegExpAST\n} = regexpp__default['default'];\nconst parser$1 = new RegExpParser();\n\nfunction getPathToRoot(node) {\n  const path = [];\n  let current = node;\n\n  do {\n    path.push(current);\n    current = current.parent;\n  } while (current);\n\n  return path;\n}\n\nfunction isLookaround(node) {\n  return node.type === \"Assertion\" && (node.kind === \"lookahead\" || node.kind === \"lookbehind\");\n}\n\nfunction isNegativeLookaround(node) {\n  return isLookaround(node) && node.negate;\n}\n\nvar noUselessBackreference = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"disallow useless backreferences in regular expressions\",\n      category: \"Possible Errors\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-useless-backreference\"\n    },\n    schema: [],\n    messages: {\n      nested: \"Backreference '{{ bref }}' will be ignored. It references group '{{ group }}' from within that group.\",\n      forward: \"Backreference '{{ bref }}' will be ignored. It references group '{{ group }}' which appears later in the pattern.\",\n      backward: \"Backreference '{{ bref }}' will be ignored. It references group '{{ group }}' which appears before in the same lookbehind.\",\n      disjunctive: \"Backreference '{{ bref }}' will be ignored. It references group '{{ group }}' which is in another alternative.\",\n      intoNegativeLookaround: \"Backreference '{{ bref }}' will be ignored. It references group '{{ group }}' which is in a negative lookaround.\"\n    }\n  },\n\n  create(context) {\n    function checkRegex(node, pattern, flags) {\n      let regExpAST;\n\n      try {\n        regExpAST = parser$1.parsePattern(pattern, 0, pattern.length, flags.includes(\"u\"));\n      } catch {\n        return;\n      }\n\n      visitRegExpAST(regExpAST, {\n        onBackreferenceEnter(bref) {\n          const group = bref.resolved,\n                brefPath = getPathToRoot(bref),\n                groupPath = getPathToRoot(group);\n          let messageId = null;\n\n          if (brefPath.includes(group)) {\n            messageId = \"nested\";\n          } else {\n            let i = brefPath.length - 1,\n                j = groupPath.length - 1;\n\n            do {\n              i--;\n              j--;\n            } while (brefPath[i] === groupPath[j]);\n\n            const indexOfLowestCommonAncestor = j + 1,\n                  groupCut = groupPath.slice(0, indexOfLowestCommonAncestor),\n                  commonPath = groupPath.slice(indexOfLowestCommonAncestor),\n                  lowestCommonLookaround = commonPath.find(isLookaround),\n                  isMatchingBackward = lowestCommonLookaround && lowestCommonLookaround.kind === \"lookbehind\";\n\n            if (!isMatchingBackward && bref.end <= group.start) {\n              messageId = \"forward\";\n            } else if (isMatchingBackward && group.end <= bref.start) {\n              messageId = \"backward\";\n            } else if (groupCut[groupCut.length - 1].type === \"Alternative\") {\n              messageId = \"disjunctive\";\n            } else if (groupCut.some(isNegativeLookaround)) {\n              messageId = \"intoNegativeLookaround\";\n            }\n          }\n\n          if (messageId) {\n            context.report({\n              node,\n              messageId,\n              data: {\n                bref: bref.raw,\n                group: group.raw\n              }\n            });\n          }\n        }\n\n      });\n    }\n\n    return {\n      \"Literal[regex]\"(node) {\n        const {\n          pattern,\n          flags\n        } = node.regex;\n        checkRegex(node, pattern, flags);\n      },\n\n      Program() {\n        const scope = context.getScope(),\n              tracker = new ReferenceTracker$5(scope),\n              traceMap = {\n          RegExp: {\n            [CALL$5]: true,\n            [CONSTRUCT$3]: true\n          }\n        };\n\n        for (const {\n          node\n        } of tracker.iterateGlobalReferences(traceMap)) {\n          const [patternNode, flagsNode] = node.arguments,\n                pattern = getStringIfConstant$2(patternNode, scope),\n                flags = getStringIfConstant$2(flagsNode, scope);\n\n          if (typeof pattern === \"string\") {\n            checkRegex(node, pattern, flags || \"\");\n          }\n        }\n      }\n\n    };\n  }\n\n};\nnoUselessBackreference.meta;\nnoUselessBackreference.create;\n\nfunction isCallOrNonVariadicApply(node) {\n  const callee = astUtils.skipChainExpression(node.callee);\n  return callee.type === \"MemberExpression\" && callee.property.type === \"Identifier\" && callee.computed === false && (callee.property.name === \"call\" && node.arguments.length >= 1 || callee.property.name === \"apply\" && node.arguments.length === 2 && node.arguments[1].type === \"ArrayExpression\");\n}\n\nfunction isValidThisArg$1(expectedThis, thisArg, sourceCode) {\n  if (!expectedThis) {\n    return astUtils.isNullOrUndefined(thisArg);\n  }\n\n  return astUtils.equalTokens(expectedThis, thisArg, sourceCode);\n}\n\nvar noUselessCall = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow unnecessary calls to `.call()` and `.apply()`\",\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-useless-call\"\n    },\n    schema: [],\n    messages: {\n      unnecessaryCall: \"Unnecessary '.{{name}}()'.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    return {\n      CallExpression(node) {\n        if (!isCallOrNonVariadicApply(node)) {\n          return;\n        }\n\n        const callee = astUtils.skipChainExpression(node.callee);\n        const applied = astUtils.skipChainExpression(callee.object);\n        const expectedThis = applied.type === \"MemberExpression\" ? applied.object : null;\n        const thisArg = node.arguments[0];\n\n        if (isValidThisArg$1(expectedThis, thisArg, sourceCode)) {\n          context.report({\n            node,\n            messageId: \"unnecessaryCall\",\n            data: {\n              name: callee.property.name\n            }\n          });\n        }\n      }\n\n    };\n  }\n\n};\nnoUselessCall.meta;\nnoUselessCall.create;\nvar noUselessCatch = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow unnecessary `catch` clauses\",\n      category: \"Best Practices\",\n      recommended: true,\n      url: \"https://eslint.org/docs/rules/no-useless-catch\"\n    },\n    schema: [],\n    messages: {\n      unnecessaryCatchClause: \"Unnecessary catch clause.\",\n      unnecessaryCatch: \"Unnecessary try/catch wrapper.\"\n    }\n  },\n\n  create(context) {\n    return {\n      CatchClause(node) {\n        if (node.param && node.param.type === \"Identifier\" && node.body.body.length && node.body.body[0].type === \"ThrowStatement\" && node.body.body[0].argument.type === \"Identifier\" && node.body.body[0].argument.name === node.param.name) {\n          if (node.parent.finalizer) {\n            context.report({\n              node,\n              messageId: \"unnecessaryCatchClause\"\n            });\n          } else {\n            context.report({\n              node: node.parent,\n              messageId: \"unnecessaryCatch\"\n            });\n          }\n        }\n      }\n\n    };\n  }\n\n};\nnoUselessCatch.meta;\nnoUselessCatch.create;\nvar noUselessComputedKey = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow unnecessary computed property keys in objects and classes\",\n      category: \"ECMAScript 6\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-useless-computed-key\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        enforceForClassMembers: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    fixable: \"code\",\n    messages: {\n      unnecessarilyComputedProperty: \"Unnecessarily computed property [{{property}}] found.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    const enforceForClassMembers = context.options[0] && context.options[0].enforceForClassMembers;\n\n    function check(node) {\n      if (!node.computed) {\n        return;\n      }\n\n      const key = node.key,\n            nodeType = typeof key.value;\n      let allowedKey;\n\n      if (node.type === \"MethodDefinition\") {\n        allowedKey = node.static ? \"prototype\" : \"constructor\";\n      } else {\n        allowedKey = \"__proto__\";\n      }\n\n      if (key.type === \"Literal\" && (nodeType === \"string\" || nodeType === \"number\") && key.value !== allowedKey) {\n        context.report({\n          node,\n          messageId: \"unnecessarilyComputedProperty\",\n          data: {\n            property: sourceCode.getText(key)\n          },\n\n          fix(fixer) {\n            const leftSquareBracket = sourceCode.getTokenBefore(key, astUtils.isOpeningBracketToken);\n            const rightSquareBracket = sourceCode.getTokenAfter(key, astUtils.isClosingBracketToken);\n\n            if (sourceCode.commentsExistBetween(leftSquareBracket, rightSquareBracket)) {\n              return null;\n            }\n\n            const tokenBeforeLeftBracket = sourceCode.getTokenBefore(leftSquareBracket);\n            const needsSpaceBeforeKey = tokenBeforeLeftBracket.range[1] === leftSquareBracket.range[0] && !astUtils.canTokensBeAdjacent(tokenBeforeLeftBracket, sourceCode.getFirstToken(key));\n            const replacementKey = (needsSpaceBeforeKey ? \" \" : \"\") + key.raw;\n            return fixer.replaceTextRange([leftSquareBracket.range[0], rightSquareBracket.range[1]], replacementKey);\n          }\n\n        });\n      }\n    }\n\n    return {\n      Property: check,\n      MethodDefinition: enforceForClassMembers ? check : function () {}\n    };\n  }\n\n};\nnoUselessComputedKey.meta;\nnoUselessComputedKey.create;\n\nfunction isConcatenation$1(node) {\n  return node.type === \"BinaryExpression\" && node.operator === \"+\";\n}\n\nfunction isConcatOperatorToken(token) {\n  return token.value === \"+\" && token.type === \"Punctuator\";\n}\n\nfunction getLeft(node) {\n  let left = node.left;\n\n  while (isConcatenation$1(left)) {\n    left = left.right;\n  }\n\n  return left;\n}\n\nfunction getRight(node) {\n  let right = node.right;\n\n  while (isConcatenation$1(right)) {\n    right = right.left;\n  }\n\n  return right;\n}\n\nvar noUselessConcat = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow unnecessary concatenation of literals or template literals\",\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-useless-concat\"\n    },\n    schema: [],\n    messages: {\n      unexpectedConcat: \"Unexpected string concatenation of literals.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    return {\n      BinaryExpression(node) {\n        if (node.operator !== \"+\") {\n          return;\n        }\n\n        const left = getLeft(node);\n        const right = getRight(node);\n\n        if (astUtils.isStringLiteral(left) && astUtils.isStringLiteral(right) && astUtils.isTokenOnSameLine(left, right)) {\n          const operatorToken = sourceCode.getFirstTokenBetween(left, right, isConcatOperatorToken);\n          context.report({\n            node,\n            loc: operatorToken.loc,\n            messageId: \"unexpectedConcat\"\n          });\n        }\n      }\n\n    };\n  }\n\n};\nnoUselessConcat.meta;\nnoUselessConcat.create;\n\nfunction isSingleSuperCall(body) {\n  return body.length === 1 && body[0].type === \"ExpressionStatement\" && body[0].expression.type === \"CallExpression\" && body[0].expression.callee.type === \"Super\";\n}\n\nfunction isSimple(node) {\n  return node.type === \"Identifier\" || node.type === \"RestElement\";\n}\n\nfunction isSpreadArguments(superArgs) {\n  return superArgs.length === 1 && superArgs[0].type === \"SpreadElement\" && superArgs[0].argument.type === \"Identifier\" && superArgs[0].argument.name === \"arguments\";\n}\n\nfunction isValidIdentifierPair(ctorParam, superArg) {\n  return ctorParam.type === \"Identifier\" && superArg.type === \"Identifier\" && ctorParam.name === superArg.name;\n}\n\nfunction isValidRestSpreadPair(ctorParam, superArg) {\n  return ctorParam.type === \"RestElement\" && superArg.type === \"SpreadElement\" && isValidIdentifierPair(ctorParam.argument, superArg.argument);\n}\n\nfunction isValidPair(ctorParam, superArg) {\n  return isValidIdentifierPair(ctorParam, superArg) || isValidRestSpreadPair(ctorParam, superArg);\n}\n\nfunction isPassingThrough(ctorParams, superArgs) {\n  if (ctorParams.length !== superArgs.length) {\n    return false;\n  }\n\n  for (let i = 0; i < ctorParams.length; ++i) {\n    if (!isValidPair(ctorParams[i], superArgs[i])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction isRedundantSuperCall(body, ctorParams) {\n  return isSingleSuperCall(body) && ctorParams.every(isSimple) && (isSpreadArguments(body[0].expression.arguments) || isPassingThrough(ctorParams, body[0].expression.arguments));\n}\n\nvar noUselessConstructor = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow unnecessary constructors\",\n      category: \"ECMAScript 6\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-useless-constructor\"\n    },\n    schema: [],\n    messages: {\n      noUselessConstructor: \"Useless constructor.\"\n    }\n  },\n\n  create(context) {\n    return {\n      MethodDefinition: function (node) {\n        if (node.kind !== \"constructor\") {\n          return;\n        }\n\n        if (!node.value.body) {\n          return;\n        }\n\n        const body = node.value.body.body;\n        const ctorParams = node.value.params;\n        const superClass = node.parent.parent.superClass;\n\n        if (superClass ? isRedundantSuperCall(body, ctorParams) : body.length === 0) {\n          context.report({\n            node,\n            messageId: \"noUselessConstructor\"\n          });\n        }\n      }\n    };\n  }\n\n};\nnoUselessConstructor.meta;\nnoUselessConstructor.create;\n\nfunction union(setA, setB) {\n  return new Set(function* () {\n    yield* setA;\n    yield* setB;\n  }());\n}\n\nconst VALID_STRING_ESCAPES = union(new Set(\"\\\\nrvtbfux\"), astUtils.LINEBREAKS);\nconst REGEX_GENERAL_ESCAPES = new Set(\"\\\\bcdDfnpPrsStvwWxu0123456789]\");\nconst REGEX_NON_CHARCLASS_ESCAPES = union(REGEX_GENERAL_ESCAPES, new Set(\"^/.$*+?[{}|()Bk\"));\n\nfunction parseRegExp(regExpText) {\n  const charList = [];\n  regExpText.split(\"\").reduce((state, char, index) => {\n    if (!state.escapeNextChar) {\n      if (char === \"\\\\\") {\n        return Object.assign(state, {\n          escapeNextChar: true\n        });\n      }\n\n      if (char === \"[\" && !state.inCharClass) {\n        return Object.assign(state, {\n          inCharClass: true,\n          startingCharClass: true\n        });\n      }\n\n      if (char === \"]\" && state.inCharClass) {\n        if (charList.length && charList[charList.length - 1].inCharClass) {\n          charList[charList.length - 1].endsCharClass = true;\n        }\n\n        return Object.assign(state, {\n          inCharClass: false,\n          startingCharClass: false\n        });\n      }\n    }\n\n    charList.push({\n      text: char,\n      index,\n      escaped: state.escapeNextChar,\n      inCharClass: state.inCharClass,\n      startsCharClass: state.startingCharClass,\n      endsCharClass: false\n    });\n    return Object.assign(state, {\n      escapeNextChar: false,\n      startingCharClass: false\n    });\n  }, {\n    escapeNextChar: false,\n    inCharClass: false,\n    startingCharClass: false\n  });\n  return charList;\n}\n\nvar noUselessEscape = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow unnecessary escape characters\",\n      category: \"Best Practices\",\n      recommended: true,\n      url: \"https://eslint.org/docs/rules/no-useless-escape\",\n      suggestion: true\n    },\n    messages: {\n      unnecessaryEscape: \"Unnecessary escape character: \\\\{{character}}.\",\n      removeEscape: \"Remove the `\\\\`. This maintains the current functionality.\",\n      escapeBackslash: \"Replace the `\\\\` with `\\\\\\\\` to include the actual backslash character.\"\n    },\n    schema: []\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n\n    function report(node, startOffset, character) {\n      const rangeStart = node.range[0] + startOffset;\n      const range = [rangeStart, rangeStart + 1];\n      const start = sourceCode.getLocFromIndex(rangeStart);\n      context.report({\n        node,\n        loc: {\n          start,\n          end: {\n            line: start.line,\n            column: start.column + 1\n          }\n        },\n        messageId: \"unnecessaryEscape\",\n        data: {\n          character\n        },\n        suggest: [{\n          messageId: \"removeEscape\",\n\n          fix(fixer) {\n            return fixer.removeRange(range);\n          }\n\n        }, {\n          messageId: \"escapeBackslash\",\n\n          fix(fixer) {\n            return fixer.insertTextBeforeRange(range, \"\\\\\");\n          }\n\n        }]\n      });\n    }\n\n    function validateString(node, match) {\n      const isTemplateElement = node.type === \"TemplateElement\";\n      const escapedChar = match[0][1];\n      let isUnnecessaryEscape = !VALID_STRING_ESCAPES.has(escapedChar);\n      let isQuoteEscape;\n\n      if (isTemplateElement) {\n        isQuoteEscape = escapedChar === \"`\";\n\n        if (escapedChar === \"$\") {\n          isUnnecessaryEscape = match.input[match.index + 2] !== \"{\";\n        } else if (escapedChar === \"{\") {\n          isUnnecessaryEscape = match.input[match.index - 1] !== \"$\";\n        }\n      } else {\n        isQuoteEscape = escapedChar === node.raw[0];\n      }\n\n      if (isUnnecessaryEscape && !isQuoteEscape) {\n        report(node, match.index, match[0].slice(1));\n      }\n    }\n\n    function check(node) {\n      const isTemplateElement = node.type === \"TemplateElement\";\n\n      if (isTemplateElement && node.parent && node.parent.parent && node.parent.parent.type === \"TaggedTemplateExpression\" && node.parent === node.parent.parent.quasi) {\n        return;\n      }\n\n      if (typeof node.value === \"string\" || isTemplateElement) {\n        if (node.parent.type === \"JSXAttribute\" || node.parent.type === \"JSXElement\" || node.parent.type === \"JSXFragment\") {\n          return;\n        }\n\n        const value = isTemplateElement ? sourceCode.getText(node) : node.raw;\n        let match;\n\n        while (match = /\\\\[^\\d]/gu.exec(value)) {\n          validateString(node, match);\n        }\n      } else if (node.regex) {\n        parseRegExp(node.regex.pattern).filter(charInfo => !(charInfo.text === \"-\" && charInfo.inCharClass && !charInfo.startsCharClass && !charInfo.endsCharClass)).filter(charInfo => !(charInfo.text === \"^\" && charInfo.startsCharClass)).filter(charInfo => charInfo.escaped).filter(charInfo => !(charInfo.inCharClass ? REGEX_GENERAL_ESCAPES : REGEX_NON_CHARCLASS_ESCAPES).has(charInfo.text)).forEach(charInfo => report(node, charInfo.index, charInfo.text));\n      }\n    }\n\n    return {\n      Literal: check,\n      TemplateElement: check\n    };\n  }\n\n};\nnoUselessEscape.meta;\nnoUselessEscape.create;\nvar noUselessRename = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow renaming import, export, and destructured assignments to the same name\",\n      category: \"ECMAScript 6\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-useless-rename\"\n    },\n    fixable: \"code\",\n    schema: [{\n      type: \"object\",\n      properties: {\n        ignoreDestructuring: {\n          type: \"boolean\",\n          default: false\n        },\n        ignoreImport: {\n          type: \"boolean\",\n          default: false\n        },\n        ignoreExport: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      unnecessarilyRenamed: \"{{type}} {{name}} unnecessarily renamed.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode(),\n          options = context.options[0] || {},\n          ignoreDestructuring = options.ignoreDestructuring === true,\n          ignoreImport = options.ignoreImport === true,\n          ignoreExport = options.ignoreExport === true;\n\n    function reportError(node, initial, type) {\n      const name = initial.type === \"Identifier\" ? initial.name : initial.value;\n      return context.report({\n        node,\n        messageId: \"unnecessarilyRenamed\",\n        data: {\n          name,\n          type\n        },\n\n        fix(fixer) {\n          const replacementNode = node.type === \"Property\" ? node.value : node.local;\n\n          if (sourceCode.getCommentsInside(node).length > sourceCode.getCommentsInside(replacementNode).length) {\n            return null;\n          }\n\n          if (replacementNode.type === \"AssignmentPattern\" && astUtils.isParenthesised(sourceCode, replacementNode.left)) {\n            return null;\n          }\n\n          return fixer.replaceText(node, sourceCode.getText(replacementNode));\n        }\n\n      });\n    }\n\n    return {\n      ObjectPattern: function (node) {\n        if (ignoreDestructuring) {\n          return;\n        }\n\n        for (const property of node.properties) {\n          if (property.type !== \"Property\" || property.shorthand || property.computed) {\n            continue;\n          }\n\n          const key = property.key.type === \"Identifier\" && property.key.name || property.key.type === \"Literal\" && property.key.value;\n          const renamedKey = property.value.type === \"AssignmentPattern\" ? property.value.left.name : property.value.name;\n\n          if (key === renamedKey) {\n            reportError(property, property.key, \"Destructuring assignment\");\n          }\n        }\n      },\n      ImportSpecifier: function (node) {\n        if (ignoreImport) {\n          return;\n        }\n\n        if (node.imported.name === node.local.name && node.imported.range[0] !== node.local.range[0]) {\n          reportError(node, node.imported, \"Import\");\n        }\n      },\n      ExportSpecifier: function (node) {\n        if (ignoreExport) {\n          return;\n        }\n\n        if (node.local.name === node.exported.name && node.local.range[0] !== node.exported.range[0]) {\n          reportError(node, node.local, \"Export\");\n        }\n      }\n    };\n  }\n\n};\nnoUselessRename.meta;\nnoUselessRename.create;\n\nfunction remove(array, element) {\n  const index = array.indexOf(element);\n\n  if (index !== -1) {\n    array.splice(index, 1);\n  }\n}\n\nfunction isRemovable(node) {\n  return astUtils.STATEMENT_LIST_PARENTS.has(node.parent.type);\n}\n\nfunction isInFinally(node) {\n  for (let currentNode = node; currentNode && currentNode.parent && !astUtils.isFunction(currentNode); currentNode = currentNode.parent) {\n    if (currentNode.parent.type === \"TryStatement\" && currentNode.parent.finalizer === currentNode) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nvar noUselessReturn = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow redundant return statements\",\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-useless-return\"\n    },\n    fixable: \"code\",\n    schema: [],\n    messages: {\n      unnecessaryReturn: \"Unnecessary return statement.\"\n    }\n  },\n\n  create(context) {\n    const segmentInfoMap = new WeakMap();\n    const usedUnreachableSegments = new WeakSet();\n    const sourceCode = context.getSourceCode();\n    let scopeInfo = null;\n\n    function isReturned(segment) {\n      const info = segmentInfoMap.get(segment);\n      return !info || info.returned;\n    }\n\n    function getUselessReturns(uselessReturns, prevSegments, providedTraversedSegments) {\n      const traversedSegments = providedTraversedSegments || new WeakSet();\n\n      for (const segment of prevSegments) {\n        if (!segment.reachable) {\n          if (!traversedSegments.has(segment)) {\n            traversedSegments.add(segment);\n            getUselessReturns(uselessReturns, segment.allPrevSegments.filter(isReturned), traversedSegments);\n          }\n\n          continue;\n        }\n\n        uselessReturns.push(...segmentInfoMap.get(segment).uselessReturns);\n      }\n\n      return uselessReturns;\n    }\n\n    function markReturnStatementsOnSegmentAsUsed(segment) {\n      if (!segment.reachable) {\n        usedUnreachableSegments.add(segment);\n        segment.allPrevSegments.filter(isReturned).filter(prevSegment => !usedUnreachableSegments.has(prevSegment)).forEach(markReturnStatementsOnSegmentAsUsed);\n        return;\n      }\n\n      const info = segmentInfoMap.get(segment);\n\n      for (const node of info.uselessReturns) {\n        remove(scopeInfo.uselessReturns, node);\n      }\n\n      info.uselessReturns = [];\n    }\n\n    function markReturnStatementsOnCurrentSegmentsAsUsed() {\n      scopeInfo.codePath.currentSegments.forEach(markReturnStatementsOnSegmentAsUsed);\n    }\n\n    return {\n      onCodePathStart(codePath) {\n        scopeInfo = {\n          upper: scopeInfo,\n          uselessReturns: [],\n          codePath\n        };\n      },\n\n      onCodePathEnd() {\n        for (const node of scopeInfo.uselessReturns) {\n          context.report({\n            node,\n            loc: node.loc,\n            messageId: \"unnecessaryReturn\",\n\n            fix(fixer) {\n              if (isRemovable(node) && !sourceCode.getCommentsInside(node).length) {\n                return new fixTracker(fixer, sourceCode).retainEnclosingFunction(node).remove(node);\n              }\n\n              return null;\n            }\n\n          });\n        }\n\n        scopeInfo = scopeInfo.upper;\n      },\n\n      onCodePathSegmentStart(segment) {\n        const info = {\n          uselessReturns: getUselessReturns([], segment.allPrevSegments),\n          returned: false\n        };\n        segmentInfoMap.set(segment, info);\n      },\n\n      ReturnStatement(node) {\n        if (node.argument) {\n          markReturnStatementsOnCurrentSegmentsAsUsed();\n        }\n\n        if (node.argument || astUtils.isInLoop(node) || isInFinally(node) || !scopeInfo.codePath.currentSegments.some(s => s.reachable)) {\n          return;\n        }\n\n        for (const segment of scopeInfo.codePath.currentSegments) {\n          const info = segmentInfoMap.get(segment);\n\n          if (info) {\n            info.uselessReturns.push(node);\n            info.returned = true;\n          }\n        }\n\n        scopeInfo.uselessReturns.push(node);\n      },\n\n      ClassDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,\n      ContinueStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n      DebuggerStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n      DoWhileStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n      EmptyStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n      ExpressionStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n      ForInStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n      ForOfStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n      ForStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n      IfStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n      ImportDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,\n      LabeledStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n      SwitchStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n      ThrowStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n      TryStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n      VariableDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,\n      WhileStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n      WithStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n      ExportNamedDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,\n      ExportDefaultDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,\n      ExportAllDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed\n    };\n  }\n\n};\nnoUselessReturn.meta;\nnoUselessReturn.create;\n\nfunction isGlobal(variable) {\n  return Boolean(variable.scope) && variable.scope.type === \"global\";\n}\n\nfunction getEnclosingFunctionScope(scope) {\n  let currentScope = scope;\n\n  while (currentScope.type !== \"function\" && currentScope.type !== \"global\") {\n    currentScope = currentScope.upper;\n  }\n\n  return currentScope;\n}\n\nfunction isReferencedInClosure(variable) {\n  const enclosingFunctionScope = getEnclosingFunctionScope(variable.scope);\n  return variable.references.some(reference => getEnclosingFunctionScope(reference.from) !== enclosingFunctionScope);\n}\n\nfunction isLoopAssignee(node) {\n  return (node.parent.type === \"ForOfStatement\" || node.parent.type === \"ForInStatement\") && node === node.parent.left;\n}\n\nfunction isDeclarationInitialized(node) {\n  return node.declarations.every(declarator => declarator.init !== null);\n}\n\nconst SCOPE_NODE_TYPE = /^(?:Program|BlockStatement|SwitchStatement|ForStatement|ForInStatement|ForOfStatement)$/u;\n\nfunction getScopeNode(node) {\n  for (let currentNode = node; currentNode; currentNode = currentNode.parent) {\n    if (SCOPE_NODE_TYPE.test(currentNode.type)) {\n      return currentNode;\n    }\n  }\n\n  return null;\n}\n\nfunction isRedeclared(variable) {\n  return variable.defs.length >= 2;\n}\n\nfunction isUsedFromOutsideOf(scopeNode) {\n  function isOutsideOfScope(reference) {\n    const scope = scopeNode.range;\n    const id = reference.identifier.range;\n    return id[0] < scope[0] || id[1] > scope[1];\n  }\n\n  return function (variable) {\n    return variable.references.some(isOutsideOfScope);\n  };\n}\n\nfunction hasReferenceInTDZ(node) {\n  const initStart = node.range[0];\n  const initEnd = node.range[1];\n  return variable => {\n    const id = variable.defs[0].name;\n    const idStart = id.range[0];\n    const defaultValue = id.parent.type === \"AssignmentPattern\" ? id.parent.right : null;\n    const defaultStart = defaultValue && defaultValue.range[0];\n    const defaultEnd = defaultValue && defaultValue.range[1];\n    return variable.references.some(reference => {\n      const start = reference.identifier.range[0];\n      const end = reference.identifier.range[1];\n      return !reference.init && (start < idStart || defaultValue !== null && start >= defaultStart && end <= defaultEnd || start >= initStart && end <= initEnd);\n    });\n  };\n}\n\nfunction hasNameDisallowedForLetDeclarations(variable) {\n  return variable.name === \"let\";\n}\n\nvar noVar = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"require `let` or `const` instead of `var`\",\n      category: \"ECMAScript 6\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-var\"\n    },\n    schema: [],\n    fixable: \"code\",\n    messages: {\n      unexpectedVar: \"Unexpected var, use let or const instead.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n\n    function hasSelfReferenceInTDZ(declarator) {\n      if (!declarator.init) {\n        return false;\n      }\n\n      const variables = context.getDeclaredVariables(declarator);\n      return variables.some(hasReferenceInTDZ(declarator.init));\n    }\n\n    function canFix(node) {\n      const variables = context.getDeclaredVariables(node);\n      const scopeNode = getScopeNode(node);\n\n      if (node.parent.type === \"SwitchCase\" || node.declarations.some(hasSelfReferenceInTDZ) || variables.some(isGlobal) || variables.some(isRedeclared) || variables.some(isUsedFromOutsideOf(scopeNode)) || variables.some(hasNameDisallowedForLetDeclarations)) {\n        return false;\n      }\n\n      if (astUtils.isInLoop(node)) {\n        if (variables.some(isReferencedInClosure)) {\n          return false;\n        }\n\n        if (!isLoopAssignee(node) && !isDeclarationInitialized(node)) {\n          return false;\n        }\n      }\n\n      if (!isLoopAssignee(node) && !(node.parent.type === \"ForStatement\" && node.parent.init === node) && !astUtils.STATEMENT_LIST_PARENTS.has(node.parent.type)) {\n        return false;\n      }\n\n      return true;\n    }\n\n    function report(node) {\n      context.report({\n        node,\n        messageId: \"unexpectedVar\",\n\n        fix(fixer) {\n          const varToken = sourceCode.getFirstToken(node, {\n            filter: t => t.value === \"var\"\n          });\n          return canFix(node) ? fixer.replaceText(varToken, \"let\") : null;\n        }\n\n      });\n    }\n\n    return {\n      \"VariableDeclaration:exit\"(node) {\n        if (node.kind === \"var\") {\n          report(node);\n        }\n      }\n\n    };\n  }\n\n};\nnoVar.meta;\nnoVar.create;\nvar noVoid = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow `void` operators\",\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-void\"\n    },\n    messages: {\n      noVoid: \"Expected 'undefined' and instead saw 'void'.\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        allowAsStatement: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }]\n  },\n\n  create(context) {\n    const allowAsStatement = context.options[0] && context.options[0].allowAsStatement;\n    return {\n      'UnaryExpression[operator=\"void\"]'(node) {\n        if (allowAsStatement && node.parent && node.parent.type === \"ExpressionStatement\") {\n          return;\n        }\n\n        context.report({\n          node,\n          messageId: \"noVoid\"\n        });\n      }\n\n    };\n  }\n\n};\nnoVoid.meta;\nnoVoid.create;\nconst CHAR_LIMIT = 40;\nvar noWarningComments = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow specified warning terms in comments\",\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-warning-comments\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        terms: {\n          type: \"array\",\n          items: {\n            type: \"string\"\n          }\n        },\n        location: {\n          enum: [\"start\", \"anywhere\"]\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      unexpectedComment: \"Unexpected '{{matchedTerm}}' comment: '{{comment}}'.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode(),\n          configuration = context.options[0] || {},\n          warningTerms = configuration.terms || [\"todo\", \"fixme\", \"xxx\"],\n          location = configuration.location || \"start\";\n    const warningRegExps = warningTerms.map(function (term) {\n      const escaped = escapeStringRegexp__default['default'](term);\n      let prefix;\n      const suffix = /\\w$/u.test(term) ? \"\\\\b\" : \"\";\n\n      if (location === \"start\") {\n        prefix = \"^\\\\s*\";\n      } else if (/^\\w/u.test(term)) {\n        prefix = \"\\\\b\";\n      } else {\n        prefix = \"\";\n      }\n\n      if (location === \"start\") {\n        return new RegExp(prefix + escaped + suffix, \"iu\");\n      }\n\n      return new RegExp(prefix + escaped + suffix + \"|\\\\b\" + term + \"\\\\b\", \"iu\");\n    });\n\n    function commentContainsWarningTerm(comment) {\n      const matches = [];\n      warningRegExps.forEach((regex, index) => {\n        if (regex.test(comment)) {\n          matches.push(warningTerms[index]);\n        }\n      });\n      return matches;\n    }\n\n    function checkComment(node) {\n      const comment = node.value;\n\n      if (astUtils.isDirectiveComment(node) && /\\bno-warning-comments\\b/u.test(comment)) {\n        return;\n      }\n\n      const matches = commentContainsWarningTerm(comment);\n      matches.forEach(matchedTerm => {\n        let commentToDisplay = \"\";\n        let truncated = false;\n\n        for (const c of comment.trim().split(/\\s+/u)) {\n          const tmp = commentToDisplay ? `${commentToDisplay} ${c}` : c;\n\n          if (tmp.length <= CHAR_LIMIT) {\n            commentToDisplay = tmp;\n          } else {\n            truncated = true;\n            break;\n          }\n        }\n\n        context.report({\n          node,\n          messageId: \"unexpectedComment\",\n          data: {\n            matchedTerm,\n            comment: `${commentToDisplay}${truncated ? \"...\" : \"\"}`\n          }\n        });\n      });\n    }\n\n    return {\n      Program() {\n        const comments = sourceCode.getAllComments();\n        comments.filter(token => token.type !== \"Shebang\").forEach(checkComment);\n      }\n\n    };\n  }\n\n};\nnoWarningComments.meta;\nnoWarningComments.create;\nvar noWhitespaceBeforeProperty = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"disallow whitespace before properties\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-whitespace-before-property\"\n    },\n    fixable: \"whitespace\",\n    schema: [],\n    messages: {\n      unexpectedWhitespace: \"Unexpected whitespace before property {{propName}}.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n\n    function reportError(node, leftToken, rightToken) {\n      context.report({\n        node,\n        messageId: \"unexpectedWhitespace\",\n        data: {\n          propName: sourceCode.getText(node.property)\n        },\n\n        fix(fixer) {\n          let replacementText = \"\";\n\n          if (!node.computed && !node.optional && astUtils.isDecimalInteger(node.object)) {\n            return null;\n          }\n\n          if (sourceCode.commentsExistBetween(leftToken, rightToken)) {\n            return null;\n          }\n\n          if (node.optional) {\n            replacementText = \"?.\";\n          } else if (!node.computed) {\n            replacementText = \".\";\n          }\n\n          return fixer.replaceTextRange([leftToken.range[1], rightToken.range[0]], replacementText);\n        }\n\n      });\n    }\n\n    return {\n      MemberExpression(node) {\n        let rightToken;\n        let leftToken;\n\n        if (!astUtils.isTokenOnSameLine(node.object, node.property)) {\n          return;\n        }\n\n        if (node.computed) {\n          rightToken = sourceCode.getTokenBefore(node.property, astUtils.isOpeningBracketToken);\n          leftToken = sourceCode.getTokenBefore(rightToken, node.optional ? 1 : 0);\n        } else {\n          rightToken = sourceCode.getFirstToken(node.property);\n          leftToken = sourceCode.getTokenBefore(rightToken, 1);\n        }\n\n        if (sourceCode.isSpaceBetweenTokens(leftToken, rightToken)) {\n          reportError(node, leftToken, rightToken);\n        }\n      }\n\n    };\n  }\n\n};\nnoWhitespaceBeforeProperty.meta;\nnoWhitespaceBeforeProperty.create;\nvar noWith = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow `with` statements\",\n      category: \"Best Practices\",\n      recommended: true,\n      url: \"https://eslint.org/docs/rules/no-with\"\n    },\n    schema: [],\n    messages: {\n      unexpectedWith: \"Unexpected use of 'with' statement.\"\n    }\n  },\n\n  create(context) {\n    return {\n      WithStatement(node) {\n        context.report({\n          node,\n          messageId: \"unexpectedWith\"\n        });\n      }\n\n    };\n  }\n\n};\nnoWith.meta;\nnoWith.create;\nconst POSITION_SCHEMA = {\n  enum: [\"beside\", \"below\", \"any\"]\n};\nvar nonblockStatementBodyPosition = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"enforce the location of single-line statements\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/nonblock-statement-body-position\"\n    },\n    fixable: \"whitespace\",\n    schema: [POSITION_SCHEMA, {\n      properties: {\n        overrides: {\n          properties: {\n            if: POSITION_SCHEMA,\n            else: POSITION_SCHEMA,\n            while: POSITION_SCHEMA,\n            do: POSITION_SCHEMA,\n            for: POSITION_SCHEMA\n          },\n          additionalProperties: false\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      expectNoLinebreak: \"Expected no linebreak before this statement.\",\n      expectLinebreak: \"Expected a linebreak before this statement.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n\n    function getOption(keywordName) {\n      return context.options[1] && context.options[1].overrides && context.options[1].overrides[keywordName] || context.options[0] || \"beside\";\n    }\n\n    function validateStatement(node, keywordName) {\n      const option = getOption(keywordName);\n\n      if (node.type === \"BlockStatement\" || option === \"any\") {\n        return;\n      }\n\n      const tokenBefore = sourceCode.getTokenBefore(node);\n\n      if (tokenBefore.loc.end.line === node.loc.start.line && option === \"below\") {\n        context.report({\n          node,\n          messageId: \"expectLinebreak\",\n          fix: fixer => fixer.insertTextBefore(node, \"\\n\")\n        });\n      } else if (tokenBefore.loc.end.line !== node.loc.start.line && option === \"beside\") {\n        context.report({\n          node,\n          messageId: \"expectNoLinebreak\",\n\n          fix(fixer) {\n            if (sourceCode.getText().slice(tokenBefore.range[1], node.range[0]).trim()) {\n              return null;\n            }\n\n            return fixer.replaceTextRange([tokenBefore.range[1], node.range[0]], \" \");\n          }\n\n        });\n      }\n    }\n\n    return {\n      IfStatement(node) {\n        validateStatement(node.consequent, \"if\");\n\n        if (node.alternate && node.alternate.type !== \"IfStatement\") {\n          validateStatement(node.alternate, \"else\");\n        }\n      },\n\n      WhileStatement: node => validateStatement(node.body, \"while\"),\n      DoWhileStatement: node => validateStatement(node.body, \"do\"),\n      ForStatement: node => validateStatement(node.body, \"for\"),\n      ForInStatement: node => validateStatement(node.body, \"for\"),\n      ForOfStatement: node => validateStatement(node.body, \"for\")\n    };\n  }\n\n};\nnonblockStatementBodyPosition.meta;\nnonblockStatementBodyPosition.create;\nconst OPTION_VALUE = {\n  oneOf: [{\n    enum: [\"always\", \"never\"]\n  }, {\n    type: \"object\",\n    properties: {\n      multiline: {\n        type: \"boolean\"\n      },\n      minProperties: {\n        type: \"integer\",\n        minimum: 0\n      },\n      consistent: {\n        type: \"boolean\"\n      }\n    },\n    additionalProperties: false,\n    minProperties: 1\n  }]\n};\n\nfunction normalizeOptionValue(value) {\n  let multiline = false;\n  let minProperties = Number.POSITIVE_INFINITY;\n  let consistent = false;\n\n  if (value) {\n    if (value === \"always\") {\n      minProperties = 0;\n    } else if (value === \"never\") {\n      minProperties = Number.POSITIVE_INFINITY;\n    } else {\n      multiline = Boolean(value.multiline);\n      minProperties = value.minProperties || Number.POSITIVE_INFINITY;\n      consistent = Boolean(value.consistent);\n    }\n  } else {\n    consistent = true;\n  }\n\n  return {\n    multiline,\n    minProperties,\n    consistent\n  };\n}\n\nfunction isObject(value) {\n  return typeof value === \"object\" && value !== null;\n}\n\nfunction isNodeSpecificOption(option) {\n  return isObject(option) || typeof option === \"string\";\n}\n\nfunction normalizeOptions(options) {\n  if (isObject(options) && Object.values(options).some(isNodeSpecificOption)) {\n    return {\n      ObjectExpression: normalizeOptionValue(options.ObjectExpression),\n      ObjectPattern: normalizeOptionValue(options.ObjectPattern),\n      ImportDeclaration: normalizeOptionValue(options.ImportDeclaration),\n      ExportNamedDeclaration: normalizeOptionValue(options.ExportDeclaration)\n    };\n  }\n\n  const value = normalizeOptionValue(options);\n  return {\n    ObjectExpression: value,\n    ObjectPattern: value,\n    ImportDeclaration: value,\n    ExportNamedDeclaration: value\n  };\n}\n\nfunction areLineBreaksRequired(node, options, first, last) {\n  let objectProperties;\n\n  if (node.type === \"ObjectExpression\" || node.type === \"ObjectPattern\") {\n    objectProperties = node.properties;\n  } else {\n    objectProperties = node.specifiers.filter(s => s.type === \"ImportSpecifier\" || s.type === \"ExportSpecifier\");\n  }\n\n  return objectProperties.length >= options.minProperties || options.multiline && objectProperties.length > 0 && first.loc.start.line !== last.loc.end.line;\n}\n\nvar objectCurlyNewline = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"enforce consistent line breaks after opening and before closing braces\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/object-curly-newline\"\n    },\n    fixable: \"whitespace\",\n    schema: [{\n      oneOf: [OPTION_VALUE, {\n        type: \"object\",\n        properties: {\n          ObjectExpression: OPTION_VALUE,\n          ObjectPattern: OPTION_VALUE,\n          ImportDeclaration: OPTION_VALUE,\n          ExportDeclaration: OPTION_VALUE\n        },\n        additionalProperties: false,\n        minProperties: 1\n      }]\n    }],\n    messages: {\n      unexpectedLinebreakBeforeClosingBrace: \"Unexpected line break before this closing brace.\",\n      unexpectedLinebreakAfterOpeningBrace: \"Unexpected line break after this opening brace.\",\n      expectedLinebreakBeforeClosingBrace: \"Expected a line break before this closing brace.\",\n      expectedLinebreakAfterOpeningBrace: \"Expected a line break after this opening brace.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    const normalizedOptions = normalizeOptions(context.options[0]);\n\n    function check(node) {\n      const options = normalizedOptions[node.type];\n\n      if (node.type === \"ImportDeclaration\" && !node.specifiers.some(specifier => specifier.type === \"ImportSpecifier\") || node.type === \"ExportNamedDeclaration\" && !node.specifiers.some(specifier => specifier.type === \"ExportSpecifier\")) {\n        return;\n      }\n\n      const openBrace = sourceCode.getFirstToken(node, token => token.value === \"{\");\n      let closeBrace;\n\n      if (node.typeAnnotation) {\n        closeBrace = sourceCode.getTokenBefore(node.typeAnnotation);\n      } else {\n        closeBrace = sourceCode.getLastToken(node, token => token.value === \"}\");\n      }\n\n      let first = sourceCode.getTokenAfter(openBrace, {\n        includeComments: true\n      });\n      let last = sourceCode.getTokenBefore(closeBrace, {\n        includeComments: true\n      });\n      const needsLineBreaks = areLineBreaksRequired(node, options, first, last);\n      const hasCommentsFirstToken = astUtils.isCommentToken(first);\n      const hasCommentsLastToken = astUtils.isCommentToken(last);\n      first = sourceCode.getTokenAfter(openBrace);\n      last = sourceCode.getTokenBefore(closeBrace);\n\n      if (needsLineBreaks) {\n        if (astUtils.isTokenOnSameLine(openBrace, first)) {\n          context.report({\n            messageId: \"expectedLinebreakAfterOpeningBrace\",\n            node,\n            loc: openBrace.loc,\n\n            fix(fixer) {\n              if (hasCommentsFirstToken) {\n                return null;\n              }\n\n              return fixer.insertTextAfter(openBrace, \"\\n\");\n            }\n\n          });\n        }\n\n        if (astUtils.isTokenOnSameLine(last, closeBrace)) {\n          context.report({\n            messageId: \"expectedLinebreakBeforeClosingBrace\",\n            node,\n            loc: closeBrace.loc,\n\n            fix(fixer) {\n              if (hasCommentsLastToken) {\n                return null;\n              }\n\n              return fixer.insertTextBefore(closeBrace, \"\\n\");\n            }\n\n          });\n        }\n      } else {\n        const consistent = options.consistent;\n        const hasLineBreakBetweenOpenBraceAndFirst = !astUtils.isTokenOnSameLine(openBrace, first);\n        const hasLineBreakBetweenCloseBraceAndLast = !astUtils.isTokenOnSameLine(last, closeBrace);\n\n        if (!consistent && hasLineBreakBetweenOpenBraceAndFirst || consistent && hasLineBreakBetweenOpenBraceAndFirst && !hasLineBreakBetweenCloseBraceAndLast) {\n          context.report({\n            messageId: \"unexpectedLinebreakAfterOpeningBrace\",\n            node,\n            loc: openBrace.loc,\n\n            fix(fixer) {\n              if (hasCommentsFirstToken) {\n                return null;\n              }\n\n              return fixer.removeRange([openBrace.range[1], first.range[0]]);\n            }\n\n          });\n        }\n\n        if (!consistent && hasLineBreakBetweenCloseBraceAndLast || consistent && !hasLineBreakBetweenOpenBraceAndFirst && hasLineBreakBetweenCloseBraceAndLast) {\n          context.report({\n            messageId: \"unexpectedLinebreakBeforeClosingBrace\",\n            node,\n            loc: closeBrace.loc,\n\n            fix(fixer) {\n              if (hasCommentsLastToken) {\n                return null;\n              }\n\n              return fixer.removeRange([last.range[1], closeBrace.range[0]]);\n            }\n\n          });\n        }\n      }\n    }\n\n    return {\n      ObjectExpression: check,\n      ObjectPattern: check,\n      ImportDeclaration: check,\n      ExportNamedDeclaration: check\n    };\n  }\n\n};\nobjectCurlyNewline.meta;\nobjectCurlyNewline.create;\nvar objectCurlySpacing = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"enforce consistent spacing inside braces\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/object-curly-spacing\"\n    },\n    fixable: \"whitespace\",\n    schema: [{\n      enum: [\"always\", \"never\"]\n    }, {\n      type: \"object\",\n      properties: {\n        arraysInObjects: {\n          type: \"boolean\"\n        },\n        objectsInObjects: {\n          type: \"boolean\"\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      requireSpaceBefore: \"A space is required before '{{token}}'.\",\n      requireSpaceAfter: \"A space is required after '{{token}}'.\",\n      unexpectedSpaceBefore: \"There should be no space before '{{token}}'.\",\n      unexpectedSpaceAfter: \"There should be no space after '{{token}}'.\"\n    }\n  },\n\n  create(context) {\n    const spaced = context.options[0] === \"always\",\n          sourceCode = context.getSourceCode();\n\n    function isOptionSet(option) {\n      return context.options[1] ? context.options[1][option] === !spaced : false;\n    }\n\n    const options = {\n      spaced,\n      arraysInObjectsException: isOptionSet(\"arraysInObjects\"),\n      objectsInObjectsException: isOptionSet(\"objectsInObjects\")\n    };\n\n    function reportNoBeginningSpace(node, token) {\n      const nextToken = context.getSourceCode().getTokenAfter(token, {\n        includeComments: true\n      });\n      context.report({\n        node,\n        loc: {\n          start: token.loc.end,\n          end: nextToken.loc.start\n        },\n        messageId: \"unexpectedSpaceAfter\",\n        data: {\n          token: token.value\n        },\n\n        fix(fixer) {\n          return fixer.removeRange([token.range[1], nextToken.range[0]]);\n        }\n\n      });\n    }\n\n    function reportNoEndingSpace(node, token) {\n      const previousToken = context.getSourceCode().getTokenBefore(token, {\n        includeComments: true\n      });\n      context.report({\n        node,\n        loc: {\n          start: previousToken.loc.end,\n          end: token.loc.start\n        },\n        messageId: \"unexpectedSpaceBefore\",\n        data: {\n          token: token.value\n        },\n\n        fix(fixer) {\n          return fixer.removeRange([previousToken.range[1], token.range[0]]);\n        }\n\n      });\n    }\n\n    function reportRequiredBeginningSpace(node, token) {\n      context.report({\n        node,\n        loc: token.loc,\n        messageId: \"requireSpaceAfter\",\n        data: {\n          token: token.value\n        },\n\n        fix(fixer) {\n          return fixer.insertTextAfter(token, \" \");\n        }\n\n      });\n    }\n\n    function reportRequiredEndingSpace(node, token) {\n      context.report({\n        node,\n        loc: token.loc,\n        messageId: \"requireSpaceBefore\",\n        data: {\n          token: token.value\n        },\n\n        fix(fixer) {\n          return fixer.insertTextBefore(token, \" \");\n        }\n\n      });\n    }\n\n    function validateBraceSpacing(node, first, second, penultimate, last) {\n      if (astUtils.isTokenOnSameLine(first, second)) {\n        const firstSpaced = sourceCode.isSpaceBetweenTokens(first, second);\n\n        if (options.spaced && !firstSpaced) {\n          reportRequiredBeginningSpace(node, first);\n        }\n\n        if (!options.spaced && firstSpaced && second.type !== \"Line\") {\n          reportNoBeginningSpace(node, first);\n        }\n      }\n\n      if (astUtils.isTokenOnSameLine(penultimate, last)) {\n        const shouldCheckPenultimate = options.arraysInObjectsException && astUtils.isClosingBracketToken(penultimate) || options.objectsInObjectsException && astUtils.isClosingBraceToken(penultimate);\n        const penultimateType = shouldCheckPenultimate && sourceCode.getNodeByRangeIndex(penultimate.range[0]).type;\n        const closingCurlyBraceMustBeSpaced = options.arraysInObjectsException && penultimateType === \"ArrayExpression\" || options.objectsInObjectsException && (penultimateType === \"ObjectExpression\" || penultimateType === \"ObjectPattern\") ? !options.spaced : options.spaced;\n        const lastSpaced = sourceCode.isSpaceBetweenTokens(penultimate, last);\n\n        if (closingCurlyBraceMustBeSpaced && !lastSpaced) {\n          reportRequiredEndingSpace(node, last);\n        }\n\n        if (!closingCurlyBraceMustBeSpaced && lastSpaced) {\n          reportNoEndingSpace(node, last);\n        }\n      }\n    }\n\n    function getClosingBraceOfObject(node) {\n      const lastProperty = node.properties[node.properties.length - 1];\n      return sourceCode.getTokenAfter(lastProperty, astUtils.isClosingBraceToken);\n    }\n\n    function checkForObject(node) {\n      if (node.properties.length === 0) {\n        return;\n      }\n\n      const first = sourceCode.getFirstToken(node),\n            last = getClosingBraceOfObject(node),\n            second = sourceCode.getTokenAfter(first, {\n        includeComments: true\n      }),\n            penultimate = sourceCode.getTokenBefore(last, {\n        includeComments: true\n      });\n      validateBraceSpacing(node, first, second, penultimate, last);\n    }\n\n    return {\n      ObjectPattern: checkForObject,\n      ObjectExpression: checkForObject,\n      ImportDeclaration: function (node) {\n        if (node.specifiers.length === 0) {\n          return;\n        }\n\n        let firstSpecifier = node.specifiers[0];\n        const lastSpecifier = node.specifiers[node.specifiers.length - 1];\n\n        if (lastSpecifier.type !== \"ImportSpecifier\") {\n          return;\n        }\n\n        if (firstSpecifier.type !== \"ImportSpecifier\") {\n          firstSpecifier = node.specifiers[1];\n        }\n\n        const first = sourceCode.getTokenBefore(firstSpecifier),\n              last = sourceCode.getTokenAfter(lastSpecifier, astUtils.isNotCommaToken),\n              second = sourceCode.getTokenAfter(first, {\n          includeComments: true\n        }),\n              penultimate = sourceCode.getTokenBefore(last, {\n          includeComments: true\n        });\n        validateBraceSpacing(node, first, second, penultimate, last);\n      },\n      ExportNamedDeclaration: function (node) {\n        if (node.specifiers.length === 0) {\n          return;\n        }\n\n        const firstSpecifier = node.specifiers[0],\n              lastSpecifier = node.specifiers[node.specifiers.length - 1],\n              first = sourceCode.getTokenBefore(firstSpecifier),\n              last = sourceCode.getTokenAfter(lastSpecifier, astUtils.isNotCommaToken),\n              second = sourceCode.getTokenAfter(first, {\n          includeComments: true\n        }),\n              penultimate = sourceCode.getTokenBefore(last, {\n          includeComments: true\n        });\n        validateBraceSpacing(node, first, second, penultimate, last);\n      }\n    };\n  }\n\n};\nobjectCurlySpacing.meta;\nobjectCurlySpacing.create;\nvar objectPropertyNewline = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"enforce placing object properties on separate lines\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/object-property-newline\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        allowAllPropertiesOnSameLine: {\n          type: \"boolean\",\n          default: false\n        },\n        allowMultiplePropertiesPerLine: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    fixable: \"whitespace\",\n    messages: {\n      propertiesOnNewlineAll: \"Object properties must go on a new line if they aren't all on the same line.\",\n      propertiesOnNewline: \"Object properties must go on a new line.\"\n    }\n  },\n\n  create(context) {\n    const allowSameLine = context.options[0] && (context.options[0].allowAllPropertiesOnSameLine || context.options[0].allowMultiplePropertiesPerLine);\n    const messageId = allowSameLine ? \"propertiesOnNewlineAll\" : \"propertiesOnNewline\";\n    const sourceCode = context.getSourceCode();\n    return {\n      ObjectExpression(node) {\n        if (allowSameLine) {\n          if (node.properties.length > 1) {\n            const firstTokenOfFirstProperty = sourceCode.getFirstToken(node.properties[0]);\n            const lastTokenOfLastProperty = sourceCode.getLastToken(node.properties[node.properties.length - 1]);\n\n            if (firstTokenOfFirstProperty.loc.end.line === lastTokenOfLastProperty.loc.start.line) {\n              return;\n            }\n          }\n        }\n\n        for (let i = 1; i < node.properties.length; i++) {\n          const lastTokenOfPreviousProperty = sourceCode.getLastToken(node.properties[i - 1]);\n          const firstTokenOfCurrentProperty = sourceCode.getFirstToken(node.properties[i]);\n\n          if (lastTokenOfPreviousProperty.loc.end.line === firstTokenOfCurrentProperty.loc.start.line) {\n            context.report({\n              node,\n              loc: firstTokenOfCurrentProperty.loc,\n              messageId,\n\n              fix(fixer) {\n                const comma = sourceCode.getTokenBefore(firstTokenOfCurrentProperty);\n                const rangeAfterComma = [comma.range[1], firstTokenOfCurrentProperty.range[0]];\n\n                if (sourceCode.text.slice(rangeAfterComma[0], rangeAfterComma[1]).trim()) {\n                  return null;\n                }\n\n                return fixer.replaceTextRange(rangeAfterComma, \"\\n\");\n              }\n\n            });\n          }\n        }\n      }\n\n    };\n  }\n\n};\nobjectPropertyNewline.meta;\nobjectPropertyNewline.create;\nconst OPTIONS = {\n  always: \"always\",\n  never: \"never\",\n  methods: \"methods\",\n  properties: \"properties\",\n  consistent: \"consistent\",\n  consistentAsNeeded: \"consistent-as-needed\"\n};\nvar objectShorthand = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"require or disallow method and property shorthand syntax for object literals\",\n      category: \"ECMAScript 6\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/object-shorthand\"\n    },\n    fixable: \"code\",\n    schema: {\n      anyOf: [{\n        type: \"array\",\n        items: [{\n          enum: [\"always\", \"methods\", \"properties\", \"never\", \"consistent\", \"consistent-as-needed\"]\n        }],\n        minItems: 0,\n        maxItems: 1\n      }, {\n        type: \"array\",\n        items: [{\n          enum: [\"always\", \"methods\", \"properties\"]\n        }, {\n          type: \"object\",\n          properties: {\n            avoidQuotes: {\n              type: \"boolean\"\n            }\n          },\n          additionalProperties: false\n        }],\n        minItems: 0,\n        maxItems: 2\n      }, {\n        type: \"array\",\n        items: [{\n          enum: [\"always\", \"methods\"]\n        }, {\n          type: \"object\",\n          properties: {\n            ignoreConstructors: {\n              type: \"boolean\"\n            },\n            avoidQuotes: {\n              type: \"boolean\"\n            },\n            avoidExplicitReturnArrows: {\n              type: \"boolean\"\n            }\n          },\n          additionalProperties: false\n        }],\n        minItems: 0,\n        maxItems: 2\n      }]\n    },\n    messages: {\n      expectedAllPropertiesShorthanded: \"Expected shorthand for all properties.\",\n      expectedLiteralMethodLongform: \"Expected longform method syntax for string literal keys.\",\n      expectedPropertyShorthand: \"Expected property shorthand.\",\n      expectedPropertyLongform: \"Expected longform property syntax.\",\n      expectedMethodShorthand: \"Expected method shorthand.\",\n      expectedMethodLongform: \"Expected longform method syntax.\",\n      unexpectedMix: \"Unexpected mix of shorthand and non-shorthand properties.\"\n    }\n  },\n\n  create(context) {\n    const APPLY = context.options[0] || OPTIONS.always;\n    const APPLY_TO_METHODS = APPLY === OPTIONS.methods || APPLY === OPTIONS.always;\n    const APPLY_TO_PROPS = APPLY === OPTIONS.properties || APPLY === OPTIONS.always;\n    const APPLY_NEVER = APPLY === OPTIONS.never;\n    const APPLY_CONSISTENT = APPLY === OPTIONS.consistent;\n    const APPLY_CONSISTENT_AS_NEEDED = APPLY === OPTIONS.consistentAsNeeded;\n    const PARAMS = context.options[1] || {};\n    const IGNORE_CONSTRUCTORS = PARAMS.ignoreConstructors;\n    const AVOID_QUOTES = PARAMS.avoidQuotes;\n    const AVOID_EXPLICIT_RETURN_ARROWS = !!PARAMS.avoidExplicitReturnArrows;\n    const sourceCode = context.getSourceCode();\n\n    function isConstructor(name) {\n      const match = /[^_$0-9]/u.exec(name);\n\n      if (!match) {\n        return false;\n      }\n\n      const firstChar = name.charAt(match.index);\n      return firstChar === firstChar.toUpperCase();\n    }\n\n    function canHaveShorthand(property) {\n      return property.kind !== \"set\" && property.kind !== \"get\" && property.type !== \"SpreadElement\" && property.type !== \"SpreadProperty\" && property.type !== \"ExperimentalSpreadProperty\";\n    }\n\n    function isStringLiteral(node) {\n      return node.type === \"Literal\" && typeof node.value === \"string\";\n    }\n\n    function isShorthand(property) {\n      return property.shorthand || property.method;\n    }\n\n    function isRedundant(property) {\n      const value = property.value;\n\n      if (value.type === \"FunctionExpression\") {\n        return !value.id;\n      }\n\n      if (value.type === \"Identifier\") {\n        return astUtils.getStaticPropertyName(property) === value.name;\n      }\n\n      return false;\n    }\n\n    function checkConsistency(node, checkRedundancy) {\n      const properties = node.properties.filter(canHaveShorthand);\n\n      if (properties.length > 0) {\n        const shorthandProperties = properties.filter(isShorthand);\n\n        if (shorthandProperties.length !== properties.length) {\n          if (shorthandProperties.length > 0) {\n            context.report({\n              node,\n              messageId: \"unexpectedMix\"\n            });\n          } else if (checkRedundancy) {\n            const canAlwaysUseShorthand = properties.every(isRedundant);\n\n            if (canAlwaysUseShorthand) {\n              context.report({\n                node,\n                messageId: \"expectedAllPropertiesShorthanded\"\n              });\n            }\n          }\n        }\n      }\n    }\n\n    function makeFunctionShorthand(fixer, node) {\n      const firstKeyToken = node.computed ? sourceCode.getFirstToken(node, astUtils.isOpeningBracketToken) : sourceCode.getFirstToken(node.key);\n      const lastKeyToken = node.computed ? sourceCode.getFirstTokenBetween(node.key, node.value, astUtils.isClosingBracketToken) : sourceCode.getLastToken(node.key);\n      const keyText = sourceCode.text.slice(firstKeyToken.range[0], lastKeyToken.range[1]);\n      let keyPrefix = \"\";\n\n      if (sourceCode.commentsExistBetween(lastKeyToken, node.value)) {\n        return null;\n      }\n\n      if (node.value.async) {\n        keyPrefix += \"async \";\n      }\n\n      if (node.value.generator) {\n        keyPrefix += \"*\";\n      }\n\n      const fixRange = [firstKeyToken.range[0], node.range[1]];\n      const methodPrefix = keyPrefix + keyText;\n\n      if (node.value.type === \"FunctionExpression\") {\n        const functionToken = sourceCode.getTokens(node.value).find(token => token.type === \"Keyword\" && token.value === \"function\");\n        const tokenBeforeParams = node.value.generator ? sourceCode.getTokenAfter(functionToken) : functionToken;\n        return fixer.replaceTextRange(fixRange, methodPrefix + sourceCode.text.slice(tokenBeforeParams.range[1], node.value.range[1]));\n      }\n\n      const arrowToken = sourceCode.getTokenBefore(node.value.body, astUtils.isArrowToken);\n      const fnBody = sourceCode.text.slice(arrowToken.range[1], node.value.range[1]);\n      let shouldAddParensAroundParameters = false;\n      let tokenBeforeParams;\n\n      if (node.value.params.length === 0) {\n        tokenBeforeParams = sourceCode.getFirstToken(node.value, astUtils.isOpeningParenToken);\n      } else {\n        tokenBeforeParams = sourceCode.getTokenBefore(node.value.params[0]);\n      }\n\n      if (node.value.params.length === 1) {\n        const hasParen = astUtils.isOpeningParenToken(tokenBeforeParams);\n        const isTokenOutsideNode = tokenBeforeParams.range[0] < node.range[0];\n        shouldAddParensAroundParameters = !hasParen || isTokenOutsideNode;\n      }\n\n      const sliceStart = shouldAddParensAroundParameters ? node.value.params[0].range[0] : tokenBeforeParams.range[0];\n      const sliceEnd = sourceCode.getTokenBefore(arrowToken).range[1];\n      const oldParamText = sourceCode.text.slice(sliceStart, sliceEnd);\n      const newParamText = shouldAddParensAroundParameters ? `(${oldParamText})` : oldParamText;\n      return fixer.replaceTextRange(fixRange, methodPrefix + newParamText + fnBody);\n    }\n\n    function makeFunctionLongform(fixer, node) {\n      const firstKeyToken = node.computed ? sourceCode.getTokens(node).find(token => token.value === \"[\") : sourceCode.getFirstToken(node.key);\n      const lastKeyToken = node.computed ? sourceCode.getTokensBetween(node.key, node.value).find(token => token.value === \"]\") : sourceCode.getLastToken(node.key);\n      const keyText = sourceCode.text.slice(firstKeyToken.range[0], lastKeyToken.range[1]);\n      let functionHeader = \"function\";\n\n      if (node.value.async) {\n        functionHeader = `async ${functionHeader}`;\n      }\n\n      if (node.value.generator) {\n        functionHeader = `${functionHeader}*`;\n      }\n\n      return fixer.replaceTextRange([node.range[0], lastKeyToken.range[1]], `${keyText}: ${functionHeader}`);\n    }\n\n    const lexicalScopeStack = [];\n    const arrowsWithLexicalIdentifiers = new WeakSet();\n    const argumentsIdentifiers = new WeakSet();\n\n    function enterFunction() {\n      lexicalScopeStack.unshift(new Set());\n      context.getScope().variables.filter(variable => variable.name === \"arguments\").forEach(variable => {\n        variable.references.map(ref => ref.identifier).forEach(identifier => argumentsIdentifiers.add(identifier));\n      });\n    }\n\n    function exitFunction() {\n      lexicalScopeStack.shift();\n    }\n\n    function reportLexicalIdentifier() {\n      lexicalScopeStack[0].forEach(arrowFunction => arrowsWithLexicalIdentifiers.add(arrowFunction));\n    }\n\n    return {\n      Program: enterFunction,\n      FunctionDeclaration: enterFunction,\n      FunctionExpression: enterFunction,\n      \"Program:exit\": exitFunction,\n      \"FunctionDeclaration:exit\": exitFunction,\n      \"FunctionExpression:exit\": exitFunction,\n\n      ArrowFunctionExpression(node) {\n        lexicalScopeStack[0].add(node);\n      },\n\n      \"ArrowFunctionExpression:exit\"(node) {\n        lexicalScopeStack[0].delete(node);\n      },\n\n      ThisExpression: reportLexicalIdentifier,\n      Super: reportLexicalIdentifier,\n\n      MetaProperty(node) {\n        if (node.meta.name === \"new\" && node.property.name === \"target\") {\n          reportLexicalIdentifier();\n        }\n      },\n\n      Identifier(node) {\n        if (argumentsIdentifiers.has(node)) {\n          reportLexicalIdentifier();\n        }\n      },\n\n      ObjectExpression(node) {\n        if (APPLY_CONSISTENT) {\n          checkConsistency(node, false);\n        } else if (APPLY_CONSISTENT_AS_NEEDED) {\n          checkConsistency(node, true);\n        }\n      },\n\n      \"Property:exit\"(node) {\n        const isConciseProperty = node.method || node.shorthand;\n\n        if (node.parent.type === \"ObjectPattern\") {\n          return;\n        }\n\n        if (node.kind === \"get\" || node.kind === \"set\") {\n          return;\n        }\n\n        if (node.computed && node.value.type !== \"FunctionExpression\" && node.value.type !== \"ArrowFunctionExpression\") {\n          return;\n        }\n\n        if (isConciseProperty) {\n          if (node.method && (APPLY_NEVER || AVOID_QUOTES && isStringLiteral(node.key))) {\n            const messageId = APPLY_NEVER ? \"expectedMethodLongform\" : \"expectedLiteralMethodLongform\";\n            context.report({\n              node,\n              messageId,\n              fix: fixer => makeFunctionLongform(fixer, node)\n            });\n          } else if (APPLY_NEVER) {\n            context.report({\n              node,\n              messageId: \"expectedPropertyLongform\",\n              fix: fixer => fixer.insertTextAfter(node.key, `: ${node.key.name}`)\n            });\n          }\n        } else if (APPLY_TO_METHODS && !node.value.id && (node.value.type === \"FunctionExpression\" || node.value.type === \"ArrowFunctionExpression\")) {\n          if (IGNORE_CONSTRUCTORS && node.key.type === \"Identifier\" && isConstructor(node.key.name)) {\n            return;\n          }\n\n          if (AVOID_QUOTES && isStringLiteral(node.key)) {\n            return;\n          }\n\n          if (node.value.type === \"FunctionExpression\" || node.value.type === \"ArrowFunctionExpression\" && node.value.body.type === \"BlockStatement\" && AVOID_EXPLICIT_RETURN_ARROWS && !arrowsWithLexicalIdentifiers.has(node.value)) {\n            context.report({\n              node,\n              messageId: \"expectedMethodShorthand\",\n              fix: fixer => makeFunctionShorthand(fixer, node)\n            });\n          }\n        } else if (node.value.type === \"Identifier\" && node.key.name === node.value.name && APPLY_TO_PROPS) {\n          context.report({\n            node,\n            messageId: \"expectedPropertyShorthand\",\n\n            fix(fixer) {\n              return fixer.replaceText(node, node.value.name);\n            }\n\n          });\n        } else if (node.value.type === \"Identifier\" && node.key.type === \"Literal\" && node.key.value === node.value.name && APPLY_TO_PROPS) {\n          if (AVOID_QUOTES) {\n            return;\n          }\n\n          context.report({\n            node,\n            messageId: \"expectedPropertyShorthand\",\n\n            fix(fixer) {\n              return fixer.replaceText(node, node.value.name);\n            }\n\n          });\n        }\n      }\n\n    };\n  }\n\n};\nobjectShorthand.meta;\nobjectShorthand.create;\nvar oneVarDeclarationPerLine = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"require or disallow newlines around variable declarations\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/one-var-declaration-per-line\"\n    },\n    schema: [{\n      enum: [\"always\", \"initializations\"]\n    }],\n    fixable: \"whitespace\",\n    messages: {\n      expectVarOnNewline: \"Expected variable declaration to be on a new line.\"\n    }\n  },\n\n  create(context) {\n    const always = context.options[0] === \"always\";\n\n    function isForTypeSpecifier(keyword) {\n      return keyword === \"ForStatement\" || keyword === \"ForInStatement\" || keyword === \"ForOfStatement\";\n    }\n\n    return {\n      VariableDeclaration: function (node) {\n        if (isForTypeSpecifier(node.parent.type)) {\n          return;\n        }\n\n        const declarations = node.declarations;\n        let prev;\n        declarations.forEach(current => {\n          if (prev && prev.loc.end.line === current.loc.start.line) {\n            if (always || prev.init || current.init) {\n              context.report({\n                node,\n                messageId: \"expectVarOnNewline\",\n                loc: current.loc,\n                fix: fixer => fixer.insertTextBefore(current, \"\\n\")\n              });\n            }\n          }\n\n          prev = current;\n        });\n      }\n    };\n  }\n\n};\noneVarDeclarationPerLine.meta;\noneVarDeclarationPerLine.create;\n\nfunction isInStatementList(node) {\n  return astUtils.STATEMENT_LIST_PARENTS.has(node.parent.type);\n}\n\nvar oneVar = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"enforce variables to be declared either together or separately in functions\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/one-var\"\n    },\n    fixable: \"code\",\n    schema: [{\n      oneOf: [{\n        enum: [\"always\", \"never\", \"consecutive\"]\n      }, {\n        type: \"object\",\n        properties: {\n          separateRequires: {\n            type: \"boolean\"\n          },\n          var: {\n            enum: [\"always\", \"never\", \"consecutive\"]\n          },\n          let: {\n            enum: [\"always\", \"never\", \"consecutive\"]\n          },\n          const: {\n            enum: [\"always\", \"never\", \"consecutive\"]\n          }\n        },\n        additionalProperties: false\n      }, {\n        type: \"object\",\n        properties: {\n          initialized: {\n            enum: [\"always\", \"never\", \"consecutive\"]\n          },\n          uninitialized: {\n            enum: [\"always\", \"never\", \"consecutive\"]\n          }\n        },\n        additionalProperties: false\n      }]\n    }],\n    messages: {\n      combineUninitialized: \"Combine this with the previous '{{type}}' statement with uninitialized variables.\",\n      combineInitialized: \"Combine this with the previous '{{type}}' statement with initialized variables.\",\n      splitUninitialized: \"Split uninitialized '{{type}}' declarations into multiple statements.\",\n      splitInitialized: \"Split initialized '{{type}}' declarations into multiple statements.\",\n      splitRequires: \"Split requires to be separated into a single block.\",\n      combine: \"Combine this with the previous '{{type}}' statement.\",\n      split: \"Split '{{type}}' declarations into multiple statements.\"\n    }\n  },\n\n  create(context) {\n    const MODE_ALWAYS = \"always\";\n    const MODE_NEVER = \"never\";\n    const MODE_CONSECUTIVE = \"consecutive\";\n    const mode = context.options[0] || \"always\";\n    const options = {};\n\n    if (typeof mode === \"string\") {\n      options.var = {\n        uninitialized: mode,\n        initialized: mode\n      };\n      options.let = {\n        uninitialized: mode,\n        initialized: mode\n      };\n      options.const = {\n        uninitialized: mode,\n        initialized: mode\n      };\n    } else if (typeof mode === \"object\") {\n      options.separateRequires = !!mode.separateRequires;\n      options.var = {\n        uninitialized: mode.var,\n        initialized: mode.var\n      };\n      options.let = {\n        uninitialized: mode.let,\n        initialized: mode.let\n      };\n      options.const = {\n        uninitialized: mode.const,\n        initialized: mode.const\n      };\n\n      if (Object.prototype.hasOwnProperty.call(mode, \"uninitialized\")) {\n        options.var.uninitialized = mode.uninitialized;\n        options.let.uninitialized = mode.uninitialized;\n        options.const.uninitialized = mode.uninitialized;\n      }\n\n      if (Object.prototype.hasOwnProperty.call(mode, \"initialized\")) {\n        options.var.initialized = mode.initialized;\n        options.let.initialized = mode.initialized;\n        options.const.initialized = mode.initialized;\n      }\n    }\n\n    const sourceCode = context.getSourceCode();\n    const functionStack = [];\n    const blockStack = [];\n\n    function startBlock() {\n      blockStack.push({\n        let: {\n          initialized: false,\n          uninitialized: false\n        },\n        const: {\n          initialized: false,\n          uninitialized: false\n        }\n      });\n    }\n\n    function startFunction() {\n      functionStack.push({\n        initialized: false,\n        uninitialized: false\n      });\n      startBlock();\n    }\n\n    function endBlock() {\n      blockStack.pop();\n    }\n\n    function endFunction() {\n      functionStack.pop();\n      endBlock();\n    }\n\n    function isRequire(decl) {\n      return decl.init && decl.init.type === \"CallExpression\" && decl.init.callee.name === \"require\";\n    }\n\n    function recordTypes(statementType, declarations, currentScope) {\n      for (let i = 0; i < declarations.length; i++) {\n        if (declarations[i].init === null) {\n          if (options[statementType] && options[statementType].uninitialized === MODE_ALWAYS) {\n            currentScope.uninitialized = true;\n          }\n        } else {\n          if (options[statementType] && options[statementType].initialized === MODE_ALWAYS) {\n            if (options.separateRequires && isRequire(declarations[i])) {\n              currentScope.required = true;\n            } else {\n              currentScope.initialized = true;\n            }\n          }\n        }\n      }\n    }\n\n    function getCurrentScope(statementType) {\n      let currentScope;\n\n      if (statementType === \"var\") {\n        currentScope = functionStack[functionStack.length - 1];\n      } else if (statementType === \"let\") {\n        currentScope = blockStack[blockStack.length - 1].let;\n      } else if (statementType === \"const\") {\n        currentScope = blockStack[blockStack.length - 1].const;\n      }\n\n      return currentScope;\n    }\n\n    function countDeclarations(declarations) {\n      const counts = {\n        uninitialized: 0,\n        initialized: 0\n      };\n\n      for (let i = 0; i < declarations.length; i++) {\n        if (declarations[i].init === null) {\n          counts.uninitialized++;\n        } else {\n          counts.initialized++;\n        }\n      }\n\n      return counts;\n    }\n\n    function hasOnlyOneStatement(statementType, declarations) {\n      const declarationCounts = countDeclarations(declarations);\n      const currentOptions = options[statementType] || {};\n      const currentScope = getCurrentScope(statementType);\n      const hasRequires = declarations.some(isRequire);\n\n      if (currentOptions.uninitialized === MODE_ALWAYS && currentOptions.initialized === MODE_ALWAYS) {\n        if (currentScope.uninitialized || currentScope.initialized) {\n          if (!hasRequires) {\n            return false;\n          }\n        }\n      }\n\n      if (declarationCounts.uninitialized > 0) {\n        if (currentOptions.uninitialized === MODE_ALWAYS && currentScope.uninitialized) {\n          return false;\n        }\n      }\n\n      if (declarationCounts.initialized > 0) {\n        if (currentOptions.initialized === MODE_ALWAYS && currentScope.initialized) {\n          if (!hasRequires) {\n            return false;\n          }\n        }\n      }\n\n      if (currentScope.required && hasRequires) {\n        return false;\n      }\n\n      recordTypes(statementType, declarations, currentScope);\n      return true;\n    }\n\n    function joinDeclarations(declarations) {\n      const declaration = declarations[0];\n      const body = Array.isArray(declaration.parent.parent.body) ? declaration.parent.parent.body : [];\n      const currentIndex = body.findIndex(node => node.range[0] === declaration.parent.range[0]);\n      const previousNode = body[currentIndex - 1];\n      return fixer => {\n        const type = sourceCode.getTokenBefore(declaration);\n        const prevSemi = sourceCode.getTokenBefore(type);\n        const res = [];\n\n        if (previousNode && previousNode.kind === sourceCode.getText(type)) {\n          if (prevSemi.value === \";\") {\n            res.push(fixer.replaceText(prevSemi, \",\"));\n          } else {\n            res.push(fixer.insertTextAfter(prevSemi, \",\"));\n          }\n\n          res.push(fixer.replaceText(type, \"\"));\n        }\n\n        return res;\n      };\n    }\n\n    function splitDeclarations(declaration) {\n      const {\n        parent\n      } = declaration;\n\n      if (!isInStatementList(parent.type === \"ExportNamedDeclaration\" ? parent : declaration)) {\n        return null;\n      }\n\n      return fixer => declaration.declarations.map(declarator => {\n        const tokenAfterDeclarator = sourceCode.getTokenAfter(declarator);\n\n        if (tokenAfterDeclarator === null) {\n          return null;\n        }\n\n        const afterComma = sourceCode.getTokenAfter(tokenAfterDeclarator, {\n          includeComments: true\n        });\n\n        if (tokenAfterDeclarator.value !== \",\") {\n          return null;\n        }\n\n        const exportPlacement = declaration.parent.type === \"ExportNamedDeclaration\" ? \"export \" : \"\";\n\n        if (afterComma.range[0] === tokenAfterDeclarator.range[1]) {\n          return fixer.replaceText(tokenAfterDeclarator, `; ${exportPlacement}${declaration.kind} `);\n        }\n\n        if (afterComma.loc.start.line > tokenAfterDeclarator.loc.end.line || afterComma.type === \"Line\" || afterComma.type === \"Block\") {\n          let lastComment = afterComma;\n\n          while (lastComment.type === \"Line\" || lastComment.type === \"Block\") {\n            lastComment = sourceCode.getTokenAfter(lastComment, {\n              includeComments: true\n            });\n          }\n\n          return fixer.replaceTextRange([tokenAfterDeclarator.range[0], lastComment.range[0]], `;${sourceCode.text.slice(tokenAfterDeclarator.range[1], lastComment.range[0])}${exportPlacement}${declaration.kind} `);\n        }\n\n        return fixer.replaceText(tokenAfterDeclarator, `; ${exportPlacement}${declaration.kind}`);\n      }).filter(x => x);\n    }\n\n    return {\n      Program: startFunction,\n      FunctionDeclaration: startFunction,\n      FunctionExpression: startFunction,\n      ArrowFunctionExpression: startFunction,\n      BlockStatement: startBlock,\n      ForStatement: startBlock,\n      ForInStatement: startBlock,\n      ForOfStatement: startBlock,\n      SwitchStatement: startBlock,\n      VariableDeclaration: function (node) {\n        const parent = node.parent;\n        const type = node.kind;\n\n        if (!options[type]) {\n          return;\n        }\n\n        const declarations = node.declarations;\n        const declarationCounts = countDeclarations(declarations);\n        const mixedRequires = declarations.some(isRequire) && !declarations.every(isRequire);\n\n        if (options[type].initialized === MODE_ALWAYS) {\n          if (options.separateRequires && mixedRequires) {\n            context.report({\n              node,\n              messageId: \"splitRequires\"\n            });\n          }\n        }\n\n        const nodeIndex = parent.body && parent.body.length > 0 && parent.body.indexOf(node) || 0;\n\n        if (nodeIndex > 0) {\n          const previousNode = parent.body[nodeIndex - 1];\n          const isPreviousNodeDeclaration = previousNode.type === \"VariableDeclaration\";\n          const declarationsWithPrevious = declarations.concat(previousNode.declarations || []);\n\n          if (isPreviousNodeDeclaration && previousNode.kind === type && !(declarationsWithPrevious.some(isRequire) && !declarationsWithPrevious.every(isRequire))) {\n            const previousDeclCounts = countDeclarations(previousNode.declarations);\n\n            if (options[type].initialized === MODE_CONSECUTIVE && options[type].uninitialized === MODE_CONSECUTIVE) {\n              context.report({\n                node,\n                messageId: \"combine\",\n                data: {\n                  type\n                },\n                fix: joinDeclarations(declarations)\n              });\n            } else if (options[type].initialized === MODE_CONSECUTIVE && declarationCounts.initialized > 0 && previousDeclCounts.initialized > 0) {\n              context.report({\n                node,\n                messageId: \"combineInitialized\",\n                data: {\n                  type\n                },\n                fix: joinDeclarations(declarations)\n              });\n            } else if (options[type].uninitialized === MODE_CONSECUTIVE && declarationCounts.uninitialized > 0 && previousDeclCounts.uninitialized > 0) {\n              context.report({\n                node,\n                messageId: \"combineUninitialized\",\n                data: {\n                  type\n                },\n                fix: joinDeclarations(declarations)\n              });\n            }\n          }\n        }\n\n        if (!hasOnlyOneStatement(type, declarations)) {\n          if (options[type].initialized === MODE_ALWAYS && options[type].uninitialized === MODE_ALWAYS) {\n            context.report({\n              node,\n              messageId: \"combine\",\n              data: {\n                type\n              },\n              fix: joinDeclarations(declarations)\n            });\n          } else {\n            if (options[type].initialized === MODE_ALWAYS && declarationCounts.initialized > 0) {\n              context.report({\n                node,\n                messageId: \"combineInitialized\",\n                data: {\n                  type\n                },\n                fix: joinDeclarations(declarations)\n              });\n            }\n\n            if (options[type].uninitialized === MODE_ALWAYS && declarationCounts.uninitialized > 0) {\n              if (node.parent.left === node && (node.parent.type === \"ForInStatement\" || node.parent.type === \"ForOfStatement\")) {\n                return;\n              }\n\n              context.report({\n                node,\n                messageId: \"combineUninitialized\",\n                data: {\n                  type\n                },\n                fix: joinDeclarations(declarations)\n              });\n            }\n          }\n        }\n\n        if (parent.type !== \"ForStatement\" || parent.init !== node) {\n          const totalDeclarations = declarationCounts.uninitialized + declarationCounts.initialized;\n\n          if (totalDeclarations > 1) {\n            if (options[type].initialized === MODE_NEVER && options[type].uninitialized === MODE_NEVER) {\n              context.report({\n                node,\n                messageId: \"split\",\n                data: {\n                  type\n                },\n                fix: splitDeclarations(node)\n              });\n            } else if (options[type].initialized === MODE_NEVER && declarationCounts.initialized > 0) {\n              context.report({\n                node,\n                messageId: \"splitInitialized\",\n                data: {\n                  type\n                },\n                fix: splitDeclarations(node)\n              });\n            } else if (options[type].uninitialized === MODE_NEVER && declarationCounts.uninitialized > 0) {\n              context.report({\n                node,\n                messageId: \"splitUninitialized\",\n                data: {\n                  type\n                },\n                fix: splitDeclarations(node)\n              });\n            }\n          }\n        }\n      },\n      \"ForStatement:exit\": endBlock,\n      \"ForOfStatement:exit\": endBlock,\n      \"ForInStatement:exit\": endBlock,\n      \"SwitchStatement:exit\": endBlock,\n      \"BlockStatement:exit\": endBlock,\n      \"Program:exit\": endFunction,\n      \"FunctionDeclaration:exit\": endFunction,\n      \"FunctionExpression:exit\": endFunction,\n      \"ArrowFunctionExpression:exit\": endFunction\n    };\n  }\n\n};\noneVar.meta;\noneVar.create;\n\nfunction isCommutativeOperatorWithShorthand(operator) {\n  return [\"*\", \"&\", \"^\", \"|\"].indexOf(operator) >= 0;\n}\n\nfunction isNonCommutativeOperatorWithShorthand(operator) {\n  return [\"+\", \"-\", \"/\", \"%\", \"<<\", \">>\", \">>>\", \"**\"].indexOf(operator) >= 0;\n}\n\nfunction canBeFixed(node) {\n  return node.type === \"Identifier\" || node.type === \"MemberExpression\" && (node.object.type === \"Identifier\" || node.object.type === \"ThisExpression\") && (!node.computed || node.property.type === \"Literal\");\n}\n\nvar operatorAssignment = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"require or disallow assignment operator shorthand where possible\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/operator-assignment\"\n    },\n    schema: [{\n      enum: [\"always\", \"never\"]\n    }],\n    fixable: \"code\",\n    messages: {\n      replaced: \"Assignment (=) can be replaced with operator assignment ({{operator}}=).\",\n      unexpected: \"Unexpected operator assignment ({{operator}}=) shorthand.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n\n    function getOperatorToken(node) {\n      return sourceCode.getFirstTokenBetween(node.left, node.right, token => token.value === node.operator);\n    }\n\n    return {\n      AssignmentExpression: context.options[0] !== \"never\" ? function (node) {\n        if (node.operator !== \"=\" || node.right.type !== \"BinaryExpression\") {\n          return;\n        }\n\n        const left = node.left;\n        const expr = node.right;\n        const operator = expr.operator;\n\n        if (isCommutativeOperatorWithShorthand(operator) || isNonCommutativeOperatorWithShorthand(operator)) {\n          if (astUtils.isSameReference(left, expr.left, true)) {\n            context.report({\n              node,\n              messageId: \"replaced\",\n              data: {\n                operator\n              },\n\n              fix(fixer) {\n                if (canBeFixed(left) && canBeFixed(expr.left)) {\n                  const equalsToken = getOperatorToken(node);\n                  const operatorToken = getOperatorToken(expr);\n                  const leftText = sourceCode.getText().slice(node.range[0], equalsToken.range[0]);\n                  const rightText = sourceCode.getText().slice(operatorToken.range[1], node.right.range[1]);\n\n                  if (sourceCode.commentsExistBetween(equalsToken, operatorToken)) {\n                    return null;\n                  }\n\n                  return fixer.replaceText(node, `${leftText}${expr.operator}=${rightText}`);\n                }\n\n                return null;\n              }\n\n            });\n          } else if (astUtils.isSameReference(left, expr.right, true) && isCommutativeOperatorWithShorthand(operator)) {\n            context.report({\n              node,\n              messageId: \"replaced\",\n              data: {\n                operator\n              }\n            });\n          }\n        }\n      } : function (node) {\n        if (node.operator !== \"=\" && !astUtils.isLogicalAssignmentOperator(node.operator)) {\n          context.report({\n            node,\n            messageId: \"unexpected\",\n            data: {\n              operator: node.operator\n            },\n\n            fix(fixer) {\n              if (canBeFixed(node.left)) {\n                const firstToken = sourceCode.getFirstToken(node);\n                const operatorToken = getOperatorToken(node);\n                const leftText = sourceCode.getText().slice(node.range[0], operatorToken.range[0]);\n                const newOperator = node.operator.slice(0, -1);\n                let rightText;\n\n                if (sourceCode.commentsExistBetween(firstToken, operatorToken)) {\n                  return null;\n                }\n\n                if (astUtils.getPrecedence(node.right) <= astUtils.getPrecedence({\n                  type: \"BinaryExpression\",\n                  operator: newOperator\n                }) && !astUtils.isParenthesised(sourceCode, node.right)) {\n                  rightText = `${sourceCode.text.slice(operatorToken.range[1], node.right.range[0])}(${sourceCode.getText(node.right)})`;\n                } else {\n                  const tokenAfterOperator = sourceCode.getTokenAfter(operatorToken, {\n                    includeComments: true\n                  });\n                  let rightTextPrefix = \"\";\n\n                  if (operatorToken.range[1] === tokenAfterOperator.range[0] && !astUtils.canTokensBeAdjacent({\n                    type: \"Punctuator\",\n                    value: newOperator\n                  }, tokenAfterOperator)) {\n                    rightTextPrefix = \" \";\n                  }\n\n                  rightText = `${rightTextPrefix}${sourceCode.text.slice(operatorToken.range[1], node.range[1])}`;\n                }\n\n                return fixer.replaceText(node, `${leftText}= ${leftText}${newOperator}${rightText}`);\n              }\n\n              return null;\n            }\n\n          });\n        }\n      }\n    };\n  }\n\n};\noperatorAssignment.meta;\noperatorAssignment.create;\nvar operatorLinebreak = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"enforce consistent linebreak style for operators\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/operator-linebreak\"\n    },\n    schema: [{\n      enum: [\"after\", \"before\", \"none\", null]\n    }, {\n      type: \"object\",\n      properties: {\n        overrides: {\n          type: \"object\",\n          additionalProperties: {\n            enum: [\"after\", \"before\", \"none\", \"ignore\"]\n          }\n        }\n      },\n      additionalProperties: false\n    }],\n    fixable: \"code\",\n    messages: {\n      operatorAtBeginning: \"'{{operator}}' should be placed at the beginning of the line.\",\n      operatorAtEnd: \"'{{operator}}' should be placed at the end of the line.\",\n      badLinebreak: \"Bad line breaking before and after '{{operator}}'.\",\n      noLinebreak: \"There should be no line break before or after '{{operator}}'.\"\n    }\n  },\n\n  create(context) {\n    const usedDefaultGlobal = !context.options[0];\n    const globalStyle = context.options[0] || \"after\";\n    const options = context.options[1] || {};\n    const styleOverrides = options.overrides ? Object.assign({}, options.overrides) : {};\n\n    if (usedDefaultGlobal && !styleOverrides[\"?\"]) {\n      styleOverrides[\"?\"] = \"before\";\n    }\n\n    if (usedDefaultGlobal && !styleOverrides[\":\"]) {\n      styleOverrides[\":\"] = \"before\";\n    }\n\n    const sourceCode = context.getSourceCode();\n\n    function getFixer(operatorToken, desiredStyle) {\n      return fixer => {\n        const tokenBefore = sourceCode.getTokenBefore(operatorToken);\n        const tokenAfter = sourceCode.getTokenAfter(operatorToken);\n        const textBefore = sourceCode.text.slice(tokenBefore.range[1], operatorToken.range[0]);\n        const textAfter = sourceCode.text.slice(operatorToken.range[1], tokenAfter.range[0]);\n        const hasLinebreakBefore = !astUtils.isTokenOnSameLine(tokenBefore, operatorToken);\n        const hasLinebreakAfter = !astUtils.isTokenOnSameLine(operatorToken, tokenAfter);\n        let newTextBefore, newTextAfter;\n\n        if (hasLinebreakBefore !== hasLinebreakAfter && desiredStyle !== \"none\") {\n          if (sourceCode.getTokenBefore(operatorToken, {\n            includeComments: true\n          }) !== tokenBefore && sourceCode.getTokenAfter(operatorToken, {\n            includeComments: true\n          }) !== tokenAfter) {\n            return null;\n          }\n\n          newTextBefore = textAfter;\n          newTextAfter = textBefore;\n        } else {\n          const LINEBREAK_REGEX = astUtils.createGlobalLinebreakMatcher();\n          newTextBefore = desiredStyle === \"before\" || textBefore.trim() ? textBefore : textBefore.replace(LINEBREAK_REGEX, \"\");\n          newTextAfter = desiredStyle === \"after\" || textAfter.trim() ? textAfter : textAfter.replace(LINEBREAK_REGEX, \"\");\n\n          if (newTextBefore === textBefore && newTextAfter === textAfter) {\n            return null;\n          }\n        }\n\n        if (newTextAfter === \"\" && tokenAfter.type === \"Punctuator\" && \"+-\".includes(operatorToken.value) && tokenAfter.value === operatorToken.value) {\n          newTextAfter += \" \";\n        }\n\n        return fixer.replaceTextRange([tokenBefore.range[1], tokenAfter.range[0]], newTextBefore + operatorToken.value + newTextAfter);\n      };\n    }\n\n    function validateNode(node, leftSide) {\n      const operatorToken = sourceCode.getTokenAfter(leftSide, astUtils.isNotClosingParenToken);\n      const leftToken = sourceCode.getTokenBefore(operatorToken);\n      const rightToken = sourceCode.getTokenAfter(operatorToken);\n      const operator = operatorToken.value;\n      const operatorStyleOverride = styleOverrides[operator];\n      const style = operatorStyleOverride || globalStyle;\n      const fix = getFixer(operatorToken, style);\n      if (astUtils.isTokenOnSameLine(leftToken, operatorToken) && astUtils.isTokenOnSameLine(operatorToken, rightToken)) ;else if (operatorStyleOverride !== \"ignore\" && !astUtils.isTokenOnSameLine(leftToken, operatorToken) && !astUtils.isTokenOnSameLine(operatorToken, rightToken)) {\n        context.report({\n          node,\n          loc: operatorToken.loc,\n          messageId: \"badLinebreak\",\n          data: {\n            operator\n          },\n          fix\n        });\n      } else if (style === \"before\" && astUtils.isTokenOnSameLine(leftToken, operatorToken)) {\n        context.report({\n          node,\n          loc: operatorToken.loc,\n          messageId: \"operatorAtBeginning\",\n          data: {\n            operator\n          },\n          fix\n        });\n      } else if (style === \"after\" && astUtils.isTokenOnSameLine(operatorToken, rightToken)) {\n        context.report({\n          node,\n          loc: operatorToken.loc,\n          messageId: \"operatorAtEnd\",\n          data: {\n            operator\n          },\n          fix\n        });\n      } else if (style === \"none\") {\n        context.report({\n          node,\n          loc: operatorToken.loc,\n          messageId: \"noLinebreak\",\n          data: {\n            operator\n          },\n          fix\n        });\n      }\n    }\n\n    function validateBinaryExpression(node) {\n      validateNode(node, node.left);\n    }\n\n    return {\n      BinaryExpression: validateBinaryExpression,\n      LogicalExpression: validateBinaryExpression,\n      AssignmentExpression: validateBinaryExpression,\n\n      VariableDeclarator(node) {\n        if (node.init) {\n          validateNode(node, node.id);\n        }\n      },\n\n      ConditionalExpression(node) {\n        validateNode(node, node.test);\n        validateNode(node, node.consequent);\n      }\n\n    };\n  }\n\n};\noperatorLinebreak.meta;\noperatorLinebreak.create;\nvar paddedBlocks = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"require or disallow padding within blocks\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/padded-blocks\"\n    },\n    fixable: \"whitespace\",\n    schema: [{\n      oneOf: [{\n        enum: [\"always\", \"never\"]\n      }, {\n        type: \"object\",\n        properties: {\n          blocks: {\n            enum: [\"always\", \"never\"]\n          },\n          switches: {\n            enum: [\"always\", \"never\"]\n          },\n          classes: {\n            enum: [\"always\", \"never\"]\n          }\n        },\n        additionalProperties: false,\n        minProperties: 1\n      }]\n    }, {\n      type: \"object\",\n      properties: {\n        allowSingleLineBlocks: {\n          type: \"boolean\"\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      alwaysPadBlock: \"Block must be padded by blank lines.\",\n      neverPadBlock: \"Block must not be padded by blank lines.\"\n    }\n  },\n\n  create(context) {\n    const options = {};\n    const typeOptions = context.options[0] || \"always\";\n    const exceptOptions = context.options[1] || {};\n\n    if (typeof typeOptions === \"string\") {\n      const shouldHavePadding = typeOptions === \"always\";\n      options.blocks = shouldHavePadding;\n      options.switches = shouldHavePadding;\n      options.classes = shouldHavePadding;\n    } else {\n      if (Object.prototype.hasOwnProperty.call(typeOptions, \"blocks\")) {\n        options.blocks = typeOptions.blocks === \"always\";\n      }\n\n      if (Object.prototype.hasOwnProperty.call(typeOptions, \"switches\")) {\n        options.switches = typeOptions.switches === \"always\";\n      }\n\n      if (Object.prototype.hasOwnProperty.call(typeOptions, \"classes\")) {\n        options.classes = typeOptions.classes === \"always\";\n      }\n    }\n\n    if (Object.prototype.hasOwnProperty.call(exceptOptions, \"allowSingleLineBlocks\")) {\n      options.allowSingleLineBlocks = exceptOptions.allowSingleLineBlocks === true;\n    }\n\n    const sourceCode = context.getSourceCode();\n\n    function getOpenBrace(node) {\n      if (node.type === \"SwitchStatement\") {\n        return sourceCode.getTokenBefore(node.cases[0]);\n      }\n\n      return sourceCode.getFirstToken(node);\n    }\n\n    function isComment(node) {\n      return node.type === \"Line\" || node.type === \"Block\";\n    }\n\n    function isPaddingBetweenTokens(first, second) {\n      return second.loc.start.line - first.loc.end.line >= 2;\n    }\n\n    function getFirstBlockToken(token) {\n      let prev,\n          first = token;\n\n      do {\n        prev = first;\n        first = sourceCode.getTokenAfter(first, {\n          includeComments: true\n        });\n      } while (isComment(first) && first.loc.start.line === prev.loc.end.line);\n\n      return first;\n    }\n\n    function getLastBlockToken(token) {\n      let last = token,\n          next;\n\n      do {\n        next = last;\n        last = sourceCode.getTokenBefore(last, {\n          includeComments: true\n        });\n      } while (isComment(last) && last.loc.end.line === next.loc.start.line);\n\n      return last;\n    }\n\n    function requirePaddingFor(node) {\n      switch (node.type) {\n        case \"BlockStatement\":\n          return options.blocks;\n\n        case \"SwitchStatement\":\n          return options.switches;\n\n        case \"ClassBody\":\n          return options.classes;\n\n        default:\n          throw new Error(\"unreachable\");\n      }\n    }\n\n    function checkPadding(node) {\n      const openBrace = getOpenBrace(node),\n            firstBlockToken = getFirstBlockToken(openBrace),\n            tokenBeforeFirst = sourceCode.getTokenBefore(firstBlockToken, {\n        includeComments: true\n      }),\n            closeBrace = sourceCode.getLastToken(node),\n            lastBlockToken = getLastBlockToken(closeBrace),\n            tokenAfterLast = sourceCode.getTokenAfter(lastBlockToken, {\n        includeComments: true\n      }),\n            blockHasTopPadding = isPaddingBetweenTokens(tokenBeforeFirst, firstBlockToken),\n            blockHasBottomPadding = isPaddingBetweenTokens(lastBlockToken, tokenAfterLast);\n\n      if (options.allowSingleLineBlocks && astUtils.isTokenOnSameLine(tokenBeforeFirst, tokenAfterLast)) {\n        return;\n      }\n\n      if (requirePaddingFor(node)) {\n        if (!blockHasTopPadding) {\n          context.report({\n            node,\n            loc: {\n              start: tokenBeforeFirst.loc.start,\n              end: firstBlockToken.loc.start\n            },\n\n            fix(fixer) {\n              return fixer.insertTextAfter(tokenBeforeFirst, \"\\n\");\n            },\n\n            messageId: \"alwaysPadBlock\"\n          });\n        }\n\n        if (!blockHasBottomPadding) {\n          context.report({\n            node,\n            loc: {\n              end: tokenAfterLast.loc.start,\n              start: lastBlockToken.loc.end\n            },\n\n            fix(fixer) {\n              return fixer.insertTextBefore(tokenAfterLast, \"\\n\");\n            },\n\n            messageId: \"alwaysPadBlock\"\n          });\n        }\n      } else {\n        if (blockHasTopPadding) {\n          context.report({\n            node,\n            loc: {\n              start: tokenBeforeFirst.loc.start,\n              end: firstBlockToken.loc.start\n            },\n\n            fix(fixer) {\n              return fixer.replaceTextRange([tokenBeforeFirst.range[1], firstBlockToken.range[0] - firstBlockToken.loc.start.column], \"\\n\");\n            },\n\n            messageId: \"neverPadBlock\"\n          });\n        }\n\n        if (blockHasBottomPadding) {\n          context.report({\n            node,\n            loc: {\n              end: tokenAfterLast.loc.start,\n              start: lastBlockToken.loc.end\n            },\n            messageId: \"neverPadBlock\",\n\n            fix(fixer) {\n              return fixer.replaceTextRange([lastBlockToken.range[1], tokenAfterLast.range[0] - tokenAfterLast.loc.start.column], \"\\n\");\n            }\n\n          });\n        }\n      }\n    }\n\n    const rule = {};\n\n    if (Object.prototype.hasOwnProperty.call(options, \"switches\")) {\n      rule.SwitchStatement = function (node) {\n        if (node.cases.length === 0) {\n          return;\n        }\n\n        checkPadding(node);\n      };\n    }\n\n    if (Object.prototype.hasOwnProperty.call(options, \"blocks\")) {\n      rule.BlockStatement = function (node) {\n        if (node.body.length === 0) {\n          return;\n        }\n\n        checkPadding(node);\n      };\n    }\n\n    if (Object.prototype.hasOwnProperty.call(options, \"classes\")) {\n      rule.ClassBody = function (node) {\n        if (node.body.length === 0) {\n          return;\n        }\n\n        checkPadding(node);\n      };\n    }\n\n    return rule;\n  }\n\n};\npaddedBlocks.meta;\npaddedBlocks.create;\nconst LT = `[${Array.from(astUtils.LINEBREAKS).join(\"\")}]`;\nconst PADDING_LINE_SEQUENCE = new RegExp(\"^(\\\\s*?)\\\\s*(\\\\s*;?)$\", \"u\");\nconst CJS_EXPORT = /^(?:module\\s*\\.\\s*)?exports(?:\\s*\\.|\\s*\\[|$)/u;\nconst CJS_IMPORT = /^require\\(/u;\n\nfunction newKeywordTester(keyword) {\n  return {\n    test: (node, sourceCode) => sourceCode.getFirstToken(node).value === keyword\n  };\n}\n\nfunction newSinglelineKeywordTester(keyword) {\n  return {\n    test: (node, sourceCode) => node.loc.start.line === node.loc.end.line && sourceCode.getFirstToken(node).value === keyword\n  };\n}\n\nfunction newMultilineKeywordTester(keyword) {\n  return {\n    test: (node, sourceCode) => node.loc.start.line !== node.loc.end.line && sourceCode.getFirstToken(node).value === keyword\n  };\n}\n\nfunction newNodeTypeTester(type) {\n  return {\n    test: node => node.type === type\n  };\n}\n\nfunction isIIFEStatement(node) {\n  if (node.type === \"ExpressionStatement\") {\n    let call = astUtils.skipChainExpression(node.expression);\n\n    if (call.type === \"UnaryExpression\") {\n      call = astUtils.skipChainExpression(call.argument);\n    }\n\n    return call.type === \"CallExpression\" && astUtils.isFunction(call.callee);\n  }\n\n  return false;\n}\n\nfunction isBlockLikeStatement(sourceCode, node) {\n  if (node.type === \"DoWhileStatement\" && node.body.type === \"BlockStatement\") {\n    return true;\n  }\n\n  if (isIIFEStatement(node)) {\n    return true;\n  }\n\n  const lastToken = sourceCode.getLastToken(node, astUtils.isNotSemicolonToken);\n  const belongingNode = lastToken && astUtils.isClosingBraceToken(lastToken) ? sourceCode.getNodeByRangeIndex(lastToken.range[0]) : null;\n  return Boolean(belongingNode) && (belongingNode.type === \"BlockStatement\" || belongingNode.type === \"SwitchStatement\");\n}\n\nfunction isDirective(node, sourceCode) {\n  return node.type === \"ExpressionStatement\" && (node.parent.type === \"Program\" || node.parent.type === \"BlockStatement\" && astUtils.isFunction(node.parent.parent)) && node.expression.type === \"Literal\" && typeof node.expression.value === \"string\" && !astUtils.isParenthesised(sourceCode, node.expression);\n}\n\nfunction isDirectivePrologue(node, sourceCode) {\n  if (isDirective(node, sourceCode)) {\n    for (const sibling of node.parent.body) {\n      if (sibling === node) {\n        break;\n      }\n\n      if (!isDirective(sibling, sourceCode)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  return false;\n}\n\nfunction getActualLastToken(sourceCode, node) {\n  const semiToken = sourceCode.getLastToken(node);\n  const prevToken = sourceCode.getTokenBefore(semiToken);\n  const nextToken = sourceCode.getTokenAfter(semiToken);\n  const isSemicolonLessStyle = Boolean(prevToken && nextToken && prevToken.range[0] >= node.range[0] && astUtils.isSemicolonToken(semiToken) && semiToken.loc.start.line !== prevToken.loc.end.line && semiToken.loc.end.line === nextToken.loc.start.line);\n  return isSemicolonLessStyle ? prevToken : semiToken;\n}\n\nfunction replacerToRemovePaddingLines(_, trailingSpaces, indentSpaces) {\n  return trailingSpaces + indentSpaces;\n}\n\nfunction verifyForAny() {}\n\nfunction verifyForNever(context, _, nextNode, paddingLines) {\n  if (paddingLines.length === 0) {\n    return;\n  }\n\n  context.report({\n    node: nextNode,\n    messageId: \"unexpectedBlankLine\",\n\n    fix(fixer) {\n      if (paddingLines.length >= 2) {\n        return null;\n      }\n\n      const prevToken = paddingLines[0][0];\n      const nextToken = paddingLines[0][1];\n      const start = prevToken.range[1];\n      const end = nextToken.range[0];\n      const text = context.getSourceCode().text.slice(start, end).replace(PADDING_LINE_SEQUENCE, replacerToRemovePaddingLines);\n      return fixer.replaceTextRange([start, end], text);\n    }\n\n  });\n}\n\nfunction verifyForAlways(context, prevNode, nextNode, paddingLines) {\n  if (paddingLines.length > 0) {\n    return;\n  }\n\n  context.report({\n    node: nextNode,\n    messageId: \"expectedBlankLine\",\n\n    fix(fixer) {\n      const sourceCode = context.getSourceCode();\n      let prevToken = getActualLastToken(sourceCode, prevNode);\n      const nextToken = sourceCode.getFirstTokenBetween(prevToken, nextNode, {\n        includeComments: true,\n\n        filter(token) {\n          if (astUtils.isTokenOnSameLine(prevToken, token)) {\n            prevToken = token;\n            return false;\n          }\n\n          return true;\n        }\n\n      }) || nextNode;\n      const insertText = astUtils.isTokenOnSameLine(prevToken, nextToken) ? \"\\n\\n\" : \"\\n\";\n      return fixer.insertTextAfter(prevToken, insertText);\n    }\n\n  });\n}\n\nconst PaddingTypes = {\n  any: {\n    verify: verifyForAny\n  },\n  never: {\n    verify: verifyForNever\n  },\n  always: {\n    verify: verifyForAlways\n  }\n};\nconst StatementTypes = {\n  \"*\": {\n    test: () => true\n  },\n  \"block-like\": {\n    test: (node, sourceCode) => isBlockLikeStatement(sourceCode, node)\n  },\n  \"cjs-export\": {\n    test: (node, sourceCode) => node.type === \"ExpressionStatement\" && node.expression.type === \"AssignmentExpression\" && CJS_EXPORT.test(sourceCode.getText(node.expression.left))\n  },\n  \"cjs-import\": {\n    test: (node, sourceCode) => node.type === \"VariableDeclaration\" && node.declarations.length > 0 && Boolean(node.declarations[0].init) && CJS_IMPORT.test(sourceCode.getText(node.declarations[0].init))\n  },\n  directive: {\n    test: isDirectivePrologue\n  },\n  expression: {\n    test: (node, sourceCode) => node.type === \"ExpressionStatement\" && !isDirectivePrologue(node, sourceCode)\n  },\n  iife: {\n    test: isIIFEStatement\n  },\n  \"multiline-block-like\": {\n    test: (node, sourceCode) => node.loc.start.line !== node.loc.end.line && isBlockLikeStatement(sourceCode, node)\n  },\n  \"multiline-expression\": {\n    test: (node, sourceCode) => node.loc.start.line !== node.loc.end.line && node.type === \"ExpressionStatement\" && !isDirectivePrologue(node, sourceCode)\n  },\n  \"multiline-const\": newMultilineKeywordTester(\"const\"),\n  \"multiline-let\": newMultilineKeywordTester(\"let\"),\n  \"multiline-var\": newMultilineKeywordTester(\"var\"),\n  \"singleline-const\": newSinglelineKeywordTester(\"const\"),\n  \"singleline-let\": newSinglelineKeywordTester(\"let\"),\n  \"singleline-var\": newSinglelineKeywordTester(\"var\"),\n  block: newNodeTypeTester(\"BlockStatement\"),\n  empty: newNodeTypeTester(\"EmptyStatement\"),\n  function: newNodeTypeTester(\"FunctionDeclaration\"),\n  break: newKeywordTester(\"break\"),\n  case: newKeywordTester(\"case\"),\n  class: newKeywordTester(\"class\"),\n  const: newKeywordTester(\"const\"),\n  continue: newKeywordTester(\"continue\"),\n  debugger: newKeywordTester(\"debugger\"),\n  default: newKeywordTester(\"default\"),\n  do: newKeywordTester(\"do\"),\n  export: newKeywordTester(\"export\"),\n  for: newKeywordTester(\"for\"),\n  if: newKeywordTester(\"if\"),\n  import: newKeywordTester(\"import\"),\n  let: newKeywordTester(\"let\"),\n  return: newKeywordTester(\"return\"),\n  switch: newKeywordTester(\"switch\"),\n  throw: newKeywordTester(\"throw\"),\n  try: newKeywordTester(\"try\"),\n  var: newKeywordTester(\"var\"),\n  while: newKeywordTester(\"while\"),\n  with: newKeywordTester(\"with\")\n};\nvar paddingLineBetweenStatements = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"require or disallow padding lines between statements\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/padding-line-between-statements\"\n    },\n    fixable: \"whitespace\",\n    schema: {\n      definitions: {\n        paddingType: {\n          enum: Object.keys(PaddingTypes)\n        },\n        statementType: {\n          anyOf: [{\n            enum: Object.keys(StatementTypes)\n          }, {\n            type: \"array\",\n            items: {\n              enum: Object.keys(StatementTypes)\n            },\n            minItems: 1,\n            uniqueItems: true,\n            additionalItems: false\n          }]\n        }\n      },\n      type: \"array\",\n      items: {\n        type: \"object\",\n        properties: {\n          blankLine: {\n            $ref: \"#/definitions/paddingType\"\n          },\n          prev: {\n            $ref: \"#/definitions/statementType\"\n          },\n          next: {\n            $ref: \"#/definitions/statementType\"\n          }\n        },\n        additionalProperties: false,\n        required: [\"blankLine\", \"prev\", \"next\"]\n      },\n      additionalItems: false\n    },\n    messages: {\n      unexpectedBlankLine: \"Unexpected blank line before this statement.\",\n      expectedBlankLine: \"Expected blank line before this statement.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    const configureList = context.options || [];\n    let scopeInfo = null;\n\n    function enterScope() {\n      scopeInfo = {\n        upper: scopeInfo,\n        prevNode: null\n      };\n    }\n\n    function exitScope() {\n      scopeInfo = scopeInfo.upper;\n    }\n\n    function match(node, type) {\n      let innerStatementNode = node;\n\n      while (innerStatementNode.type === \"LabeledStatement\") {\n        innerStatementNode = innerStatementNode.body;\n      }\n\n      if (Array.isArray(type)) {\n        return type.some(match.bind(null, innerStatementNode));\n      }\n\n      return StatementTypes[type].test(innerStatementNode, sourceCode);\n    }\n\n    function getPaddingType(prevNode, nextNode) {\n      for (let i = configureList.length - 1; i >= 0; --i) {\n        const configure = configureList[i];\n        const matched = match(prevNode, configure.prev) && match(nextNode, configure.next);\n\n        if (matched) {\n          return PaddingTypes[configure.blankLine];\n        }\n      }\n\n      return PaddingTypes.any;\n    }\n\n    function getPaddingLineSequences(prevNode, nextNode) {\n      const pairs = [];\n      let prevToken = getActualLastToken(sourceCode, prevNode);\n\n      if (nextNode.loc.start.line - prevToken.loc.end.line >= 2) {\n        do {\n          const token = sourceCode.getTokenAfter(prevToken, {\n            includeComments: true\n          });\n\n          if (token.loc.start.line - prevToken.loc.end.line >= 2) {\n            pairs.push([prevToken, token]);\n          }\n\n          prevToken = token;\n        } while (prevToken.range[0] < nextNode.range[0]);\n      }\n\n      return pairs;\n    }\n\n    function verify(node) {\n      const parentType = node.parent.type;\n      const validParent = astUtils.STATEMENT_LIST_PARENTS.has(parentType) || parentType === \"SwitchStatement\";\n\n      if (!validParent) {\n        return;\n      }\n\n      const prevNode = scopeInfo.prevNode;\n\n      if (prevNode) {\n        const type = getPaddingType(prevNode, node);\n        const paddingLines = getPaddingLineSequences(prevNode, node);\n        type.verify(context, prevNode, node, paddingLines);\n      }\n\n      scopeInfo.prevNode = node;\n    }\n\n    return {\n      Program: enterScope,\n      BlockStatement: enterScope,\n      SwitchStatement: enterScope,\n      \"Program:exit\": exitScope,\n      \"BlockStatement:exit\": exitScope,\n      \"SwitchStatement:exit\": exitScope,\n      \":statement\": verify,\n      SwitchCase: function (node) {\n        verify(node);\n        enterScope();\n      },\n      \"SwitchCase:exit\": exitScope\n    };\n  }\n\n};\npaddingLineBetweenStatements.meta;\npaddingLineBetweenStatements.create;\n\nfunction isFunctionName(variable) {\n  return variable && variable.defs[0].type === \"FunctionName\";\n}\n\nfunction checkMetaProperty(node, metaName, propertyName) {\n  return node.meta.name === metaName && node.property.name === propertyName;\n}\n\nfunction getVariableOfArguments$1(scope) {\n  const variables = scope.variables;\n\n  for (let i = 0; i < variables.length; ++i) {\n    const variable = variables[i];\n\n    if (variable.name === \"arguments\") {\n      return variable.identifiers.length === 0 ? variable : null;\n    }\n  }\n\n  return null;\n}\n\nfunction getCallbackInfo(node) {\n  const retv = {\n    isCallback: false,\n    isLexicalThis: false\n  };\n  let currentNode = node;\n  let parent = node.parent;\n  let bound = false;\n\n  while (currentNode) {\n    switch (parent.type) {\n      case \"LogicalExpression\":\n      case \"ChainExpression\":\n      case \"ConditionalExpression\":\n        break;\n\n      case \"MemberExpression\":\n        if (parent.object === currentNode && !parent.property.computed && parent.property.type === \"Identifier\" && parent.property.name === \"bind\") {\n          const maybeCallee = parent.parent.type === \"ChainExpression\" ? parent.parent : parent;\n\n          if (astUtils.isCallee(maybeCallee)) {\n            if (!bound) {\n              bound = true;\n              retv.isLexicalThis = maybeCallee.parent.arguments.length === 1 && maybeCallee.parent.arguments[0].type === \"ThisExpression\";\n            }\n\n            parent = maybeCallee.parent;\n          } else {\n            return retv;\n          }\n        } else {\n          return retv;\n        }\n\n        break;\n\n      case \"CallExpression\":\n      case \"NewExpression\":\n        if (parent.callee !== currentNode) {\n          retv.isCallback = true;\n        }\n\n        return retv;\n\n      default:\n        return retv;\n    }\n\n    currentNode = parent;\n    parent = parent.parent;\n  }\n\n  throw new Error(\"unreachable\");\n}\n\nfunction hasDuplicateParams(paramsList) {\n  return paramsList.every(param => param.type === \"Identifier\") && paramsList.length !== new Set(paramsList.map(param => param.name)).size;\n}\n\nvar preferArrowCallback = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"require using arrow functions for callbacks\",\n      category: \"ECMAScript 6\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/prefer-arrow-callback\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        allowNamedFunctions: {\n          type: \"boolean\",\n          default: false\n        },\n        allowUnboundThis: {\n          type: \"boolean\",\n          default: true\n        }\n      },\n      additionalProperties: false\n    }],\n    fixable: \"code\",\n    messages: {\n      preferArrowCallback: \"Unexpected function expression.\"\n    }\n  },\n\n  create(context) {\n    const options = context.options[0] || {};\n    const allowUnboundThis = options.allowUnboundThis !== false;\n    const allowNamedFunctions = options.allowNamedFunctions;\n    const sourceCode = context.getSourceCode();\n    let stack = [];\n\n    function enterScope() {\n      stack.push({\n        this: false,\n        super: false,\n        meta: false\n      });\n    }\n\n    function exitScope() {\n      return stack.pop();\n    }\n\n    return {\n      Program() {\n        stack = [];\n      },\n\n      ThisExpression() {\n        const info = stack[stack.length - 1];\n\n        if (info) {\n          info.this = true;\n        }\n      },\n\n      Super() {\n        const info = stack[stack.length - 1];\n\n        if (info) {\n          info.super = true;\n        }\n      },\n\n      MetaProperty(node) {\n        const info = stack[stack.length - 1];\n\n        if (info && checkMetaProperty(node, \"new\", \"target\")) {\n          info.meta = true;\n        }\n      },\n\n      FunctionDeclaration: enterScope,\n      \"FunctionDeclaration:exit\": exitScope,\n      FunctionExpression: enterScope,\n\n      \"FunctionExpression:exit\"(node) {\n        const scopeInfo = exitScope();\n\n        if (allowNamedFunctions && node.id && node.id.name) {\n          return;\n        }\n\n        if (node.generator) {\n          return;\n        }\n\n        const nameVar = context.getDeclaredVariables(node)[0];\n\n        if (isFunctionName(nameVar) && nameVar.references.length > 0) {\n          return;\n        }\n\n        const variable = getVariableOfArguments$1(context.getScope());\n\n        if (variable && variable.references.length > 0) {\n          return;\n        }\n\n        const callbackInfo = getCallbackInfo(node);\n\n        if (callbackInfo.isCallback && (!allowUnboundThis || !scopeInfo.this || callbackInfo.isLexicalThis) && !scopeInfo.super && !scopeInfo.meta) {\n          context.report({\n            node,\n            messageId: \"preferArrowCallback\",\n\n            *fix(fixer) {\n              if (!callbackInfo.isLexicalThis && scopeInfo.this || hasDuplicateParams(node.params)) {\n                return;\n              }\n\n              if (callbackInfo.isLexicalThis) {\n                const memberNode = node.parent;\n\n                if (memberNode.type !== \"MemberExpression\") {\n                  return;\n                }\n\n                const callNode = memberNode.parent;\n                const firstTokenToRemove = sourceCode.getTokenAfter(memberNode.object, astUtils.isNotClosingParenToken);\n                const lastTokenToRemove = sourceCode.getLastToken(callNode);\n\n                if (astUtils.isParenthesised(sourceCode, memberNode)) {\n                  return;\n                }\n\n                if (sourceCode.commentsExistBetween(firstTokenToRemove, lastTokenToRemove)) {\n                  return;\n                }\n\n                yield fixer.removeRange([firstTokenToRemove.range[0], lastTokenToRemove.range[1]]);\n              }\n\n              const functionToken = sourceCode.getFirstToken(node, node.async ? 1 : 0);\n              const leftParenToken = sourceCode.getTokenAfter(functionToken, astUtils.isOpeningParenToken);\n\n              if (sourceCode.commentsExistBetween(functionToken, leftParenToken)) {\n                yield fixer.remove(functionToken);\n\n                if (node.id) {\n                  yield fixer.remove(node.id);\n                }\n              } else {\n                yield fixer.removeRange([functionToken.range[0], leftParenToken.range[0]]);\n              }\n\n              yield fixer.insertTextBefore(node.body, \"=> \");\n              let replacedNode = callbackInfo.isLexicalThis ? node.parent.parent : node;\n\n              if (replacedNode.type === \"ChainExpression\") {\n                replacedNode = replacedNode.parent;\n              }\n\n              if (replacedNode.parent.type !== \"CallExpression\" && replacedNode.parent.type !== \"ConditionalExpression\" && !astUtils.isParenthesised(sourceCode, replacedNode) && !astUtils.isParenthesised(sourceCode, node)) {\n                yield fixer.insertTextBefore(replacedNode, \"(\");\n                yield fixer.insertTextAfter(replacedNode, \")\");\n              }\n            }\n\n          });\n        }\n      }\n\n    };\n  }\n\n};\npreferArrowCallback.meta;\npreferArrowCallback.create;\nconst PATTERN_TYPE = /^(?:.+?Pattern|RestElement|SpreadProperty|ExperimentalRestProperty|Property)$/u;\nconst DECLARATION_HOST_TYPE = /^(?:Program|BlockStatement|SwitchCase)$/u;\nconst DESTRUCTURING_HOST_TYPE = /^(?:VariableDeclarator|AssignmentExpression)$/u;\n\nfunction isInitOfForStatement(node) {\n  return node.parent.type === \"ForStatement\" && node.parent.init === node;\n}\n\nfunction canBecomeVariableDeclaration(identifier) {\n  let node = identifier.parent;\n\n  while (PATTERN_TYPE.test(node.type)) {\n    node = node.parent;\n  }\n\n  return node.type === \"VariableDeclarator\" || node.type === \"AssignmentExpression\" && node.parent.type === \"ExpressionStatement\" && DECLARATION_HOST_TYPE.test(node.parent.parent.type);\n}\n\nfunction isOuterVariableInDestructing(name, initScope) {\n  if (initScope.through.find(ref => ref.resolved && ref.resolved.name === name)) {\n    return true;\n  }\n\n  const variable = astUtils.getVariableByName(initScope, name);\n\n  if (variable !== null) {\n    return variable.defs.some(def => def.type === \"Parameter\");\n  }\n\n  return false;\n}\n\nfunction getDestructuringHost(reference) {\n  if (!reference.isWrite()) {\n    return null;\n  }\n\n  let node = reference.identifier.parent;\n\n  while (PATTERN_TYPE.test(node.type)) {\n    node = node.parent;\n  }\n\n  if (!DESTRUCTURING_HOST_TYPE.test(node.type)) {\n    return null;\n  }\n\n  return node;\n}\n\nfunction hasMemberExpressionAssignment(node) {\n  switch (node.type) {\n    case \"ObjectPattern\":\n      return node.properties.some(prop => {\n        if (prop) {\n          return hasMemberExpressionAssignment(prop.argument || prop.value);\n        }\n\n        return false;\n      });\n\n    case \"ArrayPattern\":\n      return node.elements.some(element => {\n        if (element) {\n          return hasMemberExpressionAssignment(element);\n        }\n\n        return false;\n      });\n\n    case \"AssignmentPattern\":\n      return hasMemberExpressionAssignment(node.left);\n\n    case \"MemberExpression\":\n      return true;\n  }\n\n  return false;\n}\n\nfunction getIdentifierIfShouldBeConst(variable, ignoreReadBeforeAssign) {\n  if (variable.eslintUsed && variable.scope.type === \"global\") {\n    return null;\n  }\n\n  let writer = null;\n  let isReadBeforeInit = false;\n  const references = variable.references;\n\n  for (let i = 0; i < references.length; ++i) {\n    const reference = references[i];\n\n    if (reference.isWrite()) {\n      const isReassigned = writer !== null && writer.identifier !== reference.identifier;\n\n      if (isReassigned) {\n        return null;\n      }\n\n      const destructuringHost = getDestructuringHost(reference);\n\n      if (destructuringHost !== null && destructuringHost.left !== void 0) {\n        const leftNode = destructuringHost.left;\n        let hasOuterVariables = false,\n            hasNonIdentifiers = false;\n\n        if (leftNode.type === \"ObjectPattern\") {\n          const properties = leftNode.properties;\n          hasOuterVariables = properties.filter(prop => prop.value).map(prop => prop.value.name).some(name => isOuterVariableInDestructing(name, variable.scope));\n          hasNonIdentifiers = hasMemberExpressionAssignment(leftNode);\n        } else if (leftNode.type === \"ArrayPattern\") {\n          const elements = leftNode.elements;\n          hasOuterVariables = elements.map(element => element && element.name).some(name => isOuterVariableInDestructing(name, variable.scope));\n          hasNonIdentifiers = hasMemberExpressionAssignment(leftNode);\n        }\n\n        if (hasOuterVariables || hasNonIdentifiers) {\n          return null;\n        }\n      }\n\n      writer = reference;\n    } else if (reference.isRead() && writer === null) {\n      if (ignoreReadBeforeAssign) {\n        return null;\n      }\n\n      isReadBeforeInit = true;\n    }\n  }\n\n  const shouldBeConst = writer !== null && writer.from === variable.scope && canBecomeVariableDeclaration(writer.identifier);\n\n  if (!shouldBeConst) {\n    return null;\n  }\n\n  if (isReadBeforeInit) {\n    return variable.defs[0].name;\n  }\n\n  return writer.identifier;\n}\n\nfunction groupByDestructuring(variables, ignoreReadBeforeAssign) {\n  const identifierMap = new Map();\n\n  for (let i = 0; i < variables.length; ++i) {\n    const variable = variables[i];\n    const references = variable.references;\n    const identifier = getIdentifierIfShouldBeConst(variable, ignoreReadBeforeAssign);\n    let prevId = null;\n\n    for (let j = 0; j < references.length; ++j) {\n      const reference = references[j];\n      const id = reference.identifier;\n\n      if (id === prevId) {\n        continue;\n      }\n\n      prevId = id;\n      const group = getDestructuringHost(reference);\n\n      if (group) {\n        if (identifierMap.has(group)) {\n          identifierMap.get(group).push(identifier);\n        } else {\n          identifierMap.set(group, [identifier]);\n        }\n      }\n    }\n  }\n\n  return identifierMap;\n}\n\nfunction findUp(node, type, shouldStop) {\n  if (!node || shouldStop(node)) {\n    return null;\n  }\n\n  if (node.type === type) {\n    return node;\n  }\n\n  return findUp(node.parent, type, shouldStop);\n}\n\nvar preferConst = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"require `const` declarations for variables that are never reassigned after declared\",\n      category: \"ECMAScript 6\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/prefer-const\"\n    },\n    fixable: \"code\",\n    schema: [{\n      type: \"object\",\n      properties: {\n        destructuring: {\n          enum: [\"any\", \"all\"],\n          default: \"any\"\n        },\n        ignoreReadBeforeAssign: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      useConst: \"'{{name}}' is never reassigned. Use 'const' instead.\"\n    }\n  },\n\n  create(context) {\n    const options = context.options[0] || {};\n    const sourceCode = context.getSourceCode();\n    const shouldMatchAnyDestructuredVariable = options.destructuring !== \"all\";\n    const ignoreReadBeforeAssign = options.ignoreReadBeforeAssign === true;\n    const variables = [];\n    let reportCount = 0;\n    let checkedId = null;\n    let checkedName = \"\";\n\n    function checkGroup(nodes) {\n      const nodesToReport = nodes.filter(Boolean);\n\n      if (nodes.length && (shouldMatchAnyDestructuredVariable || nodesToReport.length === nodes.length)) {\n        const varDeclParent = findUp(nodes[0], \"VariableDeclaration\", parentNode => parentNode.type.endsWith(\"Statement\"));\n        const isVarDecParentNull = varDeclParent === null;\n\n        if (!isVarDecParentNull && varDeclParent.declarations.length > 0) {\n          const firstDeclaration = varDeclParent.declarations[0];\n\n          if (firstDeclaration.init) {\n            const firstDecParent = firstDeclaration.init.parent;\n\n            if (firstDecParent.type === \"VariableDeclarator\") {\n              if (firstDecParent.id.name !== checkedName) {\n                checkedName = firstDecParent.id.name;\n                reportCount = 0;\n              }\n\n              if (firstDecParent.id.type === \"ObjectPattern\") {\n                if (firstDecParent.init.name !== checkedName) {\n                  checkedName = firstDecParent.init.name;\n                  reportCount = 0;\n                }\n              }\n\n              if (firstDecParent.id !== checkedId) {\n                checkedId = firstDecParent.id;\n                reportCount = 0;\n              }\n            }\n          }\n        }\n\n        let shouldFix = varDeclParent && (varDeclParent.parent.type === \"ForInStatement\" || varDeclParent.parent.type === \"ForOfStatement\" || varDeclParent.declarations.every(declaration => declaration.init)) && nodesToReport.length === nodes.length;\n\n        if (!isVarDecParentNull && varDeclParent.declarations && varDeclParent.declarations.length !== 1) {\n          if (varDeclParent && varDeclParent.declarations && varDeclParent.declarations.length >= 1) {\n            reportCount += nodesToReport.length;\n            shouldFix = shouldFix && reportCount === varDeclParent.declarations.length;\n          }\n        }\n\n        nodesToReport.forEach(node => {\n          context.report({\n            node,\n            messageId: \"useConst\",\n            data: node,\n            fix: shouldFix ? fixer => {\n              const letKeywordToken = sourceCode.getFirstToken(varDeclParent, t => t.value === varDeclParent.kind);\n              return new fixTracker(fixer, sourceCode).retainRange(varDeclParent.range).replaceTextRange(letKeywordToken.range, \"const\");\n            } : null\n          });\n        });\n      }\n    }\n\n    return {\n      \"Program:exit\"() {\n        groupByDestructuring(variables, ignoreReadBeforeAssign).forEach(checkGroup);\n      },\n\n      VariableDeclaration(node) {\n        if (node.kind === \"let\" && !isInitOfForStatement(node)) {\n          variables.push(...context.getDeclaredVariables(node));\n        }\n      }\n\n    };\n  }\n\n};\npreferConst.meta;\npreferConst.create;\nconst PRECEDENCE_OF_ASSIGNMENT_EXPR = astUtils.getPrecedence({\n  type: \"AssignmentExpression\"\n});\nvar preferDestructuring = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"require destructuring from arrays and/or objects\",\n      category: \"ECMAScript 6\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/prefer-destructuring\"\n    },\n    fixable: \"code\",\n    schema: [{\n      oneOf: [{\n        type: \"object\",\n        properties: {\n          VariableDeclarator: {\n            type: \"object\",\n            properties: {\n              array: {\n                type: \"boolean\"\n              },\n              object: {\n                type: \"boolean\"\n              }\n            },\n            additionalProperties: false\n          },\n          AssignmentExpression: {\n            type: \"object\",\n            properties: {\n              array: {\n                type: \"boolean\"\n              },\n              object: {\n                type: \"boolean\"\n              }\n            },\n            additionalProperties: false\n          }\n        },\n        additionalProperties: false\n      }, {\n        type: \"object\",\n        properties: {\n          array: {\n            type: \"boolean\"\n          },\n          object: {\n            type: \"boolean\"\n          }\n        },\n        additionalProperties: false\n      }]\n    }, {\n      type: \"object\",\n      properties: {\n        enforceForRenamedProperties: {\n          type: \"boolean\"\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      preferDestructuring: \"Use {{type}} destructuring.\"\n    }\n  },\n\n  create(context) {\n    const enabledTypes = context.options[0];\n    const enforceForRenamedProperties = context.options[1] && context.options[1].enforceForRenamedProperties;\n    let normalizedOptions = {\n      VariableDeclarator: {\n        array: true,\n        object: true\n      },\n      AssignmentExpression: {\n        array: true,\n        object: true\n      }\n    };\n\n    if (enabledTypes) {\n      normalizedOptions = typeof enabledTypes.array !== \"undefined\" || typeof enabledTypes.object !== \"undefined\" ? {\n        VariableDeclarator: enabledTypes,\n        AssignmentExpression: enabledTypes\n      } : enabledTypes;\n    }\n\n    function shouldCheck(nodeType, destructuringType) {\n      return normalizedOptions && normalizedOptions[nodeType] && normalizedOptions[nodeType][destructuringType];\n    }\n\n    function isArrayIndexAccess(node) {\n      return Number.isInteger(node.property.value);\n    }\n\n    function report(reportNode, type, fix) {\n      context.report({\n        node: reportNode,\n        messageId: \"preferDestructuring\",\n        data: {\n          type\n        },\n        fix\n      });\n    }\n\n    function shouldFix(node) {\n      return node.type === \"VariableDeclarator\" && node.id.type === \"Identifier\" && node.init.type === \"MemberExpression\" && !node.init.computed && node.init.property.type === \"Identifier\" && node.id.name === node.init.property.name;\n    }\n\n    function fixIntoObjectDestructuring(fixer, node) {\n      const rightNode = node.init;\n      const sourceCode = context.getSourceCode();\n\n      if (sourceCode.getCommentsInside(node).length > sourceCode.getCommentsInside(rightNode.object).length) {\n        return null;\n      }\n\n      let objectText = sourceCode.getText(rightNode.object);\n\n      if (astUtils.getPrecedence(rightNode.object) < PRECEDENCE_OF_ASSIGNMENT_EXPR) {\n        objectText = `(${objectText})`;\n      }\n\n      return fixer.replaceText(node, `{${rightNode.property.name}} = ${objectText}`);\n    }\n\n    function performCheck(leftNode, rightNode, reportNode) {\n      if (rightNode.type !== \"MemberExpression\" || rightNode.object.type === \"Super\") {\n        return;\n      }\n\n      if (isArrayIndexAccess(rightNode)) {\n        if (shouldCheck(reportNode.type, \"array\")) {\n          report(reportNode, \"array\", null);\n        }\n\n        return;\n      }\n\n      const fix = shouldFix(reportNode) ? fixer => fixIntoObjectDestructuring(fixer, reportNode) : null;\n\n      if (shouldCheck(reportNode.type, \"object\") && enforceForRenamedProperties) {\n        report(reportNode, \"object\", fix);\n        return;\n      }\n\n      if (shouldCheck(reportNode.type, \"object\")) {\n        const property = rightNode.property;\n\n        if (property.type === \"Literal\" && leftNode.name === property.value || property.type === \"Identifier\" && leftNode.name === property.name && !rightNode.computed) {\n          report(reportNode, \"object\", fix);\n        }\n      }\n    }\n\n    return {\n      VariableDeclarator: function (node) {\n        if (!node.init) {\n          return;\n        }\n\n        if (node.init.type !== \"MemberExpression\") {\n          return;\n        }\n\n        performCheck(node.id, node.init, node);\n      },\n      AssignmentExpression: function (node) {\n        if (node.operator === \"=\") {\n          performCheck(node.left, node.right, node);\n        }\n      }\n    };\n  }\n\n};\npreferDestructuring.meta;\npreferDestructuring.create;\nconst {\n  CALL: CALL$4,\n  ReferenceTracker: ReferenceTracker$4\n} = eslintUtils__default['default'];\nconst PRECEDENCE_OF_EXPONENTIATION_EXPR = astUtils.getPrecedence({\n  type: \"BinaryExpression\",\n  operator: \"**\"\n});\n\nfunction doesBaseNeedParens(base) {\n  return astUtils.getPrecedence(base) <= PRECEDENCE_OF_EXPONENTIATION_EXPR || base.type === \"AwaitExpression\" || base.type === \"UnaryExpression\";\n}\n\nfunction doesExponentNeedParens(exponent) {\n  return astUtils.getPrecedence(exponent) < PRECEDENCE_OF_EXPONENTIATION_EXPR;\n}\n\nfunction doesExponentiationExpressionNeedParens(node, sourceCode) {\n  const parent = node.parent.type === \"ChainExpression\" ? node.parent.parent : node.parent;\n  const needsParens = parent.type === \"ClassDeclaration\" || parent.type.endsWith(\"Expression\") && astUtils.getPrecedence(parent) >= PRECEDENCE_OF_EXPONENTIATION_EXPR && !(parent.type === \"BinaryExpression\" && parent.operator === \"**\" && parent.right === node) && !((parent.type === \"CallExpression\" || parent.type === \"NewExpression\") && parent.arguments.includes(node)) && !(parent.type === \"MemberExpression\" && parent.computed && parent.property === node) && !(parent.type === \"ArrayExpression\");\n  return needsParens && !astUtils.isParenthesised(sourceCode, node);\n}\n\nfunction parenthesizeIfShould(text, shouldParenthesize) {\n  return shouldParenthesize ? `(${text})` : text;\n}\n\nvar preferExponentiationOperator = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow the use of `Math.pow` in favor of the `**` operator\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/prefer-exponentiation-operator\"\n    },\n    schema: [],\n    fixable: \"code\",\n    messages: {\n      useExponentiation: \"Use the '**' operator instead of 'Math.pow'.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n\n    function report(node) {\n      context.report({\n        node,\n        messageId: \"useExponentiation\",\n\n        fix(fixer) {\n          if (node.arguments.length !== 2 || node.arguments.some(arg => arg.type === \"SpreadElement\") || sourceCode.getCommentsInside(node).length > 0) {\n            return null;\n          }\n\n          const base = node.arguments[0],\n                exponent = node.arguments[1],\n                baseText = sourceCode.getText(base),\n                exponentText = sourceCode.getText(exponent),\n                shouldParenthesizeBase = doesBaseNeedParens(base),\n                shouldParenthesizeExponent = doesExponentNeedParens(exponent),\n                shouldParenthesizeAll = doesExponentiationExpressionNeedParens(node, sourceCode);\n          let prefix = \"\",\n              suffix = \"\";\n\n          if (!shouldParenthesizeAll) {\n            if (!shouldParenthesizeBase) {\n              const firstReplacementToken = sourceCode.getFirstToken(base),\n                    tokenBefore = sourceCode.getTokenBefore(node);\n\n              if (tokenBefore && tokenBefore.range[1] === node.range[0] && !astUtils.canTokensBeAdjacent(tokenBefore, firstReplacementToken)) {\n                prefix = \" \";\n              }\n            }\n\n            if (!shouldParenthesizeExponent) {\n              const lastReplacementToken = sourceCode.getLastToken(exponent),\n                    tokenAfter = sourceCode.getTokenAfter(node);\n\n              if (tokenAfter && node.range[1] === tokenAfter.range[0] && !astUtils.canTokensBeAdjacent(lastReplacementToken, tokenAfter)) {\n                suffix = \" \";\n              }\n            }\n          }\n\n          const baseReplacement = parenthesizeIfShould(baseText, shouldParenthesizeBase),\n                exponentReplacement = parenthesizeIfShould(exponentText, shouldParenthesizeExponent),\n                replacement = parenthesizeIfShould(`${baseReplacement}**${exponentReplacement}`, shouldParenthesizeAll);\n          return fixer.replaceText(node, `${prefix}${replacement}${suffix}`);\n        }\n\n      });\n    }\n\n    return {\n      Program() {\n        const scope = context.getScope();\n        const tracker = new ReferenceTracker$4(scope);\n        const trackMap = {\n          Math: {\n            pow: {\n              [CALL$4]: true\n            }\n          }\n        };\n\n        for (const {\n          node\n        } of tracker.iterateGlobalReferences(trackMap)) {\n          report(node);\n        }\n      }\n\n    };\n  }\n\n};\npreferExponentiationOperator.meta;\npreferExponentiationOperator.create;\nconst {\n  CALL: CALL$3,\n  CONSTRUCT: CONSTRUCT$2,\n  ReferenceTracker: ReferenceTracker$3,\n  getStringIfConstant: getStringIfConstant$1\n} = eslintUtils__default['default'];\nconst parser = new regexpp__default['default'].RegExpParser();\nvar preferNamedCaptureGroup = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"enforce using named capture group in regular expression\",\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/prefer-named-capture-group\"\n    },\n    schema: [],\n    messages: {\n      required: \"Capture group '{{group}}' should be converted to a named or non-capturing group.\"\n    }\n  },\n\n  create(context) {\n    function checkRegex(pattern, node, uFlag) {\n      let ast;\n\n      try {\n        ast = parser.parsePattern(pattern, 0, pattern.length, uFlag);\n      } catch {\n        return;\n      }\n\n      regexpp__default['default'].visitRegExpAST(ast, {\n        onCapturingGroupEnter(group) {\n          if (!group.name) {\n            context.report({\n              node,\n              messageId: \"required\",\n              data: {\n                group: group.raw\n              }\n            });\n          }\n        }\n\n      });\n    }\n\n    return {\n      Literal(node) {\n        if (node.regex) {\n          checkRegex(node.regex.pattern, node, node.regex.flags.includes(\"u\"));\n        }\n      },\n\n      Program() {\n        const scope = context.getScope();\n        const tracker = new ReferenceTracker$3(scope);\n        const traceMap = {\n          RegExp: {\n            [CALL$3]: true,\n            [CONSTRUCT$2]: true\n          }\n        };\n\n        for (const {\n          node\n        } of tracker.iterateGlobalReferences(traceMap)) {\n          const regex = getStringIfConstant$1(node.arguments[0]);\n          const flags = getStringIfConstant$1(node.arguments[1]);\n\n          if (regex) {\n            checkRegex(regex, node, flags && flags.includes(\"u\"));\n          }\n        }\n      }\n\n    };\n  }\n\n};\npreferNamedCaptureGroup.meta;\npreferNamedCaptureGroup.create;\nconst radixMap = new Map([[2, {\n  system: \"binary\",\n  literalPrefix: \"0b\"\n}], [8, {\n  system: \"octal\",\n  literalPrefix: \"0o\"\n}], [16, {\n  system: \"hexadecimal\",\n  literalPrefix: \"0x\"\n}]]);\n\nfunction isParseInt(calleeNode) {\n  return astUtils.isSpecificId(calleeNode, \"parseInt\") || astUtils.isSpecificMemberAccess(calleeNode, \"Number\", \"parseInt\");\n}\n\nvar preferNumericLiterals = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow `parseInt()` and `Number.parseInt()` in favor of binary, octal, and hexadecimal literals\",\n      category: \"ECMAScript 6\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/prefer-numeric-literals\"\n    },\n    schema: [],\n    messages: {\n      useLiteral: \"Use {{system}} literals instead of {{functionName}}().\"\n    },\n    fixable: \"code\"\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    return {\n      \"CallExpression[arguments.length=2]\"(node) {\n        const [strNode, radixNode] = node.arguments,\n              str = astUtils.getStaticStringValue(strNode),\n              radix = radixNode.value;\n\n        if (str !== null && astUtils.isStringLiteral(strNode) && radixNode.type === \"Literal\" && typeof radix === \"number\" && radixMap.has(radix) && isParseInt(node.callee)) {\n          const {\n            system,\n            literalPrefix\n          } = radixMap.get(radix);\n          context.report({\n            node,\n            messageId: \"useLiteral\",\n            data: {\n              system,\n              functionName: sourceCode.getText(node.callee)\n            },\n\n            fix(fixer) {\n              if (sourceCode.getCommentsInside(node).length) {\n                return null;\n              }\n\n              const replacement = `${literalPrefix}${str}`;\n\n              if (+replacement !== parseInt(str, radix)) {\n                return null;\n              }\n\n              const tokenBefore = sourceCode.getTokenBefore(node),\n                    tokenAfter = sourceCode.getTokenAfter(node);\n              let prefix = \"\",\n                  suffix = \"\";\n\n              if (tokenBefore && tokenBefore.range[1] === node.range[0] && !astUtils.canTokensBeAdjacent(tokenBefore, replacement)) {\n                prefix = \" \";\n              }\n\n              if (tokenAfter && node.range[1] === tokenAfter.range[0] && !astUtils.canTokensBeAdjacent(replacement, tokenAfter)) {\n                suffix = \" \";\n              }\n\n              return fixer.replaceText(node, `${prefix}${replacement}${suffix}`);\n            }\n\n          });\n        }\n      }\n\n    };\n  }\n\n};\npreferNumericLiterals.meta;\npreferNumericLiterals.create;\nconst {\n  CALL: CALL$2,\n  ReferenceTracker: ReferenceTracker$2\n} = eslintUtils__default['default'];\nconst {\n  isCommaToken,\n  isOpeningParenToken,\n  isClosingParenToken,\n  isParenthesised\n} = astUtils;\nconst ANY_SPACE = /\\s/u;\n\nfunction hasArraySpread(node) {\n  return node.arguments.some(arg => arg.type === \"SpreadElement\");\n}\n\nfunction isAccessorProperty(node) {\n  return node.type === \"Property\" && (node.kind === \"get\" || node.kind === \"set\");\n}\n\nfunction hasAccessors(node) {\n  return node.properties.some(isAccessorProperty);\n}\n\nfunction hasArgumentsWithAccessors(node) {\n  return node.arguments.filter(arg => arg.type === \"ObjectExpression\").some(hasAccessors);\n}\n\nfunction needsParens(node, sourceCode) {\n  const parent = node.parent;\n\n  switch (parent.type) {\n    case \"VariableDeclarator\":\n    case \"ArrayExpression\":\n    case \"ReturnStatement\":\n    case \"CallExpression\":\n    case \"Property\":\n      return false;\n\n    case \"AssignmentExpression\":\n      return parent.left === node && !isParenthesised(sourceCode, node);\n\n    default:\n      return !isParenthesised(sourceCode, node);\n  }\n}\n\nfunction argNeedsParens(node, sourceCode) {\n  switch (node.type) {\n    case \"AssignmentExpression\":\n    case \"ArrowFunctionExpression\":\n    case \"ConditionalExpression\":\n      return !isParenthesised(sourceCode, node);\n\n    default:\n      return false;\n  }\n}\n\nfunction getParenTokens(node, leftArgumentListParen, sourceCode) {\n  const parens = [sourceCode.getFirstToken(node), sourceCode.getLastToken(node)];\n  let leftNext = sourceCode.getTokenBefore(node);\n  let rightNext = sourceCode.getTokenAfter(node);\n\n  while (leftNext && rightNext && leftNext.range[0] > leftArgumentListParen.range[0] && isOpeningParenToken(leftNext) && isClosingParenToken(rightNext)) {\n    parens.push(leftNext, rightNext);\n    leftNext = sourceCode.getTokenBefore(leftNext);\n    rightNext = sourceCode.getTokenAfter(rightNext);\n  }\n\n  return parens.sort((a, b) => a.range[0] - b.range[0]);\n}\n\nfunction getStartWithSpaces(token, sourceCode) {\n  const text = sourceCode.text;\n  let start = token.range[0];\n  {\n    const prevToken = sourceCode.getTokenBefore(token, {\n      includeComments: true\n    });\n\n    if (prevToken && prevToken.type === \"Line\") {\n      return start;\n    }\n  }\n\n  while (ANY_SPACE.test(text[start - 1] || \"\")) {\n    start -= 1;\n  }\n\n  return start;\n}\n\nfunction getEndWithSpaces(token, sourceCode) {\n  const text = sourceCode.text;\n  let end = token.range[1];\n\n  while (ANY_SPACE.test(text[end] || \"\")) {\n    end += 1;\n  }\n\n  return end;\n}\n\nfunction defineFixer(node, sourceCode) {\n  return function* (fixer) {\n    const leftParen = sourceCode.getTokenAfter(node.callee, isOpeningParenToken);\n    const rightParen = sourceCode.getLastToken(node);\n    yield fixer.removeRange([node.range[0], leftParen.range[0]]);\n\n    if (needsParens(node, sourceCode)) {\n      yield fixer.replaceText(leftParen, \"({\");\n      yield fixer.replaceText(rightParen, \"})\");\n    } else {\n      yield fixer.replaceText(leftParen, \"{\");\n      yield fixer.replaceText(rightParen, \"}\");\n    }\n\n    for (const argNode of node.arguments) {\n      const innerParens = getParenTokens(argNode, leftParen, sourceCode);\n      const left = innerParens.shift();\n      const right = innerParens.pop();\n\n      if (argNode.type === \"ObjectExpression\") {\n        const maybeTrailingComma = sourceCode.getLastToken(argNode, 1);\n        const maybeArgumentComma = sourceCode.getTokenAfter(right);\n\n        for (const innerParen of innerParens) {\n          yield fixer.remove(innerParen);\n        }\n\n        const leftRange = [left.range[0], getEndWithSpaces(left, sourceCode)];\n        const rightRange = [Math.max(getStartWithSpaces(right, sourceCode), leftRange[1]), right.range[1]];\n        yield fixer.removeRange(leftRange);\n        yield fixer.removeRange(rightRange);\n\n        if ((argNode.properties.length === 0 || isCommaToken(maybeTrailingComma)) && isCommaToken(maybeArgumentComma)) {\n          yield fixer.remove(maybeArgumentComma);\n        }\n      } else {\n        if (argNeedsParens(argNode, sourceCode)) {\n          yield fixer.insertTextBefore(left, \"...(\");\n          yield fixer.insertTextAfter(right, \")\");\n        } else {\n          yield fixer.insertTextBefore(left, \"...\");\n        }\n      }\n    }\n  };\n}\n\nvar preferObjectSpread = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow using Object.assign with an object literal as the first argument and prefer the use of object spread instead.\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/prefer-object-spread\"\n    },\n    schema: [],\n    fixable: \"code\",\n    messages: {\n      useSpreadMessage: \"Use an object spread instead of `Object.assign` eg: `{ ...foo }`.\",\n      useLiteralMessage: \"Use an object literal instead of `Object.assign`. eg: `{ foo: bar }`.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    return {\n      Program() {\n        const scope = context.getScope();\n        const tracker = new ReferenceTracker$2(scope);\n        const trackMap = {\n          Object: {\n            assign: {\n              [CALL$2]: true\n            }\n          }\n        };\n\n        for (const {\n          node\n        } of tracker.iterateGlobalReferences(trackMap)) {\n          if (node.arguments.length >= 1 && node.arguments[0].type === \"ObjectExpression\" && !hasArraySpread(node) && !(node.arguments.length > 1 && hasArgumentsWithAccessors(node))) {\n            const messageId = node.arguments.length === 1 ? \"useLiteralMessage\" : \"useSpreadMessage\";\n            const fix = defineFixer(node, sourceCode);\n            context.report({\n              node,\n              messageId,\n              fix\n            });\n          }\n        }\n      }\n\n    };\n  }\n\n};\npreferObjectSpread.meta;\npreferObjectSpread.create;\nvar preferPromiseRejectErrors = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"require using Error objects as Promise rejection reasons\",\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/prefer-promise-reject-errors\"\n    },\n    fixable: null,\n    schema: [{\n      type: \"object\",\n      properties: {\n        allowEmptyReject: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      rejectAnError: \"Expected the Promise rejection reason to be an Error.\"\n    }\n  },\n\n  create(context) {\n    const ALLOW_EMPTY_REJECT = context.options.length && context.options[0].allowEmptyReject;\n\n    function checkRejectCall(callExpression) {\n      if (!callExpression.arguments.length && ALLOW_EMPTY_REJECT) {\n        return;\n      }\n\n      if (!callExpression.arguments.length || !astUtils.couldBeError(callExpression.arguments[0]) || callExpression.arguments[0].type === \"Identifier\" && callExpression.arguments[0].name === \"undefined\") {\n        context.report({\n          node: callExpression,\n          messageId: \"rejectAnError\"\n        });\n      }\n    }\n\n    function isPromiseRejectCall(node) {\n      return astUtils.isSpecificMemberAccess(node.callee, \"Promise\", \"reject\");\n    }\n\n    return {\n      CallExpression(node) {\n        if (isPromiseRejectCall(node)) {\n          checkRejectCall(node);\n        }\n      },\n\n      \"NewExpression:exit\"(node) {\n        if (node.callee.type === \"Identifier\" && node.callee.name === \"Promise\" && node.arguments.length && astUtils.isFunction(node.arguments[0]) && node.arguments[0].params.length > 1 && node.arguments[0].params[1].type === \"Identifier\") {\n          context.getDeclaredVariables(node.arguments[0]).find(variable => variable.name === node.arguments[0].params[1].name).references.filter(ref => ref.isRead()).filter(ref => ref.identifier.parent.type === \"CallExpression\" && ref.identifier === ref.identifier.parent.callee).forEach(ref => checkRejectCall(ref.identifier.parent));\n        }\n      }\n\n    };\n  }\n\n};\npreferPromiseRejectErrors.meta;\npreferPromiseRejectErrors.create;\nvar preferReflect = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"require `Reflect` methods where applicable\",\n      category: \"ECMAScript 6\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/prefer-reflect\"\n    },\n    deprecated: true,\n    replacedBy: [],\n    schema: [{\n      type: \"object\",\n      properties: {\n        exceptions: {\n          type: \"array\",\n          items: {\n            enum: [\"apply\", \"call\", \"delete\", \"defineProperty\", \"getOwnPropertyDescriptor\", \"getPrototypeOf\", \"setPrototypeOf\", \"isExtensible\", \"getOwnPropertyNames\", \"preventExtensions\"]\n          },\n          uniqueItems: true\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      preferReflect: \"Avoid using {{existing}}, instead use {{substitute}}.\"\n    }\n  },\n\n  create(context) {\n    const existingNames = {\n      apply: \"Function.prototype.apply\",\n      call: \"Function.prototype.call\",\n      defineProperty: \"Object.defineProperty\",\n      getOwnPropertyDescriptor: \"Object.getOwnPropertyDescriptor\",\n      getPrototypeOf: \"Object.getPrototypeOf\",\n      setPrototypeOf: \"Object.setPrototypeOf\",\n      isExtensible: \"Object.isExtensible\",\n      getOwnPropertyNames: \"Object.getOwnPropertyNames\",\n      preventExtensions: \"Object.preventExtensions\"\n    };\n    const reflectSubstitutes = {\n      apply: \"Reflect.apply\",\n      call: \"Reflect.apply\",\n      defineProperty: \"Reflect.defineProperty\",\n      getOwnPropertyDescriptor: \"Reflect.getOwnPropertyDescriptor\",\n      getPrototypeOf: \"Reflect.getPrototypeOf\",\n      setPrototypeOf: \"Reflect.setPrototypeOf\",\n      isExtensible: \"Reflect.isExtensible\",\n      getOwnPropertyNames: \"Reflect.getOwnPropertyNames\",\n      preventExtensions: \"Reflect.preventExtensions\"\n    };\n    const exceptions = (context.options[0] || {}).exceptions || [];\n\n    function report(node, existing, substitute) {\n      context.report({\n        node,\n        messageId: \"preferReflect\",\n        data: {\n          existing,\n          substitute\n        }\n      });\n    }\n\n    return {\n      CallExpression(node) {\n        const methodName = (node.callee.property || {}).name;\n        const isReflectCall = (node.callee.object || {}).name === \"Reflect\";\n        const hasReflectSubstitute = Object.prototype.hasOwnProperty.call(reflectSubstitutes, methodName);\n        const userConfiguredException = exceptions.indexOf(methodName) !== -1;\n\n        if (hasReflectSubstitute && !isReflectCall && !userConfiguredException) {\n          report(node, existingNames[methodName], reflectSubstitutes[methodName]);\n        }\n      },\n\n      UnaryExpression(node) {\n        const isDeleteOperator = node.operator === \"delete\";\n        const targetsIdentifier = node.argument.type === \"Identifier\";\n        const userConfiguredException = exceptions.indexOf(\"delete\") !== -1;\n\n        if (isDeleteOperator && !targetsIdentifier && !userConfiguredException) {\n          report(node, \"the delete keyword\", \"Reflect.deleteProperty\");\n        }\n      }\n\n    };\n  }\n\n};\npreferReflect.meta;\npreferReflect.create;\nconst {\n  CALL: CALL$1,\n  CONSTRUCT: CONSTRUCT$1,\n  ReferenceTracker: ReferenceTracker$1,\n  findVariable\n} = eslintUtils__default['default'];\n\nfunction isStringLiteral(node) {\n  return node.type === \"Literal\" && typeof node.value === \"string\";\n}\n\nfunction isRegexLiteral(node) {\n  return node.type === \"Literal\" && Object.prototype.hasOwnProperty.call(node, \"regex\");\n}\n\nfunction isStaticTemplateLiteral$1(node) {\n  return node.type === \"TemplateLiteral\" && node.expressions.length === 0;\n}\n\nvar preferRegexLiterals = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow use of the `RegExp` constructor in favor of regular expression literals\",\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/prefer-regex-literals\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        disallowRedundantWrapping: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      unexpectedRegExp: \"Use a regular expression literal instead of the 'RegExp' constructor.\",\n      unexpectedRedundantRegExp: \"Regular expression literal is unnecessarily wrapped within a 'RegExp' constructor.\",\n      unexpectedRedundantRegExpWithFlags: \"Use regular expression literal with flags instead of the 'RegExp' constructor.\"\n    }\n  },\n\n  create(context) {\n    const [{\n      disallowRedundantWrapping = false\n    } = {}] = context.options;\n\n    function isGlobalReference(node) {\n      const scope = context.getScope();\n      const variable = findVariable(scope, node);\n      return variable !== null && variable.scope.type === \"global\" && variable.defs.length === 0;\n    }\n\n    function isStringRawTaggedStaticTemplateLiteral(node) {\n      return node.type === \"TaggedTemplateExpression\" && astUtils.isSpecificMemberAccess(node.tag, \"String\", \"raw\") && isGlobalReference(astUtils.skipChainExpression(node.tag).object) && isStaticTemplateLiteral$1(node.quasi);\n    }\n\n    function isStaticString(node) {\n      return isStringLiteral(node) || isStaticTemplateLiteral$1(node) || isStringRawTaggedStaticTemplateLiteral(node);\n    }\n\n    function hasOnlyStaticStringArguments(node) {\n      const args = node.arguments;\n\n      if ((args.length === 1 || args.length === 2) && args.every(isStaticString)) {\n        return true;\n      }\n\n      return false;\n    }\n\n    function isUnnecessarilyWrappedRegexLiteral(node) {\n      const args = node.arguments;\n\n      if (args.length === 1 && isRegexLiteral(args[0])) {\n        return true;\n      }\n\n      if (args.length === 2 && isRegexLiteral(args[0]) && isStaticString(args[1])) {\n        return true;\n      }\n\n      return false;\n    }\n\n    return {\n      Program() {\n        const scope = context.getScope();\n        const tracker = new ReferenceTracker$1(scope);\n        const traceMap = {\n          RegExp: {\n            [CALL$1]: true,\n            [CONSTRUCT$1]: true\n          }\n        };\n\n        for (const {\n          node\n        } of tracker.iterateGlobalReferences(traceMap)) {\n          if (disallowRedundantWrapping && isUnnecessarilyWrappedRegexLiteral(node)) {\n            if (node.arguments.length === 2) {\n              context.report({\n                node,\n                messageId: \"unexpectedRedundantRegExpWithFlags\"\n              });\n            } else {\n              context.report({\n                node,\n                messageId: \"unexpectedRedundantRegExp\"\n              });\n            }\n          } else if (hasOnlyStaticStringArguments(node)) {\n            context.report({\n              node,\n              messageId: \"unexpectedRegExp\"\n            });\n          }\n        }\n      }\n\n    };\n  }\n\n};\npreferRegexLiterals.meta;\npreferRegexLiterals.create;\n\nfunction getVariableOfArguments(scope) {\n  const variables = scope.variables;\n\n  for (let i = 0; i < variables.length; ++i) {\n    const variable = variables[i];\n\n    if (variable.name === \"arguments\") {\n      return variable.identifiers.length === 0 ? variable : null;\n    }\n  }\n\n  return null;\n}\n\nfunction isNotNormalMemberAccess(reference) {\n  const id = reference.identifier;\n  const parent = id.parent;\n  return !(parent.type === \"MemberExpression\" && parent.object === id && !parent.computed);\n}\n\nvar preferRestParams = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"require rest parameters instead of `arguments`\",\n      category: \"ECMAScript 6\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/prefer-rest-params\"\n    },\n    schema: [],\n    messages: {\n      preferRestParams: \"Use the rest parameters instead of 'arguments'.\"\n    }\n  },\n\n  create(context) {\n    function report(reference) {\n      context.report({\n        node: reference.identifier,\n        loc: reference.identifier.loc,\n        messageId: \"preferRestParams\"\n      });\n    }\n\n    function checkForArguments() {\n      const argumentsVar = getVariableOfArguments(context.getScope());\n\n      if (argumentsVar) {\n        argumentsVar.references.filter(isNotNormalMemberAccess).forEach(report);\n      }\n    }\n\n    return {\n      \"FunctionDeclaration:exit\": checkForArguments,\n      \"FunctionExpression:exit\": checkForArguments\n    };\n  }\n\n};\npreferRestParams.meta;\npreferRestParams.create;\n\nfunction isVariadicApplyCalling(node) {\n  return astUtils.isSpecificMemberAccess(node.callee, null, \"apply\") && node.arguments.length === 2 && node.arguments[1].type !== \"ArrayExpression\" && node.arguments[1].type !== \"SpreadElement\";\n}\n\nfunction isValidThisArg(expectedThis, thisArg, context) {\n  if (!expectedThis) {\n    return astUtils.isNullOrUndefined(thisArg);\n  }\n\n  return astUtils.equalTokens(expectedThis, thisArg, context);\n}\n\nvar preferSpread = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"require spread operators instead of `.apply()`\",\n      category: \"ECMAScript 6\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/prefer-spread\"\n    },\n    schema: [],\n    fixable: null,\n    messages: {\n      preferSpread: \"Use the spread operator instead of '.apply()'.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    return {\n      CallExpression(node) {\n        if (!isVariadicApplyCalling(node)) {\n          return;\n        }\n\n        const applied = astUtils.skipChainExpression(astUtils.skipChainExpression(node.callee).object);\n        const expectedThis = applied.type === \"MemberExpression\" ? applied.object : null;\n        const thisArg = node.arguments[0];\n\n        if (isValidThisArg(expectedThis, thisArg, sourceCode)) {\n          context.report({\n            node,\n            messageId: \"preferSpread\"\n          });\n        }\n      }\n\n    };\n  }\n\n};\npreferSpread.meta;\npreferSpread.create;\n\nfunction isConcatenation(node) {\n  return node.type === \"BinaryExpression\" && node.operator === \"+\";\n}\n\nfunction getTopConcatBinaryExpression(node) {\n  let currentNode = node;\n\n  while (isConcatenation(currentNode.parent)) {\n    currentNode = currentNode.parent;\n  }\n\n  return currentNode;\n}\n\nfunction hasOctalOrNonOctalDecimalEscapeSequence(node) {\n  if (isConcatenation(node)) {\n    return hasOctalOrNonOctalDecimalEscapeSequence(node.left) || hasOctalOrNonOctalDecimalEscapeSequence(node.right);\n  }\n\n  if (node.type === \"Literal\" && typeof node.value === \"string\") {\n    return astUtils.hasOctalOrNonOctalDecimalEscapeSequence(node.raw);\n  }\n\n  return false;\n}\n\nfunction hasStringLiteral(node) {\n  if (isConcatenation(node)) {\n    return hasStringLiteral(node.right) || hasStringLiteral(node.left);\n  }\n\n  return astUtils.isStringLiteral(node);\n}\n\nfunction hasNonStringLiteral(node) {\n  if (isConcatenation(node)) {\n    return hasNonStringLiteral(node.right) || hasNonStringLiteral(node.left);\n  }\n\n  return !astUtils.isStringLiteral(node);\n}\n\nfunction startsWithTemplateCurly(node) {\n  if (node.type === \"BinaryExpression\") {\n    return startsWithTemplateCurly(node.left);\n  }\n\n  if (node.type === \"TemplateLiteral\") {\n    return node.expressions.length && node.quasis.length && node.quasis[0].range[0] === node.quasis[0].range[1];\n  }\n\n  return node.type !== \"Literal\" || typeof node.value !== \"string\";\n}\n\nfunction endsWithTemplateCurly(node) {\n  if (node.type === \"BinaryExpression\") {\n    return startsWithTemplateCurly(node.right);\n  }\n\n  if (node.type === \"TemplateLiteral\") {\n    return node.expressions.length && node.quasis.length && node.quasis[node.quasis.length - 1].range[0] === node.quasis[node.quasis.length - 1].range[1];\n  }\n\n  return node.type !== \"Literal\" || typeof node.value !== \"string\";\n}\n\nvar preferTemplate = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"require template literals instead of string concatenation\",\n      category: \"ECMAScript 6\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/prefer-template\"\n    },\n    schema: [],\n    fixable: \"code\",\n    messages: {\n      unexpectedStringConcatenation: \"Unexpected string concatenation.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    let done = Object.create(null);\n\n    function getTextBetween(node1, node2) {\n      const allTokens = [node1].concat(sourceCode.getTokensBetween(node1, node2)).concat(node2);\n      const sourceText = sourceCode.getText();\n      return allTokens.slice(0, -1).reduce((accumulator, token, index) => accumulator + sourceText.slice(token.range[1], allTokens[index + 1].range[0]), \"\");\n    }\n\n    function getTemplateLiteral(currentNode, textBeforeNode, textAfterNode) {\n      if (currentNode.type === \"Literal\" && typeof currentNode.value === \"string\") {\n        return `\\`${currentNode.raw.slice(1, -1).replace(/\\\\*(\\$\\{|`)/gu, matched => {\n          if (matched.lastIndexOf(\"\\\\\") % 2) {\n            return `\\\\${matched}`;\n          }\n\n          return matched;\n        }).replace(new RegExp(`\\\\\\\\${currentNode.raw[0]}`, \"gu\"), currentNode.raw[0])}\\``;\n      }\n\n      if (currentNode.type === \"TemplateLiteral\") {\n        return sourceCode.getText(currentNode);\n      }\n\n      if (isConcatenation(currentNode) && hasStringLiteral(currentNode) && hasNonStringLiteral(currentNode)) {\n        const plusSign = sourceCode.getFirstTokenBetween(currentNode.left, currentNode.right, token => token.value === \"+\");\n        const textBeforePlus = getTextBetween(currentNode.left, plusSign);\n        const textAfterPlus = getTextBetween(plusSign, currentNode.right);\n        const leftEndsWithCurly = endsWithTemplateCurly(currentNode.left);\n        const rightStartsWithCurly = startsWithTemplateCurly(currentNode.right);\n\n        if (leftEndsWithCurly) {\n          return getTemplateLiteral(currentNode.left, textBeforeNode, textBeforePlus + textAfterPlus).slice(0, -1) + getTemplateLiteral(currentNode.right, null, textAfterNode).slice(1);\n        }\n\n        if (rightStartsWithCurly) {\n          return getTemplateLiteral(currentNode.left, textBeforeNode, null).slice(0, -1) + getTemplateLiteral(currentNode.right, textBeforePlus + textAfterPlus, textAfterNode).slice(1);\n        }\n\n        return `${getTemplateLiteral(currentNode.left, textBeforeNode, null)}${textBeforePlus}+${textAfterPlus}${getTemplateLiteral(currentNode.right, textAfterNode, null)}`;\n      }\n\n      return `\\`\\${${textBeforeNode || \"\"}${sourceCode.getText(currentNode)}${textAfterNode || \"\"}}\\``;\n    }\n\n    function fixNonStringBinaryExpression(fixer, node) {\n      const topBinaryExpr = getTopConcatBinaryExpression(node.parent);\n\n      if (hasOctalOrNonOctalDecimalEscapeSequence(topBinaryExpr)) {\n        return null;\n      }\n\n      return fixer.replaceText(topBinaryExpr, getTemplateLiteral(topBinaryExpr, null, null));\n    }\n\n    function checkForStringConcat(node) {\n      if (!astUtils.isStringLiteral(node) || !isConcatenation(node.parent)) {\n        return;\n      }\n\n      const topBinaryExpr = getTopConcatBinaryExpression(node.parent);\n\n      if (done[topBinaryExpr.range[0]]) {\n        return;\n      }\n\n      done[topBinaryExpr.range[0]] = true;\n\n      if (hasNonStringLiteral(topBinaryExpr)) {\n        context.report({\n          node: topBinaryExpr,\n          messageId: \"unexpectedStringConcatenation\",\n          fix: fixer => fixNonStringBinaryExpression(fixer, node)\n        });\n      }\n    }\n\n    return {\n      Program() {\n        done = Object.create(null);\n      },\n\n      Literal: checkForStringConcat,\n      TemplateLiteral: checkForStringConcat\n    };\n  }\n\n};\npreferTemplate.meta;\npreferTemplate.create;\nvar quoteProps = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"require quotes around object literal property names\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/quote-props\"\n    },\n    schema: {\n      anyOf: [{\n        type: \"array\",\n        items: [{\n          enum: [\"always\", \"as-needed\", \"consistent\", \"consistent-as-needed\"]\n        }],\n        minItems: 0,\n        maxItems: 1\n      }, {\n        type: \"array\",\n        items: [{\n          enum: [\"always\", \"as-needed\", \"consistent\", \"consistent-as-needed\"]\n        }, {\n          type: \"object\",\n          properties: {\n            keywords: {\n              type: \"boolean\"\n            },\n            unnecessary: {\n              type: \"boolean\"\n            },\n            numbers: {\n              type: \"boolean\"\n            }\n          },\n          additionalProperties: false\n        }],\n        minItems: 0,\n        maxItems: 2\n      }]\n    },\n    fixable: \"code\",\n    messages: {\n      requireQuotesDueToReservedWord: \"Properties should be quoted as '{{property}}' is a reserved word.\",\n      inconsistentlyQuotedProperty: \"Inconsistently quoted property '{{key}}' found.\",\n      unnecessarilyQuotedProperty: \"Unnecessarily quoted property '{{property}}' found.\",\n      unquotedReservedProperty: \"Unquoted reserved word '{{property}}' used as key.\",\n      unquotedNumericProperty: \"Unquoted number literal '{{property}}' used as key.\",\n      unquotedPropertyFound: \"Unquoted property '{{property}}' found.\",\n      redundantQuoting: \"Properties shouldn't be quoted as all quotes are redundant.\"\n    }\n  },\n\n  create(context) {\n    const MODE = context.options[0],\n          KEYWORDS = context.options[1] && context.options[1].keywords,\n          CHECK_UNNECESSARY = !context.options[1] || context.options[1].unnecessary !== false,\n          NUMBERS = context.options[1] && context.options[1].numbers,\n          sourceCode = context.getSourceCode();\n\n    function isKeyword(tokenStr) {\n      return keywords.indexOf(tokenStr) >= 0;\n    }\n\n    function areQuotesRedundant(rawKey, tokens, skipNumberLiterals) {\n      return tokens.length === 1 && tokens[0].start === 0 && tokens[0].end === rawKey.length && ([\"Identifier\", \"Keyword\", \"Null\", \"Boolean\"].indexOf(tokens[0].type) >= 0 || tokens[0].type === \"Numeric\" && !skipNumberLiterals && String(+tokens[0].value) === tokens[0].value);\n    }\n\n    function getUnquotedKey(key) {\n      return key.type === \"Identifier\" ? key.name : key.value;\n    }\n\n    function getQuotedKey(key) {\n      if (key.type === \"Literal\" && typeof key.value === \"string\") {\n        return sourceCode.getText(key);\n      }\n\n      return `\"${key.type === \"Identifier\" ? key.name : key.value}\"`;\n    }\n\n    function checkUnnecessaryQuotes(node) {\n      const key = node.key;\n\n      if (node.method || node.computed || node.shorthand) {\n        return;\n      }\n\n      if (key.type === \"Literal\" && typeof key.value === \"string\") {\n        let tokens;\n\n        try {\n          tokens = espree__default['default'].tokenize(key.value);\n        } catch {\n          return;\n        }\n\n        if (tokens.length !== 1) {\n          return;\n        }\n\n        const isKeywordToken = isKeyword(tokens[0].value);\n\n        if (isKeywordToken && KEYWORDS) {\n          return;\n        }\n\n        if (CHECK_UNNECESSARY && areQuotesRedundant(key.value, tokens, NUMBERS)) {\n          context.report({\n            node,\n            messageId: \"unnecessarilyQuotedProperty\",\n            data: {\n              property: key.value\n            },\n            fix: fixer => fixer.replaceText(key, getUnquotedKey(key))\n          });\n        }\n      } else if (KEYWORDS && key.type === \"Identifier\" && isKeyword(key.name)) {\n        context.report({\n          node,\n          messageId: \"unquotedReservedProperty\",\n          data: {\n            property: key.name\n          },\n          fix: fixer => fixer.replaceText(key, getQuotedKey(key))\n        });\n      } else if (NUMBERS && key.type === \"Literal\" && astUtils.isNumericLiteral(key)) {\n        context.report({\n          node,\n          messageId: \"unquotedNumericProperty\",\n          data: {\n            property: key.value\n          },\n          fix: fixer => fixer.replaceText(key, getQuotedKey(key))\n        });\n      }\n    }\n\n    function checkOmittedQuotes(node) {\n      const key = node.key;\n\n      if (!node.method && !node.computed && !node.shorthand && !(key.type === \"Literal\" && typeof key.value === \"string\")) {\n        context.report({\n          node,\n          messageId: \"unquotedPropertyFound\",\n          data: {\n            property: key.name || key.value\n          },\n          fix: fixer => fixer.replaceText(key, getQuotedKey(key))\n        });\n      }\n    }\n\n    function checkConsistency(node, checkQuotesRedundancy) {\n      const quotedProps = [],\n            unquotedProps = [];\n      let keywordKeyName = null,\n          necessaryQuotes = false;\n      node.properties.forEach(property => {\n        const key = property.key;\n\n        if (!key || property.method || property.computed || property.shorthand) {\n          return;\n        }\n\n        if (key.type === \"Literal\" && typeof key.value === \"string\") {\n          quotedProps.push(property);\n\n          if (checkQuotesRedundancy) {\n            let tokens;\n\n            try {\n              tokens = espree__default['default'].tokenize(key.value);\n            } catch {\n              necessaryQuotes = true;\n              return;\n            }\n\n            necessaryQuotes = necessaryQuotes || !areQuotesRedundant(key.value, tokens) || KEYWORDS && isKeyword(tokens[0].value);\n          }\n        } else if (KEYWORDS && checkQuotesRedundancy && key.type === \"Identifier\" && isKeyword(key.name)) {\n          unquotedProps.push(property);\n          necessaryQuotes = true;\n          keywordKeyName = key.name;\n        } else {\n          unquotedProps.push(property);\n        }\n      });\n\n      if (checkQuotesRedundancy && quotedProps.length && !necessaryQuotes) {\n        quotedProps.forEach(property => {\n          context.report({\n            node: property,\n            messageId: \"redundantQuoting\",\n            fix: fixer => fixer.replaceText(property.key, getUnquotedKey(property.key))\n          });\n        });\n      } else if (unquotedProps.length && keywordKeyName) {\n        unquotedProps.forEach(property => {\n          context.report({\n            node: property,\n            messageId: \"requireQuotesDueToReservedWord\",\n            data: {\n              property: keywordKeyName\n            },\n            fix: fixer => fixer.replaceText(property.key, getQuotedKey(property.key))\n          });\n        });\n      } else if (quotedProps.length && unquotedProps.length) {\n        unquotedProps.forEach(property => {\n          context.report({\n            node: property,\n            messageId: \"inconsistentlyQuotedProperty\",\n            data: {\n              key: property.key.name || property.key.value\n            },\n            fix: fixer => fixer.replaceText(property.key, getQuotedKey(property.key))\n          });\n        });\n      }\n    }\n\n    return {\n      Property(node) {\n        if (MODE === \"always\" || !MODE) {\n          checkOmittedQuotes(node);\n        }\n\n        if (MODE === \"as-needed\") {\n          checkUnnecessaryQuotes(node);\n        }\n      },\n\n      ObjectExpression(node) {\n        if (MODE === \"consistent\") {\n          checkConsistency(node, false);\n        }\n\n        if (MODE === \"consistent-as-needed\") {\n          checkConsistency(node, true);\n        }\n      }\n\n    };\n  }\n\n};\nquoteProps.meta;\nquoteProps.create;\nconst QUOTE_SETTINGS = {\n  double: {\n    quote: \"\\\"\",\n    alternateQuote: \"'\",\n    description: \"doublequote\"\n  },\n  single: {\n    quote: \"'\",\n    alternateQuote: \"\\\"\",\n    description: \"singlequote\"\n  },\n  backtick: {\n    quote: \"`\",\n    alternateQuote: \"\\\"\",\n    description: \"backtick\"\n  }\n};\nconst UNESCAPED_LINEBREAK_PATTERN = new RegExp(String.raw`(^|[^\\\\])(\\\\\\\\)*[${Array.from(astUtils.LINEBREAKS).join(\"\")}]`, \"u\");\n\nQUOTE_SETTINGS.double.convert = QUOTE_SETTINGS.single.convert = QUOTE_SETTINGS.backtick.convert = function (str) {\n  const newQuote = this.quote;\n  const oldQuote = str[0];\n\n  if (newQuote === oldQuote) {\n    return str;\n  }\n\n  return newQuote + str.slice(1, -1).replace(/\\\\(\\$\\{|\\r\\n?|\\n|.)|[\"'`]|\\$\\{|(\\r\\n?|\\n)/gu, (match, escaped, newline) => {\n    if (escaped === oldQuote || oldQuote === \"`\" && escaped === \"${\") {\n      return escaped;\n    }\n\n    if (match === newQuote || newQuote === \"`\" && match === \"${\") {\n      return `\\\\${match}`;\n    }\n\n    if (newline && oldQuote === \"`\") {\n      return \"\\\\n\";\n    }\n\n    return match;\n  }) + newQuote;\n};\n\nconst AVOID_ESCAPE = \"avoid-escape\";\nvar quotes = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"enforce the consistent use of either backticks, double, or single quotes\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/quotes\"\n    },\n    fixable: \"code\",\n    schema: [{\n      enum: [\"single\", \"double\", \"backtick\"]\n    }, {\n      anyOf: [{\n        enum: [\"avoid-escape\"]\n      }, {\n        type: \"object\",\n        properties: {\n          avoidEscape: {\n            type: \"boolean\"\n          },\n          allowTemplateLiterals: {\n            type: \"boolean\"\n          }\n        },\n        additionalProperties: false\n      }]\n    }],\n    messages: {\n      wrongQuotes: \"Strings must use {{description}}.\"\n    }\n  },\n\n  create(context) {\n    const quoteOption = context.options[0],\n          settings = QUOTE_SETTINGS[quoteOption || \"double\"],\n          options = context.options[1],\n          allowTemplateLiterals = options && options.allowTemplateLiterals === true,\n          sourceCode = context.getSourceCode();\n    let avoidEscape = options && options.avoidEscape === true;\n\n    if (options === AVOID_ESCAPE) {\n      avoidEscape = true;\n    }\n\n    function isJSXLiteral(node) {\n      return node.parent.type === \"JSXAttribute\" || node.parent.type === \"JSXElement\" || node.parent.type === \"JSXFragment\";\n    }\n\n    function isDirective(node) {\n      return node.type === \"ExpressionStatement\" && node.expression.type === \"Literal\" && typeof node.expression.value === \"string\";\n    }\n\n    function isPartOfDirectivePrologue(node) {\n      const block = node.parent.parent;\n\n      if (block.type !== \"Program\" && (block.type !== \"BlockStatement\" || !astUtils.isFunction(block.parent))) {\n        return false;\n      }\n\n      for (let i = 0; i < block.body.length; ++i) {\n        const statement = block.body[i];\n\n        if (statement === node.parent) {\n          return true;\n        }\n\n        if (!isDirective(statement)) {\n          break;\n        }\n      }\n\n      return false;\n    }\n\n    function isAllowedAsNonBacktick(node) {\n      const parent = node.parent;\n\n      switch (parent.type) {\n        case \"ExpressionStatement\":\n          return isPartOfDirectivePrologue(node);\n\n        case \"Property\":\n        case \"MethodDefinition\":\n          return parent.key === node && !parent.computed;\n\n        case \"ImportDeclaration\":\n        case \"ExportNamedDeclaration\":\n        case \"ExportAllDeclaration\":\n          return parent.source === node;\n\n        default:\n          return false;\n      }\n    }\n\n    function isUsingFeatureOfTemplateLiteral(node) {\n      const hasTag = node.parent.type === \"TaggedTemplateExpression\" && node === node.parent.quasi;\n\n      if (hasTag) {\n        return true;\n      }\n\n      const hasStringInterpolation = node.expressions.length > 0;\n\n      if (hasStringInterpolation) {\n        return true;\n      }\n\n      const isMultilineString = node.quasis.length >= 1 && UNESCAPED_LINEBREAK_PATTERN.test(node.quasis[0].value.raw);\n\n      if (isMultilineString) {\n        return true;\n      }\n\n      return false;\n    }\n\n    return {\n      Literal(node) {\n        const val = node.value,\n              rawVal = node.raw;\n\n        if (settings && typeof val === \"string\") {\n          let isValid = quoteOption === \"backtick\" && isAllowedAsNonBacktick(node) || isJSXLiteral(node) || astUtils.isSurroundedBy(rawVal, settings.quote);\n\n          if (!isValid && avoidEscape) {\n            isValid = astUtils.isSurroundedBy(rawVal, settings.alternateQuote) && rawVal.indexOf(settings.quote) >= 0;\n          }\n\n          if (!isValid) {\n            context.report({\n              node,\n              messageId: \"wrongQuotes\",\n              data: {\n                description: settings.description\n              },\n\n              fix(fixer) {\n                if (quoteOption === \"backtick\" && astUtils.hasOctalOrNonOctalDecimalEscapeSequence(rawVal)) {\n                  return null;\n                }\n\n                return fixer.replaceText(node, settings.convert(node.raw));\n              }\n\n            });\n          }\n        }\n      },\n\n      TemplateLiteral(node) {\n        if (allowTemplateLiterals || quoteOption === \"backtick\" || isUsingFeatureOfTemplateLiteral(node)) {\n          return;\n        }\n\n        context.report({\n          node,\n          messageId: \"wrongQuotes\",\n          data: {\n            description: settings.description\n          },\n\n          fix(fixer) {\n            if (isPartOfDirectivePrologue(node)) {\n              return null;\n            }\n\n            return fixer.replaceText(node, settings.convert(sourceCode.getText(node)));\n          }\n\n        });\n      }\n\n    };\n  }\n\n};\nquotes.meta;\nquotes.create;\nconst MODE_ALWAYS = \"always\",\n      MODE_AS_NEEDED = \"as-needed\";\nconst validRadixValues = new Set(Array.from({\n  length: 35\n}, (_, index) => index + 2));\n\nfunction isShadowed(variable) {\n  return variable.defs.length >= 1;\n}\n\nfunction isParseIntMethod(node) {\n  return node.type === \"MemberExpression\" && !node.computed && node.property.type === \"Identifier\" && node.property.name === \"parseInt\";\n}\n\nfunction isValidRadix(radix) {\n  return !(radix.type === \"Literal\" && !validRadixValues.has(radix.value) || radix.type === \"Identifier\" && radix.name === \"undefined\");\n}\n\nfunction isDefaultRadix(radix) {\n  return radix.type === \"Literal\" && radix.value === 10;\n}\n\nvar radix = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"enforce the consistent use of the radix argument when using `parseInt()`\",\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/radix\",\n      suggestion: true\n    },\n    schema: [{\n      enum: [\"always\", \"as-needed\"]\n    }],\n    messages: {\n      missingParameters: \"Missing parameters.\",\n      redundantRadix: \"Redundant radix parameter.\",\n      missingRadix: \"Missing radix parameter.\",\n      invalidRadix: \"Invalid radix parameter, must be an integer between 2 and 36.\",\n      addRadixParameter10: \"Add radix parameter `10` for parsing decimal numbers.\"\n    }\n  },\n\n  create(context) {\n    const mode = context.options[0] || MODE_ALWAYS;\n\n    function checkArguments(node) {\n      const args = node.arguments;\n\n      switch (args.length) {\n        case 0:\n          context.report({\n            node,\n            messageId: \"missingParameters\"\n          });\n          break;\n\n        case 1:\n          if (mode === MODE_ALWAYS) {\n            context.report({\n              node,\n              messageId: \"missingRadix\",\n              suggest: [{\n                messageId: \"addRadixParameter10\",\n\n                fix(fixer) {\n                  const sourceCode = context.getSourceCode();\n                  const tokens = sourceCode.getTokens(node);\n                  const lastToken = tokens[tokens.length - 1];\n                  const secondToLastToken = tokens[tokens.length - 2];\n                  const hasTrailingComma = secondToLastToken.type === \"Punctuator\" && secondToLastToken.value === \",\";\n                  return fixer.insertTextBefore(lastToken, hasTrailingComma ? \" 10,\" : \", 10\");\n                }\n\n              }]\n            });\n          }\n\n          break;\n\n        default:\n          if (mode === MODE_AS_NEEDED && isDefaultRadix(args[1])) {\n            context.report({\n              node,\n              messageId: \"redundantRadix\"\n            });\n          } else if (!isValidRadix(args[1])) {\n            context.report({\n              node,\n              messageId: \"invalidRadix\"\n            });\n          }\n\n          break;\n      }\n    }\n\n    return {\n      \"Program:exit\"() {\n        const scope = context.getScope();\n        let variable = astUtils.getVariableByName(scope, \"parseInt\");\n\n        if (variable && !isShadowed(variable)) {\n          variable.references.forEach(reference => {\n            const node = reference.identifier;\n\n            if (astUtils.isCallee(node)) {\n              checkArguments(node.parent);\n            }\n          });\n        }\n\n        variable = astUtils.getVariableByName(scope, \"Number\");\n\n        if (variable && !isShadowed(variable)) {\n          variable.references.forEach(reference => {\n            const node = reference.identifier.parent;\n            const maybeCallee = node.parent.type === \"ChainExpression\" ? node.parent : node;\n\n            if (isParseIntMethod(node) && astUtils.isCallee(maybeCallee)) {\n              checkArguments(maybeCallee.parent);\n            }\n          });\n        }\n      }\n\n    };\n  }\n\n};\nradix.meta;\nradix.create;\n\nfunction createReferenceMap(scope, outReferenceMap = new Map()) {\n  for (const reference of scope.references) {\n    if (reference.resolved === null) {\n      continue;\n    }\n\n    outReferenceMap.set(reference.identifier, reference);\n  }\n\n  for (const childScope of scope.childScopes) {\n    if (childScope.type !== \"function\") {\n      createReferenceMap(childScope, outReferenceMap);\n    }\n  }\n\n  return outReferenceMap;\n}\n\nfunction getWriteExpr(reference) {\n  if (reference.writeExpr) {\n    return reference.writeExpr;\n  }\n\n  let node = reference.identifier;\n\n  while (node) {\n    const t = node.parent.type;\n\n    if (t === \"AssignmentExpression\" && node.parent.left === node) {\n      return node.parent.right;\n    }\n\n    if (t === \"MemberExpression\" && node.parent.object === node) {\n      node = node.parent;\n      continue;\n    }\n\n    break;\n  }\n\n  return null;\n}\n\nfunction isLocalVariableWithoutEscape(variable, isMemberAccess) {\n  if (!variable) {\n    return false;\n  }\n\n  if (isMemberAccess && variable.defs.some(d => d.type === \"Parameter\")) {\n    return false;\n  }\n\n  const functionScope = variable.scope.variableScope;\n  return variable.references.every(reference => reference.from.variableScope === functionScope);\n}\n\nclass SegmentInfo {\n  constructor() {\n    this.info = new WeakMap();\n  }\n\n  initialize(segment) {\n    const outdatedReadVariables = new Set();\n    const freshReadVariables = new Set();\n\n    for (const prevSegment of segment.prevSegments) {\n      const info = this.info.get(prevSegment);\n\n      if (info) {\n        info.outdatedReadVariables.forEach(Set.prototype.add, outdatedReadVariables);\n        info.freshReadVariables.forEach(Set.prototype.add, freshReadVariables);\n      }\n    }\n\n    this.info.set(segment, {\n      outdatedReadVariables,\n      freshReadVariables\n    });\n  }\n\n  markAsRead(segments, variable) {\n    for (const segment of segments) {\n      const info = this.info.get(segment);\n\n      if (info) {\n        info.freshReadVariables.add(variable);\n        info.outdatedReadVariables.delete(variable);\n      }\n    }\n  }\n\n  makeOutdated(segments) {\n    for (const segment of segments) {\n      const info = this.info.get(segment);\n\n      if (info) {\n        info.freshReadVariables.forEach(Set.prototype.add, info.outdatedReadVariables);\n        info.freshReadVariables.clear();\n      }\n    }\n  }\n\n  isOutdated(segments, variable) {\n    for (const segment of segments) {\n      const info = this.info.get(segment);\n\n      if (info && info.outdatedReadVariables.has(variable)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n}\n\nvar requireAtomicUpdates = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"disallow assignments that can lead to race conditions due to usage of `await` or `yield`\",\n      category: \"Possible Errors\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/require-atomic-updates\"\n    },\n    fixable: null,\n    schema: [],\n    messages: {\n      nonAtomicUpdate: \"Possible race condition: `{{value}}` might be reassigned based on an outdated value of `{{value}}`.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    const assignmentReferences = new Map();\n    const segmentInfo = new SegmentInfo();\n    let stack = null;\n    return {\n      onCodePathStart(codePath) {\n        const scope = context.getScope();\n        const shouldVerify = scope.type === \"function\" && (scope.block.async || scope.block.generator);\n        stack = {\n          upper: stack,\n          codePath,\n          referenceMap: shouldVerify ? createReferenceMap(scope) : null\n        };\n      },\n\n      onCodePathEnd() {\n        stack = stack.upper;\n      },\n\n      onCodePathSegmentStart(segment) {\n        segmentInfo.initialize(segment);\n      },\n\n      Identifier(node) {\n        const {\n          codePath,\n          referenceMap\n        } = stack;\n        const reference = referenceMap && referenceMap.get(node);\n\n        if (!reference) {\n          return;\n        }\n\n        const variable = reference.resolved;\n        const writeExpr = getWriteExpr(reference);\n        const isMemberAccess = reference.identifier.parent.type === \"MemberExpression\";\n\n        if (reference.isRead() && !(writeExpr && writeExpr.parent.operator === \"=\")) {\n          segmentInfo.markAsRead(codePath.currentSegments, variable);\n        }\n\n        if (writeExpr && writeExpr.parent.right === writeExpr && !isLocalVariableWithoutEscape(variable, isMemberAccess)) {\n          let refs = assignmentReferences.get(writeExpr);\n\n          if (!refs) {\n            refs = [];\n            assignmentReferences.set(writeExpr, refs);\n          }\n\n          refs.push(reference);\n        }\n      },\n\n      \":expression:exit\"(node) {\n        const {\n          codePath,\n          referenceMap\n        } = stack;\n\n        if (!referenceMap) {\n          return;\n        }\n\n        if (node.type === \"AwaitExpression\" || node.type === \"YieldExpression\") {\n          segmentInfo.makeOutdated(codePath.currentSegments);\n        }\n\n        const references = assignmentReferences.get(node);\n\n        if (references) {\n          assignmentReferences.delete(node);\n\n          for (const reference of references) {\n            const variable = reference.resolved;\n\n            if (segmentInfo.isOutdated(codePath.currentSegments, variable)) {\n              context.report({\n                node: node.parent,\n                messageId: \"nonAtomicUpdate\",\n                data: {\n                  value: sourceCode.getText(node.parent.left)\n                }\n              });\n            }\n          }\n        }\n      }\n\n    };\n  }\n\n};\nrequireAtomicUpdates.meta;\nrequireAtomicUpdates.create;\n\nfunction capitalizeFirstLetter(text) {\n  return text[0].toUpperCase() + text.slice(1);\n}\n\nvar requireAwait = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow async functions which have no `await` expression\",\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/require-await\"\n    },\n    schema: [],\n    messages: {\n      missingAwait: \"{{name}} has no 'await' expression.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    let scopeInfo = null;\n\n    function enterFunction() {\n      scopeInfo = {\n        upper: scopeInfo,\n        hasAwait: false\n      };\n    }\n\n    function exitFunction(node) {\n      if (!node.generator && node.async && !scopeInfo.hasAwait && !astUtils.isEmptyFunction(node)) {\n        context.report({\n          node,\n          loc: astUtils.getFunctionHeadLoc(node, sourceCode),\n          messageId: \"missingAwait\",\n          data: {\n            name: capitalizeFirstLetter(astUtils.getFunctionNameWithKind(node))\n          }\n        });\n      }\n\n      scopeInfo = scopeInfo.upper;\n    }\n\n    return {\n      FunctionDeclaration: enterFunction,\n      FunctionExpression: enterFunction,\n      ArrowFunctionExpression: enterFunction,\n      \"FunctionDeclaration:exit\": exitFunction,\n      \"FunctionExpression:exit\": exitFunction,\n      \"ArrowFunctionExpression:exit\": exitFunction,\n\n      AwaitExpression() {\n        if (!scopeInfo) {\n          return;\n        }\n\n        scopeInfo.hasAwait = true;\n      },\n\n      ForOfStatement(node) {\n        if (!scopeInfo) {\n          return;\n        }\n\n        if (node.await) {\n          scopeInfo.hasAwait = true;\n        }\n      }\n\n    };\n  }\n\n};\nrequireAwait.meta;\nrequireAwait.create;\nvar requireJsdoc = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"require JSDoc comments\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/require-jsdoc\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        require: {\n          type: \"object\",\n          properties: {\n            ClassDeclaration: {\n              type: \"boolean\",\n              default: false\n            },\n            MethodDefinition: {\n              type: \"boolean\",\n              default: false\n            },\n            FunctionDeclaration: {\n              type: \"boolean\",\n              default: true\n            },\n            ArrowFunctionExpression: {\n              type: \"boolean\",\n              default: false\n            },\n            FunctionExpression: {\n              type: \"boolean\",\n              default: false\n            }\n          },\n          additionalProperties: false,\n          default: {}\n        }\n      },\n      additionalProperties: false\n    }],\n    deprecated: true,\n    replacedBy: [],\n    messages: {\n      missingJSDocComment: \"Missing JSDoc comment.\"\n    }\n  },\n\n  create(context) {\n    const source = context.getSourceCode();\n    const options = Object.assign({\n      FunctionDeclaration: true,\n      MethodDefinition: false,\n      ClassDeclaration: false,\n      ArrowFunctionExpression: false,\n      FunctionExpression: false\n    }, context.options[0] && context.options[0].require);\n\n    function report(node) {\n      context.report({\n        node,\n        messageId: \"missingJSDocComment\"\n      });\n    }\n\n    function checkJsDoc(node) {\n      const jsdocComment = source.getJSDocComment(node);\n\n      if (!jsdocComment) {\n        report(node);\n      }\n    }\n\n    return {\n      FunctionDeclaration(node) {\n        if (options.FunctionDeclaration) {\n          checkJsDoc(node);\n        }\n      },\n\n      FunctionExpression(node) {\n        if (options.MethodDefinition && node.parent.type === \"MethodDefinition\" || options.FunctionExpression && (node.parent.type === \"VariableDeclarator\" || node.parent.type === \"Property\" && node === node.parent.value)) {\n          checkJsDoc(node);\n        }\n      },\n\n      ClassDeclaration(node) {\n        if (options.ClassDeclaration) {\n          checkJsDoc(node);\n        }\n      },\n\n      ArrowFunctionExpression(node) {\n        if (options.ArrowFunctionExpression && node.parent.type === \"VariableDeclarator\") {\n          checkJsDoc(node);\n        }\n      }\n\n    };\n  }\n\n};\nrequireJsdoc.meta;\nrequireJsdoc.create;\nconst {\n  CALL,\n  CONSTRUCT,\n  ReferenceTracker,\n  getStringIfConstant\n} = eslintUtils__default['default'];\nvar requireUnicodeRegexp = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"enforce the use of `u` flag on RegExp\",\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/require-unicode-regexp\"\n    },\n    messages: {\n      requireUFlag: \"Use the 'u' flag.\"\n    },\n    schema: []\n  },\n\n  create(context) {\n    return {\n      \"Literal[regex]\"(node) {\n        const flags = node.regex.flags || \"\";\n\n        if (!flags.includes(\"u\")) {\n          context.report({\n            node,\n            messageId: \"requireUFlag\"\n          });\n        }\n      },\n\n      Program() {\n        const scope = context.getScope();\n        const tracker = new ReferenceTracker(scope);\n        const trackMap = {\n          RegExp: {\n            [CALL]: true,\n            [CONSTRUCT]: true\n          }\n        };\n\n        for (const {\n          node\n        } of tracker.iterateGlobalReferences(trackMap)) {\n          const flagsNode = node.arguments[1];\n          const flags = getStringIfConstant(flagsNode, scope);\n\n          if (!flagsNode || typeof flags === \"string\" && !flags.includes(\"u\")) {\n            context.report({\n              node,\n              messageId: \"requireUFlag\"\n            });\n          }\n        }\n      }\n\n    };\n  }\n\n};\nrequireUnicodeRegexp.meta;\nrequireUnicodeRegexp.create;\nvar requireYield = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"require generator functions to contain `yield`\",\n      category: \"ECMAScript 6\",\n      recommended: true,\n      url: \"https://eslint.org/docs/rules/require-yield\"\n    },\n    schema: [],\n    messages: {\n      missingYield: \"This generator function does not have 'yield'.\"\n    }\n  },\n\n  create(context) {\n    const stack = [];\n\n    function beginChecking(node) {\n      if (node.generator) {\n        stack.push(0);\n      }\n    }\n\n    function endChecking(node) {\n      if (!node.generator) {\n        return;\n      }\n\n      const countYield = stack.pop();\n\n      if (countYield === 0 && node.body.body.length > 0) {\n        context.report({\n          node,\n          messageId: \"missingYield\"\n        });\n      }\n    }\n\n    return {\n      FunctionDeclaration: beginChecking,\n      \"FunctionDeclaration:exit\": endChecking,\n      FunctionExpression: beginChecking,\n      \"FunctionExpression:exit\": endChecking,\n\n      YieldExpression() {\n        if (stack.length > 0) {\n          stack[stack.length - 1] += 1;\n        }\n      }\n\n    };\n  }\n\n};\nrequireYield.meta;\nrequireYield.create;\nvar restSpreadSpacing = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"enforce spacing between rest and spread operators and their expressions\",\n      category: \"ECMAScript 6\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/rest-spread-spacing\"\n    },\n    fixable: \"whitespace\",\n    schema: [{\n      enum: [\"always\", \"never\"]\n    }],\n    messages: {\n      unexpectedWhitespace: \"Unexpected whitespace after {{type}} operator.\",\n      expectedWhitespace: \"Expected whitespace after {{type}} operator.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode(),\n          alwaysSpace = context.options[0] === \"always\";\n\n    function checkWhiteSpace(node) {\n      const operator = sourceCode.getFirstToken(node),\n            nextToken = sourceCode.getTokenAfter(operator),\n            hasWhitespace = sourceCode.isSpaceBetweenTokens(operator, nextToken);\n      let type;\n\n      switch (node.type) {\n        case \"SpreadElement\":\n          type = \"spread\";\n\n          if (node.parent.type === \"ObjectExpression\") {\n            type += \" property\";\n          }\n\n          break;\n\n        case \"RestElement\":\n          type = \"rest\";\n\n          if (node.parent.type === \"ObjectPattern\") {\n            type += \" property\";\n          }\n\n          break;\n\n        case \"ExperimentalSpreadProperty\":\n          type = \"spread property\";\n          break;\n\n        case \"ExperimentalRestProperty\":\n          type = \"rest property\";\n          break;\n\n        default:\n          return;\n      }\n\n      if (alwaysSpace && !hasWhitespace) {\n        context.report({\n          node,\n          loc: operator.loc,\n          messageId: \"expectedWhitespace\",\n          data: {\n            type\n          },\n\n          fix(fixer) {\n            return fixer.replaceTextRange([operator.range[1], nextToken.range[0]], \" \");\n          }\n\n        });\n      } else if (!alwaysSpace && hasWhitespace) {\n        context.report({\n          node,\n          loc: {\n            start: operator.loc.end,\n            end: nextToken.loc.start\n          },\n          messageId: \"unexpectedWhitespace\",\n          data: {\n            type\n          },\n\n          fix(fixer) {\n            return fixer.removeRange([operator.range[1], nextToken.range[0]]);\n          }\n\n        });\n      }\n    }\n\n    return {\n      SpreadElement: checkWhiteSpace,\n      RestElement: checkWhiteSpace,\n      ExperimentalSpreadProperty: checkWhiteSpace,\n      ExperimentalRestProperty: checkWhiteSpace\n    };\n  }\n\n};\nrestSpreadSpacing.meta;\nrestSpreadSpacing.create;\nvar semiSpacing = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"enforce consistent spacing before and after semicolons\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/semi-spacing\"\n    },\n    fixable: \"whitespace\",\n    schema: [{\n      type: \"object\",\n      properties: {\n        before: {\n          type: \"boolean\",\n          default: false\n        },\n        after: {\n          type: \"boolean\",\n          default: true\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      unexpectedWhitespaceBefore: \"Unexpected whitespace before semicolon.\",\n      unexpectedWhitespaceAfter: \"Unexpected whitespace after semicolon.\",\n      missingWhitespaceBefore: \"Missing whitespace before semicolon.\",\n      missingWhitespaceAfter: \"Missing whitespace after semicolon.\"\n    }\n  },\n\n  create(context) {\n    const config = context.options[0],\n          sourceCode = context.getSourceCode();\n    let requireSpaceBefore = false,\n        requireSpaceAfter = true;\n\n    if (typeof config === \"object\") {\n      requireSpaceBefore = config.before;\n      requireSpaceAfter = config.after;\n    }\n\n    function hasLeadingSpace(token) {\n      const tokenBefore = sourceCode.getTokenBefore(token);\n      return tokenBefore && astUtils.isTokenOnSameLine(tokenBefore, token) && sourceCode.isSpaceBetweenTokens(tokenBefore, token);\n    }\n\n    function hasTrailingSpace(token) {\n      const tokenAfter = sourceCode.getTokenAfter(token);\n      return tokenAfter && astUtils.isTokenOnSameLine(token, tokenAfter) && sourceCode.isSpaceBetweenTokens(token, tokenAfter);\n    }\n\n    function isLastTokenInCurrentLine(token) {\n      const tokenAfter = sourceCode.getTokenAfter(token);\n      return !(tokenAfter && astUtils.isTokenOnSameLine(token, tokenAfter));\n    }\n\n    function isFirstTokenInCurrentLine(token) {\n      const tokenBefore = sourceCode.getTokenBefore(token);\n      return !(tokenBefore && astUtils.isTokenOnSameLine(token, tokenBefore));\n    }\n\n    function isBeforeClosingParen(token) {\n      const nextToken = sourceCode.getTokenAfter(token);\n      return nextToken && astUtils.isClosingBraceToken(nextToken) || astUtils.isClosingParenToken(nextToken);\n    }\n\n    function checkSemicolonSpacing(token, node) {\n      if (astUtils.isSemicolonToken(token)) {\n        if (hasLeadingSpace(token)) {\n          if (!requireSpaceBefore) {\n            const tokenBefore = sourceCode.getTokenBefore(token);\n            const loc = {\n              start: tokenBefore.loc.end,\n              end: token.loc.start\n            };\n            context.report({\n              node,\n              loc,\n              messageId: \"unexpectedWhitespaceBefore\",\n\n              fix(fixer) {\n                return fixer.removeRange([tokenBefore.range[1], token.range[0]]);\n              }\n\n            });\n          }\n        } else {\n          if (requireSpaceBefore) {\n            const loc = token.loc;\n            context.report({\n              node,\n              loc,\n              messageId: \"missingWhitespaceBefore\",\n\n              fix(fixer) {\n                return fixer.insertTextBefore(token, \" \");\n              }\n\n            });\n          }\n        }\n\n        if (!isFirstTokenInCurrentLine(token) && !isLastTokenInCurrentLine(token) && !isBeforeClosingParen(token)) {\n          if (hasTrailingSpace(token)) {\n            if (!requireSpaceAfter) {\n              const tokenAfter = sourceCode.getTokenAfter(token);\n              const loc = {\n                start: token.loc.end,\n                end: tokenAfter.loc.start\n              };\n              context.report({\n                node,\n                loc,\n                messageId: \"unexpectedWhitespaceAfter\",\n\n                fix(fixer) {\n                  return fixer.removeRange([token.range[1], tokenAfter.range[0]]);\n                }\n\n              });\n            }\n          } else {\n            if (requireSpaceAfter) {\n              const loc = token.loc;\n              context.report({\n                node,\n                loc,\n                messageId: \"missingWhitespaceAfter\",\n\n                fix(fixer) {\n                  return fixer.insertTextAfter(token, \" \");\n                }\n\n              });\n            }\n          }\n        }\n      }\n    }\n\n    function checkNode(node) {\n      const token = sourceCode.getLastToken(node);\n      checkSemicolonSpacing(token, node);\n    }\n\n    return {\n      VariableDeclaration: checkNode,\n      ExpressionStatement: checkNode,\n      BreakStatement: checkNode,\n      ContinueStatement: checkNode,\n      DebuggerStatement: checkNode,\n      DoWhileStatement: checkNode,\n      ReturnStatement: checkNode,\n      ThrowStatement: checkNode,\n      ImportDeclaration: checkNode,\n      ExportNamedDeclaration: checkNode,\n      ExportAllDeclaration: checkNode,\n      ExportDefaultDeclaration: checkNode,\n\n      ForStatement(node) {\n        if (node.init) {\n          checkSemicolonSpacing(sourceCode.getTokenAfter(node.init), node);\n        }\n\n        if (node.test) {\n          checkSemicolonSpacing(sourceCode.getTokenAfter(node.test), node);\n        }\n      }\n\n    };\n  }\n\n};\nsemiSpacing.meta;\nsemiSpacing.create;\nconst SELECTOR = `:matches(${\"BreakStatement,ContinueStatement,DebuggerStatement,DoWhileStatement,ExportAllDeclaration,ExportDefaultDeclaration,ExportNamedDeclaration,ExpressionStatement,ImportDeclaration,ReturnStatement,ThrowStatement,VariableDeclaration\"})`;\n\nfunction getChildren(node) {\n  const t = node.type;\n\n  if (t === \"BlockStatement\" || t === \"Program\") {\n    return node.body;\n  }\n\n  if (t === \"SwitchCase\") {\n    return node.consequent;\n  }\n\n  return null;\n}\n\nfunction isLastChild(node) {\n  const t = node.parent.type;\n\n  if (t === \"IfStatement\" && node.parent.consequent === node && node.parent.alternate) {\n    return true;\n  }\n\n  if (t === \"DoWhileStatement\") {\n    return true;\n  }\n\n  const nodeList = getChildren(node.parent);\n  return nodeList !== null && nodeList[nodeList.length - 1] === node;\n}\n\nvar semiStyle = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"enforce location of semicolons\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/semi-style\"\n    },\n    schema: [{\n      enum: [\"last\", \"first\"]\n    }],\n    fixable: \"whitespace\",\n    messages: {\n      expectedSemiColon: \"Expected this semicolon to be at {{pos}}.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    const option = context.options[0] || \"last\";\n\n    function check(semiToken, expected) {\n      const prevToken = sourceCode.getTokenBefore(semiToken);\n      const nextToken = sourceCode.getTokenAfter(semiToken);\n      const prevIsSameLine = !prevToken || astUtils.isTokenOnSameLine(prevToken, semiToken);\n      const nextIsSameLine = !nextToken || astUtils.isTokenOnSameLine(semiToken, nextToken);\n\n      if (expected === \"last\" && !prevIsSameLine || expected === \"first\" && !nextIsSameLine) {\n        context.report({\n          loc: semiToken.loc,\n          messageId: \"expectedSemiColon\",\n          data: {\n            pos: expected === \"last\" ? \"the end of the previous line\" : \"the beginning of the next line\"\n          },\n\n          fix(fixer) {\n            if (prevToken && nextToken && sourceCode.commentsExistBetween(prevToken, nextToken)) {\n              return null;\n            }\n\n            const start = prevToken ? prevToken.range[1] : semiToken.range[0];\n            const end = nextToken ? nextToken.range[0] : semiToken.range[1];\n            const text = expected === \"last\" ? \";\\n\" : \"\\n;\";\n            return fixer.replaceTextRange([start, end], text);\n          }\n\n        });\n      }\n    }\n\n    return {\n      [SELECTOR](node) {\n        if (option === \"first\" && isLastChild(node)) {\n          return;\n        }\n\n        const lastToken = sourceCode.getLastToken(node);\n\n        if (astUtils.isSemicolonToken(lastToken)) {\n          check(lastToken, option);\n        }\n      },\n\n      ForStatement(node) {\n        const firstSemi = node.init && sourceCode.getTokenAfter(node.init, astUtils.isSemicolonToken);\n        const secondSemi = node.test && sourceCode.getTokenAfter(node.test, astUtils.isSemicolonToken);\n\n        if (firstSemi) {\n          check(firstSemi, \"last\");\n        }\n\n        if (secondSemi) {\n          check(secondSemi, \"last\");\n        }\n      }\n\n    };\n  }\n\n};\nsemiStyle.meta;\nsemiStyle.create;\nvar semi = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"require or disallow semicolons instead of ASI\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/semi\"\n    },\n    fixable: \"code\",\n    schema: {\n      anyOf: [{\n        type: \"array\",\n        items: [{\n          enum: [\"never\"]\n        }, {\n          type: \"object\",\n          properties: {\n            beforeStatementContinuationChars: {\n              enum: [\"always\", \"any\", \"never\"]\n            }\n          },\n          additionalProperties: false\n        }],\n        minItems: 0,\n        maxItems: 2\n      }, {\n        type: \"array\",\n        items: [{\n          enum: [\"always\"]\n        }, {\n          type: \"object\",\n          properties: {\n            omitLastInOneLineBlock: {\n              type: \"boolean\"\n            }\n          },\n          additionalProperties: false\n        }],\n        minItems: 0,\n        maxItems: 2\n      }]\n    },\n    messages: {\n      missingSemi: \"Missing semicolon.\",\n      extraSemi: \"Extra semicolon.\"\n    }\n  },\n\n  create(context) {\n    const options = context.options[1];\n    const never = context.options[0] === \"never\";\n    const exceptOneLine = Boolean(options && options.omitLastInOneLineBlock);\n    const beforeStatementContinuationChars = options && options.beforeStatementContinuationChars || \"any\";\n    const sourceCode = context.getSourceCode();\n\n    function report(node, missing) {\n      const lastToken = sourceCode.getLastToken(node);\n      let messageId, fix, loc;\n\n      if (!missing) {\n        messageId = \"missingSemi\";\n        loc = {\n          start: lastToken.loc.end,\n          end: astUtils.getNextLocation(sourceCode, lastToken.loc.end)\n        };\n\n        fix = function (fixer) {\n          return fixer.insertTextAfter(lastToken, \";\");\n        };\n      } else {\n        messageId = \"extraSemi\";\n        loc = lastToken.loc;\n\n        fix = function (fixer) {\n          return new fixTracker(fixer, sourceCode).retainSurroundingTokens(lastToken).remove(lastToken);\n        };\n      }\n\n      context.report({\n        node,\n        loc,\n        messageId,\n        fix\n      });\n    }\n\n    function isRedundantSemi(semiToken) {\n      const nextToken = sourceCode.getTokenAfter(semiToken);\n      return !nextToken || astUtils.isClosingBraceToken(nextToken) || astUtils.isSemicolonToken(nextToken);\n    }\n\n    function isEndOfArrowBlock(lastToken) {\n      if (!astUtils.isClosingBraceToken(lastToken)) {\n        return false;\n      }\n\n      const node = sourceCode.getNodeByRangeIndex(lastToken.range[0]);\n      return node.type === \"BlockStatement\" && node.parent.type === \"ArrowFunctionExpression\";\n    }\n\n    function isOnSameLineWithNextToken(node) {\n      const prevToken = sourceCode.getLastToken(node, 1);\n      const nextToken = sourceCode.getTokenAfter(node);\n      return !!nextToken && astUtils.isTokenOnSameLine(prevToken, nextToken);\n    }\n\n    function maybeAsiHazardAfter(node) {\n      const t = node.type;\n\n      if (t === \"DoWhileStatement\" || t === \"BreakStatement\" || t === \"ContinueStatement\" || t === \"DebuggerStatement\" || t === \"ImportDeclaration\" || t === \"ExportAllDeclaration\") {\n        return false;\n      }\n\n      if (t === \"ReturnStatement\") {\n        return Boolean(node.argument);\n      }\n\n      if (t === \"ExportNamedDeclaration\") {\n        return Boolean(node.declaration);\n      }\n\n      if (isEndOfArrowBlock(sourceCode.getLastToken(node, 1))) {\n        return false;\n      }\n\n      return true;\n    }\n\n    function maybeAsiHazardBefore(token) {\n      return Boolean(token) && /^[-[(/+`]/u.test(token.value) && token.value !== \"++\" && token.value !== \"--\";\n    }\n\n    function canRemoveSemicolon(node) {\n      if (isRedundantSemi(sourceCode.getLastToken(node))) {\n        return true;\n      }\n\n      if (isOnSameLineWithNextToken(node)) {\n        return false;\n      }\n\n      if (beforeStatementContinuationChars === \"never\" && !maybeAsiHazardAfter(node)) {\n        return true;\n      }\n\n      if (!maybeAsiHazardBefore(sourceCode.getTokenAfter(node))) {\n        return true;\n      }\n\n      return false;\n    }\n\n    function isOneLinerBlock(node) {\n      const parent = node.parent;\n      const nextToken = sourceCode.getTokenAfter(node);\n\n      if (!nextToken || nextToken.value !== \"}\") {\n        return false;\n      }\n\n      return !!parent && parent.type === \"BlockStatement\" && parent.loc.start.line === parent.loc.end.line;\n    }\n\n    function checkForSemicolon(node) {\n      const isSemi = astUtils.isSemicolonToken(sourceCode.getLastToken(node));\n\n      if (never) {\n        if (isSemi && canRemoveSemicolon(node)) {\n          report(node, true);\n        } else if (!isSemi && beforeStatementContinuationChars === \"always\" && maybeAsiHazardBefore(sourceCode.getTokenAfter(node))) {\n          report(node);\n        }\n      } else {\n        const oneLinerBlock = exceptOneLine && isOneLinerBlock(node);\n\n        if (isSemi && oneLinerBlock) {\n          report(node, true);\n        } else if (!isSemi && !oneLinerBlock) {\n          report(node);\n        }\n      }\n    }\n\n    return {\n      VariableDeclaration: function (node) {\n        const parent = node.parent;\n\n        if ((parent.type !== \"ForStatement\" || parent.init !== node) && (!/^For(?:In|Of)Statement/u.test(parent.type) || parent.left !== node)) {\n          checkForSemicolon(node);\n        }\n      },\n      ExpressionStatement: checkForSemicolon,\n      ReturnStatement: checkForSemicolon,\n      ThrowStatement: checkForSemicolon,\n      DoWhileStatement: checkForSemicolon,\n      DebuggerStatement: checkForSemicolon,\n      BreakStatement: checkForSemicolon,\n      ContinueStatement: checkForSemicolon,\n      ImportDeclaration: checkForSemicolon,\n      ExportAllDeclaration: checkForSemicolon,\n\n      ExportNamedDeclaration(node) {\n        if (!node.declaration) {\n          checkForSemicolon(node);\n        }\n      },\n\n      ExportDefaultDeclaration(node) {\n        if (!/(?:Class|Function)Declaration/u.test(node.declaration.type)) {\n          checkForSemicolon(node);\n        }\n      }\n\n    };\n  }\n\n};\nsemi.meta;\nsemi.create;\nvar sortImports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"enforce sorted import declarations within modules\",\n      category: \"ECMAScript 6\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/sort-imports\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        ignoreCase: {\n          type: \"boolean\",\n          default: false\n        },\n        memberSyntaxSortOrder: {\n          type: \"array\",\n          items: {\n            enum: [\"none\", \"all\", \"multiple\", \"single\"]\n          },\n          uniqueItems: true,\n          minItems: 4,\n          maxItems: 4\n        },\n        ignoreDeclarationSort: {\n          type: \"boolean\",\n          default: false\n        },\n        ignoreMemberSort: {\n          type: \"boolean\",\n          default: false\n        },\n        allowSeparatedGroups: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    fixable: \"code\",\n    messages: {\n      sortImportsAlphabetically: \"Imports should be sorted alphabetically.\",\n      sortMembersAlphabetically: \"Member '{{memberName}}' of the import declaration should be sorted alphabetically.\",\n      unexpectedSyntaxOrder: \"Expected '{{syntaxA}}' syntax before '{{syntaxB}}' syntax.\"\n    }\n  },\n\n  create(context) {\n    const configuration = context.options[0] || {},\n          ignoreCase = configuration.ignoreCase || false,\n          ignoreDeclarationSort = configuration.ignoreDeclarationSort || false,\n          ignoreMemberSort = configuration.ignoreMemberSort || false,\n          memberSyntaxSortOrder = configuration.memberSyntaxSortOrder || [\"none\", \"all\", \"multiple\", \"single\"],\n          allowSeparatedGroups = configuration.allowSeparatedGroups || false,\n          sourceCode = context.getSourceCode();\n    let previousDeclaration = null;\n\n    function usedMemberSyntax(node) {\n      if (node.specifiers.length === 0) {\n        return \"none\";\n      }\n\n      if (node.specifiers[0].type === \"ImportNamespaceSpecifier\") {\n        return \"all\";\n      }\n\n      if (node.specifiers.length === 1) {\n        return \"single\";\n      }\n\n      return \"multiple\";\n    }\n\n    function getMemberParameterGroupIndex(node) {\n      return memberSyntaxSortOrder.indexOf(usedMemberSyntax(node));\n    }\n\n    function getFirstLocalMemberName(node) {\n      if (node.specifiers[0]) {\n        return node.specifiers[0].local.name;\n      }\n\n      return null;\n    }\n\n    function getNumberOfLinesBetween(left, right) {\n      return Math.max(right.loc.start.line - left.loc.end.line - 1, 0);\n    }\n\n    return {\n      ImportDeclaration(node) {\n        if (!ignoreDeclarationSort) {\n          if (previousDeclaration && allowSeparatedGroups && getNumberOfLinesBetween(previousDeclaration, node) > 0) {\n            previousDeclaration = null;\n          }\n\n          if (previousDeclaration) {\n            const currentMemberSyntaxGroupIndex = getMemberParameterGroupIndex(node),\n                  previousMemberSyntaxGroupIndex = getMemberParameterGroupIndex(previousDeclaration);\n            let currentLocalMemberName = getFirstLocalMemberName(node),\n                previousLocalMemberName = getFirstLocalMemberName(previousDeclaration);\n\n            if (ignoreCase) {\n              previousLocalMemberName = previousLocalMemberName && previousLocalMemberName.toLowerCase();\n              currentLocalMemberName = currentLocalMemberName && currentLocalMemberName.toLowerCase();\n            }\n\n            if (currentMemberSyntaxGroupIndex !== previousMemberSyntaxGroupIndex) {\n              if (currentMemberSyntaxGroupIndex < previousMemberSyntaxGroupIndex) {\n                context.report({\n                  node,\n                  messageId: \"unexpectedSyntaxOrder\",\n                  data: {\n                    syntaxA: memberSyntaxSortOrder[currentMemberSyntaxGroupIndex],\n                    syntaxB: memberSyntaxSortOrder[previousMemberSyntaxGroupIndex]\n                  }\n                });\n              }\n            } else {\n              if (previousLocalMemberName && currentLocalMemberName && currentLocalMemberName < previousLocalMemberName) {\n                context.report({\n                  node,\n                  messageId: \"sortImportsAlphabetically\"\n                });\n              }\n            }\n          }\n\n          previousDeclaration = node;\n        }\n\n        if (!ignoreMemberSort) {\n          const importSpecifiers = node.specifiers.filter(specifier => specifier.type === \"ImportSpecifier\");\n          const getSortableName = ignoreCase ? specifier => specifier.local.name.toLowerCase() : specifier => specifier.local.name;\n          const firstUnsortedIndex = importSpecifiers.map(getSortableName).findIndex((name, index, array) => array[index - 1] > name);\n\n          if (firstUnsortedIndex !== -1) {\n            context.report({\n              node: importSpecifiers[firstUnsortedIndex],\n              messageId: \"sortMembersAlphabetically\",\n              data: {\n                memberName: importSpecifiers[firstUnsortedIndex].local.name\n              },\n\n              fix(fixer) {\n                if (importSpecifiers.some(specifier => sourceCode.getCommentsBefore(specifier).length || sourceCode.getCommentsAfter(specifier).length)) {\n                  return null;\n                }\n\n                return fixer.replaceTextRange([importSpecifiers[0].range[0], importSpecifiers[importSpecifiers.length - 1].range[1]], importSpecifiers.slice().sort((specifierA, specifierB) => {\n                  const aName = getSortableName(specifierA);\n                  const bName = getSortableName(specifierB);\n                  return aName > bName ? 1 : -1;\n                }).reduce((sourceText, specifier, index) => {\n                  const textAfterSpecifier = index === importSpecifiers.length - 1 ? \"\" : sourceCode.getText().slice(importSpecifiers[index].range[1], importSpecifiers[index + 1].range[0]);\n                  return sourceText + sourceCode.getText(specifier) + textAfterSpecifier;\n                }, \"\"));\n              }\n\n            });\n          }\n        }\n      }\n\n    };\n  }\n\n};\nsortImports.meta;\nsortImports.create;\n\nfunction getPropertyName(node) {\n  const staticName = astUtils.getStaticPropertyName(node);\n\n  if (staticName !== null) {\n    return staticName;\n  }\n\n  return node.key.name || null;\n}\n\nconst isValidOrders = {\n  asc(a, b) {\n    return a <= b;\n  },\n\n  ascI(a, b) {\n    return a.toLowerCase() <= b.toLowerCase();\n  },\n\n  ascN(a, b) {\n    return naturalCompare__default['default'](a, b) <= 0;\n  },\n\n  ascIN(a, b) {\n    return naturalCompare__default['default'](a.toLowerCase(), b.toLowerCase()) <= 0;\n  },\n\n  desc(a, b) {\n    return isValidOrders.asc(b, a);\n  },\n\n  descI(a, b) {\n    return isValidOrders.ascI(b, a);\n  },\n\n  descN(a, b) {\n    return isValidOrders.ascN(b, a);\n  },\n\n  descIN(a, b) {\n    return isValidOrders.ascIN(b, a);\n  }\n\n};\nvar sortKeys = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"require object keys to be sorted\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/sort-keys\"\n    },\n    schema: [{\n      enum: [\"asc\", \"desc\"]\n    }, {\n      type: \"object\",\n      properties: {\n        caseSensitive: {\n          type: \"boolean\",\n          default: true\n        },\n        natural: {\n          type: \"boolean\",\n          default: false\n        },\n        minKeys: {\n          type: \"integer\",\n          minimum: 2,\n          default: 2\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      sortKeys: \"Expected object keys to be in {{natural}}{{insensitive}}{{order}}ending order. '{{thisName}}' should be before '{{prevName}}'.\"\n    }\n  },\n\n  create(context) {\n    const order = context.options[0] || \"asc\";\n    const options = context.options[1];\n    const insensitive = options && options.caseSensitive === false;\n    const natural = options && options.natural;\n    const minKeys = options && options.minKeys;\n    const isValidOrder = isValidOrders[order + (insensitive ? \"I\" : \"\") + (natural ? \"N\" : \"\")];\n    let stack = null;\n    return {\n      ObjectExpression(node) {\n        stack = {\n          upper: stack,\n          prevName: null,\n          numKeys: node.properties.length\n        };\n      },\n\n      \"ObjectExpression:exit\"() {\n        stack = stack.upper;\n      },\n\n      SpreadElement(node) {\n        if (node.parent.type === \"ObjectExpression\") {\n          stack.prevName = null;\n        }\n      },\n\n      Property(node) {\n        if (node.parent.type === \"ObjectPattern\") {\n          return;\n        }\n\n        const prevName = stack.prevName;\n        const numKeys = stack.numKeys;\n        const thisName = getPropertyName(node);\n\n        if (thisName !== null) {\n          stack.prevName = thisName;\n        }\n\n        if (prevName === null || thisName === null || numKeys < minKeys) {\n          return;\n        }\n\n        if (!isValidOrder(prevName, thisName)) {\n          context.report({\n            node,\n            loc: node.key.loc,\n            messageId: \"sortKeys\",\n            data: {\n              thisName,\n              prevName,\n              order,\n              insensitive: insensitive ? \"insensitive \" : \"\",\n              natural: natural ? \"natural \" : \"\"\n            }\n          });\n        }\n      }\n\n    };\n  }\n\n};\nsortKeys.meta;\nsortKeys.create;\nvar sortVars = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"require variables within the same declaration block to be sorted\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/sort-vars\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        ignoreCase: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    fixable: \"code\",\n    messages: {\n      sortVars: \"Variables within the same declaration block should be sorted alphabetically.\"\n    }\n  },\n\n  create(context) {\n    const configuration = context.options[0] || {},\n          ignoreCase = configuration.ignoreCase || false,\n          sourceCode = context.getSourceCode();\n    return {\n      VariableDeclaration(node) {\n        const idDeclarations = node.declarations.filter(decl => decl.id.type === \"Identifier\");\n        const getSortableName = ignoreCase ? decl => decl.id.name.toLowerCase() : decl => decl.id.name;\n        const unfixable = idDeclarations.some(decl => decl.init !== null && decl.init.type !== \"Literal\");\n        let fixed = false;\n        idDeclarations.slice(1).reduce((memo, decl) => {\n          const lastVariableName = getSortableName(memo),\n                currentVariableName = getSortableName(decl);\n\n          if (currentVariableName < lastVariableName) {\n            context.report({\n              node: decl,\n              messageId: \"sortVars\",\n\n              fix(fixer) {\n                if (unfixable || fixed) {\n                  return null;\n                }\n\n                return fixer.replaceTextRange([idDeclarations[0].range[0], idDeclarations[idDeclarations.length - 1].range[1]], idDeclarations.slice().sort((declA, declB) => {\n                  const aName = getSortableName(declA);\n                  const bName = getSortableName(declB);\n                  return aName > bName ? 1 : -1;\n                }).reduce((sourceText, identifier, index) => {\n                  const textAfterIdentifier = index === idDeclarations.length - 1 ? \"\" : sourceCode.getText().slice(idDeclarations[index].range[1], idDeclarations[index + 1].range[0]);\n                  return sourceText + sourceCode.getText(identifier) + textAfterIdentifier;\n                }, \"\"));\n              }\n\n            });\n            fixed = true;\n            return memo;\n          }\n\n          return decl;\n        }, idDeclarations[0]);\n      }\n\n    };\n  }\n\n};\nsortVars.meta;\nsortVars.create;\n\nfunction isFunctionBody(node) {\n  const parent = node.parent;\n  return node.type === \"BlockStatement\" && astUtils.isFunction(parent) && parent.body === node;\n}\n\nvar spaceBeforeBlocks = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"enforce consistent spacing before blocks\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/space-before-blocks\"\n    },\n    fixable: \"whitespace\",\n    schema: [{\n      oneOf: [{\n        enum: [\"always\", \"never\"]\n      }, {\n        type: \"object\",\n        properties: {\n          keywords: {\n            enum: [\"always\", \"never\", \"off\"]\n          },\n          functions: {\n            enum: [\"always\", \"never\", \"off\"]\n          },\n          classes: {\n            enum: [\"always\", \"never\", \"off\"]\n          }\n        },\n        additionalProperties: false\n      }]\n    }],\n    messages: {\n      unexpectedSpace: \"Unexpected space before opening brace.\",\n      missingSpace: \"Missing space before opening brace.\"\n    }\n  },\n\n  create(context) {\n    const config = context.options[0],\n          sourceCode = context.getSourceCode();\n    let alwaysFunctions = true,\n        alwaysKeywords = true,\n        alwaysClasses = true,\n        neverFunctions = false,\n        neverKeywords = false,\n        neverClasses = false;\n\n    if (typeof config === \"object\") {\n      alwaysFunctions = config.functions === \"always\";\n      alwaysKeywords = config.keywords === \"always\";\n      alwaysClasses = config.classes === \"always\";\n      neverFunctions = config.functions === \"never\";\n      neverKeywords = config.keywords === \"never\";\n      neverClasses = config.classes === \"never\";\n    } else if (config === \"never\") {\n      alwaysFunctions = false;\n      alwaysKeywords = false;\n      alwaysClasses = false;\n      neverFunctions = true;\n      neverKeywords = true;\n      neverClasses = true;\n    }\n\n    function isConflicted(precedingToken, node) {\n      return astUtils.isArrowToken(precedingToken) || astUtils.isKeywordToken(precedingToken) && !isFunctionBody(node);\n    }\n\n    function checkPrecedingSpace(node) {\n      const precedingToken = sourceCode.getTokenBefore(node);\n\n      if (precedingToken && !isConflicted(precedingToken, node) && astUtils.isTokenOnSameLine(precedingToken, node)) {\n        const hasSpace = sourceCode.isSpaceBetweenTokens(precedingToken, node);\n        let requireSpace;\n        let requireNoSpace;\n\n        if (isFunctionBody(node)) {\n          requireSpace = alwaysFunctions;\n          requireNoSpace = neverFunctions;\n        } else if (node.type === \"ClassBody\") {\n          requireSpace = alwaysClasses;\n          requireNoSpace = neverClasses;\n        } else {\n          requireSpace = alwaysKeywords;\n          requireNoSpace = neverKeywords;\n        }\n\n        if (requireSpace && !hasSpace) {\n          context.report({\n            node,\n            messageId: \"missingSpace\",\n\n            fix(fixer) {\n              return fixer.insertTextBefore(node, \" \");\n            }\n\n          });\n        } else if (requireNoSpace && hasSpace) {\n          context.report({\n            node,\n            messageId: \"unexpectedSpace\",\n\n            fix(fixer) {\n              return fixer.removeRange([precedingToken.range[1], node.range[0]]);\n            }\n\n          });\n        }\n      }\n    }\n\n    return {\n      BlockStatement: checkPrecedingSpace,\n      ClassBody: checkPrecedingSpace,\n      SwitchStatement: function (node) {\n        const cases = node.cases;\n        let openingBrace;\n\n        if (cases.length > 0) {\n          openingBrace = sourceCode.getTokenBefore(cases[0]);\n        } else {\n          openingBrace = sourceCode.getLastToken(node, 1);\n        }\n\n        checkPrecedingSpace(openingBrace);\n      }\n    };\n  }\n\n};\nspaceBeforeBlocks.meta;\nspaceBeforeBlocks.create;\nvar spaceBeforeFunctionParen = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"enforce consistent spacing before `function` definition opening parenthesis\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/space-before-function-paren\"\n    },\n    fixable: \"whitespace\",\n    schema: [{\n      oneOf: [{\n        enum: [\"always\", \"never\"]\n      }, {\n        type: \"object\",\n        properties: {\n          anonymous: {\n            enum: [\"always\", \"never\", \"ignore\"]\n          },\n          named: {\n            enum: [\"always\", \"never\", \"ignore\"]\n          },\n          asyncArrow: {\n            enum: [\"always\", \"never\", \"ignore\"]\n          }\n        },\n        additionalProperties: false\n      }]\n    }],\n    messages: {\n      unexpectedSpace: \"Unexpected space before function parentheses.\",\n      missingSpace: \"Missing space before function parentheses.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    const baseConfig = typeof context.options[0] === \"string\" ? context.options[0] : \"always\";\n    const overrideConfig = typeof context.options[0] === \"object\" ? context.options[0] : {};\n\n    function isNamedFunction(node) {\n      if (node.id) {\n        return true;\n      }\n\n      const parent = node.parent;\n      return parent.type === \"MethodDefinition\" || parent.type === \"Property\" && (parent.kind === \"get\" || parent.kind === \"set\" || parent.method);\n    }\n\n    function getConfigForFunction(node) {\n      if (node.type === \"ArrowFunctionExpression\") {\n        if (node.async && astUtils.isOpeningParenToken(sourceCode.getFirstToken(node, {\n          skip: 1\n        }))) {\n          return overrideConfig.asyncArrow || baseConfig;\n        }\n      } else if (isNamedFunction(node)) {\n        return overrideConfig.named || baseConfig;\n      } else if (!node.generator) {\n        return overrideConfig.anonymous || baseConfig;\n      }\n\n      return \"ignore\";\n    }\n\n    function checkFunction(node) {\n      const functionConfig = getConfigForFunction(node);\n\n      if (functionConfig === \"ignore\") {\n        return;\n      }\n\n      const rightToken = sourceCode.getFirstToken(node, astUtils.isOpeningParenToken);\n      const leftToken = sourceCode.getTokenBefore(rightToken);\n      const hasSpacing = sourceCode.isSpaceBetweenTokens(leftToken, rightToken);\n\n      if (hasSpacing && functionConfig === \"never\") {\n        context.report({\n          node,\n          loc: {\n            start: leftToken.loc.end,\n            end: rightToken.loc.start\n          },\n          messageId: \"unexpectedSpace\",\n\n          fix(fixer) {\n            const comments = sourceCode.getCommentsBefore(rightToken);\n\n            if (comments.some(comment => comment.type === \"Line\")) {\n              return null;\n            }\n\n            return fixer.replaceTextRange([leftToken.range[1], rightToken.range[0]], comments.reduce((text, comment) => text + sourceCode.getText(comment), \"\"));\n          }\n\n        });\n      } else if (!hasSpacing && functionConfig === \"always\") {\n        context.report({\n          node,\n          loc: rightToken.loc,\n          messageId: \"missingSpace\",\n          fix: fixer => fixer.insertTextAfter(leftToken, \" \")\n        });\n      }\n    }\n\n    return {\n      ArrowFunctionExpression: checkFunction,\n      FunctionDeclaration: checkFunction,\n      FunctionExpression: checkFunction\n    };\n  }\n\n};\nspaceBeforeFunctionParen.meta;\nspaceBeforeFunctionParen.create;\nvar spaceInParens = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"enforce consistent spacing inside parentheses\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/space-in-parens\"\n    },\n    fixable: \"whitespace\",\n    schema: [{\n      enum: [\"always\", \"never\"]\n    }, {\n      type: \"object\",\n      properties: {\n        exceptions: {\n          type: \"array\",\n          items: {\n            enum: [\"{}\", \"[]\", \"()\", \"empty\"]\n          },\n          uniqueItems: true\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      missingOpeningSpace: \"There must be a space after this paren.\",\n      missingClosingSpace: \"There must be a space before this paren.\",\n      rejectedOpeningSpace: \"There should be no space after this paren.\",\n      rejectedClosingSpace: \"There should be no space before this paren.\"\n    }\n  },\n\n  create(context) {\n    const ALWAYS = context.options[0] === \"always\",\n          exceptionsArrayOptions = context.options[1] && context.options[1].exceptions || [],\n          options = {};\n    let exceptions;\n\n    if (exceptionsArrayOptions.length) {\n      options.braceException = exceptionsArrayOptions.includes(\"{}\");\n      options.bracketException = exceptionsArrayOptions.includes(\"[]\");\n      options.parenException = exceptionsArrayOptions.includes(\"()\");\n      options.empty = exceptionsArrayOptions.includes(\"empty\");\n    }\n\n    function getExceptions() {\n      const openers = [],\n            closers = [];\n\n      if (options.braceException) {\n        openers.push(\"{\");\n        closers.push(\"}\");\n      }\n\n      if (options.bracketException) {\n        openers.push(\"[\");\n        closers.push(\"]\");\n      }\n\n      if (options.parenException) {\n        openers.push(\"(\");\n        closers.push(\")\");\n      }\n\n      if (options.empty) {\n        openers.push(\")\");\n        closers.push(\"(\");\n      }\n\n      return {\n        openers,\n        closers\n      };\n    }\n\n    const sourceCode = context.getSourceCode();\n\n    function isOpenerException(token) {\n      return exceptions.openers.includes(token.value);\n    }\n\n    function isCloserException(token) {\n      return exceptions.closers.includes(token.value);\n    }\n\n    function openerMissingSpace(openingParenToken, tokenAfterOpeningParen) {\n      if (sourceCode.isSpaceBetweenTokens(openingParenToken, tokenAfterOpeningParen)) {\n        return false;\n      }\n\n      if (!options.empty && astUtils.isClosingParenToken(tokenAfterOpeningParen)) {\n        return false;\n      }\n\n      if (ALWAYS) {\n        return !isOpenerException(tokenAfterOpeningParen);\n      }\n\n      return isOpenerException(tokenAfterOpeningParen);\n    }\n\n    function openerRejectsSpace(openingParenToken, tokenAfterOpeningParen) {\n      if (!astUtils.isTokenOnSameLine(openingParenToken, tokenAfterOpeningParen)) {\n        return false;\n      }\n\n      if (tokenAfterOpeningParen.type === \"Line\") {\n        return false;\n      }\n\n      if (!sourceCode.isSpaceBetweenTokens(openingParenToken, tokenAfterOpeningParen)) {\n        return false;\n      }\n\n      if (ALWAYS) {\n        return isOpenerException(tokenAfterOpeningParen);\n      }\n\n      return !isOpenerException(tokenAfterOpeningParen);\n    }\n\n    function closerMissingSpace(tokenBeforeClosingParen, closingParenToken) {\n      if (sourceCode.isSpaceBetweenTokens(tokenBeforeClosingParen, closingParenToken)) {\n        return false;\n      }\n\n      if (!options.empty && astUtils.isOpeningParenToken(tokenBeforeClosingParen)) {\n        return false;\n      }\n\n      if (ALWAYS) {\n        return !isCloserException(tokenBeforeClosingParen);\n      }\n\n      return isCloserException(tokenBeforeClosingParen);\n    }\n\n    function closerRejectsSpace(tokenBeforeClosingParen, closingParenToken) {\n      if (!astUtils.isTokenOnSameLine(tokenBeforeClosingParen, closingParenToken)) {\n        return false;\n      }\n\n      if (!sourceCode.isSpaceBetweenTokens(tokenBeforeClosingParen, closingParenToken)) {\n        return false;\n      }\n\n      if (ALWAYS) {\n        return isCloserException(tokenBeforeClosingParen);\n      }\n\n      return !isCloserException(tokenBeforeClosingParen);\n    }\n\n    return {\n      Program: function (node) {\n        exceptions = getExceptions();\n        const tokens = sourceCode.tokensAndComments;\n        tokens.forEach((token, i) => {\n          const prevToken = tokens[i - 1];\n          const nextToken = tokens[i + 1];\n\n          if (!astUtils.isOpeningParenToken(token) && !astUtils.isClosingParenToken(token)) {\n            return;\n          }\n\n          if (token.value === \"(\" && openerMissingSpace(token, nextToken)) {\n            context.report({\n              node,\n              loc: token.loc,\n              messageId: \"missingOpeningSpace\",\n\n              fix(fixer) {\n                return fixer.insertTextAfter(token, \" \");\n              }\n\n            });\n          }\n\n          if (token.value === \"(\" && openerRejectsSpace(token, nextToken)) {\n            context.report({\n              node,\n              loc: {\n                start: token.loc.end,\n                end: nextToken.loc.start\n              },\n              messageId: \"rejectedOpeningSpace\",\n\n              fix(fixer) {\n                return fixer.removeRange([token.range[1], nextToken.range[0]]);\n              }\n\n            });\n          }\n\n          if (token.value === \")\" && closerMissingSpace(prevToken, token)) {\n            context.report({\n              node,\n              loc: token.loc,\n              messageId: \"missingClosingSpace\",\n\n              fix(fixer) {\n                return fixer.insertTextBefore(token, \" \");\n              }\n\n            });\n          }\n\n          if (token.value === \")\" && closerRejectsSpace(prevToken, token)) {\n            context.report({\n              node,\n              loc: {\n                start: prevToken.loc.end,\n                end: token.loc.start\n              },\n              messageId: \"rejectedClosingSpace\",\n\n              fix(fixer) {\n                return fixer.removeRange([prevToken.range[1], token.range[0]]);\n              }\n\n            });\n          }\n        });\n      }\n    };\n  }\n\n};\nspaceInParens.meta;\nspaceInParens.create;\nvar spaceInfixOps = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"require spacing around infix operators\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/space-infix-ops\"\n    },\n    fixable: \"whitespace\",\n    schema: [{\n      type: \"object\",\n      properties: {\n        int32Hint: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      missingSpace: \"Operator '{{operator}}' must be spaced.\"\n    }\n  },\n\n  create(context) {\n    const int32Hint = context.options[0] ? context.options[0].int32Hint === true : false;\n    const sourceCode = context.getSourceCode();\n\n    function getFirstNonSpacedToken(left, right, op) {\n      const operator = sourceCode.getFirstTokenBetween(left, right, token => token.value === op);\n      const prev = sourceCode.getTokenBefore(operator);\n      const next = sourceCode.getTokenAfter(operator);\n\n      if (!sourceCode.isSpaceBetweenTokens(prev, operator) || !sourceCode.isSpaceBetweenTokens(operator, next)) {\n        return operator;\n      }\n\n      return null;\n    }\n\n    function report(mainNode, culpritToken) {\n      context.report({\n        node: mainNode,\n        loc: culpritToken.loc,\n        messageId: \"missingSpace\",\n        data: {\n          operator: culpritToken.value\n        },\n\n        fix(fixer) {\n          const previousToken = sourceCode.getTokenBefore(culpritToken);\n          const afterToken = sourceCode.getTokenAfter(culpritToken);\n          let fixString = \"\";\n\n          if (culpritToken.range[0] - previousToken.range[1] === 0) {\n            fixString = \" \";\n          }\n\n          fixString += culpritToken.value;\n\n          if (afterToken.range[0] - culpritToken.range[1] === 0) {\n            fixString += \" \";\n          }\n\n          return fixer.replaceText(culpritToken, fixString);\n        }\n\n      });\n    }\n\n    function checkBinary(node) {\n      const leftNode = node.left.typeAnnotation ? node.left.typeAnnotation : node.left;\n      const rightNode = node.right;\n      const operator = node.operator || \"=\";\n      const nonSpacedNode = getFirstNonSpacedToken(leftNode, rightNode, operator);\n\n      if (nonSpacedNode) {\n        if (!(int32Hint && sourceCode.getText(node).endsWith(\"|0\"))) {\n          report(node, nonSpacedNode);\n        }\n      }\n    }\n\n    return {\n      AssignmentExpression: checkBinary,\n      AssignmentPattern: checkBinary,\n      BinaryExpression: checkBinary,\n      LogicalExpression: checkBinary,\n      ConditionalExpression: function (node) {\n        const nonSpacedConsequentNode = getFirstNonSpacedToken(node.test, node.consequent, \"?\");\n        const nonSpacedAlternateNode = getFirstNonSpacedToken(node.consequent, node.alternate, \":\");\n\n        if (nonSpacedConsequentNode) {\n          report(node, nonSpacedConsequentNode);\n        }\n\n        if (nonSpacedAlternateNode) {\n          report(node, nonSpacedAlternateNode);\n        }\n      },\n      VariableDeclarator: function (node) {\n        const leftNode = node.id.typeAnnotation ? node.id.typeAnnotation : node.id;\n        const rightNode = node.init;\n\n        if (rightNode) {\n          const nonSpacedNode = getFirstNonSpacedToken(leftNode, rightNode, \"=\");\n\n          if (nonSpacedNode) {\n            report(node, nonSpacedNode);\n          }\n        }\n      }\n    };\n  }\n\n};\nspaceInfixOps.meta;\nspaceInfixOps.create;\nvar spaceUnaryOps = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"enforce consistent spacing before or after unary operators\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/space-unary-ops\"\n    },\n    fixable: \"whitespace\",\n    schema: [{\n      type: \"object\",\n      properties: {\n        words: {\n          type: \"boolean\",\n          default: true\n        },\n        nonwords: {\n          type: \"boolean\",\n          default: false\n        },\n        overrides: {\n          type: \"object\",\n          additionalProperties: {\n            type: \"boolean\"\n          }\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      unexpectedBefore: \"Unexpected space before unary operator '{{operator}}'.\",\n      unexpectedAfter: \"Unexpected space after unary operator '{{operator}}'.\",\n      unexpectedAfterWord: \"Unexpected space after unary word operator '{{word}}'.\",\n      wordOperator: \"Unary word operator '{{word}}' must be followed by whitespace.\",\n      operator: \"Unary operator '{{operator}}' must be followed by whitespace.\",\n      beforeUnaryExpressions: \"Space is required before unary expressions '{{token}}'.\"\n    }\n  },\n\n  create(context) {\n    const options = context.options[0] || {\n      words: true,\n      nonwords: false\n    };\n    const sourceCode = context.getSourceCode();\n\n    function isFirstBangInBangBangExpression(node) {\n      return node && node.type === \"UnaryExpression\" && node.argument.operator === \"!\" && node.argument && node.argument.type === \"UnaryExpression\" && node.argument.operator === \"!\";\n    }\n\n    function overrideExistsForOperator(operator) {\n      return options.overrides && Object.prototype.hasOwnProperty.call(options.overrides, operator);\n    }\n\n    function overrideEnforcesSpaces(operator) {\n      return options.overrides[operator];\n    }\n\n    function verifyWordHasSpaces(node, firstToken, secondToken, word) {\n      if (secondToken.range[0] === firstToken.range[1]) {\n        context.report({\n          node,\n          messageId: \"wordOperator\",\n          data: {\n            word\n          },\n\n          fix(fixer) {\n            return fixer.insertTextAfter(firstToken, \" \");\n          }\n\n        });\n      }\n    }\n\n    function verifyWordDoesntHaveSpaces(node, firstToken, secondToken, word) {\n      if (astUtils.canTokensBeAdjacent(firstToken, secondToken)) {\n        if (secondToken.range[0] > firstToken.range[1]) {\n          context.report({\n            node,\n            messageId: \"unexpectedAfterWord\",\n            data: {\n              word\n            },\n\n            fix(fixer) {\n              return fixer.removeRange([firstToken.range[1], secondToken.range[0]]);\n            }\n\n          });\n        }\n      }\n    }\n\n    function checkUnaryWordOperatorForSpaces(node, firstToken, secondToken, word) {\n      if (overrideExistsForOperator(word)) {\n        if (overrideEnforcesSpaces(word)) {\n          verifyWordHasSpaces(node, firstToken, secondToken, word);\n        } else {\n          verifyWordDoesntHaveSpaces(node, firstToken, secondToken, word);\n        }\n      } else if (options.words) {\n        verifyWordHasSpaces(node, firstToken, secondToken, word);\n      } else {\n        verifyWordDoesntHaveSpaces(node, firstToken, secondToken, word);\n      }\n    }\n\n    function verifyNonWordsHaveSpaces(node, firstToken, secondToken) {\n      if (node.prefix) {\n        if (isFirstBangInBangBangExpression(node)) {\n          return;\n        }\n\n        if (firstToken.range[1] === secondToken.range[0]) {\n          context.report({\n            node,\n            messageId: \"operator\",\n            data: {\n              operator: firstToken.value\n            },\n\n            fix(fixer) {\n              return fixer.insertTextAfter(firstToken, \" \");\n            }\n\n          });\n        }\n      } else {\n        if (firstToken.range[1] === secondToken.range[0]) {\n          context.report({\n            node,\n            messageId: \"beforeUnaryExpressions\",\n            data: {\n              token: secondToken.value\n            },\n\n            fix(fixer) {\n              return fixer.insertTextBefore(secondToken, \" \");\n            }\n\n          });\n        }\n      }\n    }\n\n    function verifyNonWordsDontHaveSpaces(node, firstToken, secondToken) {\n      if (node.prefix) {\n        if (secondToken.range[0] > firstToken.range[1]) {\n          context.report({\n            node,\n            messageId: \"unexpectedAfter\",\n            data: {\n              operator: firstToken.value\n            },\n\n            fix(fixer) {\n              if (astUtils.canTokensBeAdjacent(firstToken, secondToken)) {\n                return fixer.removeRange([firstToken.range[1], secondToken.range[0]]);\n              }\n\n              return null;\n            }\n\n          });\n        }\n      } else {\n        if (secondToken.range[0] > firstToken.range[1]) {\n          context.report({\n            node,\n            messageId: \"unexpectedBefore\",\n            data: {\n              operator: secondToken.value\n            },\n\n            fix(fixer) {\n              return fixer.removeRange([firstToken.range[1], secondToken.range[0]]);\n            }\n\n          });\n        }\n      }\n    }\n\n    function checkForSpaces(node) {\n      const tokens = node.type === \"UpdateExpression\" && !node.prefix ? sourceCode.getLastTokens(node, 2) : sourceCode.getFirstTokens(node, 2);\n      const firstToken = tokens[0];\n      const secondToken = tokens[1];\n\n      if ((node.type === \"NewExpression\" || node.prefix) && firstToken.type === \"Keyword\") {\n        checkUnaryWordOperatorForSpaces(node, firstToken, secondToken, firstToken.value);\n        return;\n      }\n\n      const operator = node.prefix ? tokens[0].value : tokens[1].value;\n\n      if (overrideExistsForOperator(operator)) {\n        if (overrideEnforcesSpaces(operator)) {\n          verifyNonWordsHaveSpaces(node, firstToken, secondToken);\n        } else {\n          verifyNonWordsDontHaveSpaces(node, firstToken, secondToken);\n        }\n      } else if (options.nonwords) {\n        verifyNonWordsHaveSpaces(node, firstToken, secondToken);\n      } else {\n        verifyNonWordsDontHaveSpaces(node, firstToken, secondToken);\n      }\n    }\n\n    return {\n      UnaryExpression: checkForSpaces,\n      UpdateExpression: checkForSpaces,\n      NewExpression: checkForSpaces,\n      YieldExpression: function (node) {\n        const tokens = sourceCode.getFirstTokens(node, 3);\n\n        if (!node.argument || node.delegate) {\n          return;\n        }\n\n        checkUnaryWordOperatorForSpaces(node, tokens[0], tokens[1], \"yield\");\n      },\n      AwaitExpression: function (node) {\n        const tokens = sourceCode.getFirstTokens(node, 3);\n        checkUnaryWordOperatorForSpaces(node, tokens[0], tokens[1], \"await\");\n      }\n    };\n  }\n\n};\nspaceUnaryOps.meta;\nspaceUnaryOps.create;\n\nfunction escape(s) {\n  return `(?:${escapeStringRegexp__default['default'](s)})`;\n}\n\nfunction escapeAndRepeat(s) {\n  return `${escape(s)}+`;\n}\n\nfunction parseMarkersOption(markers) {\n  if (markers.indexOf(\"*\") === -1) {\n    return markers.concat(\"*\");\n  }\n\n  return markers;\n}\n\nfunction createExceptionsPattern(exceptions) {\n  let pattern = \"\";\n\n  if (exceptions.length === 0) {\n    pattern += \"\\\\s\";\n  } else {\n    pattern += \"(?:\\\\s|\";\n\n    if (exceptions.length === 1) {\n      pattern += escapeAndRepeat(exceptions[0]);\n    } else {\n      pattern += \"(?:\";\n      pattern += exceptions.map(escapeAndRepeat).join(\"|\");\n      pattern += \")\";\n    }\n\n    pattern += `(?:$|[${Array.from(astUtils.LINEBREAKS).join(\"\")}]))`;\n  }\n\n  return pattern;\n}\n\nfunction createAlwaysStylePattern(markers, exceptions) {\n  let pattern = \"^\";\n\n  if (markers.length === 1) {\n    pattern += escape(markers[0]);\n  } else {\n    pattern += \"(?:\";\n    pattern += markers.map(escape).join(\"|\");\n    pattern += \")\";\n  }\n\n  pattern += \"?\";\n  pattern += createExceptionsPattern(exceptions);\n  return new RegExp(pattern, \"u\");\n}\n\nfunction createNeverStylePattern(markers) {\n  const pattern = `^(${markers.map(escape).join(\"|\")})?[ \\t]+`;\n  return new RegExp(pattern, \"u\");\n}\n\nvar spacedComment = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"enforce consistent spacing after the `//` or `/*` in a comment\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/spaced-comment\"\n    },\n    fixable: \"whitespace\",\n    schema: [{\n      enum: [\"always\", \"never\"]\n    }, {\n      type: \"object\",\n      properties: {\n        exceptions: {\n          type: \"array\",\n          items: {\n            type: \"string\"\n          }\n        },\n        markers: {\n          type: \"array\",\n          items: {\n            type: \"string\"\n          }\n        },\n        line: {\n          type: \"object\",\n          properties: {\n            exceptions: {\n              type: \"array\",\n              items: {\n                type: \"string\"\n              }\n            },\n            markers: {\n              type: \"array\",\n              items: {\n                type: \"string\"\n              }\n            }\n          },\n          additionalProperties: false\n        },\n        block: {\n          type: \"object\",\n          properties: {\n            exceptions: {\n              type: \"array\",\n              items: {\n                type: \"string\"\n              }\n            },\n            markers: {\n              type: \"array\",\n              items: {\n                type: \"string\"\n              }\n            },\n            balanced: {\n              type: \"boolean\",\n              default: false\n            }\n          },\n          additionalProperties: false\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      unexpectedSpaceAfterMarker: \"Unexpected space or tab after marker ({{refChar}}) in comment.\",\n      expectedExceptionAfter: \"Expected exception block, space or tab after '{{refChar}}' in comment.\",\n      unexpectedSpaceBefore: \"Unexpected space or tab before '*/' in comment.\",\n      unexpectedSpaceAfter: \"Unexpected space or tab after '{{refChar}}' in comment.\",\n      expectedSpaceBefore: \"Expected space or tab before '*/' in comment.\",\n      expectedSpaceAfter: \"Expected space or tab after '{{refChar}}' in comment.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    const requireSpace = context.options[0] !== \"never\";\n    const config = context.options[1] || {};\n    const balanced = config.block && config.block.balanced;\n    const styleRules = [\"block\", \"line\"].reduce((rule, type) => {\n      const markers = parseMarkersOption(config[type] && config[type].markers || config.markers || []);\n      const exceptions = config[type] && config[type].exceptions || config.exceptions || [];\n      rule[type] = {\n        beginRegex: requireSpace ? createAlwaysStylePattern(markers, exceptions) : createNeverStylePattern(markers),\n        endRegex: balanced && requireSpace ? new RegExp(`${createExceptionsPattern(exceptions)}$`, \"u\") : new RegExp(\"[ \\t]+$\", \"u\"),\n        hasExceptions: exceptions.length > 0,\n        captureMarker: new RegExp(`^(${markers.map(escape).join(\"|\")})`, \"u\"),\n        markers: new Set(markers)\n      };\n      return rule;\n    }, {});\n\n    function reportBegin(node, messageId, match, refChar) {\n      const type = node.type.toLowerCase(),\n            commentIdentifier = type === \"block\" ? \"/*\" : \"//\";\n      context.report({\n        node,\n\n        fix(fixer) {\n          const start = node.range[0];\n          let end = start + 2;\n\n          if (requireSpace) {\n            if (match) {\n              end += match[0].length;\n            }\n\n            return fixer.insertTextAfterRange([start, end], \" \");\n          }\n\n          end += match[0].length;\n          return fixer.replaceTextRange([start, end], commentIdentifier + (match[1] ? match[1] : \"\"));\n        },\n\n        messageId,\n        data: {\n          refChar\n        }\n      });\n    }\n\n    function reportEnd(node, messageId, match) {\n      context.report({\n        node,\n\n        fix(fixer) {\n          if (requireSpace) {\n            return fixer.insertTextAfterRange([node.range[0], node.range[1] - 2], \" \");\n          }\n\n          const end = node.range[1] - 2,\n                start = end - match[0].length;\n          return fixer.replaceTextRange([start, end], \"\");\n        },\n\n        messageId\n      });\n    }\n\n    function checkCommentForSpace(node) {\n      const type = node.type.toLowerCase(),\n            rule = styleRules[type],\n            commentIdentifier = type === \"block\" ? \"/*\" : \"//\";\n\n      if (node.value.length === 0 || rule.markers.has(node.value)) {\n        return;\n      }\n\n      const beginMatch = rule.beginRegex.exec(node.value);\n      const endMatch = rule.endRegex.exec(node.value);\n\n      if (requireSpace) {\n        if (!beginMatch) {\n          const hasMarker = rule.captureMarker.exec(node.value);\n          const marker = hasMarker ? commentIdentifier + hasMarker[0] : commentIdentifier;\n\n          if (rule.hasExceptions) {\n            reportBegin(node, \"expectedExceptionAfter\", hasMarker, marker);\n          } else {\n            reportBegin(node, \"expectedSpaceAfter\", hasMarker, marker);\n          }\n        }\n\n        if (balanced && type === \"block\" && !endMatch) {\n          reportEnd(node, \"expectedSpaceBefore\");\n        }\n      } else {\n        if (beginMatch) {\n          if (!beginMatch[1]) {\n            reportBegin(node, \"unexpectedSpaceAfter\", beginMatch, commentIdentifier);\n          } else {\n            reportBegin(node, \"unexpectedSpaceAfterMarker\", beginMatch, beginMatch[1]);\n          }\n        }\n\n        if (balanced && type === \"block\" && endMatch) {\n          reportEnd(node, \"unexpectedSpaceBefore\", endMatch);\n        }\n      }\n    }\n\n    return {\n      Program() {\n        const comments = sourceCode.getAllComments();\n        comments.filter(token => token.type !== \"Shebang\").forEach(checkCommentForSpace);\n      }\n\n    };\n  }\n\n};\nspacedComment.meta;\nspacedComment.create;\n\nfunction getUseStrictDirectives(statements) {\n  const directives = [];\n\n  for (let i = 0; i < statements.length; i++) {\n    const statement = statements[i];\n\n    if (statement.type === \"ExpressionStatement\" && statement.expression.type === \"Literal\" && statement.expression.value === \"use strict\") {\n      directives[i] = statement;\n    } else {\n      break;\n    }\n  }\n\n  return directives;\n}\n\nfunction isSimpleParameter(node) {\n  return node.type === \"Identifier\";\n}\n\nfunction isSimpleParameterList(params) {\n  return params.every(isSimpleParameter);\n}\n\nvar strict = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"require or disallow strict mode directives\",\n      category: \"Strict Mode\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/strict\"\n    },\n    schema: [{\n      enum: [\"never\", \"global\", \"function\", \"safe\"]\n    }],\n    fixable: \"code\",\n    messages: {\n      function: \"Use the function form of 'use strict'.\",\n      global: \"Use the global form of 'use strict'.\",\n      multiple: \"Multiple 'use strict' directives.\",\n      never: \"Strict mode is not permitted.\",\n      unnecessary: \"Unnecessary 'use strict' directive.\",\n      module: \"'use strict' is unnecessary inside of modules.\",\n      implied: \"'use strict' is unnecessary when implied strict mode is enabled.\",\n      unnecessaryInClasses: \"'use strict' is unnecessary inside of classes.\",\n      nonSimpleParameterList: \"'use strict' directive inside a function with non-simple parameter list throws a syntax error since ES2016.\",\n      wrap: \"Wrap {{name}} in a function with 'use strict' directive.\"\n    }\n  },\n\n  create(context) {\n    const ecmaFeatures = context.parserOptions.ecmaFeatures || {},\n          scopes = [],\n          classScopes = [];\n    let mode = context.options[0] || \"safe\";\n\n    if (ecmaFeatures.impliedStrict) {\n      mode = \"implied\";\n    } else if (mode === \"safe\") {\n      mode = ecmaFeatures.globalReturn ? \"global\" : \"function\";\n    }\n\n    function shouldFix(errorType) {\n      return errorType === \"multiple\" || errorType === \"unnecessary\" || errorType === \"module\" || errorType === \"implied\" || errorType === \"unnecessaryInClasses\";\n    }\n\n    function getFixFunction(node) {\n      return fixer => fixer.remove(node);\n    }\n\n    function reportSlice(nodes, start, end, messageId, fix) {\n      nodes.slice(start, end).forEach(node => {\n        context.report({\n          node,\n          messageId,\n          fix: fix ? getFixFunction(node) : null\n        });\n      });\n    }\n\n    function reportAll(nodes, messageId, fix) {\n      reportSlice(nodes, 0, nodes.length, messageId, fix);\n    }\n\n    function reportAllExceptFirst(nodes, messageId, fix) {\n      reportSlice(nodes, 1, nodes.length, messageId, fix);\n    }\n\n    function enterFunctionInFunctionMode(node, useStrictDirectives) {\n      const isInClass = classScopes.length > 0,\n            isParentGlobal = scopes.length === 0 && classScopes.length === 0,\n            isParentStrict = scopes.length > 0 && scopes[scopes.length - 1],\n            isStrict = useStrictDirectives.length > 0;\n\n      if (isStrict) {\n        if (!isSimpleParameterList(node.params)) {\n          context.report({\n            node: useStrictDirectives[0],\n            messageId: \"nonSimpleParameterList\"\n          });\n        } else if (isParentStrict) {\n          context.report({\n            node: useStrictDirectives[0],\n            messageId: \"unnecessary\",\n            fix: getFixFunction(useStrictDirectives[0])\n          });\n        } else if (isInClass) {\n          context.report({\n            node: useStrictDirectives[0],\n            messageId: \"unnecessaryInClasses\",\n            fix: getFixFunction(useStrictDirectives[0])\n          });\n        }\n\n        reportAllExceptFirst(useStrictDirectives, \"multiple\", true);\n      } else if (isParentGlobal) {\n        if (isSimpleParameterList(node.params)) {\n          context.report({\n            node,\n            messageId: \"function\"\n          });\n        } else {\n          context.report({\n            node,\n            messageId: \"wrap\",\n            data: {\n              name: astUtils.getFunctionNameWithKind(node)\n            }\n          });\n        }\n      }\n\n      scopes.push(isParentStrict || isStrict);\n    }\n\n    function exitFunctionInFunctionMode() {\n      scopes.pop();\n    }\n\n    function enterFunction(node) {\n      const isBlock = node.body.type === \"BlockStatement\",\n            useStrictDirectives = isBlock ? getUseStrictDirectives(node.body.body) : [];\n\n      if (mode === \"function\") {\n        enterFunctionInFunctionMode(node, useStrictDirectives);\n      } else if (useStrictDirectives.length > 0) {\n        if (isSimpleParameterList(node.params)) {\n          reportAll(useStrictDirectives, mode, shouldFix(mode));\n        } else {\n          context.report({\n            node: useStrictDirectives[0],\n            messageId: \"nonSimpleParameterList\"\n          });\n          reportAllExceptFirst(useStrictDirectives, \"multiple\", true);\n        }\n      }\n    }\n\n    const rule = {\n      Program(node) {\n        const useStrictDirectives = getUseStrictDirectives(node.body);\n\n        if (node.sourceType === \"module\") {\n          mode = \"module\";\n        }\n\n        if (mode === \"global\") {\n          if (node.body.length > 0 && useStrictDirectives.length === 0) {\n            context.report({\n              node,\n              messageId: \"global\"\n            });\n          }\n\n          reportAllExceptFirst(useStrictDirectives, \"multiple\", true);\n        } else {\n          reportAll(useStrictDirectives, mode, shouldFix(mode));\n        }\n      },\n\n      FunctionDeclaration: enterFunction,\n      FunctionExpression: enterFunction,\n      ArrowFunctionExpression: enterFunction\n    };\n\n    if (mode === \"function\") {\n      Object.assign(rule, {\n        ClassBody() {\n          classScopes.push(true);\n        },\n\n        \"ClassBody:exit\"() {\n          classScopes.pop();\n        },\n\n        \"FunctionDeclaration:exit\": exitFunctionInFunctionMode,\n        \"FunctionExpression:exit\": exitFunctionInFunctionMode,\n        \"ArrowFunctionExpression:exit\": exitFunctionInFunctionMode\n      });\n    }\n\n    return rule;\n  }\n\n};\nstrict.meta;\nstrict.create;\nvar switchColonSpacing = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"enforce spacing around colons of switch statements\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/switch-colon-spacing\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        before: {\n          type: \"boolean\",\n          default: false\n        },\n        after: {\n          type: \"boolean\",\n          default: true\n        }\n      },\n      additionalProperties: false\n    }],\n    fixable: \"whitespace\",\n    messages: {\n      expectedBefore: \"Expected space(s) before this colon.\",\n      expectedAfter: \"Expected space(s) after this colon.\",\n      unexpectedBefore: \"Unexpected space(s) before this colon.\",\n      unexpectedAfter: \"Unexpected space(s) after this colon.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    const options = context.options[0] || {};\n    const beforeSpacing = options.before === true;\n    const afterSpacing = options.after !== false;\n\n    function getColonToken(node) {\n      if (node.test) {\n        return sourceCode.getTokenAfter(node.test, astUtils.isColonToken);\n      }\n\n      return sourceCode.getFirstToken(node, 1);\n    }\n\n    function isValidSpacing(left, right, expected) {\n      return astUtils.isClosingBraceToken(right) || !astUtils.isTokenOnSameLine(left, right) || sourceCode.isSpaceBetweenTokens(left, right) === expected;\n    }\n\n    function commentsExistBetween(left, right) {\n      return sourceCode.getFirstTokenBetween(left, right, {\n        includeComments: true,\n        filter: astUtils.isCommentToken\n      }) !== null;\n    }\n\n    function fix(fixer, left, right, spacing) {\n      if (commentsExistBetween(left, right)) {\n        return null;\n      }\n\n      if (spacing) {\n        return fixer.insertTextAfter(left, \" \");\n      }\n\n      return fixer.removeRange([left.range[1], right.range[0]]);\n    }\n\n    return {\n      SwitchCase(node) {\n        const colonToken = getColonToken(node);\n        const beforeToken = sourceCode.getTokenBefore(colonToken);\n        const afterToken = sourceCode.getTokenAfter(colonToken);\n\n        if (!isValidSpacing(beforeToken, colonToken, beforeSpacing)) {\n          context.report({\n            node,\n            loc: colonToken.loc,\n            messageId: beforeSpacing ? \"expectedBefore\" : \"unexpectedBefore\",\n            fix: fixer => fix(fixer, beforeToken, colonToken, beforeSpacing)\n          });\n        }\n\n        if (!isValidSpacing(colonToken, afterToken, afterSpacing)) {\n          context.report({\n            node,\n            loc: colonToken.loc,\n            messageId: afterSpacing ? \"expectedAfter\" : \"unexpectedAfter\",\n            fix: fixer => fix(fixer, colonToken, afterToken, afterSpacing)\n          });\n        }\n      }\n\n    };\n  }\n\n};\nswitchColonSpacing.meta;\nswitchColonSpacing.create;\nvar symbolDescription = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"require symbol descriptions\",\n      category: \"ECMAScript 6\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/symbol-description\"\n    },\n    fixable: null,\n    schema: [],\n    messages: {\n      expected: \"Expected Symbol to have a description.\"\n    }\n  },\n\n  create(context) {\n    function checkArgument(node) {\n      if (node.arguments.length === 0) {\n        context.report({\n          node,\n          messageId: \"expected\"\n        });\n      }\n    }\n\n    return {\n      \"Program:exit\"() {\n        const scope = context.getScope();\n        const variable = astUtils.getVariableByName(scope, \"Symbol\");\n\n        if (variable && variable.defs.length === 0) {\n          variable.references.forEach(reference => {\n            const node = reference.identifier;\n\n            if (astUtils.isCallee(node)) {\n              checkArgument(node.parent);\n            }\n          });\n        }\n      }\n\n    };\n  }\n\n};\nsymbolDescription.meta;\nsymbolDescription.create;\nvar templateCurlySpacing = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"require or disallow spacing around embedded expressions of template strings\",\n      category: \"ECMAScript 6\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/template-curly-spacing\"\n    },\n    fixable: \"whitespace\",\n    schema: [{\n      enum: [\"always\", \"never\"]\n    }],\n    messages: {\n      expectedBefore: \"Expected space(s) before '}'.\",\n      expectedAfter: \"Expected space(s) after '${'.\",\n      unexpectedBefore: \"Unexpected space(s) before '}'.\",\n      unexpectedAfter: \"Unexpected space(s) after '${'.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    const always = context.options[0] === \"always\";\n\n    function checkSpacingBefore(token) {\n      if (!token.value.startsWith(\"}\")) {\n        return;\n      }\n\n      const prevToken = sourceCode.getTokenBefore(token, {\n        includeComments: true\n      }),\n            hasSpace = sourceCode.isSpaceBetween(prevToken, token);\n\n      if (!astUtils.isTokenOnSameLine(prevToken, token)) {\n        return;\n      }\n\n      if (always && !hasSpace) {\n        context.report({\n          loc: {\n            start: token.loc.start,\n            end: {\n              line: token.loc.start.line,\n              column: token.loc.start.column + 1\n            }\n          },\n          messageId: \"expectedBefore\",\n          fix: fixer => fixer.insertTextBefore(token, \" \")\n        });\n      }\n\n      if (!always && hasSpace) {\n        context.report({\n          loc: {\n            start: prevToken.loc.end,\n            end: token.loc.start\n          },\n          messageId: \"unexpectedBefore\",\n          fix: fixer => fixer.removeRange([prevToken.range[1], token.range[0]])\n        });\n      }\n    }\n\n    function checkSpacingAfter(token) {\n      if (!token.value.endsWith(\"${\")) {\n        return;\n      }\n\n      const nextToken = sourceCode.getTokenAfter(token, {\n        includeComments: true\n      }),\n            hasSpace = sourceCode.isSpaceBetween(token, nextToken);\n\n      if (!astUtils.isTokenOnSameLine(token, nextToken)) {\n        return;\n      }\n\n      if (always && !hasSpace) {\n        context.report({\n          loc: {\n            start: {\n              line: token.loc.end.line,\n              column: token.loc.end.column - 2\n            },\n            end: token.loc.end\n          },\n          messageId: \"expectedAfter\",\n          fix: fixer => fixer.insertTextAfter(token, \" \")\n        });\n      }\n\n      if (!always && hasSpace) {\n        context.report({\n          loc: {\n            start: token.loc.end,\n            end: nextToken.loc.start\n          },\n          messageId: \"unexpectedAfter\",\n          fix: fixer => fixer.removeRange([token.range[1], nextToken.range[0]])\n        });\n      }\n    }\n\n    return {\n      TemplateElement(node) {\n        const token = sourceCode.getFirstToken(node);\n        checkSpacingBefore(token);\n        checkSpacingAfter(token);\n      }\n\n    };\n  }\n\n};\ntemplateCurlySpacing.meta;\ntemplateCurlySpacing.create;\nvar templateTagSpacing = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"require or disallow spacing between template tags and their literals\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/template-tag-spacing\"\n    },\n    fixable: \"whitespace\",\n    schema: [{\n      enum: [\"always\", \"never\"]\n    }],\n    messages: {\n      unexpected: \"Unexpected space between template tag and template literal.\",\n      missing: \"Missing space between template tag and template literal.\"\n    }\n  },\n\n  create(context) {\n    const never = context.options[0] !== \"always\";\n    const sourceCode = context.getSourceCode();\n    return {\n      TaggedTemplateExpression: function (node) {\n        const tagToken = sourceCode.getTokenBefore(node.quasi);\n        const literalToken = sourceCode.getFirstToken(node.quasi);\n        const hasWhitespace = sourceCode.isSpaceBetweenTokens(tagToken, literalToken);\n\n        if (never && hasWhitespace) {\n          context.report({\n            node,\n            loc: {\n              start: tagToken.loc.end,\n              end: literalToken.loc.start\n            },\n            messageId: \"unexpected\",\n\n            fix(fixer) {\n              const comments = sourceCode.getCommentsBefore(node.quasi);\n\n              if (comments.some(comment => comment.type === \"Line\")) {\n                return null;\n              }\n\n              return fixer.replaceTextRange([tagToken.range[1], literalToken.range[0]], comments.reduce((text, comment) => text + sourceCode.getText(comment), \"\"));\n            }\n\n          });\n        } else if (!never && !hasWhitespace) {\n          context.report({\n            node,\n            loc: {\n              start: node.loc.start,\n              end: literalToken.loc.start\n            },\n            messageId: \"missing\",\n\n            fix(fixer) {\n              return fixer.insertTextAfter(tagToken, \" \");\n            }\n\n          });\n        }\n      }\n    };\n  }\n\n};\ntemplateTagSpacing.meta;\ntemplateTagSpacing.create;\nvar unicodeBom = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"require or disallow Unicode byte order mark (BOM)\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/unicode-bom\"\n    },\n    fixable: \"whitespace\",\n    schema: [{\n      enum: [\"always\", \"never\"]\n    }],\n    messages: {\n      expected: \"Expected Unicode BOM (Byte Order Mark).\",\n      unexpected: \"Unexpected Unicode BOM (Byte Order Mark).\"\n    }\n  },\n\n  create(context) {\n    return {\n      Program: function (node) {\n        const sourceCode = context.getSourceCode(),\n              location = {\n          column: 0,\n          line: 1\n        },\n              requireBOM = context.options[0] || \"never\";\n\n        if (!sourceCode.hasBOM && requireBOM === \"always\") {\n          context.report({\n            node,\n            loc: location,\n            messageId: \"expected\",\n\n            fix(fixer) {\n              return fixer.insertTextBeforeRange([0, 1], \"\\uFEFF\");\n            }\n\n          });\n        } else if (sourceCode.hasBOM && requireBOM === \"never\") {\n          context.report({\n            node,\n            loc: location,\n            messageId: \"unexpected\",\n\n            fix(fixer) {\n              return fixer.removeRange([-1, 0]);\n            }\n\n          });\n        }\n      }\n    };\n  }\n\n};\nunicodeBom.meta;\nunicodeBom.create;\n\nfunction isNaNIdentifier(node) {\n  return Boolean(node) && (astUtils.isSpecificId(node, \"NaN\") || astUtils.isSpecificMemberAccess(node, \"Number\", \"NaN\"));\n}\n\nvar useIsnan = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"require calls to `isNaN()` when checking for `NaN`\",\n      category: \"Possible Errors\",\n      recommended: true,\n      url: \"https://eslint.org/docs/rules/use-isnan\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        enforceForSwitchCase: {\n          type: \"boolean\",\n          default: true\n        },\n        enforceForIndexOf: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      comparisonWithNaN: \"Use the isNaN function to compare with NaN.\",\n      switchNaN: \"'switch(NaN)' can never match a case clause. Use Number.isNaN instead of the switch.\",\n      caseNaN: \"'case NaN' can never match. Use Number.isNaN before the switch.\",\n      indexOfNaN: \"Array prototype method '{{ methodName }}' cannot find NaN.\"\n    }\n  },\n\n  create(context) {\n    const enforceForSwitchCase = !context.options[0] || context.options[0].enforceForSwitchCase;\n    const enforceForIndexOf = context.options[0] && context.options[0].enforceForIndexOf;\n\n    function checkSwitchStatement(node) {\n      if (isNaNIdentifier(node.discriminant)) {\n        context.report({\n          node,\n          messageId: \"switchNaN\"\n        });\n      }\n\n      for (const switchCase of node.cases) {\n        if (isNaNIdentifier(switchCase.test)) {\n          context.report({\n            node: switchCase,\n            messageId: \"caseNaN\"\n          });\n        }\n      }\n    }\n\n    function checkCallExpression(node) {\n      const callee = astUtils.skipChainExpression(node.callee);\n\n      if (callee.type === \"MemberExpression\") {\n        const methodName = astUtils.getStaticPropertyName(callee);\n\n        if ((methodName === \"indexOf\" || methodName === \"lastIndexOf\") && node.arguments.length === 1 && isNaNIdentifier(node.arguments[0])) {\n          context.report({\n            node,\n            messageId: \"indexOfNaN\",\n            data: {\n              methodName\n            }\n          });\n        }\n      }\n    }\n\n    const listeners = {\n      BinaryExpression: function (node) {\n        if (/^(?:[<>]|[!=]=)=?$/u.test(node.operator) && (isNaNIdentifier(node.left) || isNaNIdentifier(node.right))) {\n          context.report({\n            node,\n            messageId: \"comparisonWithNaN\"\n          });\n        }\n      }\n    };\n\n    if (enforceForSwitchCase) {\n      listeners.SwitchStatement = checkSwitchStatement;\n    }\n\n    if (enforceForIndexOf) {\n      listeners.CallExpression = checkCallExpression;\n    }\n\n    return listeners;\n  }\n\n};\nuseIsnan.meta;\nuseIsnan.create;\nvar validJsdoc = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"enforce valid JSDoc comments\",\n      category: \"Possible Errors\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/valid-jsdoc\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        prefer: {\n          type: \"object\",\n          additionalProperties: {\n            type: \"string\"\n          }\n        },\n        preferType: {\n          type: \"object\",\n          additionalProperties: {\n            type: \"string\"\n          }\n        },\n        requireReturn: {\n          type: \"boolean\",\n          default: true\n        },\n        requireParamDescription: {\n          type: \"boolean\",\n          default: true\n        },\n        requireReturnDescription: {\n          type: \"boolean\",\n          default: true\n        },\n        matchDescription: {\n          type: \"string\"\n        },\n        requireReturnType: {\n          type: \"boolean\",\n          default: true\n        },\n        requireParamType: {\n          type: \"boolean\",\n          default: true\n        }\n      },\n      additionalProperties: false\n    }],\n    fixable: \"code\",\n    messages: {\n      unexpectedTag: \"Unexpected @{{title}} tag; function has no return statement.\",\n      expected: \"Expected JSDoc for '{{name}}' but found '{{jsdocName}}'.\",\n      use: \"Use @{{name}} instead.\",\n      useType: \"Use '{{expectedTypeName}}' instead of '{{currentTypeName}}'.\",\n      syntaxError: \"JSDoc syntax error.\",\n      missingBrace: \"JSDoc type missing brace.\",\n      missingParamDesc: \"Missing JSDoc parameter description for '{{name}}'.\",\n      missingParamType: \"Missing JSDoc parameter type for '{{name}}'.\",\n      missingReturnType: \"Missing JSDoc return type.\",\n      missingReturnDesc: \"Missing JSDoc return description.\",\n      missingReturn: \"Missing JSDoc @{{returns}} for function.\",\n      missingParam: \"Missing JSDoc for parameter '{{name}}'.\",\n      duplicateParam: \"Duplicate JSDoc parameter '{{name}}'.\",\n      unsatisfiedDesc: \"JSDoc description does not satisfy the regex pattern.\"\n    },\n    deprecated: true,\n    replacedBy: []\n  },\n\n  create(context) {\n    const options = context.options[0] || {},\n          prefer = options.prefer || {},\n          sourceCode = context.getSourceCode(),\n          requireReturn = options.requireReturn !== false,\n          requireParamDescription = options.requireParamDescription !== false,\n          requireReturnDescription = options.requireReturnDescription !== false,\n          requireReturnType = options.requireReturnType !== false,\n          requireParamType = options.requireParamType !== false,\n          preferType = options.preferType || {},\n          checkPreferType = Object.keys(preferType).length !== 0;\n    const fns = [];\n\n    function isTypeClass(node) {\n      return node.type === \"ClassExpression\" || node.type === \"ClassDeclaration\";\n    }\n\n    function startFunction(node) {\n      fns.push({\n        returnPresent: node.type === \"ArrowFunctionExpression\" && node.body.type !== \"BlockStatement\" || isTypeClass(node) || node.async\n      });\n    }\n\n    function isValidReturnType(tag) {\n      return tag.type === null || tag.type.name === \"void\" || tag.type.type === \"UndefinedLiteral\";\n    }\n\n    function canTypeBeValidated(type) {\n      return type !== \"UndefinedLiteral\" && type !== \"NullLiteral\" && type !== \"NullableLiteral\" && type !== \"FunctionType\" && type !== \"AllLiteral\";\n    }\n\n    function getCurrentExpectedTypes(type) {\n      let currentType;\n\n      if (type.name) {\n        currentType = type;\n      } else if (type.expression) {\n        currentType = type.expression;\n      }\n\n      return {\n        currentType,\n        expectedTypeName: currentType && preferType[currentType.name]\n      };\n    }\n\n    function getAbsoluteRange(jsdocComment, parsedJsdocNode) {\n      return {\n        start: sourceCode.getLocFromIndex(jsdocComment.range[0] + 2 + parsedJsdocNode.range[0]),\n        end: sourceCode.getLocFromIndex(jsdocComment.range[0] + 2 + parsedJsdocNode.range[1])\n      };\n    }\n\n    function validateType(jsdocNode, type) {\n      if (!type || !canTypeBeValidated(type.type)) {\n        return;\n      }\n\n      const typesToCheck = [];\n      let elements = [];\n\n      switch (type.type) {\n        case \"TypeApplication\":\n          elements = type.applications[0].type === \"UnionType\" ? type.applications[0].elements : type.applications;\n          typesToCheck.push(getCurrentExpectedTypes(type));\n          break;\n\n        case \"RecordType\":\n          elements = type.fields;\n          break;\n\n        case \"UnionType\":\n        case \"ArrayType\":\n          elements = type.elements;\n          break;\n\n        case \"FieldType\":\n          if (type.value) {\n            typesToCheck.push(getCurrentExpectedTypes(type.value));\n          }\n\n          break;\n\n        default:\n          typesToCheck.push(getCurrentExpectedTypes(type));\n      }\n\n      elements.forEach(validateType.bind(null, jsdocNode));\n      typesToCheck.forEach(typeToCheck => {\n        if (typeToCheck.expectedTypeName && typeToCheck.expectedTypeName !== typeToCheck.currentType.name) {\n          context.report({\n            node: jsdocNode,\n            messageId: \"useType\",\n            loc: getAbsoluteRange(jsdocNode, typeToCheck.currentType),\n            data: {\n              currentTypeName: typeToCheck.currentType.name,\n              expectedTypeName: typeToCheck.expectedTypeName\n            },\n\n            fix(fixer) {\n              return fixer.replaceTextRange(typeToCheck.currentType.range.map(indexInComment => jsdocNode.range[0] + 2 + indexInComment), typeToCheck.expectedTypeName);\n            }\n\n          });\n        }\n      });\n    }\n\n    function checkJSDoc(node) {\n      const jsdocNode = sourceCode.getJSDocComment(node),\n            functionData = fns.pop(),\n            paramTagsByName = Object.create(null),\n            paramTags = [];\n      let hasReturns = false,\n          returnsTag,\n          hasConstructor = false,\n          isInterface = false,\n          isOverride = false,\n          isAbstract = false;\n\n      if (jsdocNode) {\n        let jsdoc;\n\n        try {\n          jsdoc = doctrine__default['default'].parse(jsdocNode.value, {\n            strict: true,\n            unwrap: true,\n            sloppy: true,\n            range: true\n          });\n        } catch (ex) {\n          if (/braces/iu.test(ex.message)) {\n            context.report({\n              node: jsdocNode,\n              messageId: \"missingBrace\"\n            });\n          } else {\n            context.report({\n              node: jsdocNode,\n              messageId: \"syntaxError\"\n            });\n          }\n\n          return;\n        }\n\n        jsdoc.tags.forEach(tag => {\n          switch (tag.title.toLowerCase()) {\n            case \"param\":\n            case \"arg\":\n            case \"argument\":\n              paramTags.push(tag);\n              break;\n\n            case \"return\":\n            case \"returns\":\n              hasReturns = true;\n              returnsTag = tag;\n              break;\n\n            case \"constructor\":\n            case \"class\":\n              hasConstructor = true;\n              break;\n\n            case \"override\":\n            case \"inheritdoc\":\n              isOverride = true;\n              break;\n\n            case \"abstract\":\n            case \"virtual\":\n              isAbstract = true;\n              break;\n\n            case \"interface\":\n              isInterface = true;\n              break;\n          }\n\n          if (Object.prototype.hasOwnProperty.call(prefer, tag.title) && tag.title !== prefer[tag.title]) {\n            const entireTagRange = getAbsoluteRange(jsdocNode, tag);\n            context.report({\n              node: jsdocNode,\n              messageId: \"use\",\n              loc: {\n                start: entireTagRange.start,\n                end: {\n                  line: entireTagRange.start.line,\n                  column: entireTagRange.start.column + `@${tag.title}`.length\n                }\n              },\n              data: {\n                name: prefer[tag.title]\n              },\n\n              fix(fixer) {\n                return fixer.replaceTextRange([jsdocNode.range[0] + tag.range[0] + 3, jsdocNode.range[0] + tag.range[0] + tag.title.length + 3], prefer[tag.title]);\n              }\n\n            });\n          }\n\n          if (checkPreferType && tag.type) {\n            validateType(jsdocNode, tag.type);\n          }\n        });\n        paramTags.forEach(param => {\n          if (requireParamType && !param.type) {\n            context.report({\n              node: jsdocNode,\n              messageId: \"missingParamType\",\n              loc: getAbsoluteRange(jsdocNode, param),\n              data: {\n                name: param.name\n              }\n            });\n          }\n\n          if (!param.description && requireParamDescription) {\n            context.report({\n              node: jsdocNode,\n              messageId: \"missingParamDesc\",\n              loc: getAbsoluteRange(jsdocNode, param),\n              data: {\n                name: param.name\n              }\n            });\n          }\n\n          if (paramTagsByName[param.name]) {\n            context.report({\n              node: jsdocNode,\n              messageId: \"duplicateParam\",\n              loc: getAbsoluteRange(jsdocNode, param),\n              data: {\n                name: param.name\n              }\n            });\n          } else if (param.name.indexOf(\".\") === -1) {\n            paramTagsByName[param.name] = param;\n          }\n        });\n\n        if (hasReturns) {\n          if (!requireReturn && !functionData.returnPresent && (returnsTag.type === null || !isValidReturnType(returnsTag)) && !isAbstract) {\n            context.report({\n              node: jsdocNode,\n              messageId: \"unexpectedTag\",\n              loc: getAbsoluteRange(jsdocNode, returnsTag),\n              data: {\n                title: returnsTag.title\n              }\n            });\n          } else {\n            if (requireReturnType && !returnsTag.type) {\n              context.report({\n                node: jsdocNode,\n                messageId: \"missingReturnType\"\n              });\n            }\n\n            if (!isValidReturnType(returnsTag) && !returnsTag.description && requireReturnDescription) {\n              context.report({\n                node: jsdocNode,\n                messageId: \"missingReturnDesc\"\n              });\n            }\n          }\n        }\n\n        if (!isOverride && !hasReturns && !hasConstructor && !isInterface && node.parent.kind !== \"get\" && node.parent.kind !== \"constructor\" && node.parent.kind !== \"set\" && !isTypeClass(node)) {\n          if (requireReturn || functionData.returnPresent && !node.async) {\n            context.report({\n              node: jsdocNode,\n              messageId: \"missingReturn\",\n              data: {\n                returns: prefer.returns || \"returns\"\n              }\n            });\n          }\n        }\n\n        const jsdocParamNames = Object.keys(paramTagsByName);\n\n        if (node.params) {\n          node.params.forEach((param, paramsIndex) => {\n            const bindingParam = param.type === \"AssignmentPattern\" ? param.left : param;\n\n            if (bindingParam.type === \"Identifier\") {\n              const name = bindingParam.name;\n\n              if (jsdocParamNames[paramsIndex] && name !== jsdocParamNames[paramsIndex]) {\n                context.report({\n                  node: jsdocNode,\n                  messageId: \"expected\",\n                  loc: getAbsoluteRange(jsdocNode, paramTagsByName[jsdocParamNames[paramsIndex]]),\n                  data: {\n                    name,\n                    jsdocName: jsdocParamNames[paramsIndex]\n                  }\n                });\n              } else if (!paramTagsByName[name] && !isOverride) {\n                context.report({\n                  node: jsdocNode,\n                  messageId: \"missingParam\",\n                  data: {\n                    name\n                  }\n                });\n              }\n            }\n          });\n        }\n\n        if (options.matchDescription) {\n          const regex = new RegExp(options.matchDescription, \"u\");\n\n          if (!regex.test(jsdoc.description)) {\n            context.report({\n              node: jsdocNode,\n              messageId: \"unsatisfiedDesc\"\n            });\n          }\n        }\n      }\n    }\n\n    return {\n      ArrowFunctionExpression: startFunction,\n      FunctionExpression: startFunction,\n      FunctionDeclaration: startFunction,\n      ClassExpression: startFunction,\n      ClassDeclaration: startFunction,\n      \"ArrowFunctionExpression:exit\": checkJSDoc,\n      \"FunctionExpression:exit\": checkJSDoc,\n      \"FunctionDeclaration:exit\": checkJSDoc,\n      \"ClassExpression:exit\": checkJSDoc,\n      \"ClassDeclaration:exit\": checkJSDoc,\n      ReturnStatement: function (node) {\n        const functionState = fns[fns.length - 1];\n\n        if (functionState && node.argument !== null) {\n          functionState.returnPresent = true;\n        }\n      }\n    };\n  }\n\n};\nvalidJsdoc.meta;\nvalidJsdoc.create;\nvar validTypeof = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"enforce comparing `typeof` expressions against valid strings\",\n      category: \"Possible Errors\",\n      recommended: true,\n      url: \"https://eslint.org/docs/rules/valid-typeof\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        requireStringLiterals: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      invalidValue: \"Invalid typeof comparison value.\",\n      notString: \"Typeof comparisons should be to string literals.\"\n    }\n  },\n\n  create(context) {\n    const VALID_TYPES = [\"symbol\", \"undefined\", \"object\", \"boolean\", \"number\", \"string\", \"function\", \"bigint\"],\n          OPERATORS = [\"==\", \"===\", \"!=\", \"!==\"];\n    const requireStringLiterals = context.options[0] && context.options[0].requireStringLiterals;\n\n    function isTypeofExpression(node) {\n      return node.type === \"UnaryExpression\" && node.operator === \"typeof\";\n    }\n\n    return {\n      UnaryExpression(node) {\n        if (isTypeofExpression(node)) {\n          const parent = context.getAncestors().pop();\n\n          if (parent.type === \"BinaryExpression\" && OPERATORS.indexOf(parent.operator) !== -1) {\n            const sibling = parent.left === node ? parent.right : parent.left;\n\n            if (sibling.type === \"Literal\" || sibling.type === \"TemplateLiteral\" && !sibling.expressions.length) {\n              const value = sibling.type === \"Literal\" ? sibling.value : sibling.quasis[0].value.cooked;\n\n              if (VALID_TYPES.indexOf(value) === -1) {\n                context.report({\n                  node: sibling,\n                  messageId: \"invalidValue\"\n                });\n              }\n            } else if (requireStringLiterals && !isTypeofExpression(sibling)) {\n              context.report({\n                node: sibling,\n                messageId: \"notString\"\n              });\n            }\n          }\n        }\n      }\n\n    };\n  }\n\n};\nvalidTypeof.meta;\nvalidTypeof.create;\nvar varsOnTop = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"require `var` declarations be placed at the top of their containing scope\",\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/vars-on-top\"\n    },\n    schema: [],\n    messages: {\n      top: \"All 'var' declarations must be at the top of the function scope.\"\n    }\n  },\n\n  create(context) {\n    function looksLikeDirective(node) {\n      return node.type === \"ExpressionStatement\" && node.expression.type === \"Literal\" && typeof node.expression.value === \"string\";\n    }\n\n    function looksLikeImport(node) {\n      return node.type === \"ImportDeclaration\" || node.type === \"ImportSpecifier\" || node.type === \"ImportDefaultSpecifier\" || node.type === \"ImportNamespaceSpecifier\";\n    }\n\n    function isVariableDeclaration(node) {\n      return node.type === \"VariableDeclaration\" || node.type === \"ExportNamedDeclaration\" && node.declaration && node.declaration.type === \"VariableDeclaration\";\n    }\n\n    function isVarOnTop(node, statements) {\n      const l = statements.length;\n      let i = 0;\n\n      for (; i < l; ++i) {\n        if (!looksLikeDirective(statements[i]) && !looksLikeImport(statements[i])) {\n          break;\n        }\n      }\n\n      for (; i < l; ++i) {\n        if (!isVariableDeclaration(statements[i])) {\n          return false;\n        }\n\n        if (statements[i] === node) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n\n    function globalVarCheck(node, parent) {\n      if (!isVarOnTop(node, parent.body)) {\n        context.report({\n          node,\n          messageId: \"top\"\n        });\n      }\n    }\n\n    function blockScopeVarCheck(node, parent, grandParent) {\n      if (!(/Function/u.test(grandParent.type) && parent.type === \"BlockStatement\" && isVarOnTop(node, parent.body))) {\n        context.report({\n          node,\n          messageId: \"top\"\n        });\n      }\n    }\n\n    return {\n      \"VariableDeclaration[kind='var']\"(node) {\n        if (node.parent.type === \"ExportNamedDeclaration\") {\n          globalVarCheck(node.parent, node.parent.parent);\n        } else if (node.parent.type === \"Program\") {\n          globalVarCheck(node, node.parent);\n        } else {\n          blockScopeVarCheck(node, node.parent, node.parent.parent);\n        }\n      }\n\n    };\n  }\n\n};\nvarsOnTop.meta;\nvarsOnTop.create;\n\nfunction isCalleeOfNewExpression(node) {\n  const maybeCallee = node.parent.type === \"ChainExpression\" ? node.parent : node;\n  return maybeCallee.parent.type === \"NewExpression\" && maybeCallee.parent.callee === maybeCallee;\n}\n\nvar wrapIife = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"require parentheses around immediate `function` invocations\",\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/wrap-iife\"\n    },\n    schema: [{\n      enum: [\"outside\", \"inside\", \"any\"]\n    }, {\n      type: \"object\",\n      properties: {\n        functionPrototypeMethods: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    fixable: \"code\",\n    messages: {\n      wrapInvocation: \"Wrap an immediate function invocation in parentheses.\",\n      wrapExpression: \"Wrap only the function expression in parens.\",\n      moveInvocation: \"Move the invocation into the parens that contain the function.\"\n    }\n  },\n\n  create(context) {\n    const style = context.options[0] || \"outside\";\n    const includeFunctionPrototypeMethods = context.options[1] && context.options[1].functionPrototypeMethods;\n    const sourceCode = context.getSourceCode();\n\n    function isWrappedInAnyParens(node) {\n      return astUtils.isParenthesised(sourceCode, node);\n    }\n\n    function isWrappedInGroupingParens(node) {\n      return eslintUtils__default['default'].isParenthesized(1, node, sourceCode);\n    }\n\n    function getFunctionNodeFromIIFE(node) {\n      const callee = astUtils.skipChainExpression(node.callee);\n\n      if (callee.type === \"FunctionExpression\") {\n        return callee;\n      }\n\n      if (includeFunctionPrototypeMethods && callee.type === \"MemberExpression\" && callee.object.type === \"FunctionExpression\" && (astUtils.getStaticPropertyName(callee) === \"call\" || astUtils.getStaticPropertyName(callee) === \"apply\")) {\n        return callee.object;\n      }\n\n      return null;\n    }\n\n    return {\n      CallExpression(node) {\n        const innerNode = getFunctionNodeFromIIFE(node);\n\n        if (!innerNode) {\n          return;\n        }\n\n        const isCallExpressionWrapped = isWrappedInAnyParens(node),\n              isFunctionExpressionWrapped = isWrappedInAnyParens(innerNode);\n\n        if (!isCallExpressionWrapped && !isFunctionExpressionWrapped) {\n          context.report({\n            node,\n            messageId: \"wrapInvocation\",\n\n            fix(fixer) {\n              const nodeToSurround = style === \"inside\" ? innerNode : node;\n              return fixer.replaceText(nodeToSurround, `(${sourceCode.getText(nodeToSurround)})`);\n            }\n\n          });\n        } else if (style === \"inside\" && !isFunctionExpressionWrapped) {\n          context.report({\n            node,\n            messageId: \"wrapExpression\",\n\n            fix(fixer) {\n              if (isWrappedInGroupingParens(node) && !isCalleeOfNewExpression(node)) {\n                const parenAfter = sourceCode.getTokenAfter(node);\n                return fixer.replaceTextRange([innerNode.range[1], parenAfter.range[1]], `)${sourceCode.getText().slice(innerNode.range[1], parenAfter.range[0])}`);\n              }\n\n              return fixer.replaceText(innerNode, `(${sourceCode.getText(innerNode)})`);\n            }\n\n          });\n        } else if (style === \"outside\" && !isCallExpressionWrapped) {\n          context.report({\n            node,\n            messageId: \"moveInvocation\",\n\n            fix(fixer) {\n              const parenAfter = sourceCode.getTokenAfter(innerNode);\n              return fixer.replaceTextRange([parenAfter.range[0], node.range[1]], `${sourceCode.getText().slice(parenAfter.range[1], node.range[1])})`);\n            }\n\n          });\n        }\n      }\n\n    };\n  }\n\n};\nwrapIife.meta;\nwrapIife.create;\nvar wrapRegex = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"require parenthesis around regex literals\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/wrap-regex\"\n    },\n    schema: [],\n    fixable: \"code\",\n    messages: {\n      requireParens: \"Wrap the regexp literal in parens to disambiguate the slash.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    return {\n      Literal(node) {\n        const token = sourceCode.getFirstToken(node),\n              nodeType = token.type;\n\n        if (nodeType === \"RegularExpression\") {\n          const beforeToken = sourceCode.getTokenBefore(node);\n          const afterToken = sourceCode.getTokenAfter(node);\n          const ancestors = context.getAncestors();\n          const grandparent = ancestors[ancestors.length - 1];\n\n          if (grandparent.type === \"MemberExpression\" && grandparent.object === node && !(beforeToken && beforeToken.value === \"(\" && afterToken && afterToken.value === \")\")) {\n            context.report({\n              node,\n              messageId: \"requireParens\",\n              fix: fixer => fixer.replaceText(node, `(${sourceCode.getText(node)})`)\n            });\n          }\n        }\n      }\n\n    };\n  }\n\n};\nwrapRegex.meta;\nwrapRegex.create;\nvar yieldStarSpacing = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"require or disallow spacing around the `*` in `yield*` expressions\",\n      category: \"ECMAScript 6\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/yield-star-spacing\"\n    },\n    fixable: \"whitespace\",\n    schema: [{\n      oneOf: [{\n        enum: [\"before\", \"after\", \"both\", \"neither\"]\n      }, {\n        type: \"object\",\n        properties: {\n          before: {\n            type: \"boolean\"\n          },\n          after: {\n            type: \"boolean\"\n          }\n        },\n        additionalProperties: false\n      }]\n    }],\n    messages: {\n      missingBefore: \"Missing space before *.\",\n      missingAfter: \"Missing space after *.\",\n      unexpectedBefore: \"Unexpected space before *.\",\n      unexpectedAfter: \"Unexpected space after *.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n\n    const mode = function (option) {\n      if (!option || typeof option === \"string\") {\n        return {\n          before: {\n            before: true,\n            after: false\n          },\n          after: {\n            before: false,\n            after: true\n          },\n          both: {\n            before: true,\n            after: true\n          },\n          neither: {\n            before: false,\n            after: false\n          }\n        }[option || \"after\"];\n      }\n\n      return option;\n    }(context.options[0]);\n\n    function checkSpacing(side, leftToken, rightToken) {\n      if (sourceCode.isSpaceBetweenTokens(leftToken, rightToken) !== mode[side]) {\n        const after = leftToken.value === \"*\";\n        const spaceRequired = mode[side];\n        const node = after ? leftToken : rightToken;\n        let messageId = \"\";\n\n        if (spaceRequired) {\n          messageId = side === \"before\" ? \"missingBefore\" : \"missingAfter\";\n        } else {\n          messageId = side === \"before\" ? \"unexpectedBefore\" : \"unexpectedAfter\";\n        }\n\n        context.report({\n          node,\n          messageId,\n\n          fix(fixer) {\n            if (spaceRequired) {\n              if (after) {\n                return fixer.insertTextAfter(node, \" \");\n              }\n\n              return fixer.insertTextBefore(node, \" \");\n            }\n\n            return fixer.removeRange([leftToken.range[1], rightToken.range[0]]);\n          }\n\n        });\n      }\n    }\n\n    return {\n      YieldExpression: function (node) {\n        if (!node.delegate) {\n          return;\n        }\n\n        const tokens = sourceCode.getFirstTokens(node, 3);\n        const yieldToken = tokens[0];\n        const starToken = tokens[1];\n        const nextToken = tokens[2];\n        checkSpacing(\"before\", yieldToken, starToken);\n        checkSpacing(\"after\", starToken, nextToken);\n      }\n    };\n  }\n\n};\nyieldStarSpacing.meta;\nyieldStarSpacing.create;\n\nfunction isComparisonOperator(operator) {\n  return /^(==|===|!=|!==|<|>|<=|>=)$/u.test(operator);\n}\n\nfunction isEqualityOperator(operator) {\n  return /^(==|===)$/u.test(operator);\n}\n\nfunction isRangeTestOperator(operator) {\n  return [\"<\", \"<=\"].indexOf(operator) >= 0;\n}\n\nfunction isNegativeNumericLiteral(node) {\n  return node.type === \"UnaryExpression\" && node.operator === \"-\" && node.prefix && astUtils.isNumericLiteral(node.argument);\n}\n\nfunction isStaticTemplateLiteral(node) {\n  return node.type === \"TemplateLiteral\" && node.expressions.length === 0;\n}\n\nfunction looksLikeLiteral(node) {\n  return isNegativeNumericLiteral(node) || isStaticTemplateLiteral(node);\n}\n\nfunction getNormalizedLiteral(node) {\n  if (node.type === \"Literal\") {\n    return node;\n  }\n\n  if (isNegativeNumericLiteral(node)) {\n    return {\n      type: \"Literal\",\n      value: -node.argument.value,\n      raw: `-${node.argument.value}`\n    };\n  }\n\n  if (isStaticTemplateLiteral(node)) {\n    return {\n      type: \"Literal\",\n      value: node.quasis[0].value.cooked,\n      raw: node.quasis[0].value.raw\n    };\n  }\n\n  return null;\n}\n\nvar yoda = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: 'require or disallow \"Yoda\" conditions',\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/yoda\"\n    },\n    schema: [{\n      enum: [\"always\", \"never\"]\n    }, {\n      type: \"object\",\n      properties: {\n        exceptRange: {\n          type: \"boolean\",\n          default: false\n        },\n        onlyEquality: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    fixable: \"code\",\n    messages: {\n      expected: \"Expected literal to be on the {{expectedSide}} side of {{operator}}.\"\n    }\n  },\n\n  create(context) {\n    const always = context.options[0] === \"always\";\n    const exceptRange = context.options[1] && context.options[1].exceptRange;\n    const onlyEquality = context.options[1] && context.options[1].onlyEquality;\n    const sourceCode = context.getSourceCode();\n\n    function isRangeTest(node) {\n      const left = node.left,\n            right = node.right;\n      return node.type === \"LogicalExpression\" && left.type === \"BinaryExpression\" && right.type === \"BinaryExpression\" && isRangeTestOperator(left.operator) && isRangeTestOperator(right.operator) && (function () {\n        if (node.operator === \"&&\" && astUtils.isSameReference(left.right, right.left)) {\n          const leftLiteral = getNormalizedLiteral(left.left);\n          const rightLiteral = getNormalizedLiteral(right.right);\n\n          if (leftLiteral === null && rightLiteral === null) {\n            return false;\n          }\n\n          if (rightLiteral === null || leftLiteral === null) {\n            return true;\n          }\n\n          if (leftLiteral.value <= rightLiteral.value) {\n            return true;\n          }\n        }\n\n        return false;\n      }() || function () {\n        if (node.operator === \"||\" && astUtils.isSameReference(left.left, right.right)) {\n          const leftLiteral = getNormalizedLiteral(left.right);\n          const rightLiteral = getNormalizedLiteral(right.left);\n\n          if (leftLiteral === null && rightLiteral === null) {\n            return false;\n          }\n\n          if (rightLiteral === null || leftLiteral === null) {\n            return true;\n          }\n\n          if (leftLiteral.value <= rightLiteral.value) {\n            return true;\n          }\n        }\n\n        return false;\n      }()) && function () {\n        return astUtils.isParenthesised(sourceCode, node);\n      }();\n    }\n\n    const OPERATOR_FLIP_MAP = {\n      \"===\": \"===\",\n      \"!==\": \"!==\",\n      \"==\": \"==\",\n      \"!=\": \"!=\",\n      \"<\": \">\",\n      \">\": \"<\",\n      \"<=\": \">=\",\n      \">=\": \"<=\"\n    };\n\n    function getFlippedString(node) {\n      const operatorToken = sourceCode.getFirstTokenBetween(node.left, node.right, token => token.value === node.operator);\n      const lastLeftToken = sourceCode.getTokenBefore(operatorToken);\n      const firstRightToken = sourceCode.getTokenAfter(operatorToken);\n      const source = sourceCode.getText();\n      const leftText = source.slice(node.range[0], lastLeftToken.range[1]);\n      const textBeforeOperator = source.slice(lastLeftToken.range[1], operatorToken.range[0]);\n      const textAfterOperator = source.slice(operatorToken.range[1], firstRightToken.range[0]);\n      const rightText = source.slice(firstRightToken.range[0], node.range[1]);\n      const tokenBefore = sourceCode.getTokenBefore(node);\n      const tokenAfter = sourceCode.getTokenAfter(node);\n      let prefix = \"\";\n      let suffix = \"\";\n\n      if (tokenBefore && tokenBefore.range[1] === node.range[0] && !astUtils.canTokensBeAdjacent(tokenBefore, firstRightToken)) {\n        prefix = \" \";\n      }\n\n      if (tokenAfter && node.range[1] === tokenAfter.range[0] && !astUtils.canTokensBeAdjacent(lastLeftToken, tokenAfter)) {\n        suffix = \" \";\n      }\n\n      return prefix + rightText + textBeforeOperator + OPERATOR_FLIP_MAP[operatorToken.value] + textAfterOperator + leftText + suffix;\n    }\n\n    return {\n      BinaryExpression(node) {\n        const expectedLiteral = always ? node.left : node.right;\n        const expectedNonLiteral = always ? node.right : node.left;\n\n        if ((expectedNonLiteral.type === \"Literal\" || looksLikeLiteral(expectedNonLiteral)) && !(expectedLiteral.type === \"Literal\" || looksLikeLiteral(expectedLiteral)) && !(!isEqualityOperator(node.operator) && onlyEquality) && isComparisonOperator(node.operator) && !(exceptRange && isRangeTest(context.getAncestors().pop()))) {\n          context.report({\n            node,\n            messageId: \"expected\",\n            data: {\n              operator: node.operator,\n              expectedSide: always ? \"left\" : \"right\"\n            },\n            fix: fixer => fixer.replaceText(node, getFlippedString(node))\n          });\n        }\n      }\n\n    };\n  }\n\n};\nyoda.meta;\nyoda.create;\nvar coreRules = {\n  \"accessor-pairs\": accessorPairs,\n  \"array-bracket-newline\": arrayBracketNewline,\n  \"array-bracket-spacing\": arrayBracketSpacing,\n  \"array-callback-return\": arrayCallbackReturn,\n  \"array-element-newline\": arrayElementNewline,\n  \"arrow-body-style\": arrowBodyStyle,\n  \"arrow-parens\": arrowParens,\n  \"arrow-spacing\": arrowSpacing,\n  \"block-scoped-var\": blockScopedVar,\n  \"block-spacing\": blockSpacing,\n  \"brace-style\": braceStyle,\n  \"callback-return\": callbackReturn,\n  \"camelcase\": camelcase,\n  \"capitalized-comments\": capitalizedComments,\n  \"class-methods-use-this\": classMethodsUseThis,\n  \"comma-dangle\": commaDangle,\n  \"comma-spacing\": commaSpacing,\n  \"comma-style\": commaStyle,\n  \"complexity\": complexity,\n  \"computed-property-spacing\": computedPropertySpacing,\n  \"consistent-return\": consistentReturn,\n  \"consistent-this\": consistentThis,\n  \"constructor-super\": constructorSuper,\n  \"curly\": curly,\n  \"default-case-last\": defaultCaseLast,\n  \"default-case\": defaultCase,\n  \"default-param-last\": defaultParamLast,\n  \"dot-location\": dotLocation,\n  \"dot-notation\": dotNotation,\n  \"eol-last\": eolLast,\n  \"eqeqeq\": eqeqeq,\n  \"for-direction\": forDirection,\n  \"func-call-spacing\": funcCallSpacing,\n  \"func-name-matching\": funcNameMatching,\n  \"func-names\": funcNames,\n  \"func-style\": funcStyle,\n  \"function-call-argument-newline\": functionCallArgumentNewline,\n  \"function-paren-newline\": functionParenNewline,\n  \"generator-star-spacing\": generatorStarSpacing,\n  \"getter-return\": getterReturn,\n  \"global-require\": globalRequire,\n  \"grouped-accessor-pairs\": groupedAccessorPairs,\n  \"guard-for-in\": guardForIn,\n  \"handle-callback-err\": handleCallbackErr,\n  \"id-blacklist\": idBlacklist,\n  \"id-denylist\": idDenylist,\n  \"id-length\": idLength,\n  \"id-match\": idMatch,\n  \"implicit-arrow-linebreak\": implicitArrowLinebreak,\n  \"indent-legacy\": indentLegacy,\n  \"indent\": indent,\n  \"init-declarations\": initDeclarations,\n  \"jsx-quotes\": jsxQuotes,\n  \"key-spacing\": keySpacing,\n  \"keyword-spacing\": keywordSpacing,\n  \"line-comment-position\": lineCommentPosition,\n  \"linebreak-style\": linebreakStyle,\n  \"lines-around-comment\": linesAroundComment,\n  \"lines-around-directive\": linesAroundDirective,\n  \"lines-between-class-members\": linesBetweenClassMembers,\n  \"max-classes-per-file\": maxClassesPerFile,\n  \"max-depth\": maxDepth,\n  \"max-len\": maxLen,\n  \"max-lines-per-function\": maxLinesPerFunction,\n  \"max-lines\": maxLines,\n  \"max-nested-callbacks\": maxNestedCallbacks,\n  \"max-params\": maxParams,\n  \"max-statements-per-line\": maxStatementsPerLine,\n  \"max-statements\": maxStatements,\n  \"multiline-comment-style\": multilineCommentStyle,\n  \"multiline-ternary\": multilineTernary,\n  \"new-cap\": newCap,\n  \"new-parens\": newParens,\n  \"newline-after-var\": newlineAfterVar,\n  \"newline-before-return\": newlineBeforeReturn,\n  \"newline-per-chained-call\": newlinePerChainedCall,\n  \"no-alert\": noAlert,\n  \"no-array-constructor\": noArrayConstructor,\n  \"no-async-promise-executor\": noAsyncPromiseExecutor,\n  \"no-await-in-loop\": noAwaitInLoop,\n  \"no-bitwise\": noBitwise,\n  \"no-buffer-constructor\": noBufferConstructor,\n  \"no-caller\": noCaller,\n  \"no-case-declarations\": noCaseDeclarations,\n  \"no-catch-shadow\": noCatchShadow,\n  \"no-class-assign\": noClassAssign,\n  \"no-compare-neg-zero\": noCompareNegZero,\n  \"no-cond-assign\": noCondAssign,\n  \"no-confusing-arrow\": noConfusingArrow,\n  \"no-console\": noConsole,\n  \"no-const-assign\": noConstAssign,\n  \"no-constant-condition\": noConstantCondition,\n  \"no-constructor-return\": noConstructorReturn,\n  \"no-continue\": noContinue,\n  \"no-control-regex\": noControlRegex,\n  \"no-debugger\": noDebugger,\n  \"no-delete-var\": noDeleteVar,\n  \"no-div-regex\": noDivRegex,\n  \"no-dupe-args\": noDupeArgs,\n  \"no-dupe-class-members\": noDupeClassMembers,\n  \"no-dupe-else-if\": noDupeElseIf,\n  \"no-dupe-keys\": noDupeKeys,\n  \"no-duplicate-case\": noDuplicateCase,\n  \"no-duplicate-imports\": noDuplicateImports,\n  \"no-else-return\": noElseReturn,\n  \"no-empty-character-class\": noEmptyCharacterClass,\n  \"no-empty-function\": noEmptyFunction,\n  \"no-empty-pattern\": noEmptyPattern,\n  \"no-empty\": noEmpty,\n  \"no-eq-null\": noEqNull,\n  \"no-eval\": noEval,\n  \"no-ex-assign\": noExAssign,\n  \"no-extend-native\": noExtendNative,\n  \"no-extra-bind\": noExtraBind,\n  \"no-extra-boolean-cast\": noExtraBooleanCast,\n  \"no-extra-label\": noExtraLabel,\n  \"no-extra-parens\": noExtraParens,\n  \"no-extra-semi\": noExtraSemi,\n  \"no-fallthrough\": noFallthrough,\n  \"no-floating-decimal\": noFloatingDecimal,\n  \"no-func-assign\": noFuncAssign,\n  \"no-global-assign\": noGlobalAssign,\n  \"no-implicit-coercion\": noImplicitCoercion,\n  \"no-implicit-globals\": noImplicitGlobals,\n  \"no-implied-eval\": noImpliedEval,\n  \"no-import-assign\": noImportAssign,\n  \"no-inline-comments\": noInlineComments,\n  \"no-inner-declarations\": noInnerDeclarations,\n  \"no-invalid-regexp\": noInvalidRegexp,\n  \"no-invalid-this\": noInvalidThis,\n  \"no-irregular-whitespace\": noIrregularWhitespace,\n  \"no-iterator\": noIterator,\n  \"no-label-var\": noLabelVar,\n  \"no-labels\": noLabels,\n  \"no-lone-blocks\": noLoneBlocks,\n  \"no-lonely-if\": noLonelyIf,\n  \"no-loop-func\": noLoopFunc,\n  \"no-loss-of-precision\": noLossOfPrecision,\n  \"no-magic-numbers\": noMagicNumbers,\n  \"no-misleading-character-class\": noMisleadingCharacterClass,\n  \"no-mixed-operators\": noMixedOperators,\n  \"no-mixed-requires\": noMixedRequires,\n  \"no-mixed-spaces-and-tabs\": noMixedSpacesAndTabs,\n  \"no-multi-assign\": noMultiAssign,\n  \"no-multi-spaces\": noMultiSpaces,\n  \"no-multi-str\": noMultiStr,\n  \"no-multiple-empty-lines\": noMultipleEmptyLines,\n  \"no-native-reassign\": noNativeReassign,\n  \"no-negated-condition\": noNegatedCondition,\n  \"no-negated-in-lhs\": noNegatedInLhs,\n  \"no-nested-ternary\": noNestedTernary,\n  \"no-new-func\": noNewFunc,\n  \"no-new-object\": noNewObject,\n  \"no-new-require\": noNewRequire,\n  \"no-new-symbol\": noNewSymbol,\n  \"no-new-wrappers\": noNewWrappers,\n  \"no-new\": noNew,\n  \"no-nonoctal-decimal-escape\": noNonoctalDecimalEscape,\n  \"no-obj-calls\": noObjCalls,\n  \"no-octal-escape\": noOctalEscape,\n  \"no-octal\": noOctal,\n  \"no-param-reassign\": noParamReassign,\n  \"no-path-concat\": noPathConcat,\n  \"no-plusplus\": noPlusplus,\n  \"no-process-env\": noProcessEnv,\n  \"no-process-exit\": noProcessExit,\n  \"no-promise-executor-return\": noPromiseExecutorReturn,\n  \"no-proto\": noProto,\n  \"no-prototype-builtins\": noPrototypeBuiltins,\n  \"no-redeclare\": noRedeclare,\n  \"no-regex-spaces\": noRegexSpaces,\n  \"no-restricted-exports\": noRestrictedExports,\n  \"no-restricted-globals\": noRestrictedGlobals,\n  \"no-restricted-imports\": noRestrictedImports,\n  \"no-restricted-modules\": noRestrictedModules,\n  \"no-restricted-properties\": noRestrictedProperties,\n  \"no-restricted-syntax\": noRestrictedSyntax,\n  \"no-return-assign\": noReturnAssign,\n  \"no-return-await\": noReturnAwait,\n  \"no-script-url\": noScriptUrl,\n  \"no-self-assign\": noSelfAssign,\n  \"no-self-compare\": noSelfCompare,\n  \"no-sequences\": noSequences,\n  \"no-setter-return\": noSetterReturn,\n  \"no-shadow-restricted-names\": noShadowRestrictedNames,\n  \"no-shadow\": noShadow,\n  \"no-spaced-func\": noSpacedFunc,\n  \"no-sparse-arrays\": noSparseArrays,\n  \"no-sync\": noSync,\n  \"no-tabs\": noTabs,\n  \"no-template-curly-in-string\": noTemplateCurlyInString,\n  \"no-ternary\": noTernary,\n  \"no-this-before-super\": noThisBeforeSuper,\n  \"no-throw-literal\": noThrowLiteral,\n  \"no-trailing-spaces\": noTrailingSpaces,\n  \"no-undef-init\": noUndefInit,\n  \"no-undef\": noUndef,\n  \"no-undefined\": noUndefined,\n  \"no-underscore-dangle\": noUnderscoreDangle,\n  \"no-unexpected-multiline\": noUnexpectedMultiline,\n  \"no-unmodified-loop-condition\": noUnmodifiedLoopCondition,\n  \"no-unneeded-ternary\": noUnneededTernary,\n  \"no-unreachable-loop\": noUnreachableLoop,\n  \"no-unreachable\": noUnreachable,\n  \"no-unsafe-finally\": noUnsafeFinally,\n  \"no-unsafe-negation\": noUnsafeNegation,\n  \"no-unsafe-optional-chaining\": noUnsafeOptionalChaining,\n  \"no-unused-expressions\": noUnusedExpressions,\n  \"no-unused-labels\": noUnusedLabels,\n  \"no-unused-vars\": noUnusedVars,\n  \"no-use-before-define\": noUseBeforeDefine,\n  \"no-useless-backreference\": noUselessBackreference,\n  \"no-useless-call\": noUselessCall,\n  \"no-useless-catch\": noUselessCatch,\n  \"no-useless-computed-key\": noUselessComputedKey,\n  \"no-useless-concat\": noUselessConcat,\n  \"no-useless-constructor\": noUselessConstructor,\n  \"no-useless-escape\": noUselessEscape,\n  \"no-useless-rename\": noUselessRename,\n  \"no-useless-return\": noUselessReturn,\n  \"no-var\": noVar,\n  \"no-void\": noVoid,\n  \"no-warning-comments\": noWarningComments,\n  \"no-whitespace-before-property\": noWhitespaceBeforeProperty,\n  \"no-with\": noWith,\n  \"nonblock-statement-body-position\": nonblockStatementBodyPosition,\n  \"object-curly-newline\": objectCurlyNewline,\n  \"object-curly-spacing\": objectCurlySpacing,\n  \"object-property-newline\": objectPropertyNewline,\n  \"object-shorthand\": objectShorthand,\n  \"one-var-declaration-per-line\": oneVarDeclarationPerLine,\n  \"one-var\": oneVar,\n  \"operator-assignment\": operatorAssignment,\n  \"operator-linebreak\": operatorLinebreak,\n  \"padded-blocks\": paddedBlocks,\n  \"padding-line-between-statements\": paddingLineBetweenStatements,\n  \"prefer-arrow-callback\": preferArrowCallback,\n  \"prefer-const\": preferConst,\n  \"prefer-destructuring\": preferDestructuring,\n  \"prefer-exponentiation-operator\": preferExponentiationOperator,\n  \"prefer-named-capture-group\": preferNamedCaptureGroup,\n  \"prefer-numeric-literals\": preferNumericLiterals,\n  \"prefer-object-spread\": preferObjectSpread,\n  \"prefer-promise-reject-errors\": preferPromiseRejectErrors,\n  \"prefer-reflect\": preferReflect,\n  \"prefer-regex-literals\": preferRegexLiterals,\n  \"prefer-rest-params\": preferRestParams,\n  \"prefer-spread\": preferSpread,\n  \"prefer-template\": preferTemplate,\n  \"quote-props\": quoteProps,\n  \"quotes\": quotes,\n  \"radix\": radix,\n  \"require-atomic-updates\": requireAtomicUpdates,\n  \"require-await\": requireAwait,\n  \"require-jsdoc\": requireJsdoc,\n  \"require-unicode-regexp\": requireUnicodeRegexp,\n  \"require-yield\": requireYield,\n  \"rest-spread-spacing\": restSpreadSpacing,\n  \"semi-spacing\": semiSpacing,\n  \"semi-style\": semiStyle,\n  \"semi\": semi,\n  \"sort-imports\": sortImports,\n  \"sort-keys\": sortKeys,\n  \"sort-vars\": sortVars,\n  \"space-before-blocks\": spaceBeforeBlocks,\n  \"space-before-function-paren\": spaceBeforeFunctionParen,\n  \"space-in-parens\": spaceInParens,\n  \"space-infix-ops\": spaceInfixOps,\n  \"space-unary-ops\": spaceUnaryOps,\n  \"spaced-comment\": spacedComment,\n  \"strict\": strict,\n  \"switch-colon-spacing\": switchColonSpacing,\n  \"symbol-description\": symbolDescription,\n  \"template-curly-spacing\": templateCurlySpacing,\n  \"template-tag-spacing\": templateTagSpacing,\n  \"unicode-bom\": unicodeBom,\n  \"use-isnan\": useIsnan,\n  \"valid-jsdoc\": validJsdoc,\n  \"valid-typeof\": validTypeof,\n  \"vars-on-top\": varsOnTop,\n  \"wrap-iife\": wrapIife,\n  \"wrap-regex\": wrapRegex,\n  \"yield-star-spacing\": yieldStarSpacing,\n  \"yoda\": yoda\n};\nmodule.exports = coreRules;\n//# sourceMappingURL=core-rules.js.map\n\n//# sourceURL=webpack://javascript/./node_modules/eslint4b/dist/core-rules.js?");

/***/ }),

/***/ "./node_modules/eslint4b/dist/index-7114f0bb.js":
/*!******************************************************!*\
  !*** ./node_modules/eslint4b/dist/index-7114f0bb.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/* provided dependency */ var console = __webpack_require__(/*! ./node_modules/console-browserify/index.js */ \"./node_modules/console-browserify/index.js\");\n/* provided dependency */ var process = __webpack_require__(/*! ./node_modules/process/browser.js */ \"./node_modules/process/browser.js\");\n\n\nvar path = __webpack_require__(/*! path */ \"./node_modules/path-browserify/index.js\");\n\nvar eslintScope = __webpack_require__(/*! eslint-scope */ \"./node_modules/eslint-scope/lib/index.js\");\n\nvar eslintVisitorKeys = __webpack_require__(/*! eslint-visitor-keys */ \"./node_modules/eslint4b/node_modules/eslint-visitor-keys/lib/index.js\");\n\nvar espree = __webpack_require__(/*! espree */ \"./node_modules/espree/espree.js\");\n\nvar lodash = __webpack_require__(/*! lodash.merge */ \"./node_modules/lodash.merge/index.js\");\n\nvar environments = __webpack_require__(/*! @eslint/eslintrc/conf/environments */ \"./node_modules/@eslint/eslintrc/conf/environments.js\");\n\nvar _commonjsHelpers = __webpack_require__(/*! ./_commonjsHelpers-11cbc178.js */ \"./node_modules/eslint4b/dist/_commonjsHelpers-11cbc178.js\");\n\nvar configOps = __webpack_require__(/*! @eslint/eslintrc/lib/shared/config-ops */ \"./node_modules/@eslint/eslintrc/lib/shared/config-ops.js\");\n\nvar configValidator = __webpack_require__(/*! @eslint/eslintrc/lib/shared/config-validator */ \"./node_modules/@eslint/eslintrc/lib/shared/config-validator.js\");\n\nvar eslintUtils = __webpack_require__(/*! eslint-utils */ \"./node_modules/eslint-utils/index.mjs\");\n\nvar assert = __webpack_require__(/*! assert */ \"./node_modules/assert/build/assert.js\");\n\nvar debug$4 = __webpack_require__(/*! debug */ \"./node_modules/eslint4b/node_modules/debug/src/browser.js\");\n\nvar levn = __webpack_require__(/*! levn */ \"./node_modules/levn/lib/index.js\");\n\nvar esquery = __webpack_require__(/*! esquery */ \"./node_modules/esquery/dist/esquery.esm.min.js\");\n\nfunction _interopDefaultLegacy(e) {\n  return e && typeof e === 'object' && 'default' in e ? e : {\n    'default': e\n  };\n}\n\nvar path__default = _interopDefaultLegacy(path);\n\nvar eslintScope__default = _interopDefaultLegacy(eslintScope);\n\nvar eslintVisitorKeys__default = _interopDefaultLegacy(eslintVisitorKeys);\n\nvar espree__default = _interopDefaultLegacy(espree);\n\nvar lodash__default = _interopDefaultLegacy(lodash);\n\nvar environments__default = _interopDefaultLegacy(environments);\n\nvar configOps__default = _interopDefaultLegacy(configOps);\n\nvar configValidator__default = _interopDefaultLegacy(configValidator);\n\nvar eslintUtils__default = _interopDefaultLegacy(eslintUtils);\n\nvar assert__default = _interopDefaultLegacy(assert);\n\nvar debug__default = _interopDefaultLegacy(debug$4);\n\nvar levn__default = _interopDefaultLegacy(levn);\n\nvar esquery__default = _interopDefaultLegacy(esquery);\n\nconst _from = \"eslint@^7.0.0\";\nconst _id = \"eslint@7.32.0\";\nconst _inBundle = false;\nconst _integrity = \"sha512-VHZ8gX+EDfz+97jGcgyGCyRia/dPOd6Xh9yPv8Bl1+SoaIwD+a/vlrOmGRUyOYu7MwUhc7CxqeaDZU13S4+EpA==\";\nconst _location = \"/eslint\";\nconst _phantomChildren = {\n  \"@babel/highlight\": \"7.14.5\"\n};\nconst _requested = {\n  type: \"range\",\n  registry: true,\n  raw: \"eslint@^7.0.0\",\n  name: \"eslint\",\n  escapedName: \"eslint\",\n  rawSpec: \"^7.0.0\",\n  saveSpec: null,\n  fetchSpec: \"^7.0.0\"\n};\nconst _requiredBy = [\"#DEV:/\"];\nconst _resolved = \"https://registry.npmjs.org/eslint/-/eslint-7.32.0.tgz\";\nconst _shasum = \"c6d328a14be3fb08c8d1d21e12c02fdb7a2a812d\";\nconst _spec = \"eslint@^7.0.0\";\nconst _where = \"/home/runner/work/eslint4b/eslint4b\";\nconst author = {\n  name: \"Nicholas C. Zakas\",\n  email: \"nicholas+npm@nczconsulting.com\"\n};\nconst bin = {\n  eslint: \"bin/eslint.js\"\n};\nconst bugs = {\n  url: \"https://github.com/eslint/eslint/issues/\"\n};\nconst bundleDependencies = false;\nconst dependencies = {\n  \"@babel/code-frame\": \"7.12.11\",\n  \"@eslint/eslintrc\": \"^0.4.3\",\n  \"@humanwhocodes/config-array\": \"^0.5.0\",\n  ajv: \"^6.10.0\",\n  chalk: \"^4.0.0\",\n  \"cross-spawn\": \"^7.0.2\",\n  debug: \"^4.0.1\",\n  doctrine: \"^3.0.0\",\n  enquirer: \"^2.3.5\",\n  \"escape-string-regexp\": \"^4.0.0\",\n  \"eslint-scope\": \"^5.1.1\",\n  \"eslint-utils\": \"^2.1.0\",\n  \"eslint-visitor-keys\": \"^2.0.0\",\n  espree: \"^7.3.1\",\n  esquery: \"^1.4.0\",\n  esutils: \"^2.0.2\",\n  \"fast-deep-equal\": \"^3.1.3\",\n  \"file-entry-cache\": \"^6.0.1\",\n  \"functional-red-black-tree\": \"^1.0.1\",\n  \"glob-parent\": \"^5.1.2\",\n  globals: \"^13.6.0\",\n  ignore: \"^4.0.6\",\n  \"import-fresh\": \"^3.0.0\",\n  imurmurhash: \"^0.1.4\",\n  \"is-glob\": \"^4.0.0\",\n  \"js-yaml\": \"^3.13.1\",\n  \"json-stable-stringify-without-jsonify\": \"^1.0.1\",\n  levn: \"^0.4.1\",\n  \"lodash.merge\": \"^4.6.2\",\n  minimatch: \"^3.0.4\",\n  \"natural-compare\": \"^1.4.0\",\n  optionator: \"^0.9.1\",\n  progress: \"^2.0.0\",\n  regexpp: \"^3.1.0\",\n  semver: \"^7.2.1\",\n  \"strip-ansi\": \"^6.0.0\",\n  \"strip-json-comments\": \"^3.1.0\",\n  table: \"^6.0.9\",\n  \"text-table\": \"^0.2.0\",\n  \"v8-compile-cache\": \"^2.0.3\"\n};\nconst deprecated = false;\nconst description = \"An AST-based pattern checker for JavaScript.\";\nconst devDependencies = {\n  \"@babel/core\": \"^7.4.3\",\n  \"@babel/preset-env\": \"^7.4.3\",\n  \"babel-loader\": \"^8.0.5\",\n  chai: \"^4.0.1\",\n  cheerio: \"^0.22.0\",\n  \"common-tags\": \"^1.8.0\",\n  \"core-js\": \"^3.1.3\",\n  dateformat: \"^3.0.3\",\n  ejs: \"^3.0.2\",\n  eslint: \"file:.\",\n  \"eslint-config-eslint\": \"file:packages/eslint-config-eslint\",\n  \"eslint-plugin-eslint-plugin\": \"^3.5.3\",\n  \"eslint-plugin-internal-rules\": \"file:tools/internal-rules\",\n  \"eslint-plugin-jsdoc\": \"^25.4.3\",\n  \"eslint-plugin-node\": \"^11.1.0\",\n  \"eslint-release\": \"^2.0.0\",\n  eslump: \"^3.0.0\",\n  esprima: \"^4.0.1\",\n  \"fs-teardown\": \"0.1.1\",\n  glob: \"^7.1.6\",\n  jsdoc: \"^3.5.5\",\n  karma: \"^6.1.1\",\n  \"karma-chrome-launcher\": \"^3.1.0\",\n  \"karma-mocha\": \"^2.0.1\",\n  \"karma-mocha-reporter\": \"^2.2.5\",\n  \"karma-webpack\": \"^5.0.0\",\n  \"lint-staged\": \"^10.1.2\",\n  \"load-perf\": \"^0.2.0\",\n  markdownlint: \"^0.19.0\",\n  \"markdownlint-cli\": \"^0.22.0\",\n  memfs: \"^3.0.1\",\n  mocha: \"^8.3.2\",\n  \"mocha-junit-reporter\": \"^2.0.0\",\n  \"node-polyfill-webpack-plugin\": \"^1.0.3\",\n  \"npm-license\": \"^0.3.3\",\n  nyc: \"^15.0.1\",\n  proxyquire: \"^2.0.1\",\n  puppeteer: \"^7.1.0\",\n  recast: \"^0.19.0\",\n  \"regenerator-runtime\": \"^0.13.2\",\n  shelljs: \"^0.8.2\",\n  sinon: \"^9.0.1\",\n  temp: \"^0.9.0\",\n  webpack: \"^5.23.0\",\n  \"webpack-cli\": \"^4.5.0\",\n  yorkie: \"^2.0.0\"\n};\nconst engines = {\n  node: \"^10.12.0 || >=12.0.0\"\n};\nconst files = [\"LICENSE\", \"README.md\", \"bin\", \"conf\", \"lib\", \"messages\"];\nconst funding = \"https://opencollective.com/eslint\";\nconst gitHooks = {\n  \"pre-commit\": \"lint-staged\"\n};\nconst homepage = \"https://eslint.org\";\nconst keywords = [\"ast\", \"lint\", \"javascript\", \"ecmascript\", \"espree\"];\nconst license = \"MIT\";\nconst main = \"./lib/api.js\";\nconst name = \"eslint\";\nconst repository = {\n  type: \"git\",\n  url: \"git+https://github.com/eslint/eslint.git\"\n};\nconst scripts = {\n  docs: \"node Makefile.js docs\",\n  fix: \"node Makefile.js lint -- fix\",\n  fuzz: \"node Makefile.js fuzz\",\n  \"generate-alpharelease\": \"node Makefile.js generatePrerelease -- alpha\",\n  \"generate-betarelease\": \"node Makefile.js generatePrerelease -- beta\",\n  \"generate-rcrelease\": \"node Makefile.js generatePrerelease -- rc\",\n  \"generate-release\": \"node Makefile.js generateRelease\",\n  gensite: \"node Makefile.js gensite\",\n  lint: \"node Makefile.js lint\",\n  perf: \"node Makefile.js perf\",\n  \"publish-release\": \"node Makefile.js publishRelease\",\n  test: \"node Makefile.js test\",\n  \"test:cli\": \"mocha\",\n  webpack: \"node Makefile.js webpack\"\n};\nconst version = \"7.32.0\";\nvar _package = {\n  _from: \"eslint@^7.0.0\",\n  _id: \"eslint@7.32.0\",\n  _inBundle: false,\n  _integrity: \"sha512-VHZ8gX+EDfz+97jGcgyGCyRia/dPOd6Xh9yPv8Bl1+SoaIwD+a/vlrOmGRUyOYu7MwUhc7CxqeaDZU13S4+EpA==\",\n  _location: \"/eslint\",\n  _phantomChildren: _phantomChildren,\n  _requested: _requested,\n  _requiredBy: _requiredBy,\n  _resolved: \"https://registry.npmjs.org/eslint/-/eslint-7.32.0.tgz\",\n  _shasum: \"c6d328a14be3fb08c8d1d21e12c02fdb7a2a812d\",\n  _spec: \"eslint@^7.0.0\",\n  _where: \"/home/runner/work/eslint4b/eslint4b\",\n  author: author,\n  bin: bin,\n  bugs: bugs,\n  bundleDependencies: false,\n  dependencies: dependencies,\n  deprecated: false,\n  description: \"An AST-based pattern checker for JavaScript.\",\n  devDependencies: devDependencies,\n  engines: engines,\n  files: files,\n  funding: \"https://opencollective.com/eslint\",\n  gitHooks: gitHooks,\n  homepage: \"https://eslint.org\",\n  keywords: keywords,\n  license: \"MIT\",\n  \"lint-staged\": {\n    \"*.js\": \"eslint --fix\",\n    \"*.md\": \"markdownlint\"\n  },\n  main: \"./lib/api.js\",\n  name: \"eslint\",\n  repository: repository,\n  scripts: scripts,\n  version: \"7.32.0\"\n};\n\nvar _package$1 = Object.freeze({\n  __proto__: null,\n  _from: \"eslint@^7.0.0\",\n  _id: \"eslint@7.32.0\",\n  _inBundle: false,\n  _integrity: \"sha512-VHZ8gX+EDfz+97jGcgyGCyRia/dPOd6Xh9yPv8Bl1+SoaIwD+a/vlrOmGRUyOYu7MwUhc7CxqeaDZU13S4+EpA==\",\n  _location: \"/eslint\",\n  _phantomChildren: _phantomChildren,\n  _requested: _requested,\n  _requiredBy: _requiredBy,\n  _resolved: \"https://registry.npmjs.org/eslint/-/eslint-7.32.0.tgz\",\n  _shasum: \"c6d328a14be3fb08c8d1d21e12c02fdb7a2a812d\",\n  _spec: \"eslint@^7.0.0\",\n  _where: \"/home/runner/work/eslint4b/eslint4b\",\n  author: author,\n  bin: bin,\n  bugs: bugs,\n  bundleDependencies: false,\n  dependencies: dependencies,\n  deprecated: false,\n  description: \"An AST-based pattern checker for JavaScript.\",\n  devDependencies: devDependencies,\n  engines: engines,\n  files: files,\n  funding: \"https://opencollective.com/eslint\",\n  gitHooks: gitHooks,\n  homepage: \"https://eslint.org\",\n  keywords: keywords,\n  license: \"MIT\",\n  main: \"./lib/api.js\",\n  name: \"eslint\",\n  repository: repository,\n  scripts: scripts,\n  version: \"7.32.0\",\n  'default': _package\n});\n\nvar cursor = class {\n  constructor() {\n    this.current = null;\n  }\n\n  getOneToken() {\n    return this.moveNext() ? this.current : null;\n  }\n\n  getAllTokens() {\n    const tokens = [];\n\n    while (this.moveNext()) {\n      tokens.push(this.current);\n    }\n\n    return tokens;\n  }\n\n  moveNext() {\n    throw new Error(\"Not implemented.\");\n  }\n\n};\n\nfunction getStartLocation(token) {\n  return token.range[0];\n}\n\nvar search = function (tokens, location) {\n  const index = tokens.findIndex(el => location <= getStartLocation(el));\n  return index === -1 ? tokens.length : index;\n};\n\nvar getFirstIndex = function (tokens, indexMap, startLoc) {\n  if (startLoc in indexMap) {\n    return indexMap[startLoc];\n  }\n\n  if (startLoc - 1 in indexMap) {\n    const index = indexMap[startLoc - 1];\n    const token = index >= 0 && index < tokens.length ? tokens[index] : null;\n\n    if (token && token.range[0] >= startLoc) {\n      return index;\n    }\n\n    return index + 1;\n  }\n\n  return 0;\n};\n\nvar getLastIndex = function (tokens, indexMap, endLoc) {\n  if (endLoc in indexMap) {\n    return indexMap[endLoc] - 1;\n  }\n\n  if (endLoc - 1 in indexMap) {\n    const index = indexMap[endLoc - 1];\n    const token = index >= 0 && index < tokens.length ? tokens[index] : null;\n\n    if (token && token.range[1] > endLoc) {\n      return index - 1;\n    }\n\n    return index;\n  }\n\n  return tokens.length - 1;\n};\n\nvar utils = {\n  search: search,\n  getFirstIndex: getFirstIndex,\n  getLastIndex: getLastIndex\n};\nvar backwardTokenCommentCursor = class extends cursor {\n  constructor(tokens, comments, indexMap, startLoc, endLoc) {\n    super();\n    this.tokens = tokens;\n    this.comments = comments;\n    this.tokenIndex = utils.getLastIndex(tokens, indexMap, endLoc);\n    this.commentIndex = utils.search(comments, endLoc) - 1;\n    this.border = startLoc;\n  }\n\n  moveNext() {\n    const token = this.tokenIndex >= 0 ? this.tokens[this.tokenIndex] : null;\n    const comment = this.commentIndex >= 0 ? this.comments[this.commentIndex] : null;\n\n    if (token && (!comment || token.range[1] > comment.range[1])) {\n      this.current = token;\n      this.tokenIndex -= 1;\n    } else if (comment) {\n      this.current = comment;\n      this.commentIndex -= 1;\n    } else {\n      this.current = null;\n    }\n\n    return Boolean(this.current) && (this.border === -1 || this.current.range[0] >= this.border);\n  }\n\n};\nvar backwardTokenCursor = class extends cursor {\n  constructor(tokens, comments, indexMap, startLoc, endLoc) {\n    super();\n    this.tokens = tokens;\n    this.index = utils.getLastIndex(tokens, indexMap, endLoc);\n    this.indexEnd = utils.getFirstIndex(tokens, indexMap, startLoc);\n  }\n\n  moveNext() {\n    if (this.index >= this.indexEnd) {\n      this.current = this.tokens[this.index];\n      this.index -= 1;\n      return true;\n    }\n\n    return false;\n  }\n\n  getOneToken() {\n    return this.index >= this.indexEnd ? this.tokens[this.index] : null;\n  }\n\n};\nvar decorativeCursor = class extends cursor {\n  constructor(cursor) {\n    super();\n    this.cursor = cursor;\n  }\n\n  moveNext() {\n    const retv = this.cursor.moveNext();\n    this.current = this.cursor.current;\n    return retv;\n  }\n\n};\nvar filterCursor = class extends decorativeCursor {\n  constructor(cursor, predicate) {\n    super(cursor);\n    this.predicate = predicate;\n  }\n\n  moveNext() {\n    const predicate = this.predicate;\n\n    while (super.moveNext()) {\n      if (predicate(this.current)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n};\nvar forwardTokenCommentCursor = class extends cursor {\n  constructor(tokens, comments, indexMap, startLoc, endLoc) {\n    super();\n    this.tokens = tokens;\n    this.comments = comments;\n    this.tokenIndex = utils.getFirstIndex(tokens, indexMap, startLoc);\n    this.commentIndex = utils.search(comments, startLoc);\n    this.border = endLoc;\n  }\n\n  moveNext() {\n    const token = this.tokenIndex < this.tokens.length ? this.tokens[this.tokenIndex] : null;\n    const comment = this.commentIndex < this.comments.length ? this.comments[this.commentIndex] : null;\n\n    if (token && (!comment || token.range[0] < comment.range[0])) {\n      this.current = token;\n      this.tokenIndex += 1;\n    } else if (comment) {\n      this.current = comment;\n      this.commentIndex += 1;\n    } else {\n      this.current = null;\n    }\n\n    return Boolean(this.current) && (this.border === -1 || this.current.range[1] <= this.border);\n  }\n\n};\nvar forwardTokenCursor = class extends cursor {\n  constructor(tokens, comments, indexMap, startLoc, endLoc) {\n    super();\n    this.tokens = tokens;\n    this.index = utils.getFirstIndex(tokens, indexMap, startLoc);\n    this.indexEnd = utils.getLastIndex(tokens, indexMap, endLoc);\n  }\n\n  moveNext() {\n    if (this.index <= this.indexEnd) {\n      this.current = this.tokens[this.index];\n      this.index += 1;\n      return true;\n    }\n\n    return false;\n  }\n\n  getOneToken() {\n    return this.index <= this.indexEnd ? this.tokens[this.index] : null;\n  }\n\n  getAllTokens() {\n    return this.tokens.slice(this.index, this.indexEnd + 1);\n  }\n\n};\nvar limitCursor = class extends decorativeCursor {\n  constructor(cursor, count) {\n    super(cursor);\n    this.count = count;\n  }\n\n  moveNext() {\n    if (this.count > 0) {\n      this.count -= 1;\n      return super.moveNext();\n    }\n\n    return false;\n  }\n\n};\nvar skipCursor = class extends decorativeCursor {\n  constructor(cursor, count) {\n    super(cursor);\n    this.count = count;\n  }\n\n  moveNext() {\n    while (this.count > 0) {\n      this.count -= 1;\n\n      if (!super.moveNext()) {\n        return false;\n      }\n    }\n\n    return super.moveNext();\n  }\n\n};\n\nclass CursorFactory {\n  constructor(TokenCursor, TokenCommentCursor) {\n    this.TokenCursor = TokenCursor;\n    this.TokenCommentCursor = TokenCommentCursor;\n  }\n\n  createBaseCursor(tokens, comments, indexMap, startLoc, endLoc, includeComments) {\n    const Cursor = includeComments ? this.TokenCommentCursor : this.TokenCursor;\n    return new Cursor(tokens, comments, indexMap, startLoc, endLoc);\n  }\n\n  createCursor(tokens, comments, indexMap, startLoc, endLoc, includeComments, filter, skip, count) {\n    let cursor = this.createBaseCursor(tokens, comments, indexMap, startLoc, endLoc, includeComments);\n\n    if (filter) {\n      cursor = new filterCursor(cursor, filter);\n    }\n\n    if (skip >= 1) {\n      cursor = new skipCursor(cursor, skip);\n    }\n\n    if (count >= 0) {\n      cursor = new limitCursor(cursor, count);\n    }\n\n    return cursor;\n  }\n\n}\n\nvar forward = new CursorFactory(forwardTokenCursor, forwardTokenCommentCursor);\nvar backward = new CursorFactory(backwardTokenCursor, backwardTokenCommentCursor);\nvar cursors = {\n  forward: forward,\n  backward: backward\n};\nvar paddedTokenCursor = class extends forwardTokenCursor {\n  constructor(tokens, comments, indexMap, startLoc, endLoc, beforeCount, afterCount) {\n    super(tokens, comments, indexMap, startLoc, endLoc);\n    this.index = Math.max(0, this.index - beforeCount);\n    this.indexEnd = Math.min(tokens.length - 1, this.indexEnd + afterCount);\n  }\n\n};\nconst {\n  isCommentToken: isCommentToken$1\n} = eslintUtils__default['default'];\nconst TOKENS = Symbol(\"tokens\");\nconst COMMENTS = Symbol(\"comments\");\nconst INDEX_MAP = Symbol(\"indexMap\");\n\nfunction createIndexMap(tokens, comments) {\n  const map = Object.create(null);\n  let tokenIndex = 0;\n  let commentIndex = 0;\n  let nextStart = 0;\n  let range = null;\n\n  while (tokenIndex < tokens.length || commentIndex < comments.length) {\n    nextStart = commentIndex < comments.length ? comments[commentIndex].range[0] : Number.MAX_SAFE_INTEGER;\n\n    while (tokenIndex < tokens.length && (range = tokens[tokenIndex].range)[0] < nextStart) {\n      map[range[0]] = tokenIndex;\n      map[range[1] - 1] = tokenIndex;\n      tokenIndex += 1;\n    }\n\n    nextStart = tokenIndex < tokens.length ? tokens[tokenIndex].range[0] : Number.MAX_SAFE_INTEGER;\n\n    while (commentIndex < comments.length && (range = comments[commentIndex].range)[0] < nextStart) {\n      map[range[0]] = tokenIndex;\n      map[range[1] - 1] = tokenIndex;\n      commentIndex += 1;\n    }\n  }\n\n  return map;\n}\n\nfunction createCursorWithSkip(factory, tokens, comments, indexMap, startLoc, endLoc, opts) {\n  let includeComments = false;\n  let skip = 0;\n  let filter = null;\n\n  if (typeof opts === \"number\") {\n    skip = opts | 0;\n  } else if (typeof opts === \"function\") {\n    filter = opts;\n  } else if (opts) {\n    includeComments = !!opts.includeComments;\n    skip = opts.skip | 0;\n    filter = opts.filter || null;\n  }\n\n  assert__default['default'](skip >= 0, \"options.skip should be zero or a positive integer.\");\n  assert__default['default'](!filter || typeof filter === \"function\", \"options.filter should be a function.\");\n  return factory.createCursor(tokens, comments, indexMap, startLoc, endLoc, includeComments, filter, skip, -1);\n}\n\nfunction createCursorWithCount(factory, tokens, comments, indexMap, startLoc, endLoc, opts) {\n  let includeComments = false;\n  let count = 0;\n  let countExists = false;\n  let filter = null;\n\n  if (typeof opts === \"number\") {\n    count = opts | 0;\n    countExists = true;\n  } else if (typeof opts === \"function\") {\n    filter = opts;\n  } else if (opts) {\n    includeComments = !!opts.includeComments;\n    count = opts.count | 0;\n    countExists = typeof opts.count === \"number\";\n    filter = opts.filter || null;\n  }\n\n  assert__default['default'](count >= 0, \"options.count should be zero or a positive integer.\");\n  assert__default['default'](!filter || typeof filter === \"function\", \"options.filter should be a function.\");\n  return factory.createCursor(tokens, comments, indexMap, startLoc, endLoc, includeComments, filter, 0, countExists ? count : -1);\n}\n\nfunction createCursorWithPadding(tokens, comments, indexMap, startLoc, endLoc, beforeCount, afterCount) {\n  if (typeof beforeCount === \"undefined\" && typeof afterCount === \"undefined\") {\n    return new forwardTokenCursor(tokens, comments, indexMap, startLoc, endLoc);\n  }\n\n  if (typeof beforeCount === \"number\" || typeof beforeCount === \"undefined\") {\n    return new paddedTokenCursor(tokens, comments, indexMap, startLoc, endLoc, beforeCount | 0, afterCount | 0);\n  }\n\n  return createCursorWithCount(cursors.forward, tokens, comments, indexMap, startLoc, endLoc, beforeCount);\n}\n\nfunction getAdjacentCommentTokensFromCursor(cursor) {\n  const tokens = [];\n  let currentToken = cursor.getOneToken();\n\n  while (currentToken && isCommentToken$1(currentToken)) {\n    tokens.push(currentToken);\n    currentToken = cursor.getOneToken();\n  }\n\n  return tokens;\n}\n\nvar tokenStore = class {\n  constructor(tokens, comments) {\n    this[TOKENS] = tokens;\n    this[COMMENTS] = comments;\n    this[INDEX_MAP] = createIndexMap(tokens, comments);\n  }\n\n  getTokenByRangeStart(offset, options) {\n    const includeComments = options && options.includeComments;\n    const token = cursors.forward.createBaseCursor(this[TOKENS], this[COMMENTS], this[INDEX_MAP], offset, -1, includeComments).getOneToken();\n\n    if (token && token.range[0] === offset) {\n      return token;\n    }\n\n    return null;\n  }\n\n  getFirstToken(node, options) {\n    return createCursorWithSkip(cursors.forward, this[TOKENS], this[COMMENTS], this[INDEX_MAP], node.range[0], node.range[1], options).getOneToken();\n  }\n\n  getLastToken(node, options) {\n    return createCursorWithSkip(cursors.backward, this[TOKENS], this[COMMENTS], this[INDEX_MAP], node.range[0], node.range[1], options).getOneToken();\n  }\n\n  getTokenBefore(node, options) {\n    return createCursorWithSkip(cursors.backward, this[TOKENS], this[COMMENTS], this[INDEX_MAP], -1, node.range[0], options).getOneToken();\n  }\n\n  getTokenAfter(node, options) {\n    return createCursorWithSkip(cursors.forward, this[TOKENS], this[COMMENTS], this[INDEX_MAP], node.range[1], -1, options).getOneToken();\n  }\n\n  getFirstTokenBetween(left, right, options) {\n    return createCursorWithSkip(cursors.forward, this[TOKENS], this[COMMENTS], this[INDEX_MAP], left.range[1], right.range[0], options).getOneToken();\n  }\n\n  getLastTokenBetween(left, right, options) {\n    return createCursorWithSkip(cursors.backward, this[TOKENS], this[COMMENTS], this[INDEX_MAP], left.range[1], right.range[0], options).getOneToken();\n  }\n\n  getTokenOrCommentBefore(node, skip) {\n    return this.getTokenBefore(node, {\n      includeComments: true,\n      skip\n    });\n  }\n\n  getTokenOrCommentAfter(node, skip) {\n    return this.getTokenAfter(node, {\n      includeComments: true,\n      skip\n    });\n  }\n\n  getFirstTokens(node, options) {\n    return createCursorWithCount(cursors.forward, this[TOKENS], this[COMMENTS], this[INDEX_MAP], node.range[0], node.range[1], options).getAllTokens();\n  }\n\n  getLastTokens(node, options) {\n    return createCursorWithCount(cursors.backward, this[TOKENS], this[COMMENTS], this[INDEX_MAP], node.range[0], node.range[1], options).getAllTokens().reverse();\n  }\n\n  getTokensBefore(node, options) {\n    return createCursorWithCount(cursors.backward, this[TOKENS], this[COMMENTS], this[INDEX_MAP], -1, node.range[0], options).getAllTokens().reverse();\n  }\n\n  getTokensAfter(node, options) {\n    return createCursorWithCount(cursors.forward, this[TOKENS], this[COMMENTS], this[INDEX_MAP], node.range[1], -1, options).getAllTokens();\n  }\n\n  getFirstTokensBetween(left, right, options) {\n    return createCursorWithCount(cursors.forward, this[TOKENS], this[COMMENTS], this[INDEX_MAP], left.range[1], right.range[0], options).getAllTokens();\n  }\n\n  getLastTokensBetween(left, right, options) {\n    return createCursorWithCount(cursors.backward, this[TOKENS], this[COMMENTS], this[INDEX_MAP], left.range[1], right.range[0], options).getAllTokens().reverse();\n  }\n\n  getTokens(node, beforeCount, afterCount) {\n    return createCursorWithPadding(this[TOKENS], this[COMMENTS], this[INDEX_MAP], node.range[0], node.range[1], beforeCount, afterCount).getAllTokens();\n  }\n\n  getTokensBetween(left, right, padding) {\n    return createCursorWithPadding(this[TOKENS], this[COMMENTS], this[INDEX_MAP], left.range[1], right.range[0], padding, padding).getAllTokens();\n  }\n\n  commentsExistBetween(left, right) {\n    const index = utils.search(this[COMMENTS], left.range[1]);\n    return index < this[COMMENTS].length && this[COMMENTS][index].range[1] <= right.range[0];\n  }\n\n  getCommentsBefore(nodeOrToken) {\n    const cursor = createCursorWithCount(cursors.backward, this[TOKENS], this[COMMENTS], this[INDEX_MAP], -1, nodeOrToken.range[0], {\n      includeComments: true\n    });\n    return getAdjacentCommentTokensFromCursor(cursor).reverse();\n  }\n\n  getCommentsAfter(nodeOrToken) {\n    const cursor = createCursorWithCount(cursors.forward, this[TOKENS], this[COMMENTS], this[INDEX_MAP], nodeOrToken.range[1], -1, {\n      includeComments: true\n    });\n    return getAdjacentCommentTokensFromCursor(cursor);\n  }\n\n  getCommentsInside(node) {\n    return this.getTokens(node, {\n      includeComments: true,\n      filter: isCommentToken$1\n    });\n  }\n\n};\nconst {\n  isCommentToken\n} = eslintUtils__default['default'];\n\nfunction validate(ast) {\n  if (!ast.tokens) {\n    throw new Error(\"AST is missing the tokens array.\");\n  }\n\n  if (!ast.comments) {\n    throw new Error(\"AST is missing the comments array.\");\n  }\n\n  if (!ast.loc) {\n    throw new Error(\"AST is missing location information.\");\n  }\n\n  if (!ast.range) {\n    throw new Error(\"AST is missing range information\");\n  }\n}\n\nfunction looksLikeExport(astNode) {\n  return astNode.type === \"ExportDefaultDeclaration\" || astNode.type === \"ExportNamedDeclaration\" || astNode.type === \"ExportAllDeclaration\" || astNode.type === \"ExportSpecifier\";\n}\n\nfunction sortedMerge(tokens, comments) {\n  const result = [];\n  let tokenIndex = 0;\n  let commentIndex = 0;\n\n  while (tokenIndex < tokens.length || commentIndex < comments.length) {\n    if (commentIndex >= comments.length || tokenIndex < tokens.length && tokens[tokenIndex].range[0] < comments[commentIndex].range[0]) {\n      result.push(tokens[tokenIndex++]);\n    } else {\n      result.push(comments[commentIndex++]);\n    }\n  }\n\n  return result;\n}\n\nfunction nodesOrTokensOverlap(first, second) {\n  return first.range[0] <= second.range[0] && first.range[1] >= second.range[0] || second.range[0] <= first.range[0] && second.range[1] >= first.range[0];\n}\n\nfunction isSpaceBetween(sourceCode, first, second, checkInsideOfJSXText) {\n  if (nodesOrTokensOverlap(first, second)) {\n    return false;\n  }\n\n  const [startingNodeOrToken, endingNodeOrToken] = first.range[1] <= second.range[0] ? [first, second] : [second, first];\n  const firstToken = sourceCode.getLastToken(startingNodeOrToken) || startingNodeOrToken;\n  const finalToken = sourceCode.getFirstToken(endingNodeOrToken) || endingNodeOrToken;\n  let currentToken = firstToken;\n\n  while (currentToken !== finalToken) {\n    const nextToken = sourceCode.getTokenAfter(currentToken, {\n      includeComments: true\n    });\n\n    if (currentToken.range[1] !== nextToken.range[0] || checkInsideOfJSXText && nextToken !== finalToken && nextToken.type === \"JSXText\" && /\\s/u.test(nextToken.value)) {\n      return true;\n    }\n\n    currentToken = nextToken;\n  }\n\n  return false;\n}\n\nclass SourceCode$1 extends tokenStore {\n  constructor(textOrConfig, astIfNoConfig) {\n    let text, ast, parserServices, scopeManager, visitorKeys;\n\n    if (typeof textOrConfig === \"string\") {\n      text = textOrConfig;\n      ast = astIfNoConfig;\n    } else if (typeof textOrConfig === \"object\" && textOrConfig !== null) {\n      text = textOrConfig.text;\n      ast = textOrConfig.ast;\n      parserServices = textOrConfig.parserServices;\n      scopeManager = textOrConfig.scopeManager;\n      visitorKeys = textOrConfig.visitorKeys;\n    }\n\n    validate(ast);\n    super(ast.tokens, ast.comments);\n    this.hasBOM = text.charCodeAt(0) === 0xFEFF;\n    this.text = this.hasBOM ? text.slice(1) : text;\n    this.ast = ast;\n    this.parserServices = parserServices || {};\n    this.scopeManager = scopeManager || null;\n    this.visitorKeys = visitorKeys || _commonjsHelpers.traverser.DEFAULT_VISITOR_KEYS;\n    const shebangMatched = this.text.match(_commonjsHelpers.astUtils.shebangPattern);\n    const hasShebang = shebangMatched && ast.comments.length && ast.comments[0].value === shebangMatched[1];\n\n    if (hasShebang) {\n      ast.comments[0].type = \"Shebang\";\n    }\n\n    this.tokensAndComments = sortedMerge(ast.tokens, ast.comments);\n    this.lines = [];\n    this.lineStartIndices = [0];\n\n    const lineEndingPattern = _commonjsHelpers.astUtils.createGlobalLinebreakMatcher();\n\n    let match;\n\n    while (match = lineEndingPattern.exec(this.text)) {\n      this.lines.push(this.text.slice(this.lineStartIndices[this.lineStartIndices.length - 1], match.index));\n      this.lineStartIndices.push(match.index + match[0].length);\n    }\n\n    this.lines.push(this.text.slice(this.lineStartIndices[this.lineStartIndices.length - 1]));\n    this._commentCache = new WeakMap();\n    Object.freeze(this);\n    Object.freeze(this.lines);\n  }\n\n  static splitLines(text) {\n    return text.split(_commonjsHelpers.astUtils.createGlobalLinebreakMatcher());\n  }\n\n  getText(node, beforeCount, afterCount) {\n    if (node) {\n      return this.text.slice(Math.max(node.range[0] - (beforeCount || 0), 0), node.range[1] + (afterCount || 0));\n    }\n\n    return this.text;\n  }\n\n  getLines() {\n    return this.lines;\n  }\n\n  getAllComments() {\n    return this.ast.comments;\n  }\n\n  getComments(node) {\n    if (this._commentCache.has(node)) {\n      return this._commentCache.get(node);\n    }\n\n    const comments = {\n      leading: [],\n      trailing: []\n    };\n\n    if (node.type === \"Program\") {\n      if (node.body.length === 0) {\n        comments.leading = node.comments;\n      }\n    } else {\n      if ((node.type === \"BlockStatement\" || node.type === \"ClassBody\") && node.body.length === 0 || node.type === \"ObjectExpression\" && node.properties.length === 0 || node.type === \"ArrayExpression\" && node.elements.length === 0 || node.type === \"SwitchStatement\" && node.cases.length === 0) {\n        comments.trailing = this.getTokens(node, {\n          includeComments: true,\n          filter: isCommentToken\n        });\n      }\n\n      let currentToken = this.getTokenBefore(node, {\n        includeComments: true\n      });\n\n      while (currentToken && isCommentToken(currentToken)) {\n        if (node.parent && node.parent.type !== \"Program\" && currentToken.start < node.parent.start) {\n          break;\n        }\n\n        comments.leading.push(currentToken);\n        currentToken = this.getTokenBefore(currentToken, {\n          includeComments: true\n        });\n      }\n\n      comments.leading.reverse();\n      currentToken = this.getTokenAfter(node, {\n        includeComments: true\n      });\n\n      while (currentToken && isCommentToken(currentToken)) {\n        if (node.parent && node.parent.type !== \"Program\" && currentToken.end > node.parent.end) {\n          break;\n        }\n\n        comments.trailing.push(currentToken);\n        currentToken = this.getTokenAfter(currentToken, {\n          includeComments: true\n        });\n      }\n    }\n\n    this._commentCache.set(node, comments);\n\n    return comments;\n  }\n\n  getJSDocComment(node) {\n    const findJSDocComment = astNode => {\n      const tokenBefore = this.getTokenBefore(astNode, {\n        includeComments: true\n      });\n\n      if (tokenBefore && isCommentToken(tokenBefore) && tokenBefore.type === \"Block\" && tokenBefore.value.charAt(0) === \"*\" && astNode.loc.start.line - tokenBefore.loc.end.line <= 1) {\n        return tokenBefore;\n      }\n\n      return null;\n    };\n\n    let parent = node.parent;\n\n    switch (node.type) {\n      case \"ClassDeclaration\":\n      case \"FunctionDeclaration\":\n        return findJSDocComment(looksLikeExport(parent) ? parent : node);\n\n      case \"ClassExpression\":\n        return findJSDocComment(parent.parent);\n\n      case \"ArrowFunctionExpression\":\n      case \"FunctionExpression\":\n        if (parent.type !== \"CallExpression\" && parent.type !== \"NewExpression\") {\n          while (!this.getCommentsBefore(parent).length && !/Function/u.test(parent.type) && parent.type !== \"MethodDefinition\" && parent.type !== \"Property\") {\n            parent = parent.parent;\n\n            if (!parent) {\n              break;\n            }\n          }\n\n          if (parent && parent.type !== \"FunctionDeclaration\" && parent.type !== \"Program\") {\n            return findJSDocComment(parent);\n          }\n        }\n\n        return findJSDocComment(node);\n\n      default:\n        return null;\n    }\n  }\n\n  getNodeByRangeIndex(index) {\n    let result = null;\n\n    _commonjsHelpers.traverser.traverse(this.ast, {\n      visitorKeys: this.visitorKeys,\n\n      enter(node) {\n        if (node.range[0] <= index && index < node.range[1]) {\n          result = node;\n        } else {\n          this.skip();\n        }\n      },\n\n      leave(node) {\n        if (node === result) {\n          this.break();\n        }\n      }\n\n    });\n\n    return result;\n  }\n\n  isSpaceBetween(first, second) {\n    return isSpaceBetween(this, first, second, false);\n  }\n\n  isSpaceBetweenTokens(first, second) {\n    return isSpaceBetween(this, first, second, true);\n  }\n\n  getLocFromIndex(index) {\n    if (typeof index !== \"number\") {\n      throw new TypeError(\"Expected `index` to be a number.\");\n    }\n\n    if (index < 0 || index > this.text.length) {\n      throw new RangeError(`Index out of range (requested index ${index}, but source text has length ${this.text.length}).`);\n    }\n\n    if (index === this.text.length) {\n      return {\n        line: this.lines.length,\n        column: this.lines[this.lines.length - 1].length\n      };\n    }\n\n    const lineNumber = index >= this.lineStartIndices[this.lineStartIndices.length - 1] ? this.lineStartIndices.length : this.lineStartIndices.findIndex(el => index < el);\n    return {\n      line: lineNumber,\n      column: index - this.lineStartIndices[lineNumber - 1]\n    };\n  }\n\n  getIndexFromLoc(loc) {\n    if (typeof loc !== \"object\" || typeof loc.line !== \"number\" || typeof loc.column !== \"number\") {\n      throw new TypeError(\"Expected `loc` to be an object with numeric `line` and `column` properties.\");\n    }\n\n    if (loc.line <= 0) {\n      throw new RangeError(`Line number out of range (line ${loc.line} requested). Line numbers should be 1-based.`);\n    }\n\n    if (loc.line > this.lineStartIndices.length) {\n      throw new RangeError(`Line number out of range (line ${loc.line} requested, but only ${this.lineStartIndices.length} lines present).`);\n    }\n\n    const lineStartIndex = this.lineStartIndices[loc.line - 1];\n    const lineEndIndex = loc.line === this.lineStartIndices.length ? this.text.length : this.lineStartIndices[loc.line];\n    const positionIndex = lineStartIndex + loc.column;\n\n    if (loc.line === this.lineStartIndices.length && positionIndex > lineEndIndex || loc.line < this.lineStartIndices.length && positionIndex >= lineEndIndex) {\n      throw new RangeError(`Column number out of range (column ${loc.column} requested, but the length of line ${loc.line} is ${lineEndIndex - lineStartIndex}).`);\n    }\n\n    return positionIndex;\n  }\n\n}\n\nvar sourceCode$1 = SourceCode$1;\nvar sourceCode = {\n  SourceCode: sourceCode$1\n};\nconst debug$3 = debug__default['default'](\"eslint:code-path\");\n\nfunction getId(segment) {\n  return segment.id + (segment.reachable ? \"\" : \"!\");\n}\n\nfunction nodeToString(node, label) {\n  const suffix = label ? `:${label}` : \"\";\n\n  switch (node.type) {\n    case \"Identifier\":\n      return `${node.type}${suffix} (${node.name})`;\n\n    case \"Literal\":\n      return `${node.type}${suffix} (${node.value})`;\n\n    default:\n      return `${node.type}${suffix}`;\n  }\n}\n\nvar debugHelpers = {\n  enabled: debug$3.enabled,\n  dump: debug$3,\n  dumpState: !debug$3.enabled ? debug$3 : function (node, state, leaving) {\n    for (let i = 0; i < state.currentSegments.length; ++i) {\n      const segInternal = state.currentSegments[i].internal;\n\n      if (leaving) {\n        const last = segInternal.nodes.length - 1;\n\n        if (last >= 0 && segInternal.nodes[last] === nodeToString(node, \"enter\")) {\n          segInternal.nodes[last] = nodeToString(node, void 0);\n        } else {\n          segInternal.nodes.push(nodeToString(node, \"exit\"));\n        }\n      } else {\n        segInternal.nodes.push(nodeToString(node, \"enter\"));\n      }\n    }\n\n    debug$3([`${state.currentSegments.map(getId).join(\",\")})`, `${node.type}${leaving ? \":exit\" : \"\"}`].join(\" \"));\n  },\n  dumpDot: !debug$3.enabled ? debug$3 : function (codePath) {\n    let text = \"\\ndigraph {\\nnode[shape=box,style=\\\"rounded,filled\\\",fillcolor=white];\\ninitial[label=\\\"\\\",shape=circle,style=filled,fillcolor=black,width=0.25,height=0.25];\\n\";\n\n    if (codePath.returnedSegments.length > 0) {\n      text += \"final[label=\\\"\\\",shape=doublecircle,style=filled,fillcolor=black,width=0.25,height=0.25];\\n\";\n    }\n\n    if (codePath.thrownSegments.length > 0) {\n      text += \"thrown[label=\\\"\\\",shape=circle,width=0.3,height=0.3,fixedsize];\\n\";\n    }\n\n    const traceMap = Object.create(null);\n    const arrows = this.makeDotArrows(codePath, traceMap);\n\n    for (const id in traceMap) {\n      const segment = traceMap[id];\n      text += `${id}[`;\n\n      if (segment.reachable) {\n        text += \"label=\\\"\";\n      } else {\n        text += \"style=\\\"rounded,dashed,filled\\\",fillcolor=\\\"#FF9800\\\",label=\\\"<<unreachable>>\\\\n\";\n      }\n\n      if (segment.internal.nodes.length > 0) {\n        text += segment.internal.nodes.join(\"\\\\n\");\n      } else {\n        text += \"????\";\n      }\n\n      text += \"\\\"];\\n\";\n    }\n\n    text += `${arrows}\\n`;\n    text += \"}\";\n    debug$3(\"DOT\", text);\n  },\n\n  makeDotArrows(codePath, traceMap) {\n    const stack = [[codePath.initialSegment, 0]];\n    const done = traceMap || Object.create(null);\n    let lastId = codePath.initialSegment.id;\n    let text = `initial->${codePath.initialSegment.id}`;\n\n    while (stack.length > 0) {\n      const item = stack.pop();\n      const segment = item[0];\n      const index = item[1];\n\n      if (done[segment.id] && index === 0) {\n        continue;\n      }\n\n      done[segment.id] = segment;\n      const nextSegment = segment.allNextSegments[index];\n\n      if (!nextSegment) {\n        continue;\n      }\n\n      if (lastId === segment.id) {\n        text += `->${nextSegment.id}`;\n      } else {\n        text += `;\\n${segment.id}->${nextSegment.id}`;\n      }\n\n      lastId = nextSegment.id;\n      stack.unshift([segment, 1 + index]);\n      stack.push([nextSegment, 0]);\n    }\n\n    codePath.returnedSegments.forEach(finalSegment => {\n      if (lastId === finalSegment.id) {\n        text += \"->final\";\n      } else {\n        text += `;\\n${finalSegment.id}->final`;\n      }\n\n      lastId = null;\n    });\n    codePath.thrownSegments.forEach(finalSegment => {\n      if (lastId === finalSegment.id) {\n        text += \"->thrown\";\n      } else {\n        text += `;\\n${finalSegment.id}->thrown`;\n      }\n\n      lastId = null;\n    });\n    return `${text};`;\n  }\n\n};\ndebugHelpers.enabled;\ndebugHelpers.dump;\ndebugHelpers.dumpState;\ndebugHelpers.dumpDot;\ndebugHelpers.makeDotArrows;\n\nfunction isReachable$1(segment) {\n  return segment.reachable;\n}\n\nclass CodePathSegment {\n  constructor(id, allPrevSegments, reachable) {\n    this.id = id;\n    this.nextSegments = [];\n    this.prevSegments = allPrevSegments.filter(isReachable$1);\n    this.allNextSegments = [];\n    this.allPrevSegments = allPrevSegments;\n    this.reachable = reachable;\n    Object.defineProperty(this, \"internal\", {\n      value: {\n        used: false,\n        loopedPrevSegments: []\n      }\n    });\n\n    if (debugHelpers.enabled) {\n      this.internal.nodes = [];\n    }\n  }\n\n  isLoopedPrevSegment(segment) {\n    return this.internal.loopedPrevSegments.indexOf(segment) !== -1;\n  }\n\n  static newRoot(id) {\n    return new CodePathSegment(id, [], true);\n  }\n\n  static newNext(id, allPrevSegments) {\n    return new CodePathSegment(id, CodePathSegment.flattenUnusedSegments(allPrevSegments), allPrevSegments.some(isReachable$1));\n  }\n\n  static newUnreachable(id, allPrevSegments) {\n    const segment = new CodePathSegment(id, CodePathSegment.flattenUnusedSegments(allPrevSegments), false);\n    CodePathSegment.markUsed(segment);\n    return segment;\n  }\n\n  static newDisconnected(id, allPrevSegments) {\n    return new CodePathSegment(id, [], allPrevSegments.some(isReachable$1));\n  }\n\n  static markUsed(segment) {\n    if (segment.internal.used) {\n      return;\n    }\n\n    segment.internal.used = true;\n    let i;\n\n    if (segment.reachable) {\n      for (i = 0; i < segment.allPrevSegments.length; ++i) {\n        const prevSegment = segment.allPrevSegments[i];\n        prevSegment.allNextSegments.push(segment);\n        prevSegment.nextSegments.push(segment);\n      }\n    } else {\n      for (i = 0; i < segment.allPrevSegments.length; ++i) {\n        segment.allPrevSegments[i].allNextSegments.push(segment);\n      }\n    }\n  }\n\n  static markPrevSegmentAsLooped(segment, prevSegment) {\n    segment.internal.loopedPrevSegments.push(prevSegment);\n  }\n\n  static flattenUnusedSegments(segments) {\n    const done = Object.create(null);\n    const retv = [];\n\n    for (let i = 0; i < segments.length; ++i) {\n      const segment = segments[i];\n\n      if (done[segment.id]) {\n        continue;\n      }\n\n      if (!segment.internal.used) {\n        for (let j = 0; j < segment.allPrevSegments.length; ++j) {\n          const prevSegment = segment.allPrevSegments[j];\n\n          if (!done[prevSegment.id]) {\n            done[prevSegment.id] = true;\n            retv.push(prevSegment);\n          }\n        }\n      } else {\n        done[segment.id] = true;\n        retv.push(segment);\n      }\n    }\n\n    return retv;\n  }\n\n}\n\nvar codePathSegment = CodePathSegment;\n\nfunction isReachable(segment) {\n  return segment.reachable;\n}\n\nfunction makeSegments(context, begin, end, create) {\n  const list = context.segmentsList;\n  const normalizedBegin = begin >= 0 ? begin : list.length + begin;\n  const normalizedEnd = end >= 0 ? end : list.length + end;\n  const segments = [];\n\n  for (let i = 0; i < context.count; ++i) {\n    const allPrevSegments = [];\n\n    for (let j = normalizedBegin; j <= normalizedEnd; ++j) {\n      allPrevSegments.push(list[j][i]);\n    }\n\n    segments.push(create(context.idGenerator.next(), allPrevSegments));\n  }\n\n  return segments;\n}\n\nfunction mergeExtraSegments(context, segments) {\n  let currentSegments = segments;\n\n  while (currentSegments.length > context.count) {\n    const merged = [];\n\n    for (let i = 0, length = currentSegments.length / 2 | 0; i < length; ++i) {\n      merged.push(codePathSegment.newNext(context.idGenerator.next(), [currentSegments[i], currentSegments[i + length]]));\n    }\n\n    currentSegments = merged;\n  }\n\n  return currentSegments;\n}\n\nclass ForkContext {\n  constructor(idGenerator, upper, count) {\n    this.idGenerator = idGenerator;\n    this.upper = upper;\n    this.count = count;\n    this.segmentsList = [];\n  }\n\n  get head() {\n    const list = this.segmentsList;\n    return list.length === 0 ? [] : list[list.length - 1];\n  }\n\n  get empty() {\n    return this.segmentsList.length === 0;\n  }\n\n  get reachable() {\n    const segments = this.head;\n    return segments.length > 0 && segments.some(isReachable);\n  }\n\n  makeNext(begin, end) {\n    return makeSegments(this, begin, end, codePathSegment.newNext);\n  }\n\n  makeUnreachable(begin, end) {\n    return makeSegments(this, begin, end, codePathSegment.newUnreachable);\n  }\n\n  makeDisconnected(begin, end) {\n    return makeSegments(this, begin, end, codePathSegment.newDisconnected);\n  }\n\n  add(segments) {\n    assert__default['default'](segments.length >= this.count, `${segments.length} >= ${this.count}`);\n    this.segmentsList.push(mergeExtraSegments(this, segments));\n  }\n\n  replaceHead(segments) {\n    assert__default['default'](segments.length >= this.count, `${segments.length} >= ${this.count}`);\n    this.segmentsList.splice(-1, 1, mergeExtraSegments(this, segments));\n  }\n\n  addAll(context) {\n    assert__default['default'](context.count === this.count);\n    const source = context.segmentsList;\n\n    for (let i = 0; i < source.length; ++i) {\n      this.segmentsList.push(source[i]);\n    }\n  }\n\n  clear() {\n    this.segmentsList = [];\n  }\n\n  static newRoot(idGenerator) {\n    const context = new ForkContext(idGenerator, null, 1);\n    context.add([codePathSegment.newRoot(idGenerator.next())]);\n    return context;\n  }\n\n  static newEmpty(parentContext, forkLeavingPath) {\n    return new ForkContext(parentContext.idGenerator, parentContext, (forkLeavingPath ? 2 : 1) * parentContext.count);\n  }\n\n}\n\nvar forkContext = ForkContext;\n\nfunction addToReturnedOrThrown(dest, others, all, segments) {\n  for (let i = 0; i < segments.length; ++i) {\n    const segment = segments[i];\n    dest.push(segment);\n\n    if (others.indexOf(segment) === -1) {\n      all.push(segment);\n    }\n  }\n}\n\nfunction getContinueContext(state, label) {\n  if (!label) {\n    return state.loopContext;\n  }\n\n  let context = state.loopContext;\n\n  while (context) {\n    if (context.label === label) {\n      return context;\n    }\n\n    context = context.upper;\n  }\n\n  return null;\n}\n\nfunction getBreakContext(state, label) {\n  let context = state.breakContext;\n\n  while (context) {\n    if (label ? context.label === label : context.breakable) {\n      return context;\n    }\n\n    context = context.upper;\n  }\n\n  return null;\n}\n\nfunction getReturnContext(state) {\n  let context = state.tryContext;\n\n  while (context) {\n    if (context.hasFinalizer && context.position !== \"finally\") {\n      return context;\n    }\n\n    context = context.upper;\n  }\n\n  return state;\n}\n\nfunction getThrowContext(state) {\n  let context = state.tryContext;\n\n  while (context) {\n    if (context.position === \"try\" || context.hasFinalizer && context.position === \"catch\") {\n      return context;\n    }\n\n    context = context.upper;\n  }\n\n  return state;\n}\n\nfunction remove(xs, x) {\n  xs.splice(xs.indexOf(x), 1);\n}\n\nfunction removeConnection(prevSegments, nextSegments) {\n  for (let i = 0; i < prevSegments.length; ++i) {\n    const prevSegment = prevSegments[i];\n    const nextSegment = nextSegments[i];\n    remove(prevSegment.nextSegments, nextSegment);\n    remove(prevSegment.allNextSegments, nextSegment);\n    remove(nextSegment.prevSegments, prevSegment);\n    remove(nextSegment.allPrevSegments, prevSegment);\n  }\n}\n\nfunction makeLooped(state, unflattenedFromSegments, unflattenedToSegments) {\n  const fromSegments = codePathSegment.flattenUnusedSegments(unflattenedFromSegments);\n  const toSegments = codePathSegment.flattenUnusedSegments(unflattenedToSegments);\n  const end = Math.min(fromSegments.length, toSegments.length);\n\n  for (let i = 0; i < end; ++i) {\n    const fromSegment = fromSegments[i];\n    const toSegment = toSegments[i];\n\n    if (toSegment.reachable) {\n      fromSegment.nextSegments.push(toSegment);\n    }\n\n    if (fromSegment.reachable) {\n      toSegment.prevSegments.push(fromSegment);\n    }\n\n    fromSegment.allNextSegments.push(toSegment);\n    toSegment.allPrevSegments.push(fromSegment);\n\n    if (toSegment.allPrevSegments.length >= 2) {\n      codePathSegment.markPrevSegmentAsLooped(toSegment, fromSegment);\n    }\n\n    state.notifyLooped(fromSegment, toSegment);\n  }\n}\n\nfunction finalizeTestSegmentsOfFor(context, choiceContext, head) {\n  if (!choiceContext.processed) {\n    choiceContext.trueForkContext.add(head);\n    choiceContext.falseForkContext.add(head);\n    choiceContext.qqForkContext.add(head);\n  }\n\n  if (context.test !== true) {\n    context.brokenForkContext.addAll(choiceContext.falseForkContext);\n  }\n\n  context.endOfTestSegments = choiceContext.trueForkContext.makeNext(0, -1);\n}\n\nclass CodePathState {\n  constructor(idGenerator, onLooped) {\n    this.idGenerator = idGenerator;\n    this.notifyLooped = onLooped;\n    this.forkContext = forkContext.newRoot(idGenerator);\n    this.choiceContext = null;\n    this.switchContext = null;\n    this.tryContext = null;\n    this.loopContext = null;\n    this.breakContext = null;\n    this.chainContext = null;\n    this.currentSegments = [];\n    this.initialSegment = this.forkContext.head[0];\n    const final = this.finalSegments = [];\n    const returned = this.returnedForkContext = [];\n    const thrown = this.thrownForkContext = [];\n    returned.add = addToReturnedOrThrown.bind(null, returned, thrown, final);\n    thrown.add = addToReturnedOrThrown.bind(null, thrown, returned, final);\n  }\n\n  get headSegments() {\n    return this.forkContext.head;\n  }\n\n  get parentForkContext() {\n    const current = this.forkContext;\n    return current && current.upper;\n  }\n\n  pushForkContext(forkLeavingPath) {\n    this.forkContext = forkContext.newEmpty(this.forkContext, forkLeavingPath);\n    return this.forkContext;\n  }\n\n  popForkContext() {\n    const lastContext = this.forkContext;\n    this.forkContext = lastContext.upper;\n    this.forkContext.replaceHead(lastContext.makeNext(0, -1));\n    return lastContext;\n  }\n\n  forkPath() {\n    this.forkContext.add(this.parentForkContext.makeNext(-1, -1));\n  }\n\n  forkBypassPath() {\n    this.forkContext.add(this.parentForkContext.head);\n  }\n\n  pushChoiceContext(kind, isForkingAsResult) {\n    this.choiceContext = {\n      upper: this.choiceContext,\n      kind,\n      isForkingAsResult,\n      trueForkContext: forkContext.newEmpty(this.forkContext),\n      falseForkContext: forkContext.newEmpty(this.forkContext),\n      qqForkContext: forkContext.newEmpty(this.forkContext),\n      processed: false\n    };\n  }\n\n  popChoiceContext() {\n    const context = this.choiceContext;\n    this.choiceContext = context.upper;\n    const forkContext = this.forkContext;\n    const headSegments = forkContext.head;\n\n    switch (context.kind) {\n      case \"&&\":\n      case \"||\":\n      case \"??\":\n        if (!context.processed) {\n          context.trueForkContext.add(headSegments);\n          context.falseForkContext.add(headSegments);\n          context.qqForkContext.add(headSegments);\n        }\n\n        if (context.isForkingAsResult) {\n          const parentContext = this.choiceContext;\n          parentContext.trueForkContext.addAll(context.trueForkContext);\n          parentContext.falseForkContext.addAll(context.falseForkContext);\n          parentContext.qqForkContext.addAll(context.qqForkContext);\n          parentContext.processed = true;\n          return context;\n        }\n\n        break;\n\n      case \"test\":\n        if (!context.processed) {\n          context.trueForkContext.clear();\n          context.trueForkContext.add(headSegments);\n        } else {\n          context.falseForkContext.clear();\n          context.falseForkContext.add(headSegments);\n        }\n\n        break;\n\n      case \"loop\":\n        return context;\n\n      default:\n        throw new Error(\"unreachable\");\n    }\n\n    const prevForkContext = context.trueForkContext;\n    prevForkContext.addAll(context.falseForkContext);\n    forkContext.replaceHead(prevForkContext.makeNext(0, -1));\n    return context;\n  }\n\n  makeLogicalRight() {\n    const context = this.choiceContext;\n    const forkContext = this.forkContext;\n\n    if (context.processed) {\n      let prevForkContext;\n\n      switch (context.kind) {\n        case \"&&\":\n          prevForkContext = context.trueForkContext;\n          break;\n\n        case \"||\":\n          prevForkContext = context.falseForkContext;\n          break;\n\n        case \"??\":\n          prevForkContext = context.qqForkContext;\n          break;\n\n        default:\n          throw new Error(\"unreachable\");\n      }\n\n      forkContext.replaceHead(prevForkContext.makeNext(0, -1));\n      prevForkContext.clear();\n      context.processed = false;\n    } else {\n      switch (context.kind) {\n        case \"&&\":\n          context.falseForkContext.add(forkContext.head);\n          break;\n\n        case \"||\":\n          context.trueForkContext.add(forkContext.head);\n          break;\n\n        case \"??\":\n          context.trueForkContext.add(forkContext.head);\n          context.falseForkContext.add(forkContext.head);\n          break;\n\n        default:\n          throw new Error(\"unreachable\");\n      }\n\n      forkContext.replaceHead(forkContext.makeNext(-1, -1));\n    }\n  }\n\n  makeIfConsequent() {\n    const context = this.choiceContext;\n    const forkContext = this.forkContext;\n\n    if (!context.processed) {\n      context.trueForkContext.add(forkContext.head);\n      context.falseForkContext.add(forkContext.head);\n      context.qqForkContext.add(forkContext.head);\n    }\n\n    context.processed = false;\n    forkContext.replaceHead(context.trueForkContext.makeNext(0, -1));\n  }\n\n  makeIfAlternate() {\n    const context = this.choiceContext;\n    const forkContext = this.forkContext;\n    context.trueForkContext.clear();\n    context.trueForkContext.add(forkContext.head);\n    context.processed = true;\n    forkContext.replaceHead(context.falseForkContext.makeNext(0, -1));\n  }\n\n  pushChainContext() {\n    this.chainContext = {\n      upper: this.chainContext,\n      countChoiceContexts: 0\n    };\n  }\n\n  popChainContext() {\n    const context = this.chainContext;\n    this.chainContext = context.upper;\n\n    for (let i = context.countChoiceContexts; i > 0; --i) {\n      this.popChoiceContext();\n    }\n  }\n\n  makeOptionalNode() {\n    if (this.chainContext) {\n      this.chainContext.countChoiceContexts += 1;\n      this.pushChoiceContext(\"??\", false);\n    }\n  }\n\n  makeOptionalRight() {\n    if (this.chainContext) {\n      this.makeLogicalRight();\n    }\n  }\n\n  pushSwitchContext(hasCase, label) {\n    this.switchContext = {\n      upper: this.switchContext,\n      hasCase,\n      defaultSegments: null,\n      defaultBodySegments: null,\n      foundDefault: false,\n      lastIsDefault: false,\n      countForks: 0\n    };\n    this.pushBreakContext(true, label);\n  }\n\n  popSwitchContext() {\n    const context = this.switchContext;\n    this.switchContext = context.upper;\n    const forkContext = this.forkContext;\n    const brokenForkContext = this.popBreakContext().brokenForkContext;\n\n    if (context.countForks === 0) {\n      if (!brokenForkContext.empty) {\n        brokenForkContext.add(forkContext.makeNext(-1, -1));\n        forkContext.replaceHead(brokenForkContext.makeNext(0, -1));\n      }\n\n      return;\n    }\n\n    const lastSegments = forkContext.head;\n    this.forkBypassPath();\n    const lastCaseSegments = forkContext.head;\n    brokenForkContext.add(lastSegments);\n\n    if (!context.lastIsDefault) {\n      if (context.defaultBodySegments) {\n        removeConnection(context.defaultSegments, context.defaultBodySegments);\n        makeLooped(this, lastCaseSegments, context.defaultBodySegments);\n      } else {\n        brokenForkContext.add(lastCaseSegments);\n      }\n    }\n\n    for (let i = 0; i < context.countForks; ++i) {\n      this.forkContext = this.forkContext.upper;\n    }\n\n    this.forkContext.replaceHead(brokenForkContext.makeNext(0, -1));\n  }\n\n  makeSwitchCaseBody(isEmpty, isDefault) {\n    const context = this.switchContext;\n\n    if (!context.hasCase) {\n      return;\n    }\n\n    const parentForkContext = this.forkContext;\n    const forkContext = this.pushForkContext();\n    forkContext.add(parentForkContext.makeNext(0, -1));\n\n    if (isDefault) {\n      context.defaultSegments = parentForkContext.head;\n\n      if (isEmpty) {\n        context.foundDefault = true;\n      } else {\n        context.defaultBodySegments = forkContext.head;\n      }\n    } else {\n      if (!isEmpty && context.foundDefault) {\n        context.foundDefault = false;\n        context.defaultBodySegments = forkContext.head;\n      }\n    }\n\n    context.lastIsDefault = isDefault;\n    context.countForks += 1;\n  }\n\n  pushTryContext(hasFinalizer) {\n    this.tryContext = {\n      upper: this.tryContext,\n      position: \"try\",\n      hasFinalizer,\n      returnedForkContext: hasFinalizer ? forkContext.newEmpty(this.forkContext) : null,\n      thrownForkContext: forkContext.newEmpty(this.forkContext),\n      lastOfTryIsReachable: false,\n      lastOfCatchIsReachable: false\n    };\n  }\n\n  popTryContext() {\n    const context = this.tryContext;\n    this.tryContext = context.upper;\n\n    if (context.position === \"catch\") {\n      this.popForkContext();\n      return;\n    }\n\n    const returned = context.returnedForkContext;\n    const thrown = context.thrownForkContext;\n\n    if (returned.empty && thrown.empty) {\n      return;\n    }\n\n    const headSegments = this.forkContext.head;\n    this.forkContext = this.forkContext.upper;\n    const normalSegments = headSegments.slice(0, headSegments.length / 2 | 0);\n    const leavingSegments = headSegments.slice(headSegments.length / 2 | 0);\n\n    if (!returned.empty) {\n      getReturnContext(this).returnedForkContext.add(leavingSegments);\n    }\n\n    if (!thrown.empty) {\n      getThrowContext(this).thrownForkContext.add(leavingSegments);\n    }\n\n    this.forkContext.replaceHead(normalSegments);\n\n    if (!context.lastOfTryIsReachable && !context.lastOfCatchIsReachable) {\n      this.forkContext.makeUnreachable();\n    }\n  }\n\n  makeCatchBlock() {\n    const context = this.tryContext;\n    const forkContext$1 = this.forkContext;\n    const thrown = context.thrownForkContext;\n    context.position = \"catch\";\n    context.thrownForkContext = forkContext.newEmpty(forkContext$1);\n    context.lastOfTryIsReachable = forkContext$1.reachable;\n    thrown.add(forkContext$1.head);\n    const thrownSegments = thrown.makeNext(0, -1);\n    this.pushForkContext();\n    this.forkBypassPath();\n    this.forkContext.add(thrownSegments);\n  }\n\n  makeFinallyBlock() {\n    const context = this.tryContext;\n    let forkContext = this.forkContext;\n    const returned = context.returnedForkContext;\n    const thrown = context.thrownForkContext;\n    const headOfLeavingSegments = forkContext.head;\n\n    if (context.position === \"catch\") {\n      this.popForkContext();\n      forkContext = this.forkContext;\n      context.lastOfCatchIsReachable = forkContext.reachable;\n    } else {\n      context.lastOfTryIsReachable = forkContext.reachable;\n    }\n\n    context.position = \"finally\";\n\n    if (returned.empty && thrown.empty) {\n      return;\n    }\n\n    const segments = forkContext.makeNext(-1, -1);\n\n    for (let i = 0; i < forkContext.count; ++i) {\n      const prevSegsOfLeavingSegment = [headOfLeavingSegments[i]];\n\n      for (let j = 0; j < returned.segmentsList.length; ++j) {\n        prevSegsOfLeavingSegment.push(returned.segmentsList[j][i]);\n      }\n\n      for (let j = 0; j < thrown.segmentsList.length; ++j) {\n        prevSegsOfLeavingSegment.push(thrown.segmentsList[j][i]);\n      }\n\n      segments.push(codePathSegment.newNext(this.idGenerator.next(), prevSegsOfLeavingSegment));\n    }\n\n    this.pushForkContext(true);\n    this.forkContext.add(segments);\n  }\n\n  makeFirstThrowablePathInTryBlock() {\n    const forkContext = this.forkContext;\n\n    if (!forkContext.reachable) {\n      return;\n    }\n\n    const context = getThrowContext(this);\n\n    if (context === this || context.position !== \"try\" || !context.thrownForkContext.empty) {\n      return;\n    }\n\n    context.thrownForkContext.add(forkContext.head);\n    forkContext.replaceHead(forkContext.makeNext(-1, -1));\n  }\n\n  pushLoopContext(type, label) {\n    const forkContext$1 = this.forkContext;\n    const breakContext = this.pushBreakContext(true, label);\n\n    switch (type) {\n      case \"WhileStatement\":\n        this.pushChoiceContext(\"loop\", false);\n        this.loopContext = {\n          upper: this.loopContext,\n          type,\n          label,\n          test: void 0,\n          continueDestSegments: null,\n          brokenForkContext: breakContext.brokenForkContext\n        };\n        break;\n\n      case \"DoWhileStatement\":\n        this.pushChoiceContext(\"loop\", false);\n        this.loopContext = {\n          upper: this.loopContext,\n          type,\n          label,\n          test: void 0,\n          entrySegments: null,\n          continueForkContext: forkContext.newEmpty(forkContext$1),\n          brokenForkContext: breakContext.brokenForkContext\n        };\n        break;\n\n      case \"ForStatement\":\n        this.pushChoiceContext(\"loop\", false);\n        this.loopContext = {\n          upper: this.loopContext,\n          type,\n          label,\n          test: void 0,\n          endOfInitSegments: null,\n          testSegments: null,\n          endOfTestSegments: null,\n          updateSegments: null,\n          endOfUpdateSegments: null,\n          continueDestSegments: null,\n          brokenForkContext: breakContext.brokenForkContext\n        };\n        break;\n\n      case \"ForInStatement\":\n      case \"ForOfStatement\":\n        this.loopContext = {\n          upper: this.loopContext,\n          type,\n          label,\n          prevSegments: null,\n          leftSegments: null,\n          endOfLeftSegments: null,\n          continueDestSegments: null,\n          brokenForkContext: breakContext.brokenForkContext\n        };\n        break;\n\n      default:\n        throw new Error(`unknown type: \"${type}\"`);\n    }\n  }\n\n  popLoopContext() {\n    const context = this.loopContext;\n    this.loopContext = context.upper;\n    const forkContext = this.forkContext;\n    const brokenForkContext = this.popBreakContext().brokenForkContext;\n\n    switch (context.type) {\n      case \"WhileStatement\":\n      case \"ForStatement\":\n        this.popChoiceContext();\n        makeLooped(this, forkContext.head, context.continueDestSegments);\n        break;\n\n      case \"DoWhileStatement\":\n        {\n          const choiceContext = this.popChoiceContext();\n\n          if (!choiceContext.processed) {\n            choiceContext.trueForkContext.add(forkContext.head);\n            choiceContext.falseForkContext.add(forkContext.head);\n          }\n\n          if (context.test !== true) {\n            brokenForkContext.addAll(choiceContext.falseForkContext);\n          }\n\n          const segmentsList = choiceContext.trueForkContext.segmentsList;\n\n          for (let i = 0; i < segmentsList.length; ++i) {\n            makeLooped(this, segmentsList[i], context.entrySegments);\n          }\n\n          break;\n        }\n\n      case \"ForInStatement\":\n      case \"ForOfStatement\":\n        brokenForkContext.add(forkContext.head);\n        makeLooped(this, forkContext.head, context.leftSegments);\n        break;\n\n      default:\n        throw new Error(\"unreachable\");\n    }\n\n    if (brokenForkContext.empty) {\n      forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));\n    } else {\n      forkContext.replaceHead(brokenForkContext.makeNext(0, -1));\n    }\n  }\n\n  makeWhileTest(test) {\n    const context = this.loopContext;\n    const forkContext = this.forkContext;\n    const testSegments = forkContext.makeNext(0, -1);\n    context.test = test;\n    context.continueDestSegments = testSegments;\n    forkContext.replaceHead(testSegments);\n  }\n\n  makeWhileBody() {\n    const context = this.loopContext;\n    const choiceContext = this.choiceContext;\n    const forkContext = this.forkContext;\n\n    if (!choiceContext.processed) {\n      choiceContext.trueForkContext.add(forkContext.head);\n      choiceContext.falseForkContext.add(forkContext.head);\n    }\n\n    if (context.test !== true) {\n      context.brokenForkContext.addAll(choiceContext.falseForkContext);\n    }\n\n    forkContext.replaceHead(choiceContext.trueForkContext.makeNext(0, -1));\n  }\n\n  makeDoWhileBody() {\n    const context = this.loopContext;\n    const forkContext = this.forkContext;\n    const bodySegments = forkContext.makeNext(-1, -1);\n    context.entrySegments = bodySegments;\n    forkContext.replaceHead(bodySegments);\n  }\n\n  makeDoWhileTest(test) {\n    const context = this.loopContext;\n    const forkContext = this.forkContext;\n    context.test = test;\n\n    if (!context.continueForkContext.empty) {\n      context.continueForkContext.add(forkContext.head);\n      const testSegments = context.continueForkContext.makeNext(0, -1);\n      forkContext.replaceHead(testSegments);\n    }\n  }\n\n  makeForTest(test) {\n    const context = this.loopContext;\n    const forkContext = this.forkContext;\n    const endOfInitSegments = forkContext.head;\n    const testSegments = forkContext.makeNext(-1, -1);\n    context.test = test;\n    context.endOfInitSegments = endOfInitSegments;\n    context.continueDestSegments = context.testSegments = testSegments;\n    forkContext.replaceHead(testSegments);\n  }\n\n  makeForUpdate() {\n    const context = this.loopContext;\n    const choiceContext = this.choiceContext;\n    const forkContext = this.forkContext;\n\n    if (context.testSegments) {\n      finalizeTestSegmentsOfFor(context, choiceContext, forkContext.head);\n    } else {\n      context.endOfInitSegments = forkContext.head;\n    }\n\n    const updateSegments = forkContext.makeDisconnected(-1, -1);\n    context.continueDestSegments = context.updateSegments = updateSegments;\n    forkContext.replaceHead(updateSegments);\n  }\n\n  makeForBody() {\n    const context = this.loopContext;\n    const choiceContext = this.choiceContext;\n    const forkContext$1 = this.forkContext;\n\n    if (context.updateSegments) {\n      context.endOfUpdateSegments = forkContext$1.head;\n\n      if (context.testSegments) {\n        makeLooped(this, context.endOfUpdateSegments, context.testSegments);\n      }\n    } else if (context.testSegments) {\n      finalizeTestSegmentsOfFor(context, choiceContext, forkContext$1.head);\n    } else {\n      context.endOfInitSegments = forkContext$1.head;\n    }\n\n    let bodySegments = context.endOfTestSegments;\n\n    if (!bodySegments) {\n      const prevForkContext = forkContext.newEmpty(forkContext$1);\n      prevForkContext.add(context.endOfInitSegments);\n\n      if (context.endOfUpdateSegments) {\n        prevForkContext.add(context.endOfUpdateSegments);\n      }\n\n      bodySegments = prevForkContext.makeNext(0, -1);\n    }\n\n    context.continueDestSegments = context.continueDestSegments || bodySegments;\n    forkContext$1.replaceHead(bodySegments);\n  }\n\n  makeForInOfLeft() {\n    const context = this.loopContext;\n    const forkContext = this.forkContext;\n    const leftSegments = forkContext.makeDisconnected(-1, -1);\n    context.prevSegments = forkContext.head;\n    context.leftSegments = context.continueDestSegments = leftSegments;\n    forkContext.replaceHead(leftSegments);\n  }\n\n  makeForInOfRight() {\n    const context = this.loopContext;\n    const forkContext$1 = this.forkContext;\n    const temp = forkContext.newEmpty(forkContext$1);\n    temp.add(context.prevSegments);\n    const rightSegments = temp.makeNext(-1, -1);\n    context.endOfLeftSegments = forkContext$1.head;\n    forkContext$1.replaceHead(rightSegments);\n  }\n\n  makeForInOfBody() {\n    const context = this.loopContext;\n    const forkContext$1 = this.forkContext;\n    const temp = forkContext.newEmpty(forkContext$1);\n    temp.add(context.endOfLeftSegments);\n    const bodySegments = temp.makeNext(-1, -1);\n    makeLooped(this, forkContext$1.head, context.leftSegments);\n    context.brokenForkContext.add(forkContext$1.head);\n    forkContext$1.replaceHead(bodySegments);\n  }\n\n  pushBreakContext(breakable, label) {\n    this.breakContext = {\n      upper: this.breakContext,\n      breakable,\n      label,\n      brokenForkContext: forkContext.newEmpty(this.forkContext)\n    };\n    return this.breakContext;\n  }\n\n  popBreakContext() {\n    const context = this.breakContext;\n    const forkContext = this.forkContext;\n    this.breakContext = context.upper;\n\n    if (!context.breakable) {\n      const brokenForkContext = context.brokenForkContext;\n\n      if (!brokenForkContext.empty) {\n        brokenForkContext.add(forkContext.head);\n        forkContext.replaceHead(brokenForkContext.makeNext(0, -1));\n      }\n    }\n\n    return context;\n  }\n\n  makeBreak(label) {\n    const forkContext = this.forkContext;\n\n    if (!forkContext.reachable) {\n      return;\n    }\n\n    const context = getBreakContext(this, label);\n\n    if (context) {\n      context.brokenForkContext.add(forkContext.head);\n    }\n\n    forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));\n  }\n\n  makeContinue(label) {\n    const forkContext = this.forkContext;\n\n    if (!forkContext.reachable) {\n      return;\n    }\n\n    const context = getContinueContext(this, label);\n\n    if (context) {\n      if (context.continueDestSegments) {\n        makeLooped(this, forkContext.head, context.continueDestSegments);\n\n        if (context.type === \"ForInStatement\" || context.type === \"ForOfStatement\") {\n          context.brokenForkContext.add(forkContext.head);\n        }\n      } else {\n        context.continueForkContext.add(forkContext.head);\n      }\n    }\n\n    forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));\n  }\n\n  makeReturn() {\n    const forkContext = this.forkContext;\n\n    if (forkContext.reachable) {\n      getReturnContext(this).returnedForkContext.add(forkContext.head);\n      forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));\n    }\n  }\n\n  makeThrow() {\n    const forkContext = this.forkContext;\n\n    if (forkContext.reachable) {\n      getThrowContext(this).thrownForkContext.add(forkContext.head);\n      forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));\n    }\n  }\n\n  makeFinal() {\n    const segments = this.currentSegments;\n\n    if (segments.length > 0 && segments[0].reachable) {\n      this.returnedForkContext.add(segments);\n    }\n  }\n\n}\n\nvar codePathState = CodePathState;\n\nclass IdGenerator {\n  constructor(prefix) {\n    this.prefix = String(prefix);\n    this.n = 0;\n  }\n\n  next() {\n    this.n = 1 + this.n | 0;\n\n    if (this.n < 0) {\n      this.n = 1;\n    }\n\n    return this.prefix + this.n;\n  }\n\n}\n\nvar idGenerator = IdGenerator;\n\nclass CodePath {\n  constructor(id, upper, onLooped) {\n    this.id = id;\n    this.upper = upper;\n    this.childCodePaths = [];\n    Object.defineProperty(this, \"internal\", {\n      value: new codePathState(new idGenerator(`${id}_`), onLooped)\n    });\n\n    if (upper) {\n      upper.childCodePaths.push(this);\n    }\n  }\n\n  static getState(codePath) {\n    return codePath.internal;\n  }\n\n  get initialSegment() {\n    return this.internal.initialSegment;\n  }\n\n  get finalSegments() {\n    return this.internal.finalSegments;\n  }\n\n  get returnedSegments() {\n    return this.internal.returnedForkContext;\n  }\n\n  get thrownSegments() {\n    return this.internal.thrownForkContext;\n  }\n\n  get currentSegments() {\n    return this.internal.currentSegments;\n  }\n\n  traverseSegments(options, callback) {\n    let resolvedOptions;\n    let resolvedCallback;\n\n    if (typeof options === \"function\") {\n      resolvedCallback = options;\n      resolvedOptions = {};\n    } else {\n      resolvedOptions = options || {};\n      resolvedCallback = callback;\n    }\n\n    const startSegment = resolvedOptions.first || this.internal.initialSegment;\n    const lastSegment = resolvedOptions.last;\n    let item = null;\n    let index = 0;\n    let end = 0;\n    let segment = null;\n    const visited = Object.create(null);\n    const stack = [[startSegment, 0]];\n    let skippedSegment = null;\n    let broken = false;\n    const controller = {\n      skip() {\n        if (stack.length <= 1) {\n          broken = true;\n        } else {\n          skippedSegment = stack[stack.length - 2][0];\n        }\n      },\n\n      break() {\n        broken = true;\n      }\n\n    };\n\n    function isVisited(prevSegment) {\n      return visited[prevSegment.id] || segment.isLoopedPrevSegment(prevSegment);\n    }\n\n    while (stack.length > 0) {\n      item = stack[stack.length - 1];\n      segment = item[0];\n      index = item[1];\n\n      if (index === 0) {\n        if (visited[segment.id]) {\n          stack.pop();\n          continue;\n        }\n\n        if (segment !== startSegment && segment.prevSegments.length > 0 && !segment.prevSegments.every(isVisited)) {\n          stack.pop();\n          continue;\n        }\n\n        if (skippedSegment && segment.prevSegments.indexOf(skippedSegment) !== -1) {\n          skippedSegment = null;\n        }\n\n        visited[segment.id] = true;\n\n        if (!skippedSegment) {\n          resolvedCallback.call(this, segment, controller);\n\n          if (segment === lastSegment) {\n            controller.skip();\n          }\n\n          if (broken) {\n            break;\n          }\n        }\n      }\n\n      end = segment.nextSegments.length - 1;\n\n      if (index < end) {\n        item[1] += 1;\n        stack.push([segment.nextSegments[index], 0]);\n      } else if (index === end) {\n        item[0] = segment.nextSegments[index];\n        item[1] = 0;\n      } else {\n        stack.pop();\n      }\n    }\n  }\n\n}\n\nvar codePath = CodePath;\nconst {\n  breakableTypePattern\n} = _commonjsHelpers.astUtils;\n\nfunction isCaseNode(node) {\n  return Boolean(node.test);\n}\n\nfunction isHandledLogicalOperator(operator) {\n  return operator === \"&&\" || operator === \"||\" || operator === \"??\";\n}\n\nfunction isLogicalAssignmentOperator(operator) {\n  return operator === \"&&=\" || operator === \"||=\" || operator === \"??=\";\n}\n\nfunction getLabel(node) {\n  if (node.parent.type === \"LabeledStatement\") {\n    return node.parent.label.name;\n  }\n\n  return null;\n}\n\nfunction isForkingByTrueOrFalse(node) {\n  const parent = node.parent;\n\n  switch (parent.type) {\n    case \"ConditionalExpression\":\n    case \"IfStatement\":\n    case \"WhileStatement\":\n    case \"DoWhileStatement\":\n    case \"ForStatement\":\n      return parent.test === node;\n\n    case \"LogicalExpression\":\n      return isHandledLogicalOperator(parent.operator);\n\n    case \"AssignmentExpression\":\n      return isLogicalAssignmentOperator(parent.operator);\n\n    default:\n      return false;\n  }\n}\n\nfunction getBooleanValueIfSimpleConstant(node) {\n  if (node.type === \"Literal\") {\n    return Boolean(node.value);\n  }\n\n  return void 0;\n}\n\nfunction isIdentifierReference(node) {\n  const parent = node.parent;\n\n  switch (parent.type) {\n    case \"LabeledStatement\":\n    case \"BreakStatement\":\n    case \"ContinueStatement\":\n    case \"ArrayPattern\":\n    case \"RestElement\":\n    case \"ImportSpecifier\":\n    case \"ImportDefaultSpecifier\":\n    case \"ImportNamespaceSpecifier\":\n    case \"CatchClause\":\n      return false;\n\n    case \"FunctionDeclaration\":\n    case \"FunctionExpression\":\n    case \"ArrowFunctionExpression\":\n    case \"ClassDeclaration\":\n    case \"ClassExpression\":\n    case \"VariableDeclarator\":\n      return parent.id !== node;\n\n    case \"Property\":\n    case \"MethodDefinition\":\n      return parent.key !== node || parent.computed || parent.shorthand;\n\n    case \"AssignmentPattern\":\n      return parent.key !== node;\n\n    default:\n      return true;\n  }\n}\n\nfunction forwardCurrentToHead(analyzer, node) {\n  const codePath$1 = analyzer.codePath;\n  const state = codePath.getState(codePath$1);\n  const currentSegments = state.currentSegments;\n  const headSegments = state.headSegments;\n  const end = Math.max(currentSegments.length, headSegments.length);\n  let i, currentSegment, headSegment;\n\n  for (i = 0; i < end; ++i) {\n    currentSegment = currentSegments[i];\n    headSegment = headSegments[i];\n\n    if (currentSegment !== headSegment && currentSegment) {\n      debugHelpers.dump(`onCodePathSegmentEnd ${currentSegment.id}`);\n\n      if (currentSegment.reachable) {\n        analyzer.emitter.emit(\"onCodePathSegmentEnd\", currentSegment, node);\n      }\n    }\n  }\n\n  state.currentSegments = headSegments;\n\n  for (i = 0; i < end; ++i) {\n    currentSegment = currentSegments[i];\n    headSegment = headSegments[i];\n\n    if (currentSegment !== headSegment && headSegment) {\n      debugHelpers.dump(`onCodePathSegmentStart ${headSegment.id}`);\n      codePathSegment.markUsed(headSegment);\n\n      if (headSegment.reachable) {\n        analyzer.emitter.emit(\"onCodePathSegmentStart\", headSegment, node);\n      }\n    }\n  }\n}\n\nfunction leaveFromCurrentSegment(analyzer, node) {\n  const state = codePath.getState(analyzer.codePath);\n  const currentSegments = state.currentSegments;\n\n  for (let i = 0; i < currentSegments.length; ++i) {\n    const currentSegment = currentSegments[i];\n    debugHelpers.dump(`onCodePathSegmentEnd ${currentSegment.id}`);\n\n    if (currentSegment.reachable) {\n      analyzer.emitter.emit(\"onCodePathSegmentEnd\", currentSegment, node);\n    }\n  }\n\n  state.currentSegments = [];\n}\n\nfunction preprocess(analyzer, node) {\n  const codePath$1 = analyzer.codePath;\n  const state = codePath.getState(codePath$1);\n  const parent = node.parent;\n\n  switch (parent.type) {\n    case \"CallExpression\":\n      if (parent.optional === true && parent.arguments.length >= 1 && parent.arguments[0] === node) {\n        state.makeOptionalRight();\n      }\n\n      break;\n\n    case \"MemberExpression\":\n      if (parent.optional === true && parent.property === node) {\n        state.makeOptionalRight();\n      }\n\n      break;\n\n    case \"LogicalExpression\":\n      if (parent.right === node && isHandledLogicalOperator(parent.operator)) {\n        state.makeLogicalRight();\n      }\n\n      break;\n\n    case \"AssignmentExpression\":\n      if (parent.right === node && isLogicalAssignmentOperator(parent.operator)) {\n        state.makeLogicalRight();\n      }\n\n      break;\n\n    case \"ConditionalExpression\":\n    case \"IfStatement\":\n      if (parent.consequent === node) {\n        state.makeIfConsequent();\n      } else if (parent.alternate === node) {\n        state.makeIfAlternate();\n      }\n\n      break;\n\n    case \"SwitchCase\":\n      if (parent.consequent[0] === node) {\n        state.makeSwitchCaseBody(false, !parent.test);\n      }\n\n      break;\n\n    case \"TryStatement\":\n      if (parent.handler === node) {\n        state.makeCatchBlock();\n      } else if (parent.finalizer === node) {\n        state.makeFinallyBlock();\n      }\n\n      break;\n\n    case \"WhileStatement\":\n      if (parent.test === node) {\n        state.makeWhileTest(getBooleanValueIfSimpleConstant(node));\n      } else {\n        assert__default['default'](parent.body === node);\n        state.makeWhileBody();\n      }\n\n      break;\n\n    case \"DoWhileStatement\":\n      if (parent.body === node) {\n        state.makeDoWhileBody();\n      } else {\n        assert__default['default'](parent.test === node);\n        state.makeDoWhileTest(getBooleanValueIfSimpleConstant(node));\n      }\n\n      break;\n\n    case \"ForStatement\":\n      if (parent.test === node) {\n        state.makeForTest(getBooleanValueIfSimpleConstant(node));\n      } else if (parent.update === node) {\n        state.makeForUpdate();\n      } else if (parent.body === node) {\n        state.makeForBody();\n      }\n\n      break;\n\n    case \"ForInStatement\":\n    case \"ForOfStatement\":\n      if (parent.left === node) {\n        state.makeForInOfLeft();\n      } else if (parent.right === node) {\n        state.makeForInOfRight();\n      } else {\n        assert__default['default'](parent.body === node);\n        state.makeForInOfBody();\n      }\n\n      break;\n\n    case \"AssignmentPattern\":\n      if (parent.right === node) {\n        state.pushForkContext();\n        state.forkBypassPath();\n        state.forkPath();\n      }\n\n      break;\n  }\n}\n\nfunction processCodePathToEnter(analyzer, node) {\n  let codePath$1 = analyzer.codePath;\n  let state = codePath$1 && codePath.getState(codePath$1);\n  const parent = node.parent;\n\n  switch (node.type) {\n    case \"Program\":\n    case \"FunctionDeclaration\":\n    case \"FunctionExpression\":\n    case \"ArrowFunctionExpression\":\n      if (codePath$1) {\n        forwardCurrentToHead(analyzer, node);\n        debugHelpers.dumpState(node, state, false);\n      }\n\n      codePath$1 = analyzer.codePath = new codePath(analyzer.idGenerator.next(), codePath$1, analyzer.onLooped);\n      state = codePath.getState(codePath$1);\n      debugHelpers.dump(`onCodePathStart ${codePath$1.id}`);\n      analyzer.emitter.emit(\"onCodePathStart\", codePath$1, node);\n      break;\n\n    case \"ChainExpression\":\n      state.pushChainContext();\n      break;\n\n    case \"CallExpression\":\n      if (node.optional === true) {\n        state.makeOptionalNode();\n      }\n\n      break;\n\n    case \"MemberExpression\":\n      if (node.optional === true) {\n        state.makeOptionalNode();\n      }\n\n      break;\n\n    case \"LogicalExpression\":\n      if (isHandledLogicalOperator(node.operator)) {\n        state.pushChoiceContext(node.operator, isForkingByTrueOrFalse(node));\n      }\n\n      break;\n\n    case \"AssignmentExpression\":\n      if (isLogicalAssignmentOperator(node.operator)) {\n        state.pushChoiceContext(node.operator.slice(0, -1), isForkingByTrueOrFalse(node));\n      }\n\n      break;\n\n    case \"ConditionalExpression\":\n    case \"IfStatement\":\n      state.pushChoiceContext(\"test\", false);\n      break;\n\n    case \"SwitchStatement\":\n      state.pushSwitchContext(node.cases.some(isCaseNode), getLabel(node));\n      break;\n\n    case \"TryStatement\":\n      state.pushTryContext(Boolean(node.finalizer));\n      break;\n\n    case \"SwitchCase\":\n      if (parent.discriminant !== node && parent.cases[0] !== node) {\n        state.forkPath();\n      }\n\n      break;\n\n    case \"WhileStatement\":\n    case \"DoWhileStatement\":\n    case \"ForStatement\":\n    case \"ForInStatement\":\n    case \"ForOfStatement\":\n      state.pushLoopContext(node.type, getLabel(node));\n      break;\n\n    case \"LabeledStatement\":\n      if (!breakableTypePattern.test(node.body.type)) {\n        state.pushBreakContext(false, node.label.name);\n      }\n\n      break;\n  }\n\n  forwardCurrentToHead(analyzer, node);\n  debugHelpers.dumpState(node, state, false);\n}\n\nfunction processCodePathToExit(analyzer, node) {\n  const codePath$1 = analyzer.codePath;\n  const state = codePath.getState(codePath$1);\n  let dontForward = false;\n\n  switch (node.type) {\n    case \"ChainExpression\":\n      state.popChainContext();\n      break;\n\n    case \"IfStatement\":\n    case \"ConditionalExpression\":\n      state.popChoiceContext();\n      break;\n\n    case \"LogicalExpression\":\n      if (isHandledLogicalOperator(node.operator)) {\n        state.popChoiceContext();\n      }\n\n      break;\n\n    case \"AssignmentExpression\":\n      if (isLogicalAssignmentOperator(node.operator)) {\n        state.popChoiceContext();\n      }\n\n      break;\n\n    case \"SwitchStatement\":\n      state.popSwitchContext();\n      break;\n\n    case \"SwitchCase\":\n      if (node.consequent.length === 0) {\n        state.makeSwitchCaseBody(true, !node.test);\n      }\n\n      if (state.forkContext.reachable) {\n        dontForward = true;\n      }\n\n      break;\n\n    case \"TryStatement\":\n      state.popTryContext();\n      break;\n\n    case \"BreakStatement\":\n      forwardCurrentToHead(analyzer, node);\n      state.makeBreak(node.label && node.label.name);\n      dontForward = true;\n      break;\n\n    case \"ContinueStatement\":\n      forwardCurrentToHead(analyzer, node);\n      state.makeContinue(node.label && node.label.name);\n      dontForward = true;\n      break;\n\n    case \"ReturnStatement\":\n      forwardCurrentToHead(analyzer, node);\n      state.makeReturn();\n      dontForward = true;\n      break;\n\n    case \"ThrowStatement\":\n      forwardCurrentToHead(analyzer, node);\n      state.makeThrow();\n      dontForward = true;\n      break;\n\n    case \"Identifier\":\n      if (isIdentifierReference(node)) {\n        state.makeFirstThrowablePathInTryBlock();\n        dontForward = true;\n      }\n\n      break;\n\n    case \"CallExpression\":\n    case \"ImportExpression\":\n    case \"MemberExpression\":\n    case \"NewExpression\":\n    case \"YieldExpression\":\n      state.makeFirstThrowablePathInTryBlock();\n      break;\n\n    case \"WhileStatement\":\n    case \"DoWhileStatement\":\n    case \"ForStatement\":\n    case \"ForInStatement\":\n    case \"ForOfStatement\":\n      state.popLoopContext();\n      break;\n\n    case \"AssignmentPattern\":\n      state.popForkContext();\n      break;\n\n    case \"LabeledStatement\":\n      if (!breakableTypePattern.test(node.body.type)) {\n        state.popBreakContext();\n      }\n\n      break;\n  }\n\n  if (!dontForward) {\n    forwardCurrentToHead(analyzer, node);\n  }\n\n  debugHelpers.dumpState(node, state, true);\n}\n\nfunction postprocess(analyzer, node) {\n  switch (node.type) {\n    case \"Program\":\n    case \"FunctionDeclaration\":\n    case \"FunctionExpression\":\n    case \"ArrowFunctionExpression\":\n      {\n        let codePath$1 = analyzer.codePath;\n        codePath.getState(codePath$1).makeFinal();\n        leaveFromCurrentSegment(analyzer, node);\n        debugHelpers.dump(`onCodePathEnd ${codePath$1.id}`);\n        analyzer.emitter.emit(\"onCodePathEnd\", codePath$1, node);\n        debugHelpers.dumpDot(codePath$1);\n        codePath$1 = analyzer.codePath = analyzer.codePath.upper;\n\n        if (codePath$1) {\n          debugHelpers.dumpState(node, codePath.getState(codePath$1), true);\n        }\n\n        break;\n      }\n\n    case \"CallExpression\":\n      if (node.optional === true && node.arguments.length === 0) {\n        codePath.getState(analyzer.codePath).makeOptionalRight();\n      }\n\n      break;\n  }\n}\n\nclass CodePathAnalyzer {\n  constructor(eventGenerator) {\n    this.original = eventGenerator;\n    this.emitter = eventGenerator.emitter;\n    this.codePath = null;\n    this.idGenerator = new idGenerator(\"s\");\n    this.currentNode = null;\n    this.onLooped = this.onLooped.bind(this);\n  }\n\n  enterNode(node) {\n    this.currentNode = node;\n\n    if (node.parent) {\n      preprocess(this, node);\n    }\n\n    processCodePathToEnter(this, node);\n    this.original.enterNode(node);\n    this.currentNode = null;\n  }\n\n  leaveNode(node) {\n    this.currentNode = node;\n    processCodePathToExit(this, node);\n    this.original.leaveNode(node);\n    postprocess(this, node);\n    this.currentNode = null;\n  }\n\n  onLooped(fromSegment, toSegment) {\n    if (fromSegment.reachable && toSegment.reachable) {\n      debugHelpers.dump(`onCodePathSegmentLoop ${fromSegment.id} -> ${toSegment.id}`);\n      this.emitter.emit(\"onCodePathSegmentLoop\", fromSegment, toSegment, this.currentNode);\n    }\n  }\n\n}\n\nvar codePathAnalyzer = CodePathAnalyzer;\n\nfunction compareLocations(itemA, itemB) {\n  return itemA.line - itemB.line || itemA.column - itemB.column;\n}\n\nfunction applyDirectives(options) {\n  const problems = [];\n  let nextDirectiveIndex = 0;\n  let currentGlobalDisableDirective = null;\n  const disabledRuleMap = new Map();\n  const enabledRules = new Set();\n  const usedDisableDirectives = new Set();\n\n  for (const problem of options.problems) {\n    while (nextDirectiveIndex < options.directives.length && compareLocations(options.directives[nextDirectiveIndex], problem) <= 0) {\n      const directive = options.directives[nextDirectiveIndex++];\n\n      switch (directive.type) {\n        case \"disable\":\n          if (directive.ruleId === null) {\n            currentGlobalDisableDirective = directive;\n            disabledRuleMap.clear();\n            enabledRules.clear();\n          } else if (currentGlobalDisableDirective) {\n            enabledRules.delete(directive.ruleId);\n            disabledRuleMap.set(directive.ruleId, directive);\n          } else {\n            disabledRuleMap.set(directive.ruleId, directive);\n          }\n\n          break;\n\n        case \"enable\":\n          if (directive.ruleId === null) {\n            currentGlobalDisableDirective = null;\n            disabledRuleMap.clear();\n          } else if (currentGlobalDisableDirective) {\n            enabledRules.add(directive.ruleId);\n            disabledRuleMap.delete(directive.ruleId);\n          } else {\n            disabledRuleMap.delete(directive.ruleId);\n          }\n\n          break;\n      }\n    }\n\n    if (disabledRuleMap.has(problem.ruleId)) {\n      usedDisableDirectives.add(disabledRuleMap.get(problem.ruleId));\n    } else if (currentGlobalDisableDirective && !enabledRules.has(problem.ruleId)) {\n      usedDisableDirectives.add(currentGlobalDisableDirective);\n    } else {\n      problems.push(problem);\n    }\n  }\n\n  const unusedDisableDirectives = options.directives.filter(directive => directive.type === \"disable\" && !usedDisableDirectives.has(directive)).map(directive => ({\n    ruleId: null,\n    message: directive.ruleId ? `Unused eslint-disable directive (no problems were reported from '${directive.ruleId}').` : \"Unused eslint-disable directive (no problems were reported).\",\n    line: directive.unprocessedDirective.line,\n    column: directive.unprocessedDirective.column,\n    severity: options.reportUnusedDisableDirectives === \"warn\" ? 1 : 2,\n    nodeType: null\n  }));\n  return {\n    problems,\n    unusedDisableDirectives\n  };\n}\n\nvar applyDisableDirectives = ({\n  directives,\n  problems,\n  reportUnusedDisableDirectives = \"off\"\n}) => {\n  const blockDirectives = directives.filter(directive => directive.type === \"disable\" || directive.type === \"enable\").map(directive => Object.assign({}, directive, {\n    unprocessedDirective: directive\n  })).sort(compareLocations);\n\n  const lineDirectives = function (array, fn) {\n    const mapped = array.map(fn);\n    const flattened = [].concat(...mapped);\n    return flattened;\n  }(directives, directive => {\n    switch (directive.type) {\n      case \"disable\":\n      case \"enable\":\n        return [];\n\n      case \"disable-line\":\n        return [{\n          type: \"disable\",\n          line: directive.line,\n          column: 1,\n          ruleId: directive.ruleId,\n          unprocessedDirective: directive\n        }, {\n          type: \"enable\",\n          line: directive.line + 1,\n          column: 0,\n          ruleId: directive.ruleId,\n          unprocessedDirective: directive\n        }];\n\n      case \"disable-next-line\":\n        return [{\n          type: \"disable\",\n          line: directive.line + 1,\n          column: 1,\n          ruleId: directive.ruleId,\n          unprocessedDirective: directive\n        }, {\n          type: \"enable\",\n          line: directive.line + 2,\n          column: 0,\n          ruleId: directive.ruleId,\n          unprocessedDirective: directive\n        }];\n\n      default:\n        throw new TypeError(`Unrecognized directive type '${directive.type}'`);\n    }\n  }).sort(compareLocations);\n\n  const blockDirectivesResult = applyDirectives({\n    problems,\n    directives: blockDirectives,\n    reportUnusedDisableDirectives\n  });\n  const lineDirectivesResult = applyDirectives({\n    problems: blockDirectivesResult.problems,\n    directives: lineDirectives,\n    reportUnusedDisableDirectives\n  });\n  return reportUnusedDisableDirectives !== \"off\" ? lineDirectivesResult.problems.concat(blockDirectivesResult.unusedDisableDirectives).concat(lineDirectivesResult.unusedDisableDirectives).sort(compareLocations) : lineDirectivesResult.problems;\n};\n\nconst debug$2 = debug__default['default'](\"eslint:config-comment-parser\");\nvar configCommentParser = class {\n  parseStringConfig(string, comment) {\n    debug$2(\"Parsing String config\");\n    const items = {};\n    const trimmedString = string.replace(/\\s*([:,])\\s*/gu, \"$1\");\n    trimmedString.split(/\\s|,+/u).forEach(name => {\n      if (!name) {\n        return;\n      }\n\n      const [key, value = null] = name.split(\":\");\n      items[key] = {\n        value,\n        comment\n      };\n    });\n    return items;\n  }\n\n  parseJsonConfig(string, location) {\n    debug$2(\"Parsing JSON config\");\n    let items = {};\n\n    try {\n      items = levn__default['default'].parse(\"Object\", string) || {};\n\n      if (configOps__default['default'].isEverySeverityValid(items)) {\n        return {\n          success: true,\n          config: items\n        };\n      }\n    } catch {\n      debug$2(\"Levn parsing failed; falling back to manual parsing.\");\n    }\n\n    items = {};\n    const normalizedString = string.replace(/([-a-zA-Z0-9/]+):/gu, \"\\\"$1\\\":\").replace(/(\\]|[0-9])\\s+(?=\")/u, \"$1,\");\n\n    try {\n      items = JSON.parse(`{${normalizedString}}`);\n    } catch (ex) {\n      debug$2(\"Manual parsing failed.\");\n      return {\n        success: false,\n        error: {\n          ruleId: null,\n          fatal: true,\n          severity: 2,\n          message: `Failed to parse JSON from '${normalizedString}': ${ex.message}`,\n          line: location.start.line,\n          column: location.start.column + 1\n        }\n      };\n    }\n\n    return {\n      success: true,\n      config: items\n    };\n  }\n\n  parseListConfig(string) {\n    debug$2(\"Parsing list config\");\n    const items = {};\n    string.replace(/\\s*,\\s*/gu, \",\").split(/,+/u).forEach(name => {\n      const trimmedName = name.trim();\n\n      if (trimmedName) {\n        items[trimmedName] = true;\n      }\n    });\n    return items;\n  }\n\n};\n\nfunction union(...arrays) {\n  return [...new Set([].concat(...arrays))];\n}\n\nfunction intersection(...arrays) {\n  if (arrays.length === 0) {\n    return [];\n  }\n\n  let result = [...new Set(arrays[0])];\n\n  for (const array of arrays.slice(1)) {\n    result = result.filter(x => array.includes(x));\n  }\n\n  return result;\n}\n\nfunction getPossibleTypes(parsedSelector) {\n  switch (parsedSelector.type) {\n    case \"identifier\":\n      return [parsedSelector.value];\n\n    case \"matches\":\n      {\n        const typesForComponents = parsedSelector.selectors.map(getPossibleTypes);\n\n        if (typesForComponents.every(Boolean)) {\n          return union(...typesForComponents);\n        }\n\n        return null;\n      }\n\n    case \"compound\":\n      {\n        const typesForComponents = parsedSelector.selectors.map(getPossibleTypes).filter(typesForComponent => typesForComponent);\n\n        if (!typesForComponents.length) {\n          return null;\n        }\n\n        return intersection(...typesForComponents);\n      }\n\n    case \"child\":\n    case \"descendant\":\n    case \"sibling\":\n    case \"adjacent\":\n      return getPossibleTypes(parsedSelector.right);\n\n    default:\n      return null;\n  }\n}\n\nfunction countClassAttributes(parsedSelector) {\n  switch (parsedSelector.type) {\n    case \"child\":\n    case \"descendant\":\n    case \"sibling\":\n    case \"adjacent\":\n      return countClassAttributes(parsedSelector.left) + countClassAttributes(parsedSelector.right);\n\n    case \"compound\":\n    case \"not\":\n    case \"matches\":\n      return parsedSelector.selectors.reduce((sum, childSelector) => sum + countClassAttributes(childSelector), 0);\n\n    case \"attribute\":\n    case \"field\":\n    case \"nth-child\":\n    case \"nth-last-child\":\n      return 1;\n\n    default:\n      return 0;\n  }\n}\n\nfunction countIdentifiers(parsedSelector) {\n  switch (parsedSelector.type) {\n    case \"child\":\n    case \"descendant\":\n    case \"sibling\":\n    case \"adjacent\":\n      return countIdentifiers(parsedSelector.left) + countIdentifiers(parsedSelector.right);\n\n    case \"compound\":\n    case \"not\":\n    case \"matches\":\n      return parsedSelector.selectors.reduce((sum, childSelector) => sum + countIdentifiers(childSelector), 0);\n\n    case \"identifier\":\n      return 1;\n\n    default:\n      return 0;\n  }\n}\n\nfunction compareSpecificity(selectorA, selectorB) {\n  return selectorA.attributeCount - selectorB.attributeCount || selectorA.identifierCount - selectorB.identifierCount || (selectorA.rawSelector <= selectorB.rawSelector ? -1 : 1);\n}\n\nfunction tryParseSelector(rawSelector) {\n  try {\n    return esquery__default['default'].parse(rawSelector.replace(/:exit$/u, \"\"));\n  } catch (err) {\n    if (err.location && err.location.start && typeof err.location.start.offset === \"number\") {\n      throw new SyntaxError(`Syntax error in selector \"${rawSelector}\" at position ${err.location.start.offset}: ${err.message}`);\n    }\n\n    throw err;\n  }\n}\n\nconst selectorCache = new Map();\n\nfunction parseSelector(rawSelector) {\n  if (selectorCache.has(rawSelector)) {\n    return selectorCache.get(rawSelector);\n  }\n\n  const parsedSelector = tryParseSelector(rawSelector);\n  const result = {\n    rawSelector,\n    isExit: rawSelector.endsWith(\":exit\"),\n    parsedSelector,\n    listenerTypes: getPossibleTypes(parsedSelector),\n    attributeCount: countClassAttributes(parsedSelector),\n    identifierCount: countIdentifiers(parsedSelector)\n  };\n  selectorCache.set(rawSelector, result);\n  return result;\n}\n\nclass NodeEventGenerator {\n  constructor(emitter, esqueryOptions) {\n    this.emitter = emitter;\n    this.esqueryOptions = esqueryOptions;\n    this.currentAncestry = [];\n    this.enterSelectorsByNodeType = new Map();\n    this.exitSelectorsByNodeType = new Map();\n    this.anyTypeEnterSelectors = [];\n    this.anyTypeExitSelectors = [];\n    emitter.eventNames().forEach(rawSelector => {\n      const selector = parseSelector(rawSelector);\n\n      if (selector.listenerTypes) {\n        const typeMap = selector.isExit ? this.exitSelectorsByNodeType : this.enterSelectorsByNodeType;\n        selector.listenerTypes.forEach(nodeType => {\n          if (!typeMap.has(nodeType)) {\n            typeMap.set(nodeType, []);\n          }\n\n          typeMap.get(nodeType).push(selector);\n        });\n        return;\n      }\n\n      const selectors = selector.isExit ? this.anyTypeExitSelectors : this.anyTypeEnterSelectors;\n      selectors.push(selector);\n    });\n    this.anyTypeEnterSelectors.sort(compareSpecificity);\n    this.anyTypeExitSelectors.sort(compareSpecificity);\n    this.enterSelectorsByNodeType.forEach(selectorList => selectorList.sort(compareSpecificity));\n    this.exitSelectorsByNodeType.forEach(selectorList => selectorList.sort(compareSpecificity));\n  }\n\n  applySelector(node, selector) {\n    if (esquery__default['default'].matches(node, selector.parsedSelector, this.currentAncestry, this.esqueryOptions)) {\n      this.emitter.emit(selector.rawSelector, node);\n    }\n  }\n\n  applySelectors(node, isExit) {\n    const selectorsByNodeType = (isExit ? this.exitSelectorsByNodeType : this.enterSelectorsByNodeType).get(node.type) || [];\n    const anyTypeSelectors = isExit ? this.anyTypeExitSelectors : this.anyTypeEnterSelectors;\n    let selectorsByTypeIndex = 0;\n    let anyTypeSelectorsIndex = 0;\n\n    while (selectorsByTypeIndex < selectorsByNodeType.length || anyTypeSelectorsIndex < anyTypeSelectors.length) {\n      if (selectorsByTypeIndex >= selectorsByNodeType.length || anyTypeSelectorsIndex < anyTypeSelectors.length && compareSpecificity(anyTypeSelectors[anyTypeSelectorsIndex], selectorsByNodeType[selectorsByTypeIndex]) < 0) {\n        this.applySelector(node, anyTypeSelectors[anyTypeSelectorsIndex++]);\n      } else {\n        this.applySelector(node, selectorsByNodeType[selectorsByTypeIndex++]);\n      }\n    }\n  }\n\n  enterNode(node) {\n    if (node.parent) {\n      this.currentAncestry.unshift(node.parent);\n    }\n\n    this.applySelectors(node, false);\n  }\n\n  leaveNode(node) {\n    this.applySelectors(node, true);\n    this.currentAncestry.shift();\n  }\n\n}\n\nvar nodeEventGenerator = NodeEventGenerator;\n\nfunction insertTextAt(index, text) {\n  return {\n    range: [index, index],\n    text\n  };\n}\n\nconst ruleFixer = Object.freeze({\n  insertTextAfter(nodeOrToken, text) {\n    return this.insertTextAfterRange(nodeOrToken.range, text);\n  },\n\n  insertTextAfterRange(range, text) {\n    return insertTextAt(range[1], text);\n  },\n\n  insertTextBefore(nodeOrToken, text) {\n    return this.insertTextBeforeRange(nodeOrToken.range, text);\n  },\n\n  insertTextBeforeRange(range, text) {\n    return insertTextAt(range[0], text);\n  },\n\n  replaceText(nodeOrToken, text) {\n    return this.replaceTextRange(nodeOrToken.range, text);\n  },\n\n  replaceTextRange(range, text) {\n    return {\n      range,\n      text\n    };\n  },\n\n  remove(nodeOrToken) {\n    return this.removeRange(nodeOrToken.range);\n  },\n\n  removeRange(range) {\n    return {\n      range,\n      text: \"\"\n    };\n  }\n\n});\nvar ruleFixer_1 = ruleFixer;\n\nvar interpolate = (text, data) => {\n  if (!data) {\n    return text;\n  }\n\n  return text.replace(/\\{\\{([^{}]+?)\\}\\}/gu, (fullMatch, termWithWhitespace) => {\n    const term = termWithWhitespace.trim();\n\n    if (term in data) {\n      return data[term];\n    }\n\n    return fullMatch;\n  });\n};\n\nfunction normalizeMultiArgReportCall(...args) {\n  if (args.length === 1) {\n    return Object.assign({}, args[0]);\n  }\n\n  if (typeof args[1] === \"string\") {\n    return {\n      node: args[0],\n      message: args[1],\n      data: args[2],\n      fix: args[3]\n    };\n  }\n\n  return {\n    node: args[0],\n    loc: args[1],\n    message: args[2],\n    data: args[3],\n    fix: args[4]\n  };\n}\n\nfunction assertValidNodeInfo(descriptor) {\n  if (descriptor.node) {\n    assert__default['default'](typeof descriptor.node === \"object\", \"Node must be an object\");\n  } else {\n    assert__default['default'](descriptor.loc, \"Node must be provided when reporting error if location is not provided\");\n  }\n}\n\nfunction normalizeReportLoc(descriptor) {\n  if (descriptor.loc) {\n    if (descriptor.loc.start) {\n      return descriptor.loc;\n    }\n\n    return {\n      start: descriptor.loc,\n      end: null\n    };\n  }\n\n  return descriptor.node.loc;\n}\n\nfunction assertValidFix(fix) {\n  if (fix) {\n    assert__default['default'](fix.range && typeof fix.range[0] === \"number\" && typeof fix.range[1] === \"number\", `Fix has invalid range: ${JSON.stringify(fix, null, 2)}`);\n  }\n}\n\nfunction compareFixesByRange(a, b) {\n  return a.range[0] - b.range[0] || a.range[1] - b.range[1];\n}\n\nfunction mergeFixes(fixes, sourceCode) {\n  for (const fix of fixes) {\n    assertValidFix(fix);\n  }\n\n  if (fixes.length === 0) {\n    return null;\n  }\n\n  if (fixes.length === 1) {\n    return fixes[0];\n  }\n\n  fixes.sort(compareFixesByRange);\n  const originalText = sourceCode.text;\n  const start = fixes[0].range[0];\n  const end = fixes[fixes.length - 1].range[1];\n  let text = \"\";\n  let lastPos = Number.MIN_SAFE_INTEGER;\n\n  for (const fix of fixes) {\n    assert__default['default'](fix.range[0] >= lastPos, \"Fix objects must not be overlapped in a report.\");\n\n    if (fix.range[0] >= 0) {\n      text += originalText.slice(Math.max(0, start, lastPos), fix.range[0]);\n    }\n\n    text += fix.text;\n    lastPos = fix.range[1];\n  }\n\n  text += originalText.slice(Math.max(0, start, lastPos), end);\n  return {\n    range: [start, end],\n    text\n  };\n}\n\nfunction normalizeFixes(descriptor, sourceCode) {\n  if (typeof descriptor.fix !== \"function\") {\n    return null;\n  }\n\n  const fix = descriptor.fix(ruleFixer_1);\n\n  if (fix && Symbol.iterator in fix) {\n    return mergeFixes(Array.from(fix), sourceCode);\n  }\n\n  assertValidFix(fix);\n  return fix;\n}\n\nfunction mapSuggestions(descriptor, sourceCode, messages) {\n  if (!descriptor.suggest || !Array.isArray(descriptor.suggest)) {\n    return [];\n  }\n\n  return descriptor.suggest.map(suggestInfo => {\n    const computedDesc = suggestInfo.desc || messages[suggestInfo.messageId];\n    return { ...suggestInfo,\n      desc: interpolate(computedDesc, suggestInfo.data),\n      fix: normalizeFixes(suggestInfo, sourceCode)\n    };\n  }).filter(({\n    fix\n  }) => fix);\n}\n\nfunction createProblem(options) {\n  const problem = {\n    ruleId: options.ruleId,\n    severity: options.severity,\n    message: options.message,\n    line: options.loc.start.line,\n    column: options.loc.start.column + 1,\n    nodeType: options.node && options.node.type || null\n  };\n\n  if (options.messageId) {\n    problem.messageId = options.messageId;\n  }\n\n  if (options.loc.end) {\n    problem.endLine = options.loc.end.line;\n    problem.endColumn = options.loc.end.column + 1;\n  }\n\n  if (options.fix) {\n    problem.fix = options.fix;\n  }\n\n  if (options.suggestions && options.suggestions.length > 0) {\n    problem.suggestions = options.suggestions;\n  }\n\n  return problem;\n}\n\nfunction validateSuggestions(suggest, messages) {\n  if (suggest && Array.isArray(suggest)) {\n    suggest.forEach(suggestion => {\n      if (suggestion.messageId) {\n        const {\n          messageId\n        } = suggestion;\n\n        if (!messages) {\n          throw new TypeError(`context.report() called with a suggest option with a messageId '${messageId}', but no messages were present in the rule metadata.`);\n        }\n\n        if (!messages[messageId]) {\n          throw new TypeError(`context.report() called with a suggest option with a messageId '${messageId}' which is not present in the 'messages' config: ${JSON.stringify(messages, null, 2)}`);\n        }\n\n        if (suggestion.desc) {\n          throw new TypeError(\"context.report() called with a suggest option that defines both a 'messageId' and an 'desc'. Please only pass one.\");\n        }\n      } else if (!suggestion.desc) {\n        throw new TypeError(\"context.report() called with a suggest option that doesn't have either a `desc` or `messageId`\");\n      }\n\n      if (typeof suggestion.fix !== \"function\") {\n        throw new TypeError(`context.report() called with a suggest option without a fix function. See: ${suggestion}`);\n      }\n    });\n  }\n}\n\nvar reportTranslator = function (metadata) {\n  return (...args) => {\n    const descriptor = normalizeMultiArgReportCall(...args);\n    const messages = metadata.messageIds;\n    assertValidNodeInfo(descriptor);\n    let computedMessage;\n\n    if (descriptor.messageId) {\n      if (!messages) {\n        throw new TypeError(\"context.report() called with a messageId, but no messages were present in the rule metadata.\");\n      }\n\n      const id = descriptor.messageId;\n\n      if (descriptor.message) {\n        throw new TypeError(\"context.report() called with a message and a messageId. Please only pass one.\");\n      }\n\n      if (!messages || !Object.prototype.hasOwnProperty.call(messages, id)) {\n        throw new TypeError(`context.report() called with a messageId of '${id}' which is not present in the 'messages' config: ${JSON.stringify(messages, null, 2)}`);\n      }\n\n      computedMessage = messages[id];\n    } else if (descriptor.message) {\n      computedMessage = descriptor.message;\n    } else {\n      throw new TypeError(\"Missing `message` property in report() call; add a message that describes the linting problem.\");\n    }\n\n    validateSuggestions(descriptor.suggest, messages);\n    return createProblem({\n      ruleId: metadata.ruleId,\n      severity: metadata.severity,\n      node: descriptor.node,\n      message: interpolate(computedMessage, descriptor.data),\n      messageId: descriptor.messageId,\n      loc: normalizeReportLoc(descriptor),\n      fix: metadata.disableFixes ? null : normalizeFixes(descriptor, metadata.sourceCode),\n      suggestions: metadata.disableFixes ? [] : mapSuggestions(descriptor, metadata.sourceCode, messages)\n    });\n  };\n};\n\nvar rulesIndex = new Map();\n\nfunction normalizeRule(rule) {\n  return typeof rule === \"function\" ? Object.assign({\n    create: rule\n  }, rule) : rule;\n}\n\nclass Rules {\n  constructor() {\n    this._rules = Object.create(null);\n  }\n\n  define(ruleId, ruleModule) {\n    this._rules[ruleId] = normalizeRule(ruleModule);\n  }\n\n  get(ruleId) {\n    if (typeof this._rules[ruleId] === \"string\") {\n      this.define(ruleId, null);\n    }\n\n    if (this._rules[ruleId]) {\n      return this._rules[ruleId];\n    }\n\n    if (rulesIndex.has(ruleId)) {\n      return rulesIndex.get(ruleId);\n    }\n\n    return null;\n  }\n\n  *[Symbol.iterator]() {\n    yield* rulesIndex;\n\n    for (const ruleId of Object.keys(this._rules)) {\n      yield [ruleId, this.get(ruleId)];\n    }\n  }\n\n}\n\nvar rules$1 = Rules;\n\nvar safeEmitter = () => {\n  const listeners = Object.create(null);\n  return Object.freeze({\n    on(eventName, listener) {\n      if (eventName in listeners) {\n        listeners[eventName].push(listener);\n      } else {\n        listeners[eventName] = [listener];\n      }\n    },\n\n    emit(eventName, ...args) {\n      if (eventName in listeners) {\n        listeners[eventName].forEach(listener => listener(...args));\n      }\n    },\n\n    eventNames() {\n      return Object.keys(listeners);\n    }\n\n  });\n};\n\nconst debug$1 = debug__default['default'](\"eslint:source-code-fixer\");\nconst BOM = \"\\uFEFF\";\n\nfunction compareMessagesByFixRange(a, b) {\n  return a.fix.range[0] - b.fix.range[0] || a.fix.range[1] - b.fix.range[1];\n}\n\nfunction compareMessagesByLocation(a, b) {\n  return a.line - b.line || a.column - b.column;\n}\n\nfunction SourceCodeFixer() {\n  Object.freeze(this);\n}\n\nSourceCodeFixer.applyFixes = function (sourceText, messages, shouldFix) {\n  debug$1(\"Applying fixes\");\n\n  if (shouldFix === false) {\n    debug$1(\"shouldFix parameter was false, not attempting fixes\");\n    return {\n      fixed: false,\n      messages,\n      output: sourceText\n    };\n  }\n\n  const remainingMessages = [],\n        fixes = [],\n        bom = sourceText.startsWith(BOM) ? BOM : \"\",\n        text = bom ? sourceText.slice(1) : sourceText;\n  let lastPos = Number.NEGATIVE_INFINITY,\n      output = bom;\n\n  function attemptFix(problem) {\n    const fix = problem.fix;\n    const start = fix.range[0];\n    const end = fix.range[1];\n\n    if (lastPos >= start || start > end) {\n      remainingMessages.push(problem);\n      return false;\n    }\n\n    if (start < 0 && end >= 0 || start === 0 && fix.text.startsWith(BOM)) {\n      output = \"\";\n    }\n\n    output += text.slice(Math.max(0, lastPos), Math.max(0, start));\n    output += fix.text;\n    lastPos = end;\n    return true;\n  }\n\n  messages.forEach(problem => {\n    if (Object.prototype.hasOwnProperty.call(problem, \"fix\")) {\n      fixes.push(problem);\n    } else {\n      remainingMessages.push(problem);\n    }\n  });\n\n  if (fixes.length) {\n    debug$1(\"Found fixes to apply\");\n    let fixesWereApplied = false;\n\n    for (const problem of fixes.sort(compareMessagesByFixRange)) {\n      if (typeof shouldFix !== \"function\" || shouldFix(problem)) {\n        attemptFix(problem);\n        fixesWereApplied = true;\n      } else {\n        remainingMessages.push(problem);\n      }\n    }\n\n    output += text.slice(Math.max(0, lastPos));\n    return {\n      fixed: fixesWereApplied,\n      messages: remainingMessages.sort(compareMessagesByLocation),\n      output\n    };\n  }\n\n  debug$1(\"No fixes to apply\");\n  return {\n    fixed: false,\n    messages,\n    output: bom + text\n  };\n};\n\nvar sourceCodeFixer = SourceCodeFixer;\n\nfunction alignLeft(str, len, ch) {\n  return str + new Array(len - str.length + 1).join(ch || \" \");\n}\n\nfunction alignRight(str, len, ch) {\n  return new Array(len - str.length + 1).join(ch || \" \") + str;\n}\n\nconst enabled = false;\nconst HEADERS = [\"Rule\", \"Time (ms)\", \"Relative\"];\nconst ALIGN = [alignLeft, alignRight, alignRight];\n\nfunction getListSize() {\n  const TIMING_ENV_VAR_AS_INTEGER = Number.parseInt(\"\", 10);\n  return 10;\n}\n\nfunction display(data) {\n  let total = 0;\n  const rows = Object.keys(data).map(key => {\n    const time = data[key];\n    total += time;\n    return [key, time];\n  }).sort((a, b) => b[1] - a[1]).slice(0, getListSize());\n  rows.forEach(row => {\n    row.push(`${(row[1] * 100 / total).toFixed(1)}%`);\n    row[1] = row[1].toFixed(3);\n  });\n  rows.unshift(HEADERS);\n  const widths = [];\n  rows.forEach(row => {\n    const len = row.length;\n\n    for (let i = 0; i < len; i++) {\n      const n = row[i].length;\n\n      if (!widths[i] || n > widths[i]) {\n        widths[i] = n;\n      }\n    }\n  });\n  const table = rows.map(row => row.map((cell, index) => ALIGN[index](cell, widths[index])).join(\" | \"));\n  table.splice(1, 0, widths.map((width, index) => {\n    const extraAlignment = index !== 0 && index !== widths.length - 1 ? 2 : 1;\n    return ALIGN[index](\":\", width + extraAlignment, \"-\");\n  }).join(\"|\"));\n  console.log(table.join(\"\\n\"));\n}\n\nvar timing = function () {\n  const data = Object.create(null);\n\n  if (enabled) {\n    process.on(\"exit\", () => {\n      display(data);\n    });\n  }\n\n  return {\n    time: function (key, fn) {\n      if (typeof data[key] === \"undefined\") {\n        data[key] = 0;\n      }\n\n      return function (...args) {\n        let t = process.hrtime();\n        fn(...args);\n        t = process.hrtime(t);\n        data[key] += t[0] * 1e3 + t[1] / 1e6;\n      };\n    },\n    enabled,\n    getListSize\n  };\n}();\n\nconst rules = {\n  \"generator-star\": [\"generator-star-spacing\"],\n  \"global-strict\": [\"strict\"],\n  \"no-arrow-condition\": [\"no-confusing-arrow\", \"no-constant-condition\"],\n  \"no-comma-dangle\": [\"comma-dangle\"],\n  \"no-empty-class\": [\"no-empty-character-class\"],\n  \"no-empty-label\": [\"no-labels\"],\n  \"no-extra-strict\": [\"strict\"],\n  \"no-reserved-keys\": [\"quote-props\"],\n  \"no-space-before-semi\": [\"semi-spacing\"],\n  \"no-wrap-func\": [\"no-extra-parens\"],\n  \"space-after-function-name\": [\"space-before-function-paren\"],\n  \"space-after-keywords\": [\"keyword-spacing\"],\n  \"space-before-function-parentheses\": [\"space-before-function-paren\"],\n  \"space-before-keywords\": [\"keyword-spacing\"],\n  \"space-in-brackets\": [\"object-curly-spacing\", \"array-bracket-spacing\", \"computed-property-spacing\"],\n  \"space-return-throw-case\": [\"keyword-spacing\"],\n  \"space-unary-word-ops\": [\"space-unary-ops\"],\n  \"spaced-line-comment\": [\"spaced-comment\"]\n};\nvar replacements = {\n  rules: rules\n};\nvar replacements$1 = Object.freeze({\n  __proto__: null,\n  rules: rules,\n  'default': replacements\n});\n\nvar pkg = _commonjsHelpers.getCjsExportFromNamespace(_package$1);\n\nvar ruleReplacements = _commonjsHelpers.getCjsExportFromNamespace(replacements$1);\n\nconst {\n  SourceCode\n} = sourceCode;\nconst debug = debug__default['default'](\"eslint:linter\");\nconst MAX_AUTOFIX_PASSES = 10;\nconst DEFAULT_PARSER_NAME = \"espree\";\nconst DEFAULT_ECMA_VERSION = 5;\nconst commentParser = new configCommentParser();\nconst DEFAULT_ERROR_LOC = {\n  start: {\n    line: 1,\n    column: 0\n  },\n  end: {\n    line: 1,\n    column: 1\n  }\n};\nconst parserSymbol = Symbol.for(\"eslint.RuleTester.parser\");\n\nfunction addDeclaredGlobals(globalScope, configGlobals, {\n  exportedVariables,\n  enabledGlobals\n}) {\n  for (const id of new Set([...Object.keys(configGlobals), ...Object.keys(enabledGlobals)])) {\n    const configValue = configGlobals[id] === void 0 ? void 0 : configOps__default['default'].normalizeConfigGlobal(configGlobals[id]);\n    const commentValue = enabledGlobals[id] && enabledGlobals[id].value;\n    const value = commentValue || configValue;\n    const sourceComments = enabledGlobals[id] && enabledGlobals[id].comments;\n\n    if (value === \"off\") {\n      continue;\n    }\n\n    let variable = globalScope.set.get(id);\n\n    if (!variable) {\n      variable = new eslintScope__default['default'].Variable(id, globalScope);\n      globalScope.variables.push(variable);\n      globalScope.set.set(id, variable);\n    }\n\n    variable.eslintImplicitGlobalSetting = configValue;\n    variable.eslintExplicitGlobal = sourceComments !== void 0;\n    variable.eslintExplicitGlobalComments = sourceComments;\n    variable.writeable = value === \"writable\";\n  }\n\n  Object.keys(exportedVariables).forEach(name => {\n    const variable = globalScope.set.get(name);\n\n    if (variable) {\n      variable.eslintUsed = true;\n    }\n  });\n  globalScope.through = globalScope.through.filter(reference => {\n    const name = reference.identifier.name;\n    const variable = globalScope.set.get(name);\n\n    if (variable) {\n      reference.resolved = variable;\n      variable.references.push(reference);\n      return false;\n    }\n\n    return true;\n  });\n}\n\nfunction createMissingRuleMessage(ruleId) {\n  return Object.prototype.hasOwnProperty.call(ruleReplacements.rules, ruleId) ? `Rule '${ruleId}' was removed and replaced by: ${ruleReplacements.rules[ruleId].join(\", \")}` : `Definition for rule '${ruleId}' was not found.`;\n}\n\nfunction createLintingProblem(options) {\n  const {\n    ruleId = null,\n    loc = DEFAULT_ERROR_LOC,\n    message = createMissingRuleMessage(options.ruleId),\n    severity = 2\n  } = options;\n  return {\n    ruleId,\n    message,\n    line: loc.start.line,\n    column: loc.start.column + 1,\n    endLine: loc.end.line,\n    endColumn: loc.end.column + 1,\n    severity,\n    nodeType: null\n  };\n}\n\nfunction createDisableDirectives(options) {\n  const {\n    type,\n    loc,\n    value,\n    ruleMapper\n  } = options;\n  const ruleIds = Object.keys(commentParser.parseListConfig(value));\n  const directiveRules = ruleIds.length ? ruleIds : [null];\n  const result = {\n    directives: [],\n    directiveProblems: []\n  };\n\n  for (const ruleId of directiveRules) {\n    if (ruleId === null || ruleMapper(ruleId) !== null) {\n      result.directives.push({\n        type,\n        line: loc.start.line,\n        column: loc.start.column + 1,\n        ruleId\n      });\n    } else {\n      result.directiveProblems.push(createLintingProblem({\n        ruleId,\n        loc\n      }));\n    }\n  }\n\n  return result;\n}\n\nfunction stripDirectiveComment(value) {\n  return value.split(/\\s-{2,}\\s/u)[0].trim();\n}\n\nfunction getDirectiveComments(filename, ast, ruleMapper, warnInlineConfig) {\n  const configuredRules = {};\n  const enabledGlobals = Object.create(null);\n  const exportedVariables = {};\n  const problems = [];\n  const disableDirectives = [];\n  const validator = new configValidator__default['default']({\n    builtInRules: rules$1\n  });\n  ast.comments.filter(token => token.type !== \"Shebang\").forEach(comment => {\n    const trimmedCommentText = stripDirectiveComment(comment.value);\n    const match = /^(eslint(?:-env|-enable|-disable(?:(?:-next)?-line)?)?|exported|globals?)(?:\\s|$)/u.exec(trimmedCommentText);\n\n    if (!match) {\n      return;\n    }\n\n    const directiveText = match[1];\n    const lineCommentSupported = /^eslint-disable-(next-)?line$/u.test(directiveText);\n\n    if (comment.type === \"Line\" && !lineCommentSupported) {\n      return;\n    }\n\n    if (warnInlineConfig) {\n      const kind = comment.type === \"Block\" ? `/*${directiveText}*/` : `//${directiveText}`;\n      problems.push(createLintingProblem({\n        ruleId: null,\n        message: `'${kind}' has no effect because you have 'noInlineConfig' setting in ${warnInlineConfig}.`,\n        loc: comment.loc,\n        severity: 1\n      }));\n      return;\n    }\n\n    if (lineCommentSupported && comment.loc.start.line !== comment.loc.end.line) {\n      problems.push(createLintingProblem({\n        ruleId: null,\n        message: `${directiveText} comment should not span multiple lines.`,\n        loc: comment.loc\n      }));\n      return;\n    }\n\n    const directiveValue = trimmedCommentText.slice(match.index + directiveText.length);\n\n    switch (directiveText) {\n      case \"eslint-disable\":\n      case \"eslint-enable\":\n      case \"eslint-disable-next-line\":\n      case \"eslint-disable-line\":\n        {\n          const directiveType = directiveText.slice(7);\n          const options = {\n            type: directiveType,\n            loc: comment.loc,\n            value: directiveValue,\n            ruleMapper\n          };\n          const {\n            directives,\n            directiveProblems\n          } = createDisableDirectives(options);\n          disableDirectives.push(...directives);\n          problems.push(...directiveProblems);\n          break;\n        }\n\n      case \"exported\":\n        Object.assign(exportedVariables, commentParser.parseStringConfig(directiveValue, comment));\n        break;\n\n      case \"globals\":\n      case \"global\":\n        for (const [id, {\n          value\n        }] of Object.entries(commentParser.parseStringConfig(directiveValue, comment))) {\n          let normalizedValue;\n\n          try {\n            normalizedValue = configOps__default['default'].normalizeConfigGlobal(value);\n          } catch (err) {\n            problems.push(createLintingProblem({\n              ruleId: null,\n              loc: comment.loc,\n              message: err.message\n            }));\n            continue;\n          }\n\n          if (enabledGlobals[id]) {\n            enabledGlobals[id].comments.push(comment);\n            enabledGlobals[id].value = normalizedValue;\n          } else {\n            enabledGlobals[id] = {\n              comments: [comment],\n              value: normalizedValue\n            };\n          }\n        }\n\n        break;\n\n      case \"eslint\":\n        {\n          const parseResult = commentParser.parseJsonConfig(directiveValue, comment.loc);\n\n          if (parseResult.success) {\n            Object.keys(parseResult.config).forEach(name => {\n              const rule = ruleMapper(name);\n              const ruleValue = parseResult.config[name];\n\n              if (rule === null) {\n                problems.push(createLintingProblem({\n                  ruleId: name,\n                  loc: comment.loc\n                }));\n                return;\n              }\n\n              try {\n                validator.validateRuleOptions(rule, name, ruleValue);\n              } catch (err) {\n                problems.push(createLintingProblem({\n                  ruleId: name,\n                  message: err.message,\n                  loc: comment.loc\n                }));\n                return;\n              }\n\n              configuredRules[name] = ruleValue;\n            });\n          } else {\n            problems.push(parseResult.error);\n          }\n\n          break;\n        }\n    }\n  });\n  return {\n    configuredRules,\n    enabledGlobals,\n    exportedVariables,\n    problems,\n    disableDirectives\n  };\n}\n\nfunction normalizeEcmaVersion(parser, ecmaVersion) {\n  if ((parser[parserSymbol] || parser) === espree__default['default']) {\n    if (ecmaVersion === \"latest\") {\n      return espree__default['default'].latestEcmaVersion;\n    }\n  }\n\n  return ecmaVersion >= 2015 ? ecmaVersion - 2009 : ecmaVersion;\n}\n\nconst eslintEnvPattern = /\\/\\*\\s*eslint-env\\s(.+?)\\*\\//gsu;\n\nfunction findEslintEnv(text) {\n  let match, retv;\n  eslintEnvPattern.lastIndex = 0;\n\n  while ((match = eslintEnvPattern.exec(text)) !== null) {\n    retv = Object.assign(retv || {}, commentParser.parseListConfig(stripDirectiveComment(match[1])));\n  }\n\n  return retv;\n}\n\nfunction normalizeFilename(filename) {\n  const parts = filename.split(path__default['default'].sep);\n  const index = parts.lastIndexOf(\"<text>\");\n  return index === -1 ? filename : parts.slice(index).join(path__default['default'].sep);\n}\n\nfunction normalizeVerifyOptions(providedOptions, config) {\n  const disableInlineConfig = config.noInlineConfig === true;\n  const ignoreInlineConfig = providedOptions.allowInlineConfig === false;\n  const configNameOfNoInlineConfig = config.configNameOfNoInlineConfig ? ` (${config.configNameOfNoInlineConfig})` : \"\";\n  let reportUnusedDisableDirectives = providedOptions.reportUnusedDisableDirectives;\n\n  if (typeof reportUnusedDisableDirectives === \"boolean\") {\n    reportUnusedDisableDirectives = reportUnusedDisableDirectives ? \"error\" : \"off\";\n  }\n\n  if (typeof reportUnusedDisableDirectives !== \"string\") {\n    reportUnusedDisableDirectives = config.reportUnusedDisableDirectives ? \"warn\" : \"off\";\n  }\n\n  return {\n    filename: normalizeFilename(providedOptions.filename || \"<input>\"),\n    allowInlineConfig: !ignoreInlineConfig,\n    warnInlineConfig: disableInlineConfig && !ignoreInlineConfig ? `your config${configNameOfNoInlineConfig}` : null,\n    reportUnusedDisableDirectives,\n    disableFixes: Boolean(providedOptions.disableFixes)\n  };\n}\n\nfunction resolveParserOptions(parser, providedOptions, enabledEnvironments) {\n  const parserOptionsFromEnv = enabledEnvironments.filter(env => env.parserOptions).reduce((parserOptions, env) => lodash__default['default'](parserOptions, env.parserOptions), {});\n  const mergedParserOptions = lodash__default['default'](parserOptionsFromEnv, providedOptions || {});\n  const isModule = mergedParserOptions.sourceType === \"module\";\n\n  if (isModule) {\n    mergedParserOptions.ecmaFeatures = Object.assign({}, mergedParserOptions.ecmaFeatures, {\n      globalReturn: false\n    });\n  }\n\n  mergedParserOptions.ecmaVersion = normalizeEcmaVersion(parser, mergedParserOptions.ecmaVersion);\n  return mergedParserOptions;\n}\n\nfunction resolveGlobals(providedGlobals, enabledEnvironments) {\n  return Object.assign({}, ...enabledEnvironments.filter(env => env.globals).map(env => env.globals), providedGlobals);\n}\n\nfunction stripUnicodeBOM(text) {\n  if (text.charCodeAt(0) === 0xFEFF) {\n    return text.slice(1);\n  }\n\n  return text;\n}\n\nfunction getRuleOptions(ruleConfig) {\n  if (Array.isArray(ruleConfig)) {\n    return ruleConfig.slice(1);\n  }\n\n  return [];\n}\n\nfunction analyzeScope(ast, parserOptions, visitorKeys) {\n  const ecmaFeatures = parserOptions.ecmaFeatures || {};\n  const ecmaVersion = parserOptions.ecmaVersion || DEFAULT_ECMA_VERSION;\n  return eslintScope__default['default'].analyze(ast, {\n    ignoreEval: true,\n    nodejsScope: ecmaFeatures.globalReturn,\n    impliedStrict: ecmaFeatures.impliedStrict,\n    ecmaVersion,\n    sourceType: parserOptions.sourceType || \"script\",\n    childVisitorKeys: visitorKeys || eslintVisitorKeys__default['default'].KEYS,\n    fallback: _commonjsHelpers.traverser.getKeys\n  });\n}\n\nfunction parse(text, parser, providedParserOptions, filePath) {\n  const textToParse = stripUnicodeBOM(text).replace(_commonjsHelpers.astUtils.shebangPattern, (match, captured) => `//${captured}`);\n  const parserOptions = Object.assign({}, providedParserOptions, {\n    loc: true,\n    range: true,\n    raw: true,\n    tokens: true,\n    comment: true,\n    eslintVisitorKeys: true,\n    eslintScopeManager: true,\n    filePath\n  });\n\n  try {\n    const parseResult = typeof parser.parseForESLint === \"function\" ? parser.parseForESLint(textToParse, parserOptions) : {\n      ast: parser.parse(textToParse, parserOptions)\n    };\n    const ast = parseResult.ast;\n    const parserServices = parseResult.services || {};\n    const visitorKeys = parseResult.visitorKeys || eslintVisitorKeys__default['default'].KEYS;\n    const scopeManager = parseResult.scopeManager || analyzeScope(ast, parserOptions, visitorKeys);\n    return {\n      success: true,\n      sourceCode: new SourceCode({\n        text,\n        ast,\n        parserServices,\n        scopeManager,\n        visitorKeys\n      })\n    };\n  } catch (ex) {\n    const message = `Parsing error: ${ex.message.replace(/^line \\d+:/iu, \"\").trim()}`;\n    debug(\"%s\\n%s\", message, ex.stack);\n    return {\n      success: false,\n      error: {\n        ruleId: null,\n        fatal: true,\n        severity: 2,\n        message,\n        line: ex.lineNumber,\n        column: ex.column\n      }\n    };\n  }\n}\n\nfunction getScope(scopeManager, currentNode) {\n  const inner = currentNode.type !== \"Program\";\n\n  for (let node = currentNode; node; node = node.parent) {\n    const scope = scopeManager.acquire(node, inner);\n\n    if (scope) {\n      if (scope.type === \"function-expression-name\") {\n        return scope.childScopes[0];\n      }\n\n      return scope;\n    }\n  }\n\n  return scopeManager.scopes[0];\n}\n\nfunction markVariableAsUsed(scopeManager, currentNode, parserOptions, name) {\n  const hasGlobalReturn = parserOptions.ecmaFeatures && parserOptions.ecmaFeatures.globalReturn;\n  const specialScope = hasGlobalReturn || parserOptions.sourceType === \"module\";\n  const currentScope = getScope(scopeManager, currentNode);\n  const initialScope = currentScope.type === \"global\" && specialScope ? currentScope.childScopes[0] : currentScope;\n\n  for (let scope = initialScope; scope; scope = scope.upper) {\n    const variable = scope.variables.find(scopeVar => scopeVar.name === name);\n\n    if (variable) {\n      variable.eslintUsed = true;\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction createRuleListeners(rule, ruleContext) {\n  try {\n    return rule.create(ruleContext);\n  } catch (ex) {\n    ex.message = `Error while loading rule '${ruleContext.id}': ${ex.message}`;\n    throw ex;\n  }\n}\n\nfunction getAncestors(node) {\n  const ancestorsStartingAtParent = [];\n\n  for (let ancestor = node.parent; ancestor; ancestor = ancestor.parent) {\n    ancestorsStartingAtParent.push(ancestor);\n  }\n\n  return ancestorsStartingAtParent.reverse();\n}\n\nconst DEPRECATED_SOURCECODE_PASSTHROUGHS = {\n  getSource: \"getText\",\n  getSourceLines: \"getLines\",\n  getAllComments: \"getAllComments\",\n  getNodeByRangeIndex: \"getNodeByRangeIndex\",\n  getComments: \"getComments\",\n  getCommentsBefore: \"getCommentsBefore\",\n  getCommentsAfter: \"getCommentsAfter\",\n  getCommentsInside: \"getCommentsInside\",\n  getJSDocComment: \"getJSDocComment\",\n  getFirstToken: \"getFirstToken\",\n  getFirstTokens: \"getFirstTokens\",\n  getLastToken: \"getLastToken\",\n  getLastTokens: \"getLastTokens\",\n  getTokenAfter: \"getTokenAfter\",\n  getTokenBefore: \"getTokenBefore\",\n  getTokenByRangeStart: \"getTokenByRangeStart\",\n  getTokens: \"getTokens\",\n  getTokensAfter: \"getTokensAfter\",\n  getTokensBefore: \"getTokensBefore\",\n  getTokensBetween: \"getTokensBetween\"\n};\nconst BASE_TRAVERSAL_CONTEXT = Object.freeze(Object.keys(DEPRECATED_SOURCECODE_PASSTHROUGHS).reduce((contextInfo, methodName) => Object.assign(contextInfo, {\n  [methodName](...args) {\n    return this.getSourceCode()[DEPRECATED_SOURCECODE_PASSTHROUGHS[methodName]](...args);\n  }\n\n}), {}));\n\nfunction runRules(sourceCode, configuredRules, ruleMapper, parserOptions, parserName, settings, filename, disableFixes, cwd, physicalFilename) {\n  const emitter = safeEmitter();\n  const nodeQueue = [];\n  let currentNode = sourceCode.ast;\n\n  _commonjsHelpers.traverser.traverse(sourceCode.ast, {\n    enter(node, parent) {\n      node.parent = parent;\n      nodeQueue.push({\n        isEntering: true,\n        node\n      });\n    },\n\n    leave(node) {\n      nodeQueue.push({\n        isEntering: false,\n        node\n      });\n    },\n\n    visitorKeys: sourceCode.visitorKeys\n  });\n\n  const sharedTraversalContext = Object.freeze(Object.assign(Object.create(BASE_TRAVERSAL_CONTEXT), {\n    getAncestors: () => getAncestors(currentNode),\n    getDeclaredVariables: sourceCode.scopeManager.getDeclaredVariables.bind(sourceCode.scopeManager),\n    getCwd: () => cwd,\n    getFilename: () => filename,\n    getPhysicalFilename: () => physicalFilename || filename,\n    getScope: () => getScope(sourceCode.scopeManager, currentNode),\n    getSourceCode: () => sourceCode,\n    markVariableAsUsed: name => markVariableAsUsed(sourceCode.scopeManager, currentNode, parserOptions, name),\n    parserOptions,\n    parserPath: parserName,\n    parserServices: sourceCode.parserServices,\n    settings\n  }));\n  const lintingProblems = [];\n  Object.keys(configuredRules).forEach(ruleId => {\n    const severity = configOps__default['default'].getRuleSeverity(configuredRules[ruleId]);\n\n    if (severity === 0) {\n      return;\n    }\n\n    const rule = ruleMapper(ruleId);\n\n    if (rule === null) {\n      lintingProblems.push(createLintingProblem({\n        ruleId\n      }));\n      return;\n    }\n\n    const messageIds = rule.meta && rule.meta.messages;\n    let reportTranslator$1 = null;\n    const ruleContext = Object.freeze(Object.assign(Object.create(sharedTraversalContext), {\n      id: ruleId,\n      options: getRuleOptions(configuredRules[ruleId]),\n\n      report(...args) {\n        if (reportTranslator$1 === null) {\n          reportTranslator$1 = reportTranslator({\n            ruleId,\n            severity,\n            sourceCode,\n            messageIds,\n            disableFixes\n          });\n        }\n\n        const problem = reportTranslator$1(...args);\n\n        if (problem.fix && rule.meta && !rule.meta.fixable) {\n          throw new Error(\"Fixable rules should export a `meta.fixable` property.\");\n        }\n\n        lintingProblems.push(problem);\n      }\n\n    }));\n    const ruleListeners = createRuleListeners(rule, ruleContext);\n    Object.keys(ruleListeners).forEach(selector => {\n      emitter.on(selector, timing.enabled ? timing.time(ruleId, ruleListeners[selector]) : ruleListeners[selector]);\n    });\n  });\n  const eventGenerator = nodeQueue[0].node.type === \"Program\" ? new codePathAnalyzer(new nodeEventGenerator(emitter, {\n    visitorKeys: sourceCode.visitorKeys,\n    fallback: _commonjsHelpers.traverser.getKeys\n  })) : new nodeEventGenerator(emitter, {\n    visitorKeys: sourceCode.visitorKeys,\n    fallback: _commonjsHelpers.traverser.getKeys\n  });\n  nodeQueue.forEach(traversalInfo => {\n    currentNode = traversalInfo.node;\n\n    try {\n      if (traversalInfo.isEntering) {\n        eventGenerator.enterNode(currentNode);\n      } else {\n        eventGenerator.leaveNode(currentNode);\n      }\n    } catch (err) {\n      err.currentNode = currentNode;\n      throw err;\n    }\n  });\n  return lintingProblems;\n}\n\nfunction ensureText(textOrSourceCode) {\n  if (typeof textOrSourceCode === \"object\") {\n    const {\n      hasBOM,\n      text\n    } = textOrSourceCode;\n    const bom = hasBOM ? \"\\uFEFF\" : \"\";\n    return bom + text;\n  }\n\n  return String(textOrSourceCode);\n}\n\nfunction getEnv(slots, envId) {\n  return slots.lastConfigArray && slots.lastConfigArray.pluginEnvironments.get(envId) || environments__default['default'].get(envId) || null;\n}\n\nfunction getRule(slots, ruleId) {\n  return slots.lastConfigArray && slots.lastConfigArray.pluginRules.get(ruleId) || slots.ruleMap.get(ruleId);\n}\n\nfunction normalizeCwd(cwd) {\n  if (cwd) {\n    return cwd;\n  }\n\n  if (typeof process === \"object\") {\n    return process.cwd();\n  }\n\n  return undefined;\n}\n\nconst internalSlotsMap = new WeakMap();\n\nclass Linter$1 {\n  constructor({\n    cwd\n  } = {}) {\n    internalSlotsMap.set(this, {\n      cwd: normalizeCwd(cwd),\n      lastConfigArray: null,\n      lastSourceCode: null,\n      parserMap: new Map([[\"espree\", espree__default['default']]]),\n      ruleMap: new rules$1()\n    });\n    this.version = pkg.version;\n  }\n\n  static get version() {\n    return pkg.version;\n  }\n\n  _verifyWithoutProcessors(textOrSourceCode, providedConfig, providedOptions) {\n    const slots = internalSlotsMap.get(this);\n    const config = providedConfig || {};\n    const options = normalizeVerifyOptions(providedOptions, config);\n    let text;\n\n    if (typeof textOrSourceCode === \"string\") {\n      slots.lastSourceCode = null;\n      text = textOrSourceCode;\n    } else {\n      slots.lastSourceCode = textOrSourceCode;\n      text = textOrSourceCode.text;\n    }\n\n    let parserName = DEFAULT_PARSER_NAME;\n    let parser = espree__default['default'];\n\n    if (typeof config.parser === \"object\" && config.parser !== null) {\n      parserName = config.parser.filePath;\n      parser = config.parser.definition;\n    } else if (typeof config.parser === \"string\") {\n      if (!slots.parserMap.has(config.parser)) {\n        return [{\n          ruleId: null,\n          fatal: true,\n          severity: 2,\n          message: `Configured parser '${config.parser}' was not found.`,\n          line: 0,\n          column: 0\n        }];\n      }\n\n      parserName = config.parser;\n      parser = slots.parserMap.get(config.parser);\n    }\n\n    const envInFile = options.allowInlineConfig && !options.warnInlineConfig ? findEslintEnv(text) : {};\n    const resolvedEnvConfig = Object.assign({\n      builtin: true\n    }, config.env, envInFile);\n    const enabledEnvs = Object.keys(resolvedEnvConfig).filter(envName => resolvedEnvConfig[envName]).map(envName => getEnv(slots, envName)).filter(env => env);\n    const parserOptions = resolveParserOptions(parser, config.parserOptions || {}, enabledEnvs);\n    const configuredGlobals = resolveGlobals(config.globals || {}, enabledEnvs);\n    const settings = config.settings || {};\n\n    if (!slots.lastSourceCode) {\n      const parseResult = parse(text, parser, parserOptions, options.filename);\n\n      if (!parseResult.success) {\n        return [parseResult.error];\n      }\n\n      slots.lastSourceCode = parseResult.sourceCode;\n    } else {\n      if (!slots.lastSourceCode.scopeManager) {\n        slots.lastSourceCode = new SourceCode({\n          text: slots.lastSourceCode.text,\n          ast: slots.lastSourceCode.ast,\n          parserServices: slots.lastSourceCode.parserServices,\n          visitorKeys: slots.lastSourceCode.visitorKeys,\n          scopeManager: analyzeScope(slots.lastSourceCode.ast, parserOptions)\n        });\n      }\n    }\n\n    const sourceCode = slots.lastSourceCode;\n    const commentDirectives = options.allowInlineConfig ? getDirectiveComments(options.filename, sourceCode.ast, ruleId => getRule(slots, ruleId), options.warnInlineConfig) : {\n      configuredRules: {},\n      enabledGlobals: {},\n      exportedVariables: {},\n      problems: [],\n      disableDirectives: []\n    };\n    addDeclaredGlobals(sourceCode.scopeManager.scopes[0], configuredGlobals, {\n      exportedVariables: commentDirectives.exportedVariables,\n      enabledGlobals: commentDirectives.enabledGlobals\n    });\n    const configuredRules = Object.assign({}, config.rules, commentDirectives.configuredRules);\n    let lintingProblems;\n\n    try {\n      lintingProblems = runRules(sourceCode, configuredRules, ruleId => getRule(slots, ruleId), parserOptions, parserName, settings, options.filename, options.disableFixes, slots.cwd, providedOptions.physicalFilename);\n    } catch (err) {\n      err.message += `\\nOccurred while linting ${options.filename}`;\n      debug(\"An error occurred while traversing\");\n      debug(\"Filename:\", options.filename);\n\n      if (err.currentNode) {\n        const {\n          line\n        } = err.currentNode.loc.start;\n        debug(\"Line:\", line);\n        err.message += `:${line}`;\n      }\n\n      debug(\"Parser Options:\", parserOptions);\n      debug(\"Parser Path:\", parserName);\n      debug(\"Settings:\", settings);\n      throw err;\n    }\n\n    return applyDisableDirectives({\n      directives: commentDirectives.disableDirectives,\n      problems: lintingProblems.concat(commentDirectives.problems).sort((problemA, problemB) => problemA.line - problemB.line || problemA.column - problemB.column),\n      reportUnusedDisableDirectives: options.reportUnusedDisableDirectives\n    });\n  }\n\n  verify(textOrSourceCode, config, filenameOrOptions) {\n    debug(\"Verify\");\n    const options = typeof filenameOrOptions === \"string\" ? {\n      filename: filenameOrOptions\n    } : filenameOrOptions || {};\n\n    if (config && typeof config.extractConfig === \"function\") {\n      return this._verifyWithConfigArray(textOrSourceCode, config, options);\n    }\n\n    if (options.preprocess || options.postprocess) {\n      return this._verifyWithProcessor(textOrSourceCode, config, options);\n    }\n\n    return this._verifyWithoutProcessors(textOrSourceCode, config, options);\n  }\n\n  _verifyWithConfigArray(textOrSourceCode, configArray, options) {\n    debug(\"With ConfigArray: %s\", options.filename);\n    internalSlotsMap.get(this).lastConfigArray = configArray;\n    const config = configArray.extractConfig(options.filename);\n    const processor = config.processor && configArray.pluginProcessors.get(config.processor);\n\n    if (processor) {\n      debug(\"Apply the processor: %o\", config.processor);\n      const {\n        preprocess,\n        postprocess,\n        supportsAutofix\n      } = processor;\n      const disableFixes = options.disableFixes || !supportsAutofix;\n      return this._verifyWithProcessor(textOrSourceCode, config, { ...options,\n        disableFixes,\n        postprocess,\n        preprocess\n      }, configArray);\n    }\n\n    return this._verifyWithoutProcessors(textOrSourceCode, config, options);\n  }\n\n  _verifyWithProcessor(textOrSourceCode, config, options, configForRecursive) {\n    const filename = options.filename || \"<input>\";\n    const filenameToExpose = normalizeFilename(filename);\n    const physicalFilename = options.physicalFilename || filenameToExpose;\n    const text = ensureText(textOrSourceCode);\n\n    const preprocess = options.preprocess || (rawText => [rawText]);\n\n    const postprocess = options.postprocess || (array => [].concat(...array));\n\n    const filterCodeBlock = options.filterCodeBlock || (blockFilename => blockFilename.endsWith(\".js\"));\n\n    const originalExtname = path__default['default'].extname(filename);\n    const messageLists = preprocess(text, filenameToExpose).map((block, i) => {\n      debug(\"A code block was found: %o\", block.filename || \"(unnamed)\");\n\n      if (typeof block === \"string\") {\n        return this._verifyWithoutProcessors(block, config, options);\n      }\n\n      const blockText = block.text;\n      const blockName = path__default['default'].join(filename, `${i}_${block.filename}`);\n\n      if (!filterCodeBlock(blockName, blockText)) {\n        debug(\"This code block was skipped.\");\n        return [];\n      }\n\n      if (configForRecursive && (text !== blockText || path__default['default'].extname(blockName) !== originalExtname)) {\n        debug(\"Resolving configuration again because the file content or extension was changed.\");\n        return this._verifyWithConfigArray(blockText, configForRecursive, { ...options,\n          filename: blockName,\n          physicalFilename\n        });\n      }\n\n      return this._verifyWithoutProcessors(blockText, config, { ...options,\n        filename: blockName,\n        physicalFilename\n      });\n    });\n    return postprocess(messageLists, filenameToExpose);\n  }\n\n  getSourceCode() {\n    return internalSlotsMap.get(this).lastSourceCode;\n  }\n\n  defineRule(ruleId, ruleModule) {\n    internalSlotsMap.get(this).ruleMap.define(ruleId, ruleModule);\n  }\n\n  defineRules(rulesToDefine) {\n    Object.getOwnPropertyNames(rulesToDefine).forEach(ruleId => {\n      this.defineRule(ruleId, rulesToDefine[ruleId]);\n    });\n  }\n\n  getRules() {\n    const {\n      lastConfigArray,\n      ruleMap\n    } = internalSlotsMap.get(this);\n    return new Map(function* () {\n      yield* ruleMap;\n\n      if (lastConfigArray) {\n        yield* lastConfigArray.pluginRules;\n      }\n    }());\n  }\n\n  defineParser(parserId, parserModule) {\n    internalSlotsMap.get(this).parserMap.set(parserId, parserModule);\n  }\n\n  verifyAndFix(text, config, options) {\n    let messages = [],\n        fixedResult,\n        fixed = false,\n        passNumber = 0,\n        currentText = text;\n    const debugTextDescription = options && options.filename || `${text.slice(0, 10)}...`;\n    const shouldFix = options && typeof options.fix !== \"undefined\" ? options.fix : true;\n\n    do {\n      passNumber++;\n      debug(`Linting code for ${debugTextDescription} (pass ${passNumber})`);\n      messages = this.verify(currentText, config, options);\n      debug(`Generating fixed text for ${debugTextDescription} (pass ${passNumber})`);\n      fixedResult = sourceCodeFixer.applyFixes(currentText, messages, shouldFix);\n\n      if (messages.length === 1 && messages[0].fatal) {\n        break;\n      }\n\n      fixed = fixed || fixedResult.fixed;\n      currentText = fixedResult.output;\n    } while (fixedResult.fixed && passNumber < MAX_AUTOFIX_PASSES);\n\n    if (fixedResult.fixed) {\n      fixedResult.messages = this.verify(currentText, config, options);\n    }\n\n    fixedResult.fixed = fixed;\n    fixedResult.output = currentText;\n    return fixedResult;\n  }\n\n}\n\nvar linter$1 = {\n  Linter: Linter$1,\n\n  getLinterInternalSlots(instance) {\n    return internalSlotsMap.get(instance);\n  }\n\n};\nconst {\n  Linter\n} = linter$1;\nvar linter = {\n  Linter,\n  SourceCodeFixer: sourceCodeFixer,\n  interpolate\n};\nvar linter_1 = linter.Linter;\nexports.linter_1 = linter_1;\n//# sourceMappingURL=index-7114f0bb.js.map\n\n//# sourceURL=webpack://javascript/./node_modules/eslint4b/dist/index-7114f0bb.js?");

/***/ }),

/***/ "./node_modules/eslint4b/dist/index.js":
/*!*********************************************!*\
  !*** ./node_modules/eslint4b/dist/index.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar index = __webpack_require__(/*! ./index-7114f0bb.js */ \"./node_modules/eslint4b/dist/index-7114f0bb.js\");\n\nvar coreRules = __webpack_require__(/*! ./core-rules.js */ \"./node_modules/eslint4b/dist/core-rules.js\");\n\nclass Linter extends index.linter_1 {\n  constructor() {\n    super();\n    this.defineRules(coreRules);\n  }\n\n}\n\nmodule.exports = Linter;\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://javascript/./node_modules/eslint4b/dist/index.js?");

/***/ }),

/***/ "./node_modules/eslint4b/node_modules/debug/src/browser.js":
/*!*****************************************************************!*\
  !*** ./node_modules/eslint4b/node_modules/debug/src/browser.js ***!
  \*****************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("/* provided dependency */ var console = __webpack_require__(/*! ./node_modules/console-browserify/index.js */ \"./node_modules/console-browserify/index.js\");\n/* provided dependency */ var process = __webpack_require__(/*! ./node_modules/process/browser.js */ \"./node_modules/process/browser.js\");\n/* eslint-env browser */\n\n/**\n * This is the web browser implementation of `debug()`.\n */\n\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = localstorage();\nexports.destroy = (() => {\n\tlet warned = false;\n\n\treturn () => {\n\t\tif (!warned) {\n\t\t\twarned = true;\n\t\t\tconsole.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n\t\t}\n\t};\n})();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n\t'#0000CC',\n\t'#0000FF',\n\t'#0033CC',\n\t'#0033FF',\n\t'#0066CC',\n\t'#0066FF',\n\t'#0099CC',\n\t'#0099FF',\n\t'#00CC00',\n\t'#00CC33',\n\t'#00CC66',\n\t'#00CC99',\n\t'#00CCCC',\n\t'#00CCFF',\n\t'#3300CC',\n\t'#3300FF',\n\t'#3333CC',\n\t'#3333FF',\n\t'#3366CC',\n\t'#3366FF',\n\t'#3399CC',\n\t'#3399FF',\n\t'#33CC00',\n\t'#33CC33',\n\t'#33CC66',\n\t'#33CC99',\n\t'#33CCCC',\n\t'#33CCFF',\n\t'#6600CC',\n\t'#6600FF',\n\t'#6633CC',\n\t'#6633FF',\n\t'#66CC00',\n\t'#66CC33',\n\t'#9900CC',\n\t'#9900FF',\n\t'#9933CC',\n\t'#9933FF',\n\t'#99CC00',\n\t'#99CC33',\n\t'#CC0000',\n\t'#CC0033',\n\t'#CC0066',\n\t'#CC0099',\n\t'#CC00CC',\n\t'#CC00FF',\n\t'#CC3300',\n\t'#CC3333',\n\t'#CC3366',\n\t'#CC3399',\n\t'#CC33CC',\n\t'#CC33FF',\n\t'#CC6600',\n\t'#CC6633',\n\t'#CC9900',\n\t'#CC9933',\n\t'#CCCC00',\n\t'#CCCC33',\n\t'#FF0000',\n\t'#FF0033',\n\t'#FF0066',\n\t'#FF0099',\n\t'#FF00CC',\n\t'#FF00FF',\n\t'#FF3300',\n\t'#FF3333',\n\t'#FF3366',\n\t'#FF3399',\n\t'#FF33CC',\n\t'#FF33FF',\n\t'#FF6600',\n\t'#FF6633',\n\t'#FF9900',\n\t'#FF9933',\n\t'#FFCC00',\n\t'#FFCC33'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\n// eslint-disable-next-line complexity\nfunction useColors() {\n\t// NB: In an Electron preload script, document will be defined but not fully\n\t// initialized. Since we know we're in Chrome, we'll just detect this case\n\t// explicitly\n\tif (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {\n\t\treturn true;\n\t}\n\n\t// Internet Explorer and Edge do not support colors.\n\tif (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n\t\treturn false;\n\t}\n\n\t// Is webkit? http://stackoverflow.com/a/16459606/376773\n\t// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n\treturn (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n\t\t// Is firebug? http://stackoverflow.com/a/398120/376773\n\t\t(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n\t\t// Is firefox >= v31?\n\t\t// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\n\t\t// Double check webkit in userAgent just in case we are in a worker\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n\targs[0] = (this.useColors ? '%c' : '') +\n\t\tthis.namespace +\n\t\t(this.useColors ? ' %c' : ' ') +\n\t\targs[0] +\n\t\t(this.useColors ? '%c ' : ' ') +\n\t\t'+' + module.exports.humanize(this.diff);\n\n\tif (!this.useColors) {\n\t\treturn;\n\t}\n\n\tconst c = 'color: ' + this.color;\n\targs.splice(1, 0, c, 'color: inherit');\n\n\t// The final \"%c\" is somewhat tricky, because there could be other\n\t// arguments passed either before or after the %c, so we need to\n\t// figure out the correct index to insert the CSS into\n\tlet index = 0;\n\tlet lastC = 0;\n\targs[0].replace(/%[a-zA-Z%]/g, match => {\n\t\tif (match === '%%') {\n\t\t\treturn;\n\t\t}\n\t\tindex++;\n\t\tif (match === '%c') {\n\t\t\t// We only are interested in the *last* %c\n\t\t\t// (the user may have provided their own)\n\t\t\tlastC = index;\n\t\t}\n\t});\n\n\targs.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.debug()` when available.\n * No-op when `console.debug` is not a \"function\".\n * If `console.debug` is not available, falls back\n * to `console.log`.\n *\n * @api public\n */\nexports.log = console.debug || console.log || (() => {});\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\nfunction save(namespaces) {\n\ttry {\n\t\tif (namespaces) {\n\t\t\texports.storage.setItem('debug', namespaces);\n\t\t} else {\n\t\t\texports.storage.removeItem('debug');\n\t\t}\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\nfunction load() {\n\tlet r;\n\ttry {\n\t\tr = exports.storage.getItem('debug');\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n\n\t// If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n\tif (!r && typeof process !== 'undefined' && 'env' in process) {\n\t\tr = process.env.DEBUG;\n\t}\n\n\treturn r;\n}\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n\ttry {\n\t\t// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context\n\t\t// The Browser also has localStorage in the global context.\n\t\treturn localStorage;\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\nmodule.exports = __webpack_require__(/*! ./common */ \"./node_modules/eslint4b/node_modules/debug/src/common.js\")(exports);\n\nconst {formatters} = module.exports;\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nformatters.j = function (v) {\n\ttry {\n\t\treturn JSON.stringify(v);\n\t} catch (error) {\n\t\treturn '[UnexpectedJSONParseError]: ' + error.message;\n\t}\n};\n\n\n//# sourceURL=webpack://javascript/./node_modules/eslint4b/node_modules/debug/src/browser.js?");

/***/ }),

/***/ "./node_modules/eslint4b/node_modules/debug/src/common.js":
/*!****************************************************************!*\
  !*** ./node_modules/eslint4b/node_modules/debug/src/common.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* provided dependency */ var console = __webpack_require__(/*! ./node_modules/console-browserify/index.js */ \"./node_modules/console-browserify/index.js\");\n\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n */\n\nfunction setup(env) {\n\tcreateDebug.debug = createDebug;\n\tcreateDebug.default = createDebug;\n\tcreateDebug.coerce = coerce;\n\tcreateDebug.disable = disable;\n\tcreateDebug.enable = enable;\n\tcreateDebug.enabled = enabled;\n\tcreateDebug.humanize = __webpack_require__(/*! ms */ \"./node_modules/eslint4b/node_modules/ms/index.js\");\n\tcreateDebug.destroy = destroy;\n\n\tObject.keys(env).forEach(key => {\n\t\tcreateDebug[key] = env[key];\n\t});\n\n\t/**\n\t* The currently active debug mode names, and names to skip.\n\t*/\n\n\tcreateDebug.names = [];\n\tcreateDebug.skips = [];\n\n\t/**\n\t* Map of special \"%n\" handling functions, for the debug \"format\" argument.\n\t*\n\t* Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n\t*/\n\tcreateDebug.formatters = {};\n\n\t/**\n\t* Selects a color for a debug namespace\n\t* @param {String} namespace The namespace string for the debug instance to be colored\n\t* @return {Number|String} An ANSI color code for the given namespace\n\t* @api private\n\t*/\n\tfunction selectColor(namespace) {\n\t\tlet hash = 0;\n\n\t\tfor (let i = 0; i < namespace.length; i++) {\n\t\t\thash = ((hash << 5) - hash) + namespace.charCodeAt(i);\n\t\t\thash |= 0; // Convert to 32bit integer\n\t\t}\n\n\t\treturn createDebug.colors[Math.abs(hash) % createDebug.colors.length];\n\t}\n\tcreateDebug.selectColor = selectColor;\n\n\t/**\n\t* Create a debugger with the given `namespace`.\n\t*\n\t* @param {String} namespace\n\t* @return {Function}\n\t* @api public\n\t*/\n\tfunction createDebug(namespace) {\n\t\tlet prevTime;\n\t\tlet enableOverride = null;\n\t\tlet namespacesCache;\n\t\tlet enabledCache;\n\n\t\tfunction debug(...args) {\n\t\t\t// Disabled?\n\t\t\tif (!debug.enabled) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst self = debug;\n\n\t\t\t// Set `diff` timestamp\n\t\t\tconst curr = Number(new Date());\n\t\t\tconst ms = curr - (prevTime || curr);\n\t\t\tself.diff = ms;\n\t\t\tself.prev = prevTime;\n\t\t\tself.curr = curr;\n\t\t\tprevTime = curr;\n\n\t\t\targs[0] = createDebug.coerce(args[0]);\n\n\t\t\tif (typeof args[0] !== 'string') {\n\t\t\t\t// Anything else let's inspect with %O\n\t\t\t\targs.unshift('%O');\n\t\t\t}\n\n\t\t\t// Apply any `formatters` transformations\n\t\t\tlet index = 0;\n\t\t\targs[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {\n\t\t\t\t// If we encounter an escaped % then don't increase the array index\n\t\t\t\tif (match === '%%') {\n\t\t\t\t\treturn '%';\n\t\t\t\t}\n\t\t\t\tindex++;\n\t\t\t\tconst formatter = createDebug.formatters[format];\n\t\t\t\tif (typeof formatter === 'function') {\n\t\t\t\t\tconst val = args[index];\n\t\t\t\t\tmatch = formatter.call(self, val);\n\n\t\t\t\t\t// Now we need to remove `args[index]` since it's inlined in the `format`\n\t\t\t\t\targs.splice(index, 1);\n\t\t\t\t\tindex--;\n\t\t\t\t}\n\t\t\t\treturn match;\n\t\t\t});\n\n\t\t\t// Apply env-specific formatting (colors, etc.)\n\t\t\tcreateDebug.formatArgs.call(self, args);\n\n\t\t\tconst logFn = self.log || createDebug.log;\n\t\t\tlogFn.apply(self, args);\n\t\t}\n\n\t\tdebug.namespace = namespace;\n\t\tdebug.useColors = createDebug.useColors();\n\t\tdebug.color = createDebug.selectColor(namespace);\n\t\tdebug.extend = extend;\n\t\tdebug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.\n\n\t\tObject.defineProperty(debug, 'enabled', {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: false,\n\t\t\tget: () => {\n\t\t\t\tif (enableOverride !== null) {\n\t\t\t\t\treturn enableOverride;\n\t\t\t\t}\n\t\t\t\tif (namespacesCache !== createDebug.namespaces) {\n\t\t\t\t\tnamespacesCache = createDebug.namespaces;\n\t\t\t\t\tenabledCache = createDebug.enabled(namespace);\n\t\t\t\t}\n\n\t\t\t\treturn enabledCache;\n\t\t\t},\n\t\t\tset: v => {\n\t\t\t\tenableOverride = v;\n\t\t\t}\n\t\t});\n\n\t\t// Env-specific initialization logic for debug instances\n\t\tif (typeof createDebug.init === 'function') {\n\t\t\tcreateDebug.init(debug);\n\t\t}\n\n\t\treturn debug;\n\t}\n\n\tfunction extend(namespace, delimiter) {\n\t\tconst newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);\n\t\tnewDebug.log = this.log;\n\t\treturn newDebug;\n\t}\n\n\t/**\n\t* Enables a debug mode by namespaces. This can include modes\n\t* separated by a colon and wildcards.\n\t*\n\t* @param {String} namespaces\n\t* @api public\n\t*/\n\tfunction enable(namespaces) {\n\t\tcreateDebug.save(namespaces);\n\t\tcreateDebug.namespaces = namespaces;\n\n\t\tcreateDebug.names = [];\n\t\tcreateDebug.skips = [];\n\n\t\tlet i;\n\t\tconst split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n\t\tconst len = split.length;\n\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tif (!split[i]) {\n\t\t\t\t// ignore empty strings\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tnamespaces = split[i].replace(/\\*/g, '.*?');\n\n\t\t\tif (namespaces[0] === '-') {\n\t\t\t\tcreateDebug.skips.push(new RegExp('^' + namespaces.slice(1) + '$'));\n\t\t\t} else {\n\t\t\t\tcreateDebug.names.push(new RegExp('^' + namespaces + '$'));\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t* Disable debug output.\n\t*\n\t* @return {String} namespaces\n\t* @api public\n\t*/\n\tfunction disable() {\n\t\tconst namespaces = [\n\t\t\t...createDebug.names.map(toNamespace),\n\t\t\t...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)\n\t\t].join(',');\n\t\tcreateDebug.enable('');\n\t\treturn namespaces;\n\t}\n\n\t/**\n\t* Returns true if the given mode name is enabled, false otherwise.\n\t*\n\t* @param {String} name\n\t* @return {Boolean}\n\t* @api public\n\t*/\n\tfunction enabled(name) {\n\t\tif (name[name.length - 1] === '*') {\n\t\t\treturn true;\n\t\t}\n\n\t\tlet i;\n\t\tlet len;\n\n\t\tfor (i = 0, len = createDebug.skips.length; i < len; i++) {\n\t\t\tif (createDebug.skips[i].test(name)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0, len = createDebug.names.length; i < len; i++) {\n\t\t\tif (createDebug.names[i].test(name)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t* Convert regexp to namespace\n\t*\n\t* @param {RegExp} regxep\n\t* @return {String} namespace\n\t* @api private\n\t*/\n\tfunction toNamespace(regexp) {\n\t\treturn regexp.toString()\n\t\t\t.substring(2, regexp.toString().length - 2)\n\t\t\t.replace(/\\.\\*\\?$/, '*');\n\t}\n\n\t/**\n\t* Coerce `val`.\n\t*\n\t* @param {Mixed} val\n\t* @return {Mixed}\n\t* @api private\n\t*/\n\tfunction coerce(val) {\n\t\tif (val instanceof Error) {\n\t\t\treturn val.stack || val.message;\n\t\t}\n\t\treturn val;\n\t}\n\n\t/**\n\t* XXX DO NOT USE. This is a temporary stub function.\n\t* XXX It WILL be removed in the next major release.\n\t*/\n\tfunction destroy() {\n\t\tconsole.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n\t}\n\n\tcreateDebug.enable(createDebug.load());\n\n\treturn createDebug;\n}\n\nmodule.exports = setup;\n\n\n//# sourceURL=webpack://javascript/./node_modules/eslint4b/node_modules/debug/src/common.js?");

/***/ }),

/***/ "./node_modules/eslint4b/node_modules/eslint-visitor-keys/lib/index.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/eslint4b/node_modules/eslint-visitor-keys/lib/index.js ***!
  \*****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * @author Toru Nagashima <https://github.com/mysticatea>\n * See LICENSE file in root directory for full license.\n */\n\n\nconst KEYS = __webpack_require__(/*! ./visitor-keys.json */ \"./node_modules/eslint4b/node_modules/eslint-visitor-keys/lib/visitor-keys.json\");\n\n// Types.\nconst NODE_TYPES = Object.freeze(Object.keys(KEYS));\n\n// Freeze the keys.\nfor (const type of NODE_TYPES) {\n    Object.freeze(KEYS[type]);\n}\nObject.freeze(KEYS);\n\n// List to ignore keys.\nconst KEY_BLACKLIST = new Set([\n    \"parent\",\n    \"leadingComments\",\n    \"trailingComments\"\n]);\n\n/**\n * Check whether a given key should be used or not.\n * @param {string} key The key to check.\n * @returns {boolean} `true` if the key should be used.\n */\nfunction filterKey(key) {\n    return !KEY_BLACKLIST.has(key) && key[0] !== \"_\";\n}\n\n//------------------------------------------------------------------------------\n// Public interfaces\n//------------------------------------------------------------------------------\n\nmodule.exports = Object.freeze({\n\n    /**\n     * Visitor keys.\n     * @type {{ [type: string]: string[] | undefined }}\n     */\n    KEYS,\n\n    /**\n     * Get visitor keys of a given node.\n     * @param {Object} node The AST node to get keys.\n     * @returns {string[]} Visitor keys of the node.\n     */\n    getKeys(node) {\n        return Object.keys(node).filter(filterKey);\n    },\n\n    // Disable valid-jsdoc rule because it reports syntax error on the type of @returns.\n    // eslint-disable-next-line valid-jsdoc\n    /**\n     * Make the union set with `KEYS` and given keys.\n     * @param {Object} additionalKeys The additional keys.\n     * @returns {{ [type: string]: string[] | undefined }} The union set.\n     */\n    unionWith(additionalKeys) {\n        const retv = Object.assign({}, KEYS);\n\n        for (const type of Object.keys(additionalKeys)) {\n            if (retv.hasOwnProperty(type)) {\n                const keys = new Set(additionalKeys[type]);\n\n                for (const key of retv[type]) {\n                    keys.add(key);\n                }\n\n                retv[type] = Object.freeze(Array.from(keys));\n            } else {\n                retv[type] = Object.freeze(Array.from(additionalKeys[type]));\n            }\n        }\n\n        return Object.freeze(retv);\n    }\n});\n\n\n//# sourceURL=webpack://javascript/./node_modules/eslint4b/node_modules/eslint-visitor-keys/lib/index.js?");

/***/ }),

/***/ "./node_modules/eslint4b/node_modules/ms/index.js":
/*!********************************************************!*\
  !*** ./node_modules/eslint4b/node_modules/ms/index.js ***!
  \********************************************************/
/***/ ((module) => {

eval("/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar w = d * 7;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isFinite(val)) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'weeks':\n    case 'week':\n    case 'w':\n      return n * w;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (msAbs >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (msAbs >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (msAbs >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return plural(ms, msAbs, d, 'day');\n  }\n  if (msAbs >= h) {\n    return plural(ms, msAbs, h, 'hour');\n  }\n  if (msAbs >= m) {\n    return plural(ms, msAbs, m, 'minute');\n  }\n  if (msAbs >= s) {\n    return plural(ms, msAbs, s, 'second');\n  }\n  return ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, msAbs, n, name) {\n  var isPlural = msAbs >= n * 1.5;\n  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');\n}\n\n\n//# sourceURL=webpack://javascript/./node_modules/eslint4b/node_modules/ms/index.js?");

/***/ }),

/***/ "./node_modules/espree/espree.js":
/*!***************************************!*\
  !*** ./node_modules/espree/espree.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/**\n * @fileoverview Main Espree file that converts Acorn into Esprima output.\n *\n * This file contains code from the following MIT-licensed projects:\n * 1. Acorn\n * 2. Babylon\n * 3. Babel-ESLint\n *\n * This file also contains code from Esprima, which is BSD licensed.\n *\n * Acorn is Copyright 2012-2015 Acorn Contributors (https://github.com/marijnh/acorn/blob/master/AUTHORS)\n * Babylon is Copyright 2014-2015 various contributors (https://github.com/babel/babel/blob/master/packages/babylon/AUTHORS)\n * Babel-ESLint is Copyright 2014-2015 Sebastian McKenzie <sebmck@gmail.com>\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * * Redistributions of source code must retain the above copyright\n *   notice, this list of conditions and the following disclaimer.\n * * Redistributions in binary form must reproduce the above copyright\n *   notice, this list of conditions and the following disclaimer in the\n *   documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * Esprima is Copyright (c) jQuery Foundation, Inc. and Contributors, All Rights Reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *   * Redistributions of source code must retain the above copyright\n *     notice, this list of conditions and the following disclaimer.\n *   * Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in the\n *     documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n/* eslint no-undefined:0, no-use-before-define: 0 */\n\n\n\nconst acorn = __webpack_require__(/*! acorn */ \"./node_modules/espree/node_modules/acorn/dist/acorn.mjs\");\nconst jsx = __webpack_require__(/*! acorn-jsx */ \"./node_modules/acorn-jsx/index.js\");\nconst astNodeTypes = __webpack_require__(/*! ./lib/ast-node-types */ \"./node_modules/espree/lib/ast-node-types.js\");\nconst espree = __webpack_require__(/*! ./lib/espree */ \"./node_modules/espree/lib/espree.js\");\nconst { getLatestEcmaVersion, getSupportedEcmaVersions } = __webpack_require__(/*! ./lib/options */ \"./node_modules/espree/lib/options.js\");\n\n// To initialize lazily.\nconst parsers = {\n    _regular: null,\n    _jsx: null,\n\n    get regular() {\n        if (this._regular === null) {\n            this._regular = acorn.Parser.extend(espree());\n        }\n        return this._regular;\n    },\n\n    get jsx() {\n        if (this._jsx === null) {\n            this._jsx = acorn.Parser.extend(jsx(), espree());\n        }\n        return this._jsx;\n    },\n\n    get(options) {\n        const useJsx = Boolean(\n            options &&\n            options.ecmaFeatures &&\n            options.ecmaFeatures.jsx\n        );\n\n        return useJsx ? this.jsx : this.regular;\n    }\n};\n\n//------------------------------------------------------------------------------\n// Tokenizer\n//------------------------------------------------------------------------------\n\n/**\n * Tokenizes the given code.\n * @param {string} code The code to tokenize.\n * @param {Object} options Options defining how to tokenize.\n * @returns {Token[]} An array of tokens.\n * @throws {SyntaxError} If the input code is invalid.\n * @private\n */\nfunction tokenize(code, options) {\n    const Parser = parsers.get(options);\n\n    // Ensure to collect tokens.\n    if (!options || options.tokens !== true) {\n        options = Object.assign({}, options, { tokens: true }); // eslint-disable-line no-param-reassign\n    }\n\n    return new Parser(options, code).tokenize();\n}\n\n//------------------------------------------------------------------------------\n// Parser\n//------------------------------------------------------------------------------\n\n/**\n * Parses the given code.\n * @param {string} code The code to tokenize.\n * @param {Object} options Options defining how to tokenize.\n * @returns {ASTNode} The \"Program\" AST node.\n * @throws {SyntaxError} If the input code is invalid.\n */\nfunction parse(code, options) {\n    const Parser = parsers.get(options);\n\n    return new Parser(options, code).parse();\n}\n\n//------------------------------------------------------------------------------\n// Public\n//------------------------------------------------------------------------------\n\nexports.version = __webpack_require__(/*! ./package.json */ \"./node_modules/espree/package.json\").version;\n\nexports.tokenize = tokenize;\n\nexports.parse = parse;\n\n// Deep copy.\n/* istanbul ignore next */\nexports.Syntax = (function() {\n    let name,\n        types = {};\n\n    if (typeof Object.create === \"function\") {\n        types = Object.create(null);\n    }\n\n    for (name in astNodeTypes) {\n        if (Object.hasOwnProperty.call(astNodeTypes, name)) {\n            types[name] = astNodeTypes[name];\n        }\n    }\n\n    if (typeof Object.freeze === \"function\") {\n        Object.freeze(types);\n    }\n\n    return types;\n}());\n\n/* istanbul ignore next */\nexports.VisitorKeys = (function() {\n    return (__webpack_require__(/*! eslint-visitor-keys */ \"./node_modules/eslint-visitor-keys/lib/index.js\").KEYS);\n}());\n\nexports.latestEcmaVersion = getLatestEcmaVersion();\n\nexports.supportedEcmaVersions = getSupportedEcmaVersions();\n\n\n//# sourceURL=webpack://javascript/./node_modules/espree/espree.js?");

/***/ }),

/***/ "./node_modules/espree/lib/ast-node-types.js":
/*!***************************************************!*\
  !*** ./node_modules/espree/lib/ast-node-types.js ***!
  \***************************************************/
/***/ ((module) => {

"use strict";
eval("/**\n * @fileoverview The AST node types produced by the parser.\n * @author Nicholas C. Zakas\n */\n\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\n// None!\n\n//------------------------------------------------------------------------------\n// Public\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    AssignmentExpression: \"AssignmentExpression\",\n    AssignmentPattern: \"AssignmentPattern\",\n    ArrayExpression: \"ArrayExpression\",\n    ArrayPattern: \"ArrayPattern\",\n    ArrowFunctionExpression: \"ArrowFunctionExpression\",\n    AwaitExpression: \"AwaitExpression\",\n    BlockStatement: \"BlockStatement\",\n    BinaryExpression: \"BinaryExpression\",\n    BreakStatement: \"BreakStatement\",\n    CallExpression: \"CallExpression\",\n    CatchClause: \"CatchClause\",\n    ClassBody: \"ClassBody\",\n    ClassDeclaration: \"ClassDeclaration\",\n    ClassExpression: \"ClassExpression\",\n    ConditionalExpression: \"ConditionalExpression\",\n    ContinueStatement: \"ContinueStatement\",\n    DoWhileStatement: \"DoWhileStatement\",\n    DebuggerStatement: \"DebuggerStatement\",\n    EmptyStatement: \"EmptyStatement\",\n    ExpressionStatement: \"ExpressionStatement\",\n    ForStatement: \"ForStatement\",\n    ForInStatement: \"ForInStatement\",\n    ForOfStatement: \"ForOfStatement\",\n    FunctionDeclaration: \"FunctionDeclaration\",\n    FunctionExpression: \"FunctionExpression\",\n    Identifier: \"Identifier\",\n    IfStatement: \"IfStatement\",\n    Literal: \"Literal\",\n    LabeledStatement: \"LabeledStatement\",\n    LogicalExpression: \"LogicalExpression\",\n    MemberExpression: \"MemberExpression\",\n    MetaProperty: \"MetaProperty\",\n    MethodDefinition: \"MethodDefinition\",\n    NewExpression: \"NewExpression\",\n    ObjectExpression: \"ObjectExpression\",\n    ObjectPattern: \"ObjectPattern\",\n    Program: \"Program\",\n    Property: \"Property\",\n    RestElement: \"RestElement\",\n    ReturnStatement: \"ReturnStatement\",\n    SequenceExpression: \"SequenceExpression\",\n    SpreadElement: \"SpreadElement\",\n    Super: \"Super\",\n    SwitchCase: \"SwitchCase\",\n    SwitchStatement: \"SwitchStatement\",\n    TaggedTemplateExpression: \"TaggedTemplateExpression\",\n    TemplateElement: \"TemplateElement\",\n    TemplateLiteral: \"TemplateLiteral\",\n    ThisExpression: \"ThisExpression\",\n    ThrowStatement: \"ThrowStatement\",\n    TryStatement: \"TryStatement\",\n    UnaryExpression: \"UnaryExpression\",\n    UpdateExpression: \"UpdateExpression\",\n    VariableDeclaration: \"VariableDeclaration\",\n    VariableDeclarator: \"VariableDeclarator\",\n    WhileStatement: \"WhileStatement\",\n    WithStatement: \"WithStatement\",\n    YieldExpression: \"YieldExpression\",\n    JSXIdentifier: \"JSXIdentifier\",\n    JSXNamespacedName: \"JSXNamespacedName\",\n    JSXMemberExpression: \"JSXMemberExpression\",\n    JSXEmptyExpression: \"JSXEmptyExpression\",\n    JSXExpressionContainer: \"JSXExpressionContainer\",\n    JSXElement: \"JSXElement\",\n    JSXClosingElement: \"JSXClosingElement\",\n    JSXOpeningElement: \"JSXOpeningElement\",\n    JSXAttribute: \"JSXAttribute\",\n    JSXSpreadAttribute: \"JSXSpreadAttribute\",\n    JSXText: \"JSXText\",\n    ExportDefaultDeclaration: \"ExportDefaultDeclaration\",\n    ExportNamedDeclaration: \"ExportNamedDeclaration\",\n    ExportAllDeclaration: \"ExportAllDeclaration\",\n    ExportSpecifier: \"ExportSpecifier\",\n    ImportDeclaration: \"ImportDeclaration\",\n    ImportSpecifier: \"ImportSpecifier\",\n    ImportDefaultSpecifier: \"ImportDefaultSpecifier\",\n    ImportNamespaceSpecifier: \"ImportNamespaceSpecifier\"\n};\n\n\n//# sourceURL=webpack://javascript/./node_modules/espree/lib/ast-node-types.js?");

/***/ }),

/***/ "./node_modules/espree/lib/espree.js":
/*!*******************************************!*\
  !*** ./node_modules/espree/lib/espree.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/* eslint-disable no-param-reassign*/\nconst TokenTranslator = __webpack_require__(/*! ./token-translator */ \"./node_modules/espree/lib/token-translator.js\");\nconst { normalizeOptions } = __webpack_require__(/*! ./options */ \"./node_modules/espree/lib/options.js\");\n\nconst STATE = Symbol(\"espree's internal state\");\nconst ESPRIMA_FINISH_NODE = Symbol(\"espree's esprimaFinishNode\");\n\n\n/**\n * Converts an Acorn comment to a Esprima comment.\n * @param {boolean} block True if it's a block comment, false if not.\n * @param {string} text The text of the comment.\n * @param {int} start The index at which the comment starts.\n * @param {int} end The index at which the comment ends.\n * @param {Location} startLoc The location at which the comment starts.\n * @param {Location} endLoc The location at which the comment ends.\n * @returns {Object} The comment object.\n * @private\n */\nfunction convertAcornCommentToEsprimaComment(block, text, start, end, startLoc, endLoc) {\n    const comment = {\n        type: block ? \"Block\" : \"Line\",\n        value: text\n    };\n\n    if (typeof start === \"number\") {\n        comment.start = start;\n        comment.end = end;\n        comment.range = [start, end];\n    }\n\n    if (typeof startLoc === \"object\") {\n        comment.loc = {\n            start: startLoc,\n            end: endLoc\n        };\n    }\n\n    return comment;\n}\n\nmodule.exports = () => Parser => {\n    const tokTypes = Object.assign({}, Parser.acorn.tokTypes);\n\n    if (Parser.acornJsx) {\n        Object.assign(tokTypes, Parser.acornJsx.tokTypes);\n    }\n\n    return class Espree extends Parser {\n        constructor(opts, code) {\n            if (typeof opts !== \"object\" || opts === null) {\n                opts = {};\n            }\n            if (typeof code !== \"string\" && !(code instanceof String)) {\n                code = String(code);\n            }\n\n            const options = normalizeOptions(opts);\n            const ecmaFeatures = options.ecmaFeatures || {};\n            const tokenTranslator =\n                options.tokens === true\n                    ? new TokenTranslator(tokTypes, code)\n                    : null;\n\n            // Initialize acorn parser.\n            super({\n\n                // TODO: use {...options} when spread is supported(Node.js >= 8.3.0).\n                ecmaVersion: options.ecmaVersion,\n                sourceType: options.sourceType,\n                ranges: options.ranges,\n                locations: options.locations,\n\n                // Truthy value is true for backward compatibility.\n                allowReturnOutsideFunction: Boolean(ecmaFeatures.globalReturn),\n\n                // Collect tokens\n                onToken: token => {\n                    if (tokenTranslator) {\n\n                        // Use `tokens`, `ecmaVersion`, and `jsxAttrValueToken` in the state.\n                        tokenTranslator.onToken(token, this[STATE]);\n                    }\n                    if (token.type !== tokTypes.eof) {\n                        this[STATE].lastToken = token;\n                    }\n                },\n\n                // Collect comments\n                onComment: (block, text, start, end, startLoc, endLoc) => {\n                    if (this[STATE].comments) {\n                        const comment = convertAcornCommentToEsprimaComment(block, text, start, end, startLoc, endLoc);\n\n                        this[STATE].comments.push(comment);\n                    }\n                }\n            }, code);\n\n            // Initialize internal state.\n            this[STATE] = {\n                tokens: tokenTranslator ? [] : null,\n                comments: options.comment === true ? [] : null,\n                impliedStrict: ecmaFeatures.impliedStrict === true && this.options.ecmaVersion >= 5,\n                ecmaVersion: this.options.ecmaVersion,\n                jsxAttrValueToken: false,\n                lastToken: null\n            };\n        }\n\n        tokenize() {\n            do {\n                this.next();\n            } while (this.type !== tokTypes.eof);\n\n            // Consume the final eof token\n            this.next();\n\n            const extra = this[STATE];\n            const tokens = extra.tokens;\n\n            if (extra.comments) {\n                tokens.comments = extra.comments;\n            }\n\n            return tokens;\n        }\n\n        finishNode(...args) {\n            const result = super.finishNode(...args);\n\n            return this[ESPRIMA_FINISH_NODE](result);\n        }\n\n        finishNodeAt(...args) {\n            const result = super.finishNodeAt(...args);\n\n            return this[ESPRIMA_FINISH_NODE](result);\n        }\n\n        parse() {\n            const extra = this[STATE];\n            const program = super.parse();\n\n            program.sourceType = this.options.sourceType;\n\n            if (extra.comments) {\n                program.comments = extra.comments;\n            }\n            if (extra.tokens) {\n                program.tokens = extra.tokens;\n            }\n\n            /*\n             * Adjust opening and closing position of program to match Esprima.\n             * Acorn always starts programs at range 0 whereas Esprima starts at the\n             * first AST node's start (the only real difference is when there's leading\n             * whitespace or leading comments). Acorn also counts trailing whitespace\n             * as part of the program whereas Esprima only counts up to the last token.\n             */\n            if (program.range) {\n                program.range[0] = program.body.length ? program.body[0].range[0] : program.range[0];\n                program.range[1] = extra.lastToken ? extra.lastToken.range[1] : program.range[1];\n            }\n            if (program.loc) {\n                program.loc.start = program.body.length ? program.body[0].loc.start : program.loc.start;\n                program.loc.end = extra.lastToken ? extra.lastToken.loc.end : program.loc.end;\n            }\n\n            return program;\n        }\n\n        parseTopLevel(node) {\n            if (this[STATE].impliedStrict) {\n                this.strict = true;\n            }\n            return super.parseTopLevel(node);\n        }\n\n        /**\n         * Overwrites the default raise method to throw Esprima-style errors.\n         * @param {int} pos The position of the error.\n         * @param {string} message The error message.\n         * @throws {SyntaxError} A syntax error.\n         * @returns {void}\n         */\n        raise(pos, message) {\n            const loc = Parser.acorn.getLineInfo(this.input, pos);\n            const err = new SyntaxError(message);\n\n            err.index = pos;\n            err.lineNumber = loc.line;\n            err.column = loc.column + 1; // acorn uses 0-based columns\n            throw err;\n        }\n\n        /**\n         * Overwrites the default raise method to throw Esprima-style errors.\n         * @param {int} pos The position of the error.\n         * @param {string} message The error message.\n         * @throws {SyntaxError} A syntax error.\n         * @returns {void}\n         */\n        raiseRecoverable(pos, message) {\n            this.raise(pos, message);\n        }\n\n        /**\n         * Overwrites the default unexpected method to throw Esprima-style errors.\n         * @param {int} pos The position of the error.\n         * @throws {SyntaxError} A syntax error.\n         * @returns {void}\n         */\n        unexpected(pos) {\n            let message = \"Unexpected token\";\n\n            if (pos !== null && pos !== void 0) {\n                this.pos = pos;\n\n                if (this.options.locations) {\n                    while (this.pos < this.lineStart) {\n                        this.lineStart = this.input.lastIndexOf(\"\\n\", this.lineStart - 2) + 1;\n                        --this.curLine;\n                    }\n                }\n\n                this.nextToken();\n            }\n\n            if (this.end > this.start) {\n                message += ` ${this.input.slice(this.start, this.end)}`;\n            }\n\n            this.raise(this.start, message);\n        }\n\n        /*\n        * Esprima-FB represents JSX strings as tokens called \"JSXText\", but Acorn-JSX\n        * uses regular tt.string without any distinction between this and regular JS\n        * strings. As such, we intercept an attempt to read a JSX string and set a flag\n        * on extra so that when tokens are converted, the next token will be switched\n        * to JSXText via onToken.\n        */\n        jsx_readString(quote) { // eslint-disable-line camelcase\n            const result = super.jsx_readString(quote);\n\n            if (this.type === tokTypes.string) {\n                this[STATE].jsxAttrValueToken = true;\n            }\n            return result;\n        }\n\n        /**\n         * Performs last-minute Esprima-specific compatibility checks and fixes.\n         * @param {ASTNode} result The node to check.\n         * @returns {ASTNode} The finished node.\n         */\n        [ESPRIMA_FINISH_NODE](result) {\n\n            // Acorn doesn't count the opening and closing backticks as part of templates\n            // so we have to adjust ranges/locations appropriately.\n            if (result.type === \"TemplateElement\") {\n\n                // additional adjustment needed if ${ is the last token\n                const terminalDollarBraceL = this.input.slice(result.end, result.end + 2) === \"${\";\n\n                if (result.range) {\n                    result.range[0]--;\n                    result.range[1] += (terminalDollarBraceL ? 2 : 1);\n                }\n\n                if (result.loc) {\n                    result.loc.start.column--;\n                    result.loc.end.column += (terminalDollarBraceL ? 2 : 1);\n                }\n            }\n\n            if (result.type.indexOf(\"Function\") > -1 && !result.generator) {\n                result.generator = false;\n            }\n\n            return result;\n        }\n    };\n};\n\n\n//# sourceURL=webpack://javascript/./node_modules/espree/lib/espree.js?");

/***/ }),

/***/ "./node_modules/espree/lib/options.js":
/*!********************************************!*\
  !*** ./node_modules/espree/lib/options.js ***!
  \********************************************/
/***/ ((module) => {

"use strict";
eval("/**\n * @fileoverview A collection of methods for processing Espree's options.\n * @author Kai Cataldo\n */\n\n\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst DEFAULT_ECMA_VERSION = 5;\nconst SUPPORTED_VERSIONS = [\n    3,\n    5,\n    6,\n    7,\n    8,\n    9,\n    10,\n    11,\n    12\n];\n\n/**\n * Normalize ECMAScript version from the initial config\n * @param {number} ecmaVersion ECMAScript version from the initial config\n * @throws {Error} throws an error if the ecmaVersion is invalid.\n * @returns {number} normalized ECMAScript version\n */\nfunction normalizeEcmaVersion(ecmaVersion = DEFAULT_ECMA_VERSION) {\n    if (typeof ecmaVersion !== \"number\") {\n        throw new Error(`ecmaVersion must be a number. Received value of type ${typeof ecmaVersion} instead.`);\n    }\n\n    let version = ecmaVersion;\n\n    // Calculate ECMAScript edition number from official year version starting with\n    // ES2015, which corresponds with ES6 (or a difference of 2009).\n    if (version >= 2015) {\n        version -= 2009;\n    }\n\n    if (!SUPPORTED_VERSIONS.includes(version)) {\n        throw new Error(\"Invalid ecmaVersion.\");\n    }\n\n    return version;\n}\n\n/**\n * Normalize sourceType from the initial config\n * @param {string} sourceType to normalize\n * @throws {Error} throw an error if sourceType is invalid\n * @returns {string} normalized sourceType\n */\nfunction normalizeSourceType(sourceType = \"script\") {\n    if (sourceType === \"script\" || sourceType === \"module\") {\n        return sourceType;\n    }\n    throw new Error(\"Invalid sourceType.\");\n}\n\n/**\n * Normalize parserOptions\n * @param {Object} options the parser options to normalize\n * @throws {Error} throw an error if found invalid option.\n * @returns {Object} normalized options\n */\nfunction normalizeOptions(options) {\n    const ecmaVersion = normalizeEcmaVersion(options.ecmaVersion);\n    const sourceType = normalizeSourceType(options.sourceType);\n    const ranges = options.range === true;\n    const locations = options.loc === true;\n\n    if (sourceType === \"module\" && ecmaVersion < 6) {\n        throw new Error(\"sourceType 'module' is not supported when ecmaVersion < 2015. Consider adding `{ ecmaVersion: 2015 }` to the parser options.\");\n    }\n    return Object.assign({}, options, { ecmaVersion, sourceType, ranges, locations });\n}\n\n/**\n * Get the latest ECMAScript version supported by Espree.\n * @returns {number} The latest ECMAScript version.\n */\nfunction getLatestEcmaVersion() {\n    return SUPPORTED_VERSIONS[SUPPORTED_VERSIONS.length - 1];\n}\n\n/**\n * Get the list of ECMAScript versions supported by Espree.\n * @returns {number[]} An array containing the supported ECMAScript versions.\n */\nfunction getSupportedEcmaVersions() {\n    return [...SUPPORTED_VERSIONS];\n}\n\n//------------------------------------------------------------------------------\n// Public\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    normalizeOptions,\n    getLatestEcmaVersion,\n    getSupportedEcmaVersions\n};\n\n\n//# sourceURL=webpack://javascript/./node_modules/espree/lib/options.js?");

/***/ }),

/***/ "./node_modules/espree/lib/token-translator.js":
/*!*****************************************************!*\
  !*** ./node_modules/espree/lib/token-translator.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";
eval("/**\n * @fileoverview Translates tokens between Acorn format and Esprima format.\n * @author Nicholas C. Zakas\n */\n/* eslint no-underscore-dangle: 0 */\n\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\n// none!\n\n//------------------------------------------------------------------------------\n// Private\n//------------------------------------------------------------------------------\n\n\n// Esprima Token Types\nconst Token = {\n    Boolean: \"Boolean\",\n    EOF: \"<end>\",\n    Identifier: \"Identifier\",\n    Keyword: \"Keyword\",\n    Null: \"Null\",\n    Numeric: \"Numeric\",\n    Punctuator: \"Punctuator\",\n    String: \"String\",\n    RegularExpression: \"RegularExpression\",\n    Template: \"Template\",\n    JSXIdentifier: \"JSXIdentifier\",\n    JSXText: \"JSXText\"\n};\n\n/**\n * Converts part of a template into an Esprima token.\n * @param {AcornToken[]} tokens The Acorn tokens representing the template.\n * @param {string} code The source code.\n * @returns {EsprimaToken} The Esprima equivalent of the template token.\n * @private\n */\nfunction convertTemplatePart(tokens, code) {\n    const firstToken = tokens[0],\n        lastTemplateToken = tokens[tokens.length - 1];\n\n    const token = {\n        type: Token.Template,\n        value: code.slice(firstToken.start, lastTemplateToken.end)\n    };\n\n    if (firstToken.loc) {\n        token.loc = {\n            start: firstToken.loc.start,\n            end: lastTemplateToken.loc.end\n        };\n    }\n\n    if (firstToken.range) {\n        token.start = firstToken.range[0];\n        token.end = lastTemplateToken.range[1];\n        token.range = [token.start, token.end];\n    }\n\n    return token;\n}\n\n/**\n * Contains logic to translate Acorn tokens into Esprima tokens.\n * @param {Object} acornTokTypes The Acorn token types.\n * @param {string} code The source code Acorn is parsing. This is necessary\n *      to correct the \"value\" property of some tokens.\n * @constructor\n */\nfunction TokenTranslator(acornTokTypes, code) {\n\n    // token types\n    this._acornTokTypes = acornTokTypes;\n\n    // token buffer for templates\n    this._tokens = [];\n\n    // track the last curly brace\n    this._curlyBrace = null;\n\n    // the source code\n    this._code = code;\n\n}\n\nTokenTranslator.prototype = {\n    constructor: TokenTranslator,\n\n    /**\n     * Translates a single Esprima token to a single Acorn token. This may be\n     * inaccurate due to how templates are handled differently in Esprima and\n     * Acorn, but should be accurate for all other tokens.\n     * @param {AcornToken} token The Acorn token to translate.\n     * @param {Object} extra Espree extra object.\n     * @returns {EsprimaToken} The Esprima version of the token.\n     */\n    translate(token, extra) {\n\n        const type = token.type,\n            tt = this._acornTokTypes;\n\n        if (type === tt.name) {\n            token.type = Token.Identifier;\n\n            // TODO: See if this is an Acorn bug\n            if (token.value === \"static\") {\n                token.type = Token.Keyword;\n            }\n\n            if (extra.ecmaVersion > 5 && (token.value === \"yield\" || token.value === \"let\")) {\n                token.type = Token.Keyword;\n            }\n\n        } else if (type === tt.semi || type === tt.comma ||\n                 type === tt.parenL || type === tt.parenR ||\n                 type === tt.braceL || type === tt.braceR ||\n                 type === tt.dot || type === tt.bracketL ||\n                 type === tt.colon || type === tt.question ||\n                 type === tt.bracketR || type === tt.ellipsis ||\n                 type === tt.arrow || type === tt.jsxTagStart ||\n                 type === tt.incDec || type === tt.starstar ||\n                 type === tt.jsxTagEnd || type === tt.prefix ||\n                 type === tt.questionDot ||\n                 (type.binop && !type.keyword) ||\n                 type.isAssign) {\n\n            token.type = Token.Punctuator;\n            token.value = this._code.slice(token.start, token.end);\n        } else if (type === tt.jsxName) {\n            token.type = Token.JSXIdentifier;\n        } else if (type.label === \"jsxText\" || type === tt.jsxAttrValueToken) {\n            token.type = Token.JSXText;\n        } else if (type.keyword) {\n            if (type.keyword === \"true\" || type.keyword === \"false\") {\n                token.type = Token.Boolean;\n            } else if (type.keyword === \"null\") {\n                token.type = Token.Null;\n            } else {\n                token.type = Token.Keyword;\n            }\n        } else if (type === tt.num) {\n            token.type = Token.Numeric;\n            token.value = this._code.slice(token.start, token.end);\n        } else if (type === tt.string) {\n\n            if (extra.jsxAttrValueToken) {\n                extra.jsxAttrValueToken = false;\n                token.type = Token.JSXText;\n            } else {\n                token.type = Token.String;\n            }\n\n            token.value = this._code.slice(token.start, token.end);\n        } else if (type === tt.regexp) {\n            token.type = Token.RegularExpression;\n            const value = token.value;\n\n            token.regex = {\n                flags: value.flags,\n                pattern: value.pattern\n            };\n            token.value = `/${value.pattern}/${value.flags}`;\n        }\n\n        return token;\n    },\n\n    /**\n     * Function to call during Acorn's onToken handler.\n     * @param {AcornToken} token The Acorn token.\n     * @param {Object} extra The Espree extra object.\n     * @returns {void}\n     */\n    onToken(token, extra) {\n\n        const that = this,\n            tt = this._acornTokTypes,\n            tokens = extra.tokens,\n            templateTokens = this._tokens;\n\n        /**\n         * Flushes the buffered template tokens and resets the template\n         * tracking.\n         * @returns {void}\n         * @private\n         */\n        function translateTemplateTokens() {\n            tokens.push(convertTemplatePart(that._tokens, that._code));\n            that._tokens = [];\n        }\n\n        if (token.type === tt.eof) {\n\n            // might be one last curlyBrace\n            if (this._curlyBrace) {\n                tokens.push(this.translate(this._curlyBrace, extra));\n            }\n\n            return;\n        }\n\n        if (token.type === tt.backQuote) {\n\n            // if there's already a curly, it's not part of the template\n            if (this._curlyBrace) {\n                tokens.push(this.translate(this._curlyBrace, extra));\n                this._curlyBrace = null;\n            }\n\n            templateTokens.push(token);\n\n            // it's the end\n            if (templateTokens.length > 1) {\n                translateTemplateTokens();\n            }\n\n            return;\n        }\n        if (token.type === tt.dollarBraceL) {\n            templateTokens.push(token);\n            translateTemplateTokens();\n            return;\n        }\n        if (token.type === tt.braceR) {\n\n            // if there's already a curly, it's not part of the template\n            if (this._curlyBrace) {\n                tokens.push(this.translate(this._curlyBrace, extra));\n            }\n\n            // store new curly for later\n            this._curlyBrace = token;\n            return;\n        }\n        if (token.type === tt.template || token.type === tt.invalidTemplate) {\n            if (this._curlyBrace) {\n                templateTokens.push(this._curlyBrace);\n                this._curlyBrace = null;\n            }\n\n            templateTokens.push(token);\n            return;\n        }\n\n        if (this._curlyBrace) {\n            tokens.push(this.translate(this._curlyBrace, extra));\n            this._curlyBrace = null;\n        }\n\n        tokens.push(this.translate(token, extra));\n    }\n};\n\n//------------------------------------------------------------------------------\n// Public\n//------------------------------------------------------------------------------\n\nmodule.exports = TokenTranslator;\n\n\n//# sourceURL=webpack://javascript/./node_modules/espree/lib/token-translator.js?");

/***/ }),

/***/ "./node_modules/esquery/dist/esquery.esm.min.js":
/*!******************************************************!*\
  !*** ./node_modules/esquery/dist/esquery.esm.min.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nfunction e(t){return(e=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&\"function\"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?\"symbol\":typeof e})(t)}function t(e,t){return function(e){if(Array.isArray(e))return e}(e)||function(e,t){if(\"undefined\"==typeof Symbol||!(Symbol.iterator in Object(e)))return;var r=[],n=!0,a=!1,o=void 0;try{for(var i,s=e[Symbol.iterator]();!(n=(i=s.next()).done)&&(r.push(i.value),!t||r.length!==t);n=!0);}catch(e){a=!0,o=e}finally{try{n||null==s.return||s.return()}finally{if(a)throw o}}return r}(e,t)||n(e,t)||function(){throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\")}()}function r(e){return function(e){if(Array.isArray(e))return a(e)}(e)||function(e){if(\"undefined\"!=typeof Symbol&&Symbol.iterator in Object(e))return Array.from(e)}(e)||n(e)||function(){throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\")}()}function n(e,t){if(e){if(\"string\"==typeof e)return a(e,t);var r=Object.prototype.toString.call(e).slice(8,-1);return\"Object\"===r&&e.constructor&&(r=e.constructor.name),\"Map\"===r||\"Set\"===r?Array.from(e):\"Arguments\"===r||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)?a(e,t):void 0}}function a(e,t){(null==t||t>e.length)&&(t=e.length);for(var r=0,n=new Array(t);r<t;r++)n[r]=e[r];return n}function o(e,t){var r;if(\"undefined\"==typeof Symbol||null==e[Symbol.iterator]){if(Array.isArray(e)||(r=n(e))||t&&e&&\"number\"==typeof e.length){r&&(e=r);var a=0,o=function(){};return{s:o,n:function(){return a>=e.length?{done:!0}:{done:!1,value:e[a++]}},e:function(e){throw e},f:o}}throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\")}var i,s=!0,l=!1;return{s:function(){r=e[Symbol.iterator]()},n:function(){var e=r.next();return s=e.done,e},e:function(e){l=!0,i=e},f:function(){try{s||null==r.return||r.return()}finally{if(l)throw i}}}}\"undefined\"!=typeof globalThis?globalThis:\"undefined\"!=typeof window?window:\"undefined\"!=typeof __webpack_require__.g?__webpack_require__.g:\"undefined\"!=typeof self&&self;function i(e,t){return e(t={exports:{}},t.exports),t.exports}var s=i((function(e,t){!function e(t){var r,n,a,o,i,s;function l(e){var t,r,n={};for(t in e)e.hasOwnProperty(t)&&(r=e[t],n[t]=\"object\"==typeof r&&null!==r?l(r):r);return n}function u(e,t){this.parent=e,this.key=t}function c(e,t,r,n){this.node=e,this.path=t,this.wrap=r,this.ref=n}function f(){}function p(e){return null!=e&&(\"object\"==typeof e&&\"string\"==typeof e.type)}function h(e,t){return(e===r.ObjectExpression||e===r.ObjectPattern)&&\"properties\"===t}function y(e,t){for(var r=e.length-1;r>=0;--r)if(e[r].node===t)return!0;return!1}function d(e,t){return(new f).traverse(e,t)}function m(e,t){var r;return r=function(e,t){var r,n,a,o;for(n=e.length,a=0;n;)t(e[o=a+(r=n>>>1)])?n=r:(a=o+1,n-=r+1);return a}(t,(function(t){return t.range[0]>e.range[0]})),e.extendedRange=[e.range[0],e.range[1]],r!==t.length&&(e.extendedRange[1]=t[r].range[0]),(r-=1)>=0&&(e.extendedRange[0]=t[r].range[1]),e}return r={AssignmentExpression:\"AssignmentExpression\",AssignmentPattern:\"AssignmentPattern\",ArrayExpression:\"ArrayExpression\",ArrayPattern:\"ArrayPattern\",ArrowFunctionExpression:\"ArrowFunctionExpression\",AwaitExpression:\"AwaitExpression\",BlockStatement:\"BlockStatement\",BinaryExpression:\"BinaryExpression\",BreakStatement:\"BreakStatement\",CallExpression:\"CallExpression\",CatchClause:\"CatchClause\",ChainExpression:\"ChainExpression\",ClassBody:\"ClassBody\",ClassDeclaration:\"ClassDeclaration\",ClassExpression:\"ClassExpression\",ComprehensionBlock:\"ComprehensionBlock\",ComprehensionExpression:\"ComprehensionExpression\",ConditionalExpression:\"ConditionalExpression\",ContinueStatement:\"ContinueStatement\",DebuggerStatement:\"DebuggerStatement\",DirectiveStatement:\"DirectiveStatement\",DoWhileStatement:\"DoWhileStatement\",EmptyStatement:\"EmptyStatement\",ExportAllDeclaration:\"ExportAllDeclaration\",ExportDefaultDeclaration:\"ExportDefaultDeclaration\",ExportNamedDeclaration:\"ExportNamedDeclaration\",ExportSpecifier:\"ExportSpecifier\",ExpressionStatement:\"ExpressionStatement\",ForStatement:\"ForStatement\",ForInStatement:\"ForInStatement\",ForOfStatement:\"ForOfStatement\",FunctionDeclaration:\"FunctionDeclaration\",FunctionExpression:\"FunctionExpression\",GeneratorExpression:\"GeneratorExpression\",Identifier:\"Identifier\",IfStatement:\"IfStatement\",ImportExpression:\"ImportExpression\",ImportDeclaration:\"ImportDeclaration\",ImportDefaultSpecifier:\"ImportDefaultSpecifier\",ImportNamespaceSpecifier:\"ImportNamespaceSpecifier\",ImportSpecifier:\"ImportSpecifier\",Literal:\"Literal\",LabeledStatement:\"LabeledStatement\",LogicalExpression:\"LogicalExpression\",MemberExpression:\"MemberExpression\",MetaProperty:\"MetaProperty\",MethodDefinition:\"MethodDefinition\",ModuleSpecifier:\"ModuleSpecifier\",NewExpression:\"NewExpression\",ObjectExpression:\"ObjectExpression\",ObjectPattern:\"ObjectPattern\",Program:\"Program\",Property:\"Property\",RestElement:\"RestElement\",ReturnStatement:\"ReturnStatement\",SequenceExpression:\"SequenceExpression\",SpreadElement:\"SpreadElement\",Super:\"Super\",SwitchStatement:\"SwitchStatement\",SwitchCase:\"SwitchCase\",TaggedTemplateExpression:\"TaggedTemplateExpression\",TemplateElement:\"TemplateElement\",TemplateLiteral:\"TemplateLiteral\",ThisExpression:\"ThisExpression\",ThrowStatement:\"ThrowStatement\",TryStatement:\"TryStatement\",UnaryExpression:\"UnaryExpression\",UpdateExpression:\"UpdateExpression\",VariableDeclaration:\"VariableDeclaration\",VariableDeclarator:\"VariableDeclarator\",WhileStatement:\"WhileStatement\",WithStatement:\"WithStatement\",YieldExpression:\"YieldExpression\"},a={AssignmentExpression:[\"left\",\"right\"],AssignmentPattern:[\"left\",\"right\"],ArrayExpression:[\"elements\"],ArrayPattern:[\"elements\"],ArrowFunctionExpression:[\"params\",\"body\"],AwaitExpression:[\"argument\"],BlockStatement:[\"body\"],BinaryExpression:[\"left\",\"right\"],BreakStatement:[\"label\"],CallExpression:[\"callee\",\"arguments\"],CatchClause:[\"param\",\"body\"],ChainExpression:[\"expression\"],ClassBody:[\"body\"],ClassDeclaration:[\"id\",\"superClass\",\"body\"],ClassExpression:[\"id\",\"superClass\",\"body\"],ComprehensionBlock:[\"left\",\"right\"],ComprehensionExpression:[\"blocks\",\"filter\",\"body\"],ConditionalExpression:[\"test\",\"consequent\",\"alternate\"],ContinueStatement:[\"label\"],DebuggerStatement:[],DirectiveStatement:[],DoWhileStatement:[\"body\",\"test\"],EmptyStatement:[],ExportAllDeclaration:[\"source\"],ExportDefaultDeclaration:[\"declaration\"],ExportNamedDeclaration:[\"declaration\",\"specifiers\",\"source\"],ExportSpecifier:[\"exported\",\"local\"],ExpressionStatement:[\"expression\"],ForStatement:[\"init\",\"test\",\"update\",\"body\"],ForInStatement:[\"left\",\"right\",\"body\"],ForOfStatement:[\"left\",\"right\",\"body\"],FunctionDeclaration:[\"id\",\"params\",\"body\"],FunctionExpression:[\"id\",\"params\",\"body\"],GeneratorExpression:[\"blocks\",\"filter\",\"body\"],Identifier:[],IfStatement:[\"test\",\"consequent\",\"alternate\"],ImportExpression:[\"source\"],ImportDeclaration:[\"specifiers\",\"source\"],ImportDefaultSpecifier:[\"local\"],ImportNamespaceSpecifier:[\"local\"],ImportSpecifier:[\"imported\",\"local\"],Literal:[],LabeledStatement:[\"label\",\"body\"],LogicalExpression:[\"left\",\"right\"],MemberExpression:[\"object\",\"property\"],MetaProperty:[\"meta\",\"property\"],MethodDefinition:[\"key\",\"value\"],ModuleSpecifier:[],NewExpression:[\"callee\",\"arguments\"],ObjectExpression:[\"properties\"],ObjectPattern:[\"properties\"],Program:[\"body\"],Property:[\"key\",\"value\"],RestElement:[\"argument\"],ReturnStatement:[\"argument\"],SequenceExpression:[\"expressions\"],SpreadElement:[\"argument\"],Super:[],SwitchStatement:[\"discriminant\",\"cases\"],SwitchCase:[\"test\",\"consequent\"],TaggedTemplateExpression:[\"tag\",\"quasi\"],TemplateElement:[],TemplateLiteral:[\"quasis\",\"expressions\"],ThisExpression:[],ThrowStatement:[\"argument\"],TryStatement:[\"block\",\"handler\",\"finalizer\"],UnaryExpression:[\"argument\"],UpdateExpression:[\"argument\"],VariableDeclaration:[\"declarations\"],VariableDeclarator:[\"id\",\"init\"],WhileStatement:[\"test\",\"body\"],WithStatement:[\"object\",\"body\"],YieldExpression:[\"argument\"]},n={Break:o={},Skip:i={},Remove:s={}},u.prototype.replace=function(e){this.parent[this.key]=e},u.prototype.remove=function(){return Array.isArray(this.parent)?(this.parent.splice(this.key,1),!0):(this.replace(null),!1)},f.prototype.path=function(){var e,t,r,n,a;function o(e,t){if(Array.isArray(t))for(r=0,n=t.length;r<n;++r)e.push(t[r]);else e.push(t)}if(!this.__current.path)return null;for(a=[],e=2,t=this.__leavelist.length;e<t;++e)o(a,this.__leavelist[e].path);return o(a,this.__current.path),a},f.prototype.type=function(){return this.current().type||this.__current.wrap},f.prototype.parents=function(){var e,t,r;for(r=[],e=1,t=this.__leavelist.length;e<t;++e)r.push(this.__leavelist[e].node);return r},f.prototype.current=function(){return this.__current.node},f.prototype.__execute=function(e,t){var r,n;return n=void 0,r=this.__current,this.__current=t,this.__state=null,e&&(n=e.call(this,t.node,this.__leavelist[this.__leavelist.length-1].node)),this.__current=r,n},f.prototype.notify=function(e){this.__state=e},f.prototype.skip=function(){this.notify(i)},f.prototype.break=function(){this.notify(o)},f.prototype.remove=function(){this.notify(s)},f.prototype.__initialize=function(e,t){this.visitor=t,this.root=e,this.__worklist=[],this.__leavelist=[],this.__current=null,this.__state=null,this.__fallback=null,\"iteration\"===t.fallback?this.__fallback=Object.keys:\"function\"==typeof t.fallback&&(this.__fallback=t.fallback),this.__keys=a,t.keys&&(this.__keys=Object.assign(Object.create(this.__keys),t.keys))},f.prototype.traverse=function(e,t){var r,n,a,s,l,u,f,d,m,x,v,g;for(this.__initialize(e,t),g={},r=this.__worklist,n=this.__leavelist,r.push(new c(e,null,null,null)),n.push(new c(null,null,null,null));r.length;)if((a=r.pop())!==g){if(a.node){if(u=this.__execute(t.enter,a),this.__state===o||u===o)return;if(r.push(g),n.push(a),this.__state===i||u===i)continue;if(l=(s=a.node).type||a.wrap,!(x=this.__keys[l])){if(!this.__fallback)throw new Error(\"Unknown node type \"+l+\".\");x=this.__fallback(s)}for(d=x.length;(d-=1)>=0;)if(v=s[f=x[d]])if(Array.isArray(v)){for(m=v.length;(m-=1)>=0;)if(v[m]&&!y(n,v[m])){if(h(l,x[d]))a=new c(v[m],[f,m],\"Property\",null);else{if(!p(v[m]))continue;a=new c(v[m],[f,m],null,null)}r.push(a)}}else if(p(v)){if(y(n,v))continue;r.push(new c(v,f,null,null))}}}else if(a=n.pop(),u=this.__execute(t.leave,a),this.__state===o||u===o)return},f.prototype.replace=function(e,t){var r,n,a,l,f,y,d,m,x,v,g,b,A;function E(e){var t,n,a,o;if(e.ref.remove())for(n=e.ref.key,o=e.ref.parent,t=r.length;t--;)if((a=r[t]).ref&&a.ref.parent===o){if(a.ref.key<n)break;--a.ref.key}}for(this.__initialize(e,t),g={},r=this.__worklist,n=this.__leavelist,y=new c(e,null,null,new u(b={root:e},\"root\")),r.push(y),n.push(y);r.length;)if((y=r.pop())!==g){if(void 0!==(f=this.__execute(t.enter,y))&&f!==o&&f!==i&&f!==s&&(y.ref.replace(f),y.node=f),this.__state!==s&&f!==s||(E(y),y.node=null),this.__state===o||f===o)return b.root;if((a=y.node)&&(r.push(g),n.push(y),this.__state!==i&&f!==i)){if(l=a.type||y.wrap,!(x=this.__keys[l])){if(!this.__fallback)throw new Error(\"Unknown node type \"+l+\".\");x=this.__fallback(a)}for(d=x.length;(d-=1)>=0;)if(v=a[A=x[d]])if(Array.isArray(v)){for(m=v.length;(m-=1)>=0;)if(v[m]){if(h(l,x[d]))y=new c(v[m],[A,m],\"Property\",new u(v,m));else{if(!p(v[m]))continue;y=new c(v[m],[A,m],null,new u(v,m))}r.push(y)}}else p(v)&&r.push(new c(v,A,null,new u(a,A)))}}else if(y=n.pop(),void 0!==(f=this.__execute(t.leave,y))&&f!==o&&f!==i&&f!==s&&y.ref.replace(f),this.__state!==s&&f!==s||E(y),this.__state===o||f===o)return b.root;return b.root},t.Syntax=r,t.traverse=d,t.replace=function(e,t){return(new f).replace(e,t)},t.attachComments=function(e,t,r){var a,o,i,s,u=[];if(!e.range)throw new Error(\"attachComments needs range information\");if(!r.length){if(t.length){for(i=0,o=t.length;i<o;i+=1)(a=l(t[i])).extendedRange=[0,e.range[0]],u.push(a);e.leadingComments=u}return e}for(i=0,o=t.length;i<o;i+=1)u.push(m(l(t[i]),r));return s=0,d(e,{enter:function(e){for(var t;s<u.length&&!((t=u[s]).extendedRange[1]>e.range[0]);)t.extendedRange[1]===e.range[0]?(e.leadingComments||(e.leadingComments=[]),e.leadingComments.push(t),u.splice(s,1)):s+=1;return s===u.length?n.Break:u[s].extendedRange[0]>e.range[1]?n.Skip:void 0}}),s=0,d(e,{leave:function(e){for(var t;s<u.length&&(t=u[s],!(e.range[1]<t.extendedRange[0]));)e.range[1]===t.extendedRange[0]?(e.trailingComments||(e.trailingComments=[]),e.trailingComments.push(t),u.splice(s,1)):s+=1;return s===u.length?n.Break:u[s].extendedRange[0]>e.range[1]?n.Skip:void 0}}),e},t.VisitorKeys=a,t.VisitorOption=n,t.Controller=f,t.cloneEnvironment=function(){return e({})},t}(t)})),l=i((function(e){e.exports&&(e.exports=function(){function e(t,r,n,a){this.message=t,this.expected=r,this.found=n,this.location=a,this.name=\"SyntaxError\",\"function\"==typeof Error.captureStackTrace&&Error.captureStackTrace(this,e)}return function(e,t){function r(){this.constructor=e}r.prototype=t.prototype,e.prototype=new r}(e,Error),e.buildMessage=function(e,t){var r={literal:function(e){return'\"'+a(e.text)+'\"'},class:function(e){var t,r=\"\";for(t=0;t<e.parts.length;t++)r+=e.parts[t]instanceof Array?o(e.parts[t][0])+\"-\"+o(e.parts[t][1]):o(e.parts[t]);return\"[\"+(e.inverted?\"^\":\"\")+r+\"]\"},any:function(e){return\"any character\"},end:function(e){return\"end of input\"},other:function(e){return e.description}};function n(e){return e.charCodeAt(0).toString(16).toUpperCase()}function a(e){return e.replace(/\\\\/g,\"\\\\\\\\\").replace(/\"/g,'\\\\\"').replace(/\\0/g,\"\\\\0\").replace(/\\t/g,\"\\\\t\").replace(/\\n/g,\"\\\\n\").replace(/\\r/g,\"\\\\r\").replace(/[\\x00-\\x0F]/g,(function(e){return\"\\\\x0\"+n(e)})).replace(/[\\x10-\\x1F\\x7F-\\x9F]/g,(function(e){return\"\\\\x\"+n(e)}))}function o(e){return e.replace(/\\\\/g,\"\\\\\\\\\").replace(/\\]/g,\"\\\\]\").replace(/\\^/g,\"\\\\^\").replace(/-/g,\"\\\\-\").replace(/\\0/g,\"\\\\0\").replace(/\\t/g,\"\\\\t\").replace(/\\n/g,\"\\\\n\").replace(/\\r/g,\"\\\\r\").replace(/[\\x00-\\x0F]/g,(function(e){return\"\\\\x0\"+n(e)})).replace(/[\\x10-\\x1F\\x7F-\\x9F]/g,(function(e){return\"\\\\x\"+n(e)}))}return\"Expected \"+function(e){var t,n,a,o=new Array(e.length);for(t=0;t<e.length;t++)o[t]=(a=e[t],r[a.type](a));if(o.sort(),o.length>0){for(t=1,n=1;t<o.length;t++)o[t-1]!==o[t]&&(o[n]=o[t],n++);o.length=n}switch(o.length){case 1:return o[0];case 2:return o[0]+\" or \"+o[1];default:return o.slice(0,-1).join(\", \")+\", or \"+o[o.length-1]}}(e)+\" but \"+function(e){return e?'\"'+a(e)+'\"':\"end of input\"}(t)+\" found.\"},{SyntaxError:e,parse:function(t,r){r=void 0!==r?r:{};var n,a,o,i,s={},l={start:be},u=be,c=de(\" \",!1),f=/^[^ [\\],():#!=><~+.]/,p=me([\" \",\"[\",\"]\",\",\",\"(\",\")\",\":\",\"#\",\"!\",\"=\",\">\",\"<\",\"~\",\"+\",\".\"],!0,!1),h=de(\">\",!1),y=de(\"~\",!1),d=de(\"+\",!1),m=de(\",\",!1),x=de(\"!\",!1),v=de(\"*\",!1),g=de(\"#\",!1),b=de(\"[\",!1),A=de(\"]\",!1),E=/^[><!]/,S=me([\">\",\"<\",\"!\"],!1,!1),_=de(\"=\",!1),w=function(e){return(e||\"\")+\"=\"},C=/^[><]/,P=me([\">\",\"<\"],!1,!1),k=de(\".\",!1),D=function(e,t,r){return{type:\"attribute\",name:e,operator:t,value:r}},j=de('\"',!1),I=/^[^\\\\\"]/,T=me([\"\\\\\",'\"'],!0,!1),F=de(\"\\\\\",!1),L={type:\"any\"},O=function(e,t){return e+t},R=function(e){return{type:\"literal\",value:(t=e.join(\"\"),t.replace(/\\\\(.)/g,(function(e,t){switch(t){case\"b\":return\"\\b\";case\"f\":return\"\\f\";case\"n\":return\"\\n\";case\"r\":return\"\\r\";case\"t\":return\"\\t\";case\"v\":return\"\\v\";default:return t}})))};var t},B=de(\"'\",!1),M=/^[^\\\\']/,U=me([\"\\\\\",\"'\"],!0,!1),V=/^[0-9]/,q=me([[\"0\",\"9\"]],!1,!1),N=de(\"type(\",!1),W=/^[^ )]/,K=me([\" \",\")\"],!0,!1),G=de(\")\",!1),z=/^[imsu]/,H=me([\"i\",\"m\",\"s\",\"u\"],!1,!1),Y=de(\"/\",!1),$=/^[^\\/]/,J=me([\"/\"],!0,!1),Q=de(\":not(\",!1),X=de(\":matches(\",!1),Z=de(\":has(\",!1),ee=de(\":first-child\",!1),te=de(\":last-child\",!1),re=de(\":nth-child(\",!1),ne=de(\":nth-last-child(\",!1),ae=de(\":\",!1),oe=de(\"statement\",!0),ie=de(\"expression\",!0),se=de(\"declaration\",!0),le=de(\"function\",!0),ue=de(\"pattern\",!0),ce=0,fe=[{line:1,column:1}],pe=0,he=[],ye={};if(\"startRule\"in r){if(!(r.startRule in l))throw new Error(\"Can't start parsing from rule \\\"\"+r.startRule+'\".');u=l[r.startRule]}function de(e,t){return{type:\"literal\",text:e,ignoreCase:t}}function me(e,t,r){return{type:\"class\",parts:e,inverted:t,ignoreCase:r}}function xe(e){var r,n=fe[e];if(n)return n;for(r=e-1;!fe[r];)r--;for(n={line:(n=fe[r]).line,column:n.column};r<e;)10===t.charCodeAt(r)?(n.line++,n.column=1):n.column++,r++;return fe[e]=n,n}function ve(e,t){var r=xe(e),n=xe(t);return{start:{offset:e,line:r.line,column:r.column},end:{offset:t,line:n.line,column:n.column}}}function ge(e){ce<pe||(ce>pe&&(pe=ce,he=[]),he.push(e))}function be(){var e,t,r,n,a=30*ce+0,o=ye[a];return o?(ce=o.nextPos,o.result):(e=ce,(t=Ae())!==s&&(r=_e())!==s&&Ae()!==s?e=t=1===(n=r).length?n[0]:{type:\"matches\",selectors:n}:(ce=e,e=s),e===s&&(e=ce,(t=Ae())!==s&&(t=void 0),e=t),ye[a]={nextPos:ce,result:e},e)}function Ae(){var e,r,n=30*ce+1,a=ye[n];if(a)return ce=a.nextPos,a.result;for(e=[],32===t.charCodeAt(ce)?(r=\" \",ce++):(r=s,ge(c));r!==s;)e.push(r),32===t.charCodeAt(ce)?(r=\" \",ce++):(r=s,ge(c));return ye[n]={nextPos:ce,result:e},e}function Ee(){var e,r,n,a=30*ce+2,o=ye[a];if(o)return ce=o.nextPos,o.result;if(r=[],f.test(t.charAt(ce))?(n=t.charAt(ce),ce++):(n=s,ge(p)),n!==s)for(;n!==s;)r.push(n),f.test(t.charAt(ce))?(n=t.charAt(ce),ce++):(n=s,ge(p));else r=s;return r!==s&&(r=r.join(\"\")),e=r,ye[a]={nextPos:ce,result:e},e}function Se(){var e,r,n,a=30*ce+3,o=ye[a];return o?(ce=o.nextPos,o.result):(e=ce,(r=Ae())!==s?(62===t.charCodeAt(ce)?(n=\">\",ce++):(n=s,ge(h)),n!==s&&Ae()!==s?e=r=\"child\":(ce=e,e=s)):(ce=e,e=s),e===s&&(e=ce,(r=Ae())!==s?(126===t.charCodeAt(ce)?(n=\"~\",ce++):(n=s,ge(y)),n!==s&&Ae()!==s?e=r=\"sibling\":(ce=e,e=s)):(ce=e,e=s),e===s&&(e=ce,(r=Ae())!==s?(43===t.charCodeAt(ce)?(n=\"+\",ce++):(n=s,ge(d)),n!==s&&Ae()!==s?e=r=\"adjacent\":(ce=e,e=s)):(ce=e,e=s),e===s&&(e=ce,32===t.charCodeAt(ce)?(r=\" \",ce++):(r=s,ge(c)),r!==s&&(n=Ae())!==s?e=r=\"descendant\":(ce=e,e=s)))),ye[a]={nextPos:ce,result:e},e)}function _e(){var e,r,n,a,o,i,l,u,c=30*ce+4,f=ye[c];if(f)return ce=f.nextPos,f.result;if(e=ce,(r=we())!==s){for(n=[],a=ce,(o=Ae())!==s?(44===t.charCodeAt(ce)?(i=\",\",ce++):(i=s,ge(m)),i!==s&&(l=Ae())!==s&&(u=we())!==s?a=o=[o,i,l,u]:(ce=a,a=s)):(ce=a,a=s);a!==s;)n.push(a),a=ce,(o=Ae())!==s?(44===t.charCodeAt(ce)?(i=\",\",ce++):(i=s,ge(m)),i!==s&&(l=Ae())!==s&&(u=we())!==s?a=o=[o,i,l,u]:(ce=a,a=s)):(ce=a,a=s);n!==s?e=r=[r].concat(n.map((function(e){return e[3]}))):(ce=e,e=s)}else ce=e,e=s;return ye[c]={nextPos:ce,result:e},e}function we(){var e,t,r,n,a,o,i,l=30*ce+5,u=ye[l];if(u)return ce=u.nextPos,u.result;if(e=ce,(t=Ce())!==s){for(r=[],n=ce,(a=Se())!==s&&(o=Ce())!==s?n=a=[a,o]:(ce=n,n=s);n!==s;)r.push(n),n=ce,(a=Se())!==s&&(o=Ce())!==s?n=a=[a,o]:(ce=n,n=s);r!==s?(i=t,e=t=r.reduce((function(e,t){return{type:t[0],left:e,right:t[1]}}),i)):(ce=e,e=s)}else ce=e,e=s;return ye[l]={nextPos:ce,result:e},e}function Ce(){var e,r,n,a,o,i,l,u=30*ce+6,c=ye[u];if(c)return ce=c.nextPos,c.result;if(e=ce,33===t.charCodeAt(ce)?(r=\"!\",ce++):(r=s,ge(x)),r===s&&(r=null),r!==s){if(n=[],(a=Pe())!==s)for(;a!==s;)n.push(a),a=Pe();else n=s;n!==s?(o=r,l=1===(i=n).length?i[0]:{type:\"compound\",selectors:i},o&&(l.subject=!0),e=r=l):(ce=e,e=s)}else ce=e,e=s;return ye[u]={nextPos:ce,result:e},e}function Pe(){var e,r=30*ce+7,n=ye[r];return n?(ce=n.nextPos,n.result):((e=function(){var e,r,n=30*ce+8,a=ye[n];return a?(ce=a.nextPos,a.result):(42===t.charCodeAt(ce)?(r=\"*\",ce++):(r=s,ge(v)),r!==s&&(r={type:\"wildcard\",value:r}),e=r,ye[n]={nextPos:ce,result:e},e)}())===s&&(e=function(){var e,r,n,a=30*ce+9,o=ye[a];return o?(ce=o.nextPos,o.result):(e=ce,35===t.charCodeAt(ce)?(r=\"#\",ce++):(r=s,ge(g)),r===s&&(r=null),r!==s&&(n=Ee())!==s?e=r={type:\"identifier\",value:n}:(ce=e,e=s),ye[a]={nextPos:ce,result:e},e)}())===s&&(e=function(){var e,r,n,a,o=30*ce+10,i=ye[o];return i?(ce=i.nextPos,i.result):(e=ce,91===t.charCodeAt(ce)?(r=\"[\",ce++):(r=s,ge(b)),r!==s&&Ae()!==s&&(n=function(){var e,r,n,a,o=30*ce+14,i=ye[o];return i?(ce=i.nextPos,i.result):(e=ce,(r=ke())!==s&&Ae()!==s&&(n=function(){var e,r,n,a=30*ce+12,o=ye[a];return o?(ce=o.nextPos,o.result):(e=ce,33===t.charCodeAt(ce)?(r=\"!\",ce++):(r=s,ge(x)),r===s&&(r=null),r!==s?(61===t.charCodeAt(ce)?(n=\"=\",ce++):(n=s,ge(_)),n!==s?(r=w(r),e=r):(ce=e,e=s)):(ce=e,e=s),ye[a]={nextPos:ce,result:e},e)}())!==s&&Ae()!==s?((a=function(){var e,r,n,a,o,i=30*ce+18,l=ye[i];if(l)return ce=l.nextPos,l.result;if(e=ce,\"type(\"===t.substr(ce,5)?(r=\"type(\",ce+=5):(r=s,ge(N)),r!==s)if(Ae()!==s){if(n=[],W.test(t.charAt(ce))?(a=t.charAt(ce),ce++):(a=s,ge(K)),a!==s)for(;a!==s;)n.push(a),W.test(t.charAt(ce))?(a=t.charAt(ce),ce++):(a=s,ge(K));else n=s;n!==s&&(a=Ae())!==s?(41===t.charCodeAt(ce)?(o=\")\",ce++):(o=s,ge(G)),o!==s?(r={type:\"type\",value:n.join(\"\")},e=r):(ce=e,e=s)):(ce=e,e=s)}else ce=e,e=s;else ce=e,e=s;return ye[i]={nextPos:ce,result:e},e}())===s&&(a=function(){var e,r,n,a,o,i,l=30*ce+20,u=ye[l];if(u)return ce=u.nextPos,u.result;if(e=ce,47===t.charCodeAt(ce)?(r=\"/\",ce++):(r=s,ge(Y)),r!==s){if(n=[],$.test(t.charAt(ce))?(a=t.charAt(ce),ce++):(a=s,ge(J)),a!==s)for(;a!==s;)n.push(a),$.test(t.charAt(ce))?(a=t.charAt(ce),ce++):(a=s,ge(J));else n=s;n!==s?(47===t.charCodeAt(ce)?(a=\"/\",ce++):(a=s,ge(Y)),a!==s?((o=function(){var e,r,n=30*ce+19,a=ye[n];if(a)return ce=a.nextPos,a.result;if(e=[],z.test(t.charAt(ce))?(r=t.charAt(ce),ce++):(r=s,ge(H)),r!==s)for(;r!==s;)e.push(r),z.test(t.charAt(ce))?(r=t.charAt(ce),ce++):(r=s,ge(H));else e=s;return ye[n]={nextPos:ce,result:e},e}())===s&&(o=null),o!==s?(i=o,r={type:\"regexp\",value:new RegExp(n.join(\"\"),i?i.join(\"\"):\"\")},e=r):(ce=e,e=s)):(ce=e,e=s)):(ce=e,e=s)}else ce=e,e=s;return ye[l]={nextPos:ce,result:e},e}()),a!==s?(r=D(r,n,a),e=r):(ce=e,e=s)):(ce=e,e=s),e===s&&(e=ce,(r=ke())!==s&&Ae()!==s&&(n=function(){var e,r,n,a=30*ce+11,o=ye[a];return o?(ce=o.nextPos,o.result):(e=ce,E.test(t.charAt(ce))?(r=t.charAt(ce),ce++):(r=s,ge(S)),r===s&&(r=null),r!==s?(61===t.charCodeAt(ce)?(n=\"=\",ce++):(n=s,ge(_)),n!==s?(r=w(r),e=r):(ce=e,e=s)):(ce=e,e=s),e===s&&(C.test(t.charAt(ce))?(e=t.charAt(ce),ce++):(e=s,ge(P))),ye[a]={nextPos:ce,result:e},e)}())!==s&&Ae()!==s?((a=function(){var e,r,n,a,o,i,l=30*ce+15,u=ye[l];if(u)return ce=u.nextPos,u.result;if(e=ce,34===t.charCodeAt(ce)?(r='\"',ce++):(r=s,ge(j)),r!==s){for(n=[],I.test(t.charAt(ce))?(a=t.charAt(ce),ce++):(a=s,ge(T)),a===s&&(a=ce,92===t.charCodeAt(ce)?(o=\"\\\\\",ce++):(o=s,ge(F)),o!==s?(t.length>ce?(i=t.charAt(ce),ce++):(i=s,ge(L)),i!==s?(o=O(o,i),a=o):(ce=a,a=s)):(ce=a,a=s));a!==s;)n.push(a),I.test(t.charAt(ce))?(a=t.charAt(ce),ce++):(a=s,ge(T)),a===s&&(a=ce,92===t.charCodeAt(ce)?(o=\"\\\\\",ce++):(o=s,ge(F)),o!==s?(t.length>ce?(i=t.charAt(ce),ce++):(i=s,ge(L)),i!==s?(o=O(o,i),a=o):(ce=a,a=s)):(ce=a,a=s));n!==s?(34===t.charCodeAt(ce)?(a='\"',ce++):(a=s,ge(j)),a!==s?(r=R(n),e=r):(ce=e,e=s)):(ce=e,e=s)}else ce=e,e=s;if(e===s)if(e=ce,39===t.charCodeAt(ce)?(r=\"'\",ce++):(r=s,ge(B)),r!==s){for(n=[],M.test(t.charAt(ce))?(a=t.charAt(ce),ce++):(a=s,ge(U)),a===s&&(a=ce,92===t.charCodeAt(ce)?(o=\"\\\\\",ce++):(o=s,ge(F)),o!==s?(t.length>ce?(i=t.charAt(ce),ce++):(i=s,ge(L)),i!==s?(o=O(o,i),a=o):(ce=a,a=s)):(ce=a,a=s));a!==s;)n.push(a),M.test(t.charAt(ce))?(a=t.charAt(ce),ce++):(a=s,ge(U)),a===s&&(a=ce,92===t.charCodeAt(ce)?(o=\"\\\\\",ce++):(o=s,ge(F)),o!==s?(t.length>ce?(i=t.charAt(ce),ce++):(i=s,ge(L)),i!==s?(o=O(o,i),a=o):(ce=a,a=s)):(ce=a,a=s));n!==s?(39===t.charCodeAt(ce)?(a=\"'\",ce++):(a=s,ge(B)),a!==s?(r=R(n),e=r):(ce=e,e=s)):(ce=e,e=s)}else ce=e,e=s;return ye[l]={nextPos:ce,result:e},e}())===s&&(a=function(){var e,r,n,a,o,i,l,u=30*ce+16,c=ye[u];if(c)return ce=c.nextPos,c.result;for(e=ce,r=ce,n=[],V.test(t.charAt(ce))?(a=t.charAt(ce),ce++):(a=s,ge(q));a!==s;)n.push(a),V.test(t.charAt(ce))?(a=t.charAt(ce),ce++):(a=s,ge(q));if(n!==s?(46===t.charCodeAt(ce)?(a=\".\",ce++):(a=s,ge(k)),a!==s?r=n=[n,a]:(ce=r,r=s)):(ce=r,r=s),r===s&&(r=null),r!==s){if(n=[],V.test(t.charAt(ce))?(a=t.charAt(ce),ce++):(a=s,ge(q)),a!==s)for(;a!==s;)n.push(a),V.test(t.charAt(ce))?(a=t.charAt(ce),ce++):(a=s,ge(q));else n=s;n!==s?(i=n,l=(o=r)?[].concat.apply([],o).join(\"\"):\"\",r={type:\"literal\",value:parseFloat(l+i.join(\"\"))},e=r):(ce=e,e=s)}else ce=e,e=s;return ye[u]={nextPos:ce,result:e},e}())===s&&(a=function(){var e,t,r=30*ce+17,n=ye[r];return n?(ce=n.nextPos,n.result):((t=Ee())!==s&&(t={type:\"literal\",value:t}),e=t,ye[r]={nextPos:ce,result:e},e)}()),a!==s?(r=D(r,n,a),e=r):(ce=e,e=s)):(ce=e,e=s),e===s&&(e=ce,(r=ke())!==s&&(r={type:\"attribute\",name:r}),e=r)),ye[o]={nextPos:ce,result:e},e)}())!==s&&Ae()!==s?(93===t.charCodeAt(ce)?(a=\"]\",ce++):(a=s,ge(A)),a!==s?e=r=n:(ce=e,e=s)):(ce=e,e=s),ye[o]={nextPos:ce,result:e},e)}())===s&&(e=function(){var e,r,n,a,o,i,l,u,c=30*ce+21,f=ye[c];if(f)return ce=f.nextPos,f.result;if(e=ce,46===t.charCodeAt(ce)?(r=\".\",ce++):(r=s,ge(k)),r!==s)if((n=Ee())!==s){for(a=[],o=ce,46===t.charCodeAt(ce)?(i=\".\",ce++):(i=s,ge(k)),i!==s&&(l=Ee())!==s?o=i=[i,l]:(ce=o,o=s);o!==s;)a.push(o),o=ce,46===t.charCodeAt(ce)?(i=\".\",ce++):(i=s,ge(k)),i!==s&&(l=Ee())!==s?o=i=[i,l]:(ce=o,o=s);a!==s?(u=n,r={type:\"field\",name:a.reduce((function(e,t){return e+t[0]+t[1]}),u)},e=r):(ce=e,e=s)}else ce=e,e=s;else ce=e,e=s;return ye[c]={nextPos:ce,result:e},e}())===s&&(e=function(){var e,r,n,a,o=30*ce+22,i=ye[o];return i?(ce=i.nextPos,i.result):(e=ce,\":not(\"===t.substr(ce,5)?(r=\":not(\",ce+=5):(r=s,ge(Q)),r!==s&&Ae()!==s&&(n=_e())!==s&&Ae()!==s?(41===t.charCodeAt(ce)?(a=\")\",ce++):(a=s,ge(G)),a!==s?e=r={type:\"not\",selectors:n}:(ce=e,e=s)):(ce=e,e=s),ye[o]={nextPos:ce,result:e},e)}())===s&&(e=function(){var e,r,n,a,o=30*ce+23,i=ye[o];return i?(ce=i.nextPos,i.result):(e=ce,\":matches(\"===t.substr(ce,9)?(r=\":matches(\",ce+=9):(r=s,ge(X)),r!==s&&Ae()!==s&&(n=_e())!==s&&Ae()!==s?(41===t.charCodeAt(ce)?(a=\")\",ce++):(a=s,ge(G)),a!==s?e=r={type:\"matches\",selectors:n}:(ce=e,e=s)):(ce=e,e=s),ye[o]={nextPos:ce,result:e},e)}())===s&&(e=function(){var e,r,n,a,o=30*ce+24,i=ye[o];return i?(ce=i.nextPos,i.result):(e=ce,\":has(\"===t.substr(ce,5)?(r=\":has(\",ce+=5):(r=s,ge(Z)),r!==s&&Ae()!==s&&(n=_e())!==s&&Ae()!==s?(41===t.charCodeAt(ce)?(a=\")\",ce++):(a=s,ge(G)),a!==s?e=r={type:\"has\",selectors:n}:(ce=e,e=s)):(ce=e,e=s),ye[o]={nextPos:ce,result:e},e)}())===s&&(e=function(){var e,r,n=30*ce+25,a=ye[n];return a?(ce=a.nextPos,a.result):(\":first-child\"===t.substr(ce,12)?(r=\":first-child\",ce+=12):(r=s,ge(ee)),r!==s&&(r=De(1)),e=r,ye[n]={nextPos:ce,result:e},e)}())===s&&(e=function(){var e,r,n=30*ce+26,a=ye[n];return a?(ce=a.nextPos,a.result):(\":last-child\"===t.substr(ce,11)?(r=\":last-child\",ce+=11):(r=s,ge(te)),r!==s&&(r=je(1)),e=r,ye[n]={nextPos:ce,result:e},e)}())===s&&(e=function(){var e,r,n,a,o,i=30*ce+27,l=ye[i];if(l)return ce=l.nextPos,l.result;if(e=ce,\":nth-child(\"===t.substr(ce,11)?(r=\":nth-child(\",ce+=11):(r=s,ge(re)),r!==s)if(Ae()!==s){if(n=[],V.test(t.charAt(ce))?(a=t.charAt(ce),ce++):(a=s,ge(q)),a!==s)for(;a!==s;)n.push(a),V.test(t.charAt(ce))?(a=t.charAt(ce),ce++):(a=s,ge(q));else n=s;n!==s&&(a=Ae())!==s?(41===t.charCodeAt(ce)?(o=\")\",ce++):(o=s,ge(G)),o!==s?(r=De(parseInt(n.join(\"\"),10)),e=r):(ce=e,e=s)):(ce=e,e=s)}else ce=e,e=s;else ce=e,e=s;return ye[i]={nextPos:ce,result:e},e}())===s&&(e=function(){var e,r,n,a,o,i=30*ce+28,l=ye[i];if(l)return ce=l.nextPos,l.result;if(e=ce,\":nth-last-child(\"===t.substr(ce,16)?(r=\":nth-last-child(\",ce+=16):(r=s,ge(ne)),r!==s)if(Ae()!==s){if(n=[],V.test(t.charAt(ce))?(a=t.charAt(ce),ce++):(a=s,ge(q)),a!==s)for(;a!==s;)n.push(a),V.test(t.charAt(ce))?(a=t.charAt(ce),ce++):(a=s,ge(q));else n=s;n!==s&&(a=Ae())!==s?(41===t.charCodeAt(ce)?(o=\")\",ce++):(o=s,ge(G)),o!==s?(r=je(parseInt(n.join(\"\"),10)),e=r):(ce=e,e=s)):(ce=e,e=s)}else ce=e,e=s;else ce=e,e=s;return ye[i]={nextPos:ce,result:e},e}())===s&&(e=function(){var e,r,n,a=30*ce+29,o=ye[a];return o?(ce=o.nextPos,o.result):(e=ce,58===t.charCodeAt(ce)?(r=\":\",ce++):(r=s,ge(ae)),r!==s?(\"statement\"===t.substr(ce,9).toLowerCase()?(n=t.substr(ce,9),ce+=9):(n=s,ge(oe)),n===s&&(\"expression\"===t.substr(ce,10).toLowerCase()?(n=t.substr(ce,10),ce+=10):(n=s,ge(ie)),n===s&&(\"declaration\"===t.substr(ce,11).toLowerCase()?(n=t.substr(ce,11),ce+=11):(n=s,ge(se)),n===s&&(\"function\"===t.substr(ce,8).toLowerCase()?(n=t.substr(ce,8),ce+=8):(n=s,ge(le)),n===s&&(\"pattern\"===t.substr(ce,7).toLowerCase()?(n=t.substr(ce,7),ce+=7):(n=s,ge(ue)))))),n!==s?e=r={type:\"class\",name:n}:(ce=e,e=s)):(ce=e,e=s),ye[a]={nextPos:ce,result:e},e)}()),ye[r]={nextPos:ce,result:e},e)}function ke(){var e,r,n,a,o,i,l,u,c=30*ce+13,f=ye[c];if(f)return ce=f.nextPos,f.result;if(e=ce,(r=Ee())!==s){for(n=[],a=ce,46===t.charCodeAt(ce)?(o=\".\",ce++):(o=s,ge(k)),o!==s&&(i=Ee())!==s?a=o=[o,i]:(ce=a,a=s);a!==s;)n.push(a),a=ce,46===t.charCodeAt(ce)?(o=\".\",ce++):(o=s,ge(k)),o!==s&&(i=Ee())!==s?a=o=[o,i]:(ce=a,a=s);n!==s?(l=r,u=n,e=r=[].concat.apply([l],u).join(\"\")):(ce=e,e=s)}else ce=e,e=s;return ye[c]={nextPos:ce,result:e},e}function De(e){return{type:\"nth-child\",index:{type:\"literal\",value:e}}}function je(e){return{type:\"nth-last-child\",index:{type:\"literal\",value:e}}}if((n=u())!==s&&ce===t.length)return n;throw n!==s&&ce<t.length&&ge({type:\"end\"}),a=he,o=pe<t.length?t.charAt(pe):null,i=pe<t.length?ve(pe,pe+1):ve(pe,pe),new e(e.buildMessage(a,o),a,o,i)}}}())}));function u(t,r,n,a){if(!r)return!0;if(!t)return!1;switch(n||(n=[]),r.type){case\"wildcard\":return!0;case\"identifier\":return r.value.toLowerCase()===t.type.toLowerCase();case\"field\":var i=r.name.split(\".\"),l=n[i.length-1];return function e(t,r,n){if(0===n.length)return t===r;if(null==r)return!1;var a=r[n[0]],i=n.slice(1);if(Array.isArray(a)){var s,l=o(a);try{for(l.s();!(s=l.n()).done;){if(e(t,s.value,i))return!0}}catch(e){l.e(e)}finally{l.f()}return!1}return e(t,a,i)}(t,l,i);case\"matches\":var c,f=o(r.selectors);try{for(f.s();!(c=f.n()).done;){var d=c.value;if(u(t,d,n,a))return!0}}catch(e){f.e(e)}finally{f.f()}return!1;case\"compound\":var m,x=o(r.selectors);try{for(x.s();!(m=x.n()).done;){var v=m.value;if(!u(t,v,n,a))return!1}}catch(e){x.e(e)}finally{x.f()}return!0;case\"not\":var g,b=o(r.selectors);try{for(b.s();!(g=b.n()).done;){var A=g.value;if(u(t,A,n,a))return!1}}catch(e){b.e(e)}finally{b.f()}return!0;case\"has\":var E=function(){var e,n=[],i=o(r.selectors);try{var l=function(){var r=e.value,o=[];s.traverse(t,{enter:function(e,t){null!=t&&o.unshift(t),u(e,r,o,a)&&n.push(e)},leave:function(){o.shift()},keys:a&&a.visitorKeys,fallback:a&&a.fallback||\"iteration\"})};for(i.s();!(e=i.n()).done;)l()}catch(e){i.e(e)}finally{i.f()}return{v:0!==n.length}}();if(\"object\"===e(E))return E.v;case\"child\":return!!u(t,r.right,n,a)&&u(n[0],r.left,n.slice(1),a);case\"descendant\":if(u(t,r.right,n,a))for(var S=0,_=n.length;S<_;++S)if(u(n[S],r.left,n.slice(S+1),a))return!0;return!1;case\"attribute\":var w=function(e,t){var r,n=o(t.split(\".\"));try{for(n.s();!(r=n.n()).done;){var a=r.value;if(null==e)return e;e=e[a]}}catch(e){n.e(e)}finally{n.f()}return e}(t,r.name);switch(r.operator){case void 0:return null!=w;case\"=\":switch(r.value.type){case\"regexp\":return\"string\"==typeof w&&r.value.value.test(w);case\"literal\":return\"\".concat(r.value.value)===\"\".concat(w);case\"type\":return r.value.value===e(w)}throw new Error(\"Unknown selector value type: \".concat(r.value.type));case\"!=\":switch(r.value.type){case\"regexp\":return!r.value.value.test(w);case\"literal\":return\"\".concat(r.value.value)!==\"\".concat(w);case\"type\":return r.value.value!==e(w)}throw new Error(\"Unknown selector value type: \".concat(r.value.type));case\"<=\":return w<=r.value.value;case\"<\":return w<r.value.value;case\">\":return w>r.value.value;case\">=\":return w>=r.value.value}throw new Error(\"Unknown operator: \".concat(r.operator));case\"sibling\":return u(t,r.right,n,a)&&p(t,r.left,n,\"LEFT_SIDE\",a)||r.left.subject&&u(t,r.left,n,a)&&p(t,r.right,n,\"RIGHT_SIDE\",a);case\"adjacent\":return u(t,r.right,n,a)&&h(t,r.left,n,\"LEFT_SIDE\",a)||r.right.subject&&u(t,r.left,n,a)&&h(t,r.right,n,\"RIGHT_SIDE\",a);case\"nth-child\":return u(t,r.right,n,a)&&y(t,n,(function(){return r.index.value-1}),a);case\"nth-last-child\":return u(t,r.right,n,a)&&y(t,n,(function(e){return e-r.index.value}),a);case\"class\":switch(r.name.toLowerCase()){case\"statement\":if(\"Statement\"===t.type.slice(-9))return!0;case\"declaration\":return\"Declaration\"===t.type.slice(-11);case\"pattern\":if(\"Pattern\"===t.type.slice(-7))return!0;case\"expression\":return\"Expression\"===t.type.slice(-10)||\"Literal\"===t.type.slice(-7)||\"Identifier\"===t.type&&(0===n.length||\"MetaProperty\"!==n[0].type)||\"MetaProperty\"===t.type;case\"function\":return\"FunctionDeclaration\"===t.type||\"FunctionExpression\"===t.type||\"ArrowFunctionExpression\"===t.type}throw new Error(\"Unknown class name: \".concat(r.name))}throw new Error(\"Unknown selector type: \".concat(r.type))}function c(e,t){var r=e.type;return t&&t.visitorKeys&&t.visitorKeys[r]?t.visitorKeys[r]:s.VisitorKeys[r]?s.VisitorKeys[r]:t&&\"function\"==typeof t.fallback?t.fallback(e):Object.keys(e).filter((function(e){return\"type\"!==e}))}function f(t){return null!==t&&\"object\"===e(t)&&\"string\"==typeof t.type}function p(e,r,n,a,i){var s=t(n,1)[0];if(!s)return!1;var l,p=o(c(s,i));try{for(p.s();!(l=p.n()).done;){var h=s[l.value];if(Array.isArray(h)){var y=h.indexOf(e);if(y<0)continue;var d=void 0,m=void 0;\"LEFT_SIDE\"===a?(d=0,m=y):(d=y+1,m=h.length);for(var x=d;x<m;++x)if(f(h[x])&&u(h[x],r,n,i))return!0}}}catch(e){p.e(e)}finally{p.f()}return!1}function h(e,r,n,a,i){var s=t(n,1)[0];if(!s)return!1;var l,p=o(c(s,i));try{for(p.s();!(l=p.n()).done;){var h=s[l.value];if(Array.isArray(h)){var y=h.indexOf(e);if(y<0)continue;if(\"LEFT_SIDE\"===a&&y>0&&f(h[y-1])&&u(h[y-1],r,n,i))return!0;if(\"RIGHT_SIDE\"===a&&y<h.length-1&&f(h[y+1])&&u(h[y+1],r,n,i))return!0}}}catch(e){p.e(e)}finally{p.f()}return!1}function y(e,r,n,a){var i=t(r,1)[0];if(!i)return!1;var s,l=o(c(i,a));try{for(l.s();!(s=l.n()).done;){var u=i[s.value];if(Array.isArray(u)){var f=u.indexOf(e);if(f>=0&&f===n(u.length))return!0}}}catch(e){l.e(e)}finally{l.f()}return!1}function d(n,a){if(null==n||\"object\"!=e(n))return[];null==a&&(a=n);for(var o=n.subject?[a]:[],i=0,s=function(e){for(var t=[],r=Object.keys(e),n=0;n<r.length;n++)t.push([r[n],e[r[n]]]);return t}(n);i<s.length;i++){var l=t(s[i],2),u=l[0],c=l[1];o.push.apply(o,r(d(c,\"left\"===u?c:a)))}return o}function m(e,t,r,n){if(t){var a=[],o=d(t);s.traverse(e,{enter:function(e,i){if(null!=i&&a.unshift(i),u(e,t,a,n))if(o.length)for(var s=0,l=o.length;s<l;++s){u(e,o[s],a,n)&&r(e,i,a);for(var c=0,f=a.length;c<f;++c){var p=a.slice(c+1);u(a[c],o[s],p,n)&&r(a[c],i,p)}}else r(e,i,a)},leave:function(){a.shift()},keys:n&&n.visitorKeys,fallback:n&&n.fallback||\"iteration\"})}}function x(e,t,r){var n=[];return m(e,t,(function(e){n.push(e)}),r),n}function v(e){return l.parse(e)}function g(e,t,r){return x(e,v(t),r)}g.parse=v,g.match=x,g.traverse=m,g.matches=u,g.query=g;/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (g);\n//# sourceMappingURL=esquery.esm.min.js.map\n\n\n//# sourceURL=webpack://javascript/./node_modules/esquery/dist/esquery.esm.min.js?");

/***/ }),

/***/ "./node_modules/esrecurse/esrecurse.js":
/*!*********************************************!*\
  !*** ./node_modules/esrecurse/esrecurse.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/*\n  Copyright (C) 2014 Yusuke Suzuki <utatane.tea@gmail.com>\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n(function () {\n    'use strict';\n\n    var estraverse = __webpack_require__(/*! estraverse */ \"./node_modules/estraverse/estraverse.js\");\n\n    function isNode(node) {\n        if (node == null) {\n            return false;\n        }\n        return typeof node === 'object' && typeof node.type === 'string';\n    }\n\n    function isProperty(nodeType, key) {\n        return (nodeType === estraverse.Syntax.ObjectExpression || nodeType === estraverse.Syntax.ObjectPattern) && key === 'properties';\n    }\n\n    function Visitor(visitor, options) {\n        options = options || {};\n\n        this.__visitor = visitor ||  this;\n        this.__childVisitorKeys = options.childVisitorKeys\n            ? Object.assign({}, estraverse.VisitorKeys, options.childVisitorKeys)\n            : estraverse.VisitorKeys;\n        if (options.fallback === 'iteration') {\n            this.__fallback = Object.keys;\n        } else if (typeof options.fallback === 'function') {\n            this.__fallback = options.fallback;\n        }\n    }\n\n    /* Default method for visiting children.\n     * When you need to call default visiting operation inside custom visiting\n     * operation, you can use it with `this.visitChildren(node)`.\n     */\n    Visitor.prototype.visitChildren = function (node) {\n        var type, children, i, iz, j, jz, child;\n\n        if (node == null) {\n            return;\n        }\n\n        type = node.type || estraverse.Syntax.Property;\n\n        children = this.__childVisitorKeys[type];\n        if (!children) {\n            if (this.__fallback) {\n                children = this.__fallback(node);\n            } else {\n                throw new Error('Unknown node type ' + type + '.');\n            }\n        }\n\n        for (i = 0, iz = children.length; i < iz; ++i) {\n            child = node[children[i]];\n            if (child) {\n                if (Array.isArray(child)) {\n                    for (j = 0, jz = child.length; j < jz; ++j) {\n                        if (child[j]) {\n                            if (isNode(child[j]) || isProperty(type, children[i])) {\n                                this.visit(child[j]);\n                            }\n                        }\n                    }\n                } else if (isNode(child)) {\n                    this.visit(child);\n                }\n            }\n        }\n    };\n\n    /* Dispatching node. */\n    Visitor.prototype.visit = function (node) {\n        var type;\n\n        if (node == null) {\n            return;\n        }\n\n        type = node.type || estraverse.Syntax.Property;\n        if (this.__visitor[type]) {\n            this.__visitor[type].call(this, node);\n            return;\n        }\n        this.visitChildren(node);\n    };\n\n    exports.version = __webpack_require__(/*! ./package.json */ \"./node_modules/esrecurse/package.json\").version;\n    exports.Visitor = Visitor;\n    exports.visit = function (node, visitor, options) {\n        var v = new Visitor(visitor, options);\n        v.visit(node);\n    };\n}());\n/* vim: set sw=4 ts=4 et tw=80 : */\n\n\n//# sourceURL=webpack://javascript/./node_modules/esrecurse/esrecurse.js?");

/***/ }),

/***/ "./node_modules/estraverse/estraverse.js":
/*!***********************************************!*\
  !*** ./node_modules/estraverse/estraverse.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("/*\n  Copyright (C) 2012-2013 Yusuke Suzuki <utatane.tea@gmail.com>\n  Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com>\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n/*jslint vars:false, bitwise:true*/\n/*jshint indent:4*/\n/*global exports:true*/\n(function clone(exports) {\n    'use strict';\n\n    var Syntax,\n        VisitorOption,\n        VisitorKeys,\n        BREAK,\n        SKIP,\n        REMOVE;\n\n    function deepCopy(obj) {\n        var ret = {}, key, val;\n        for (key in obj) {\n            if (obj.hasOwnProperty(key)) {\n                val = obj[key];\n                if (typeof val === 'object' && val !== null) {\n                    ret[key] = deepCopy(val);\n                } else {\n                    ret[key] = val;\n                }\n            }\n        }\n        return ret;\n    }\n\n    // based on LLVM libc++ upper_bound / lower_bound\n    // MIT License\n\n    function upperBound(array, func) {\n        var diff, len, i, current;\n\n        len = array.length;\n        i = 0;\n\n        while (len) {\n            diff = len >>> 1;\n            current = i + diff;\n            if (func(array[current])) {\n                len = diff;\n            } else {\n                i = current + 1;\n                len -= diff + 1;\n            }\n        }\n        return i;\n    }\n\n    Syntax = {\n        AssignmentExpression: 'AssignmentExpression',\n        AssignmentPattern: 'AssignmentPattern',\n        ArrayExpression: 'ArrayExpression',\n        ArrayPattern: 'ArrayPattern',\n        ArrowFunctionExpression: 'ArrowFunctionExpression',\n        AwaitExpression: 'AwaitExpression', // CAUTION: It's deferred to ES7.\n        BlockStatement: 'BlockStatement',\n        BinaryExpression: 'BinaryExpression',\n        BreakStatement: 'BreakStatement',\n        CallExpression: 'CallExpression',\n        CatchClause: 'CatchClause',\n        ChainExpression: 'ChainExpression',\n        ClassBody: 'ClassBody',\n        ClassDeclaration: 'ClassDeclaration',\n        ClassExpression: 'ClassExpression',\n        ComprehensionBlock: 'ComprehensionBlock',  // CAUTION: It's deferred to ES7.\n        ComprehensionExpression: 'ComprehensionExpression',  // CAUTION: It's deferred to ES7.\n        ConditionalExpression: 'ConditionalExpression',\n        ContinueStatement: 'ContinueStatement',\n        DebuggerStatement: 'DebuggerStatement',\n        DirectiveStatement: 'DirectiveStatement',\n        DoWhileStatement: 'DoWhileStatement',\n        EmptyStatement: 'EmptyStatement',\n        ExportAllDeclaration: 'ExportAllDeclaration',\n        ExportDefaultDeclaration: 'ExportDefaultDeclaration',\n        ExportNamedDeclaration: 'ExportNamedDeclaration',\n        ExportSpecifier: 'ExportSpecifier',\n        ExpressionStatement: 'ExpressionStatement',\n        ForStatement: 'ForStatement',\n        ForInStatement: 'ForInStatement',\n        ForOfStatement: 'ForOfStatement',\n        FunctionDeclaration: 'FunctionDeclaration',\n        FunctionExpression: 'FunctionExpression',\n        GeneratorExpression: 'GeneratorExpression',  // CAUTION: It's deferred to ES7.\n        Identifier: 'Identifier',\n        IfStatement: 'IfStatement',\n        ImportExpression: 'ImportExpression',\n        ImportDeclaration: 'ImportDeclaration',\n        ImportDefaultSpecifier: 'ImportDefaultSpecifier',\n        ImportNamespaceSpecifier: 'ImportNamespaceSpecifier',\n        ImportSpecifier: 'ImportSpecifier',\n        Literal: 'Literal',\n        LabeledStatement: 'LabeledStatement',\n        LogicalExpression: 'LogicalExpression',\n        MemberExpression: 'MemberExpression',\n        MetaProperty: 'MetaProperty',\n        MethodDefinition: 'MethodDefinition',\n        ModuleSpecifier: 'ModuleSpecifier',\n        NewExpression: 'NewExpression',\n        ObjectExpression: 'ObjectExpression',\n        ObjectPattern: 'ObjectPattern',\n        PrivateIdentifier: 'PrivateIdentifier',\n        Program: 'Program',\n        Property: 'Property',\n        PropertyDefinition: 'PropertyDefinition',\n        RestElement: 'RestElement',\n        ReturnStatement: 'ReturnStatement',\n        SequenceExpression: 'SequenceExpression',\n        SpreadElement: 'SpreadElement',\n        Super: 'Super',\n        SwitchStatement: 'SwitchStatement',\n        SwitchCase: 'SwitchCase',\n        TaggedTemplateExpression: 'TaggedTemplateExpression',\n        TemplateElement: 'TemplateElement',\n        TemplateLiteral: 'TemplateLiteral',\n        ThisExpression: 'ThisExpression',\n        ThrowStatement: 'ThrowStatement',\n        TryStatement: 'TryStatement',\n        UnaryExpression: 'UnaryExpression',\n        UpdateExpression: 'UpdateExpression',\n        VariableDeclaration: 'VariableDeclaration',\n        VariableDeclarator: 'VariableDeclarator',\n        WhileStatement: 'WhileStatement',\n        WithStatement: 'WithStatement',\n        YieldExpression: 'YieldExpression'\n    };\n\n    VisitorKeys = {\n        AssignmentExpression: ['left', 'right'],\n        AssignmentPattern: ['left', 'right'],\n        ArrayExpression: ['elements'],\n        ArrayPattern: ['elements'],\n        ArrowFunctionExpression: ['params', 'body'],\n        AwaitExpression: ['argument'], // CAUTION: It's deferred to ES7.\n        BlockStatement: ['body'],\n        BinaryExpression: ['left', 'right'],\n        BreakStatement: ['label'],\n        CallExpression: ['callee', 'arguments'],\n        CatchClause: ['param', 'body'],\n        ChainExpression: ['expression'],\n        ClassBody: ['body'],\n        ClassDeclaration: ['id', 'superClass', 'body'],\n        ClassExpression: ['id', 'superClass', 'body'],\n        ComprehensionBlock: ['left', 'right'],  // CAUTION: It's deferred to ES7.\n        ComprehensionExpression: ['blocks', 'filter', 'body'],  // CAUTION: It's deferred to ES7.\n        ConditionalExpression: ['test', 'consequent', 'alternate'],\n        ContinueStatement: ['label'],\n        DebuggerStatement: [],\n        DirectiveStatement: [],\n        DoWhileStatement: ['body', 'test'],\n        EmptyStatement: [],\n        ExportAllDeclaration: ['source'],\n        ExportDefaultDeclaration: ['declaration'],\n        ExportNamedDeclaration: ['declaration', 'specifiers', 'source'],\n        ExportSpecifier: ['exported', 'local'],\n        ExpressionStatement: ['expression'],\n        ForStatement: ['init', 'test', 'update', 'body'],\n        ForInStatement: ['left', 'right', 'body'],\n        ForOfStatement: ['left', 'right', 'body'],\n        FunctionDeclaration: ['id', 'params', 'body'],\n        FunctionExpression: ['id', 'params', 'body'],\n        GeneratorExpression: ['blocks', 'filter', 'body'],  // CAUTION: It's deferred to ES7.\n        Identifier: [],\n        IfStatement: ['test', 'consequent', 'alternate'],\n        ImportExpression: ['source'],\n        ImportDeclaration: ['specifiers', 'source'],\n        ImportDefaultSpecifier: ['local'],\n        ImportNamespaceSpecifier: ['local'],\n        ImportSpecifier: ['imported', 'local'],\n        Literal: [],\n        LabeledStatement: ['label', 'body'],\n        LogicalExpression: ['left', 'right'],\n        MemberExpression: ['object', 'property'],\n        MetaProperty: ['meta', 'property'],\n        MethodDefinition: ['key', 'value'],\n        ModuleSpecifier: [],\n        NewExpression: ['callee', 'arguments'],\n        ObjectExpression: ['properties'],\n        ObjectPattern: ['properties'],\n        PrivateIdentifier: [],\n        Program: ['body'],\n        Property: ['key', 'value'],\n        PropertyDefinition: ['key', 'value'],\n        RestElement: [ 'argument' ],\n        ReturnStatement: ['argument'],\n        SequenceExpression: ['expressions'],\n        SpreadElement: ['argument'],\n        Super: [],\n        SwitchStatement: ['discriminant', 'cases'],\n        SwitchCase: ['test', 'consequent'],\n        TaggedTemplateExpression: ['tag', 'quasi'],\n        TemplateElement: [],\n        TemplateLiteral: ['quasis', 'expressions'],\n        ThisExpression: [],\n        ThrowStatement: ['argument'],\n        TryStatement: ['block', 'handler', 'finalizer'],\n        UnaryExpression: ['argument'],\n        UpdateExpression: ['argument'],\n        VariableDeclaration: ['declarations'],\n        VariableDeclarator: ['id', 'init'],\n        WhileStatement: ['test', 'body'],\n        WithStatement: ['object', 'body'],\n        YieldExpression: ['argument']\n    };\n\n    // unique id\n    BREAK = {};\n    SKIP = {};\n    REMOVE = {};\n\n    VisitorOption = {\n        Break: BREAK,\n        Skip: SKIP,\n        Remove: REMOVE\n    };\n\n    function Reference(parent, key) {\n        this.parent = parent;\n        this.key = key;\n    }\n\n    Reference.prototype.replace = function replace(node) {\n        this.parent[this.key] = node;\n    };\n\n    Reference.prototype.remove = function remove() {\n        if (Array.isArray(this.parent)) {\n            this.parent.splice(this.key, 1);\n            return true;\n        } else {\n            this.replace(null);\n            return false;\n        }\n    };\n\n    function Element(node, path, wrap, ref) {\n        this.node = node;\n        this.path = path;\n        this.wrap = wrap;\n        this.ref = ref;\n    }\n\n    function Controller() { }\n\n    // API:\n    // return property path array from root to current node\n    Controller.prototype.path = function path() {\n        var i, iz, j, jz, result, element;\n\n        function addToPath(result, path) {\n            if (Array.isArray(path)) {\n                for (j = 0, jz = path.length; j < jz; ++j) {\n                    result.push(path[j]);\n                }\n            } else {\n                result.push(path);\n            }\n        }\n\n        // root node\n        if (!this.__current.path) {\n            return null;\n        }\n\n        // first node is sentinel, second node is root element\n        result = [];\n        for (i = 2, iz = this.__leavelist.length; i < iz; ++i) {\n            element = this.__leavelist[i];\n            addToPath(result, element.path);\n        }\n        addToPath(result, this.__current.path);\n        return result;\n    };\n\n    // API:\n    // return type of current node\n    Controller.prototype.type = function () {\n        var node = this.current();\n        return node.type || this.__current.wrap;\n    };\n\n    // API:\n    // return array of parent elements\n    Controller.prototype.parents = function parents() {\n        var i, iz, result;\n\n        // first node is sentinel\n        result = [];\n        for (i = 1, iz = this.__leavelist.length; i < iz; ++i) {\n            result.push(this.__leavelist[i].node);\n        }\n\n        return result;\n    };\n\n    // API:\n    // return current node\n    Controller.prototype.current = function current() {\n        return this.__current.node;\n    };\n\n    Controller.prototype.__execute = function __execute(callback, element) {\n        var previous, result;\n\n        result = undefined;\n\n        previous  = this.__current;\n        this.__current = element;\n        this.__state = null;\n        if (callback) {\n            result = callback.call(this, element.node, this.__leavelist[this.__leavelist.length - 1].node);\n        }\n        this.__current = previous;\n\n        return result;\n    };\n\n    // API:\n    // notify control skip / break\n    Controller.prototype.notify = function notify(flag) {\n        this.__state = flag;\n    };\n\n    // API:\n    // skip child nodes of current node\n    Controller.prototype.skip = function () {\n        this.notify(SKIP);\n    };\n\n    // API:\n    // break traversals\n    Controller.prototype['break'] = function () {\n        this.notify(BREAK);\n    };\n\n    // API:\n    // remove node\n    Controller.prototype.remove = function () {\n        this.notify(REMOVE);\n    };\n\n    Controller.prototype.__initialize = function(root, visitor) {\n        this.visitor = visitor;\n        this.root = root;\n        this.__worklist = [];\n        this.__leavelist = [];\n        this.__current = null;\n        this.__state = null;\n        this.__fallback = null;\n        if (visitor.fallback === 'iteration') {\n            this.__fallback = Object.keys;\n        } else if (typeof visitor.fallback === 'function') {\n            this.__fallback = visitor.fallback;\n        }\n\n        this.__keys = VisitorKeys;\n        if (visitor.keys) {\n            this.__keys = Object.assign(Object.create(this.__keys), visitor.keys);\n        }\n    };\n\n    function isNode(node) {\n        if (node == null) {\n            return false;\n        }\n        return typeof node === 'object' && typeof node.type === 'string';\n    }\n\n    function isProperty(nodeType, key) {\n        return (nodeType === Syntax.ObjectExpression || nodeType === Syntax.ObjectPattern) && 'properties' === key;\n    }\n  \n    function candidateExistsInLeaveList(leavelist, candidate) {\n        for (var i = leavelist.length - 1; i >= 0; --i) {\n            if (leavelist[i].node === candidate) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    Controller.prototype.traverse = function traverse(root, visitor) {\n        var worklist,\n            leavelist,\n            element,\n            node,\n            nodeType,\n            ret,\n            key,\n            current,\n            current2,\n            candidates,\n            candidate,\n            sentinel;\n\n        this.__initialize(root, visitor);\n\n        sentinel = {};\n\n        // reference\n        worklist = this.__worklist;\n        leavelist = this.__leavelist;\n\n        // initialize\n        worklist.push(new Element(root, null, null, null));\n        leavelist.push(new Element(null, null, null, null));\n\n        while (worklist.length) {\n            element = worklist.pop();\n\n            if (element === sentinel) {\n                element = leavelist.pop();\n\n                ret = this.__execute(visitor.leave, element);\n\n                if (this.__state === BREAK || ret === BREAK) {\n                    return;\n                }\n                continue;\n            }\n\n            if (element.node) {\n\n                ret = this.__execute(visitor.enter, element);\n\n                if (this.__state === BREAK || ret === BREAK) {\n                    return;\n                }\n\n                worklist.push(sentinel);\n                leavelist.push(element);\n\n                if (this.__state === SKIP || ret === SKIP) {\n                    continue;\n                }\n\n                node = element.node;\n                nodeType = node.type || element.wrap;\n                candidates = this.__keys[nodeType];\n                if (!candidates) {\n                    if (this.__fallback) {\n                        candidates = this.__fallback(node);\n                    } else {\n                        throw new Error('Unknown node type ' + nodeType + '.');\n                    }\n                }\n\n                current = candidates.length;\n                while ((current -= 1) >= 0) {\n                    key = candidates[current];\n                    candidate = node[key];\n                    if (!candidate) {\n                        continue;\n                    }\n\n                    if (Array.isArray(candidate)) {\n                        current2 = candidate.length;\n                        while ((current2 -= 1) >= 0) {\n                            if (!candidate[current2]) {\n                                continue;\n                            }\n\n                            if (candidateExistsInLeaveList(leavelist, candidate[current2])) {\n                              continue;\n                            }\n\n                            if (isProperty(nodeType, candidates[current])) {\n                                element = new Element(candidate[current2], [key, current2], 'Property', null);\n                            } else if (isNode(candidate[current2])) {\n                                element = new Element(candidate[current2], [key, current2], null, null);\n                            } else {\n                                continue;\n                            }\n                            worklist.push(element);\n                        }\n                    } else if (isNode(candidate)) {\n                        if (candidateExistsInLeaveList(leavelist, candidate)) {\n                          continue;\n                        }\n\n                        worklist.push(new Element(candidate, key, null, null));\n                    }\n                }\n            }\n        }\n    };\n\n    Controller.prototype.replace = function replace(root, visitor) {\n        var worklist,\n            leavelist,\n            node,\n            nodeType,\n            target,\n            element,\n            current,\n            current2,\n            candidates,\n            candidate,\n            sentinel,\n            outer,\n            key;\n\n        function removeElem(element) {\n            var i,\n                key,\n                nextElem,\n                parent;\n\n            if (element.ref.remove()) {\n                // When the reference is an element of an array.\n                key = element.ref.key;\n                parent = element.ref.parent;\n\n                // If removed from array, then decrease following items' keys.\n                i = worklist.length;\n                while (i--) {\n                    nextElem = worklist[i];\n                    if (nextElem.ref && nextElem.ref.parent === parent) {\n                        if  (nextElem.ref.key < key) {\n                            break;\n                        }\n                        --nextElem.ref.key;\n                    }\n                }\n            }\n        }\n\n        this.__initialize(root, visitor);\n\n        sentinel = {};\n\n        // reference\n        worklist = this.__worklist;\n        leavelist = this.__leavelist;\n\n        // initialize\n        outer = {\n            root: root\n        };\n        element = new Element(root, null, null, new Reference(outer, 'root'));\n        worklist.push(element);\n        leavelist.push(element);\n\n        while (worklist.length) {\n            element = worklist.pop();\n\n            if (element === sentinel) {\n                element = leavelist.pop();\n\n                target = this.__execute(visitor.leave, element);\n\n                // node may be replaced with null,\n                // so distinguish between undefined and null in this place\n                if (target !== undefined && target !== BREAK && target !== SKIP && target !== REMOVE) {\n                    // replace\n                    element.ref.replace(target);\n                }\n\n                if (this.__state === REMOVE || target === REMOVE) {\n                    removeElem(element);\n                }\n\n                if (this.__state === BREAK || target === BREAK) {\n                    return outer.root;\n                }\n                continue;\n            }\n\n            target = this.__execute(visitor.enter, element);\n\n            // node may be replaced with null,\n            // so distinguish between undefined and null in this place\n            if (target !== undefined && target !== BREAK && target !== SKIP && target !== REMOVE) {\n                // replace\n                element.ref.replace(target);\n                element.node = target;\n            }\n\n            if (this.__state === REMOVE || target === REMOVE) {\n                removeElem(element);\n                element.node = null;\n            }\n\n            if (this.__state === BREAK || target === BREAK) {\n                return outer.root;\n            }\n\n            // node may be null\n            node = element.node;\n            if (!node) {\n                continue;\n            }\n\n            worklist.push(sentinel);\n            leavelist.push(element);\n\n            if (this.__state === SKIP || target === SKIP) {\n                continue;\n            }\n\n            nodeType = node.type || element.wrap;\n            candidates = this.__keys[nodeType];\n            if (!candidates) {\n                if (this.__fallback) {\n                    candidates = this.__fallback(node);\n                } else {\n                    throw new Error('Unknown node type ' + nodeType + '.');\n                }\n            }\n\n            current = candidates.length;\n            while ((current -= 1) >= 0) {\n                key = candidates[current];\n                candidate = node[key];\n                if (!candidate) {\n                    continue;\n                }\n\n                if (Array.isArray(candidate)) {\n                    current2 = candidate.length;\n                    while ((current2 -= 1) >= 0) {\n                        if (!candidate[current2]) {\n                            continue;\n                        }\n                        if (isProperty(nodeType, candidates[current])) {\n                            element = new Element(candidate[current2], [key, current2], 'Property', new Reference(candidate, current2));\n                        } else if (isNode(candidate[current2])) {\n                            element = new Element(candidate[current2], [key, current2], null, new Reference(candidate, current2));\n                        } else {\n                            continue;\n                        }\n                        worklist.push(element);\n                    }\n                } else if (isNode(candidate)) {\n                    worklist.push(new Element(candidate, key, null, new Reference(node, key)));\n                }\n            }\n        }\n\n        return outer.root;\n    };\n\n    function traverse(root, visitor) {\n        var controller = new Controller();\n        return controller.traverse(root, visitor);\n    }\n\n    function replace(root, visitor) {\n        var controller = new Controller();\n        return controller.replace(root, visitor);\n    }\n\n    function extendCommentRange(comment, tokens) {\n        var target;\n\n        target = upperBound(tokens, function search(token) {\n            return token.range[0] > comment.range[0];\n        });\n\n        comment.extendedRange = [comment.range[0], comment.range[1]];\n\n        if (target !== tokens.length) {\n            comment.extendedRange[1] = tokens[target].range[0];\n        }\n\n        target -= 1;\n        if (target >= 0) {\n            comment.extendedRange[0] = tokens[target].range[1];\n        }\n\n        return comment;\n    }\n\n    function attachComments(tree, providedComments, tokens) {\n        // At first, we should calculate extended comment ranges.\n        var comments = [], comment, len, i, cursor;\n\n        if (!tree.range) {\n            throw new Error('attachComments needs range information');\n        }\n\n        // tokens array is empty, we attach comments to tree as 'leadingComments'\n        if (!tokens.length) {\n            if (providedComments.length) {\n                for (i = 0, len = providedComments.length; i < len; i += 1) {\n                    comment = deepCopy(providedComments[i]);\n                    comment.extendedRange = [0, tree.range[0]];\n                    comments.push(comment);\n                }\n                tree.leadingComments = comments;\n            }\n            return tree;\n        }\n\n        for (i = 0, len = providedComments.length; i < len; i += 1) {\n            comments.push(extendCommentRange(deepCopy(providedComments[i]), tokens));\n        }\n\n        // This is based on John Freeman's implementation.\n        cursor = 0;\n        traverse(tree, {\n            enter: function (node) {\n                var comment;\n\n                while (cursor < comments.length) {\n                    comment = comments[cursor];\n                    if (comment.extendedRange[1] > node.range[0]) {\n                        break;\n                    }\n\n                    if (comment.extendedRange[1] === node.range[0]) {\n                        if (!node.leadingComments) {\n                            node.leadingComments = [];\n                        }\n                        node.leadingComments.push(comment);\n                        comments.splice(cursor, 1);\n                    } else {\n                        cursor += 1;\n                    }\n                }\n\n                // already out of owned node\n                if (cursor === comments.length) {\n                    return VisitorOption.Break;\n                }\n\n                if (comments[cursor].extendedRange[0] > node.range[1]) {\n                    return VisitorOption.Skip;\n                }\n            }\n        });\n\n        cursor = 0;\n        traverse(tree, {\n            leave: function (node) {\n                var comment;\n\n                while (cursor < comments.length) {\n                    comment = comments[cursor];\n                    if (node.range[1] < comment.extendedRange[0]) {\n                        break;\n                    }\n\n                    if (node.range[1] === comment.extendedRange[0]) {\n                        if (!node.trailingComments) {\n                            node.trailingComments = [];\n                        }\n                        node.trailingComments.push(comment);\n                        comments.splice(cursor, 1);\n                    } else {\n                        cursor += 1;\n                    }\n                }\n\n                // already out of owned node\n                if (cursor === comments.length) {\n                    return VisitorOption.Break;\n                }\n\n                if (comments[cursor].extendedRange[0] > node.range[1]) {\n                    return VisitorOption.Skip;\n                }\n            }\n        });\n\n        return tree;\n    }\n\n    exports.Syntax = Syntax;\n    exports.traverse = traverse;\n    exports.replace = replace;\n    exports.attachComments = attachComments;\n    exports.VisitorKeys = VisitorKeys;\n    exports.VisitorOption = VisitorOption;\n    exports.Controller = Controller;\n    exports.cloneEnvironment = function () { return clone({}); };\n\n    return exports;\n}(exports));\n/* vim: set sw=4 ts=4 et tw=80 : */\n\n\n//# sourceURL=webpack://javascript/./node_modules/estraverse/estraverse.js?");

/***/ }),

/***/ "./node_modules/esutils/lib/ast.js":
/*!*****************************************!*\
  !*** ./node_modules/esutils/lib/ast.js ***!
  \*****************************************/
/***/ ((module) => {

eval("/*\n  Copyright (C) 2013 Yusuke Suzuki <utatane.tea@gmail.com>\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS'\n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n(function () {\n    'use strict';\n\n    function isExpression(node) {\n        if (node == null) { return false; }\n        switch (node.type) {\n            case 'ArrayExpression':\n            case 'AssignmentExpression':\n            case 'BinaryExpression':\n            case 'CallExpression':\n            case 'ConditionalExpression':\n            case 'FunctionExpression':\n            case 'Identifier':\n            case 'Literal':\n            case 'LogicalExpression':\n            case 'MemberExpression':\n            case 'NewExpression':\n            case 'ObjectExpression':\n            case 'SequenceExpression':\n            case 'ThisExpression':\n            case 'UnaryExpression':\n            case 'UpdateExpression':\n                return true;\n        }\n        return false;\n    }\n\n    function isIterationStatement(node) {\n        if (node == null) { return false; }\n        switch (node.type) {\n            case 'DoWhileStatement':\n            case 'ForInStatement':\n            case 'ForStatement':\n            case 'WhileStatement':\n                return true;\n        }\n        return false;\n    }\n\n    function isStatement(node) {\n        if (node == null) { return false; }\n        switch (node.type) {\n            case 'BlockStatement':\n            case 'BreakStatement':\n            case 'ContinueStatement':\n            case 'DebuggerStatement':\n            case 'DoWhileStatement':\n            case 'EmptyStatement':\n            case 'ExpressionStatement':\n            case 'ForInStatement':\n            case 'ForStatement':\n            case 'IfStatement':\n            case 'LabeledStatement':\n            case 'ReturnStatement':\n            case 'SwitchStatement':\n            case 'ThrowStatement':\n            case 'TryStatement':\n            case 'VariableDeclaration':\n            case 'WhileStatement':\n            case 'WithStatement':\n                return true;\n        }\n        return false;\n    }\n\n    function isSourceElement(node) {\n      return isStatement(node) || node != null && node.type === 'FunctionDeclaration';\n    }\n\n    function trailingStatement(node) {\n        switch (node.type) {\n        case 'IfStatement':\n            if (node.alternate != null) {\n                return node.alternate;\n            }\n            return node.consequent;\n\n        case 'LabeledStatement':\n        case 'ForStatement':\n        case 'ForInStatement':\n        case 'WhileStatement':\n        case 'WithStatement':\n            return node.body;\n        }\n        return null;\n    }\n\n    function isProblematicIfStatement(node) {\n        var current;\n\n        if (node.type !== 'IfStatement') {\n            return false;\n        }\n        if (node.alternate == null) {\n            return false;\n        }\n        current = node.consequent;\n        do {\n            if (current.type === 'IfStatement') {\n                if (current.alternate == null)  {\n                    return true;\n                }\n            }\n            current = trailingStatement(current);\n        } while (current);\n\n        return false;\n    }\n\n    module.exports = {\n        isExpression: isExpression,\n        isStatement: isStatement,\n        isIterationStatement: isIterationStatement,\n        isSourceElement: isSourceElement,\n        isProblematicIfStatement: isProblematicIfStatement,\n\n        trailingStatement: trailingStatement\n    };\n}());\n/* vim: set sw=4 ts=4 et tw=80 : */\n\n\n//# sourceURL=webpack://javascript/./node_modules/esutils/lib/ast.js?");

/***/ }),

/***/ "./node_modules/esutils/lib/code.js":
/*!******************************************!*\
  !*** ./node_modules/esutils/lib/code.js ***!
  \******************************************/
/***/ ((module) => {

eval("/*\n  Copyright (C) 2013-2014 Yusuke Suzuki <utatane.tea@gmail.com>\n  Copyright (C) 2014 Ivan Nikulin <ifaaan@gmail.com>\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n(function () {\n    'use strict';\n\n    var ES6Regex, ES5Regex, NON_ASCII_WHITESPACES, IDENTIFIER_START, IDENTIFIER_PART, ch;\n\n    // See `tools/generate-identifier-regex.js`.\n    ES5Regex = {\n        // ECMAScript 5.1/Unicode v9.0.0 NonAsciiIdentifierStart:\n        NonAsciiIdentifierStart: /[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u08A0-\\u08B4\\u08B6-\\u08BD\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0AF9\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58-\\u0C5A\\u0C60\\u0C61\\u0C80\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D54-\\u0D56\\u0D5F-\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F5\\u13F8-\\u13FD\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u1884\\u1887-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1C80-\\u1C88\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FD5\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA7AE\\uA7B0-\\uA7B7\\uA7F7-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA8FD\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB65\\uAB70-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]/,\n        // ECMAScript 5.1/Unicode v9.0.0 NonAsciiIdentifierPart:\n        NonAsciiIdentifierPart: /[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0300-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u0483-\\u0487\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0610-\\u061A\\u0620-\\u0669\\u066E-\\u06D3\\u06D5-\\u06DC\\u06DF-\\u06E8\\u06EA-\\u06FC\\u06FF\\u0710-\\u074A\\u074D-\\u07B1\\u07C0-\\u07F5\\u07FA\\u0800-\\u082D\\u0840-\\u085B\\u08A0-\\u08B4\\u08B6-\\u08BD\\u08D4-\\u08E1\\u08E3-\\u0963\\u0966-\\u096F\\u0971-\\u0983\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BC-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CE\\u09D7\\u09DC\\u09DD\\u09DF-\\u09E3\\u09E6-\\u09F1\\u0A01-\\u0A03\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A59-\\u0A5C\\u0A5E\\u0A66-\\u0A75\\u0A81-\\u0A83\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABC-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AD0\\u0AE0-\\u0AE3\\u0AE6-\\u0AEF\\u0AF9\\u0B01-\\u0B03\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3C-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B5C\\u0B5D\\u0B5F-\\u0B63\\u0B66-\\u0B6F\\u0B71\\u0B82\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD0\\u0BD7\\u0BE6-\\u0BEF\\u0C00-\\u0C03\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C58-\\u0C5A\\u0C60-\\u0C63\\u0C66-\\u0C6F\\u0C80-\\u0C83\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBC-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CDE\\u0CE0-\\u0CE3\\u0CE6-\\u0CEF\\u0CF1\\u0CF2\\u0D01-\\u0D03\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4E\\u0D54-\\u0D57\\u0D5F-\\u0D63\\u0D66-\\u0D6F\\u0D7A-\\u0D7F\\u0D82\\u0D83\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DE6-\\u0DEF\\u0DF2\\u0DF3\\u0E01-\\u0E3A\\u0E40-\\u0E4E\\u0E50-\\u0E59\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB9\\u0EBB-\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EC8-\\u0ECD\\u0ED0-\\u0ED9\\u0EDC-\\u0EDF\\u0F00\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E-\\u0F47\\u0F49-\\u0F6C\\u0F71-\\u0F84\\u0F86-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u1000-\\u1049\\u1050-\\u109D\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u135D-\\u135F\\u1380-\\u138F\\u13A0-\\u13F5\\u13F8-\\u13FD\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1714\\u1720-\\u1734\\u1740-\\u1753\\u1760-\\u176C\\u176E-\\u1770\\u1772\\u1773\\u1780-\\u17D3\\u17D7\\u17DC\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u1810-\\u1819\\u1820-\\u1877\\u1880-\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1920-\\u192B\\u1930-\\u193B\\u1946-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u19D0-\\u19D9\\u1A00-\\u1A1B\\u1A20-\\u1A5E\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1AA7\\u1AB0-\\u1ABD\\u1B00-\\u1B4B\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1B80-\\u1BF3\\u1C00-\\u1C37\\u1C40-\\u1C49\\u1C4D-\\u1C7D\\u1C80-\\u1C88\\u1CD0-\\u1CD2\\u1CD4-\\u1CF6\\u1CF8\\u1CF9\\u1D00-\\u1DF5\\u1DFB-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u200C\\u200D\\u203F\\u2040\\u2054\\u2071\\u207F\\u2090-\\u209C\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D7F-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2DE0-\\u2DFF\\u2E2F\\u3005-\\u3007\\u3021-\\u302F\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u3099\\u309A\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FD5\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA66F\\uA674-\\uA67D\\uA67F-\\uA6F1\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA7AE\\uA7B0-\\uA7B7\\uA7F7-\\uA827\\uA840-\\uA873\\uA880-\\uA8C5\\uA8D0-\\uA8D9\\uA8E0-\\uA8F7\\uA8FB\\uA8FD\\uA900-\\uA92D\\uA930-\\uA953\\uA960-\\uA97C\\uA980-\\uA9C0\\uA9CF-\\uA9D9\\uA9E0-\\uA9FE\\uAA00-\\uAA36\\uAA40-\\uAA4D\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A-\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEF\\uAAF2-\\uAAF6\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB65\\uAB70-\\uABEA\\uABEC\\uABED\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE00-\\uFE0F\\uFE20-\\uFE2F\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF3F\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]/\n    };\n\n    ES6Regex = {\n        // ECMAScript 6/Unicode v9.0.0 NonAsciiIdentifierStart:\n        NonAsciiIdentifierStart: /[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u08A0-\\u08B4\\u08B6-\\u08BD\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0AF9\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58-\\u0C5A\\u0C60\\u0C61\\u0C80\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D54-\\u0D56\\u0D5F-\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F5\\u13F8-\\u13FD\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1C80-\\u1C88\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2118-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309B-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FD5\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA7AE\\uA7B0-\\uA7B7\\uA7F7-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA8FD\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB65\\uAB70-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]|\\uD800[\\uDC00-\\uDC0B\\uDC0D-\\uDC26\\uDC28-\\uDC3A\\uDC3C\\uDC3D\\uDC3F-\\uDC4D\\uDC50-\\uDC5D\\uDC80-\\uDCFA\\uDD40-\\uDD74\\uDE80-\\uDE9C\\uDEA0-\\uDED0\\uDF00-\\uDF1F\\uDF30-\\uDF4A\\uDF50-\\uDF75\\uDF80-\\uDF9D\\uDFA0-\\uDFC3\\uDFC8-\\uDFCF\\uDFD1-\\uDFD5]|\\uD801[\\uDC00-\\uDC9D\\uDCB0-\\uDCD3\\uDCD8-\\uDCFB\\uDD00-\\uDD27\\uDD30-\\uDD63\\uDE00-\\uDF36\\uDF40-\\uDF55\\uDF60-\\uDF67]|\\uD802[\\uDC00-\\uDC05\\uDC08\\uDC0A-\\uDC35\\uDC37\\uDC38\\uDC3C\\uDC3F-\\uDC55\\uDC60-\\uDC76\\uDC80-\\uDC9E\\uDCE0-\\uDCF2\\uDCF4\\uDCF5\\uDD00-\\uDD15\\uDD20-\\uDD39\\uDD80-\\uDDB7\\uDDBE\\uDDBF\\uDE00\\uDE10-\\uDE13\\uDE15-\\uDE17\\uDE19-\\uDE33\\uDE60-\\uDE7C\\uDE80-\\uDE9C\\uDEC0-\\uDEC7\\uDEC9-\\uDEE4\\uDF00-\\uDF35\\uDF40-\\uDF55\\uDF60-\\uDF72\\uDF80-\\uDF91]|\\uD803[\\uDC00-\\uDC48\\uDC80-\\uDCB2\\uDCC0-\\uDCF2]|\\uD804[\\uDC03-\\uDC37\\uDC83-\\uDCAF\\uDCD0-\\uDCE8\\uDD03-\\uDD26\\uDD50-\\uDD72\\uDD76\\uDD83-\\uDDB2\\uDDC1-\\uDDC4\\uDDDA\\uDDDC\\uDE00-\\uDE11\\uDE13-\\uDE2B\\uDE80-\\uDE86\\uDE88\\uDE8A-\\uDE8D\\uDE8F-\\uDE9D\\uDE9F-\\uDEA8\\uDEB0-\\uDEDE\\uDF05-\\uDF0C\\uDF0F\\uDF10\\uDF13-\\uDF28\\uDF2A-\\uDF30\\uDF32\\uDF33\\uDF35-\\uDF39\\uDF3D\\uDF50\\uDF5D-\\uDF61]|\\uD805[\\uDC00-\\uDC34\\uDC47-\\uDC4A\\uDC80-\\uDCAF\\uDCC4\\uDCC5\\uDCC7\\uDD80-\\uDDAE\\uDDD8-\\uDDDB\\uDE00-\\uDE2F\\uDE44\\uDE80-\\uDEAA\\uDF00-\\uDF19]|\\uD806[\\uDCA0-\\uDCDF\\uDCFF\\uDEC0-\\uDEF8]|\\uD807[\\uDC00-\\uDC08\\uDC0A-\\uDC2E\\uDC40\\uDC72-\\uDC8F]|\\uD808[\\uDC00-\\uDF99]|\\uD809[\\uDC00-\\uDC6E\\uDC80-\\uDD43]|[\\uD80C\\uD81C-\\uD820\\uD840-\\uD868\\uD86A-\\uD86C\\uD86F-\\uD872][\\uDC00-\\uDFFF]|\\uD80D[\\uDC00-\\uDC2E]|\\uD811[\\uDC00-\\uDE46]|\\uD81A[\\uDC00-\\uDE38\\uDE40-\\uDE5E\\uDED0-\\uDEED\\uDF00-\\uDF2F\\uDF40-\\uDF43\\uDF63-\\uDF77\\uDF7D-\\uDF8F]|\\uD81B[\\uDF00-\\uDF44\\uDF50\\uDF93-\\uDF9F\\uDFE0]|\\uD821[\\uDC00-\\uDFEC]|\\uD822[\\uDC00-\\uDEF2]|\\uD82C[\\uDC00\\uDC01]|\\uD82F[\\uDC00-\\uDC6A\\uDC70-\\uDC7C\\uDC80-\\uDC88\\uDC90-\\uDC99]|\\uD835[\\uDC00-\\uDC54\\uDC56-\\uDC9C\\uDC9E\\uDC9F\\uDCA2\\uDCA5\\uDCA6\\uDCA9-\\uDCAC\\uDCAE-\\uDCB9\\uDCBB\\uDCBD-\\uDCC3\\uDCC5-\\uDD05\\uDD07-\\uDD0A\\uDD0D-\\uDD14\\uDD16-\\uDD1C\\uDD1E-\\uDD39\\uDD3B-\\uDD3E\\uDD40-\\uDD44\\uDD46\\uDD4A-\\uDD50\\uDD52-\\uDEA5\\uDEA8-\\uDEC0\\uDEC2-\\uDEDA\\uDEDC-\\uDEFA\\uDEFC-\\uDF14\\uDF16-\\uDF34\\uDF36-\\uDF4E\\uDF50-\\uDF6E\\uDF70-\\uDF88\\uDF8A-\\uDFA8\\uDFAA-\\uDFC2\\uDFC4-\\uDFCB]|\\uD83A[\\uDC00-\\uDCC4\\uDD00-\\uDD43]|\\uD83B[\\uDE00-\\uDE03\\uDE05-\\uDE1F\\uDE21\\uDE22\\uDE24\\uDE27\\uDE29-\\uDE32\\uDE34-\\uDE37\\uDE39\\uDE3B\\uDE42\\uDE47\\uDE49\\uDE4B\\uDE4D-\\uDE4F\\uDE51\\uDE52\\uDE54\\uDE57\\uDE59\\uDE5B\\uDE5D\\uDE5F\\uDE61\\uDE62\\uDE64\\uDE67-\\uDE6A\\uDE6C-\\uDE72\\uDE74-\\uDE77\\uDE79-\\uDE7C\\uDE7E\\uDE80-\\uDE89\\uDE8B-\\uDE9B\\uDEA1-\\uDEA3\\uDEA5-\\uDEA9\\uDEAB-\\uDEBB]|\\uD869[\\uDC00-\\uDED6\\uDF00-\\uDFFF]|\\uD86D[\\uDC00-\\uDF34\\uDF40-\\uDFFF]|\\uD86E[\\uDC00-\\uDC1D\\uDC20-\\uDFFF]|\\uD873[\\uDC00-\\uDEA1]|\\uD87E[\\uDC00-\\uDE1D]/,\n        // ECMAScript 6/Unicode v9.0.0 NonAsciiIdentifierPart:\n        NonAsciiIdentifierPart: /[\\xAA\\xB5\\xB7\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0300-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u0483-\\u0487\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0610-\\u061A\\u0620-\\u0669\\u066E-\\u06D3\\u06D5-\\u06DC\\u06DF-\\u06E8\\u06EA-\\u06FC\\u06FF\\u0710-\\u074A\\u074D-\\u07B1\\u07C0-\\u07F5\\u07FA\\u0800-\\u082D\\u0840-\\u085B\\u08A0-\\u08B4\\u08B6-\\u08BD\\u08D4-\\u08E1\\u08E3-\\u0963\\u0966-\\u096F\\u0971-\\u0983\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BC-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CE\\u09D7\\u09DC\\u09DD\\u09DF-\\u09E3\\u09E6-\\u09F1\\u0A01-\\u0A03\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A59-\\u0A5C\\u0A5E\\u0A66-\\u0A75\\u0A81-\\u0A83\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABC-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AD0\\u0AE0-\\u0AE3\\u0AE6-\\u0AEF\\u0AF9\\u0B01-\\u0B03\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3C-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B5C\\u0B5D\\u0B5F-\\u0B63\\u0B66-\\u0B6F\\u0B71\\u0B82\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD0\\u0BD7\\u0BE6-\\u0BEF\\u0C00-\\u0C03\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C58-\\u0C5A\\u0C60-\\u0C63\\u0C66-\\u0C6F\\u0C80-\\u0C83\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBC-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CDE\\u0CE0-\\u0CE3\\u0CE6-\\u0CEF\\u0CF1\\u0CF2\\u0D01-\\u0D03\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4E\\u0D54-\\u0D57\\u0D5F-\\u0D63\\u0D66-\\u0D6F\\u0D7A-\\u0D7F\\u0D82\\u0D83\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DE6-\\u0DEF\\u0DF2\\u0DF3\\u0E01-\\u0E3A\\u0E40-\\u0E4E\\u0E50-\\u0E59\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB9\\u0EBB-\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EC8-\\u0ECD\\u0ED0-\\u0ED9\\u0EDC-\\u0EDF\\u0F00\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E-\\u0F47\\u0F49-\\u0F6C\\u0F71-\\u0F84\\u0F86-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u1000-\\u1049\\u1050-\\u109D\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u135D-\\u135F\\u1369-\\u1371\\u1380-\\u138F\\u13A0-\\u13F5\\u13F8-\\u13FD\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1714\\u1720-\\u1734\\u1740-\\u1753\\u1760-\\u176C\\u176E-\\u1770\\u1772\\u1773\\u1780-\\u17D3\\u17D7\\u17DC\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u1810-\\u1819\\u1820-\\u1877\\u1880-\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1920-\\u192B\\u1930-\\u193B\\u1946-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u19D0-\\u19DA\\u1A00-\\u1A1B\\u1A20-\\u1A5E\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1AA7\\u1AB0-\\u1ABD\\u1B00-\\u1B4B\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1B80-\\u1BF3\\u1C00-\\u1C37\\u1C40-\\u1C49\\u1C4D-\\u1C7D\\u1C80-\\u1C88\\u1CD0-\\u1CD2\\u1CD4-\\u1CF6\\u1CF8\\u1CF9\\u1D00-\\u1DF5\\u1DFB-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u200C\\u200D\\u203F\\u2040\\u2054\\u2071\\u207F\\u2090-\\u209C\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2118-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D7F-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2DE0-\\u2DFF\\u3005-\\u3007\\u3021-\\u302F\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u3099-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FD5\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA66F\\uA674-\\uA67D\\uA67F-\\uA6F1\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA7AE\\uA7B0-\\uA7B7\\uA7F7-\\uA827\\uA840-\\uA873\\uA880-\\uA8C5\\uA8D0-\\uA8D9\\uA8E0-\\uA8F7\\uA8FB\\uA8FD\\uA900-\\uA92D\\uA930-\\uA953\\uA960-\\uA97C\\uA980-\\uA9C0\\uA9CF-\\uA9D9\\uA9E0-\\uA9FE\\uAA00-\\uAA36\\uAA40-\\uAA4D\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A-\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEF\\uAAF2-\\uAAF6\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB65\\uAB70-\\uABEA\\uABEC\\uABED\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE00-\\uFE0F\\uFE20-\\uFE2F\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF3F\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]|\\uD800[\\uDC00-\\uDC0B\\uDC0D-\\uDC26\\uDC28-\\uDC3A\\uDC3C\\uDC3D\\uDC3F-\\uDC4D\\uDC50-\\uDC5D\\uDC80-\\uDCFA\\uDD40-\\uDD74\\uDDFD\\uDE80-\\uDE9C\\uDEA0-\\uDED0\\uDEE0\\uDF00-\\uDF1F\\uDF30-\\uDF4A\\uDF50-\\uDF7A\\uDF80-\\uDF9D\\uDFA0-\\uDFC3\\uDFC8-\\uDFCF\\uDFD1-\\uDFD5]|\\uD801[\\uDC00-\\uDC9D\\uDCA0-\\uDCA9\\uDCB0-\\uDCD3\\uDCD8-\\uDCFB\\uDD00-\\uDD27\\uDD30-\\uDD63\\uDE00-\\uDF36\\uDF40-\\uDF55\\uDF60-\\uDF67]|\\uD802[\\uDC00-\\uDC05\\uDC08\\uDC0A-\\uDC35\\uDC37\\uDC38\\uDC3C\\uDC3F-\\uDC55\\uDC60-\\uDC76\\uDC80-\\uDC9E\\uDCE0-\\uDCF2\\uDCF4\\uDCF5\\uDD00-\\uDD15\\uDD20-\\uDD39\\uDD80-\\uDDB7\\uDDBE\\uDDBF\\uDE00-\\uDE03\\uDE05\\uDE06\\uDE0C-\\uDE13\\uDE15-\\uDE17\\uDE19-\\uDE33\\uDE38-\\uDE3A\\uDE3F\\uDE60-\\uDE7C\\uDE80-\\uDE9C\\uDEC0-\\uDEC7\\uDEC9-\\uDEE6\\uDF00-\\uDF35\\uDF40-\\uDF55\\uDF60-\\uDF72\\uDF80-\\uDF91]|\\uD803[\\uDC00-\\uDC48\\uDC80-\\uDCB2\\uDCC0-\\uDCF2]|\\uD804[\\uDC00-\\uDC46\\uDC66-\\uDC6F\\uDC7F-\\uDCBA\\uDCD0-\\uDCE8\\uDCF0-\\uDCF9\\uDD00-\\uDD34\\uDD36-\\uDD3F\\uDD50-\\uDD73\\uDD76\\uDD80-\\uDDC4\\uDDCA-\\uDDCC\\uDDD0-\\uDDDA\\uDDDC\\uDE00-\\uDE11\\uDE13-\\uDE37\\uDE3E\\uDE80-\\uDE86\\uDE88\\uDE8A-\\uDE8D\\uDE8F-\\uDE9D\\uDE9F-\\uDEA8\\uDEB0-\\uDEEA\\uDEF0-\\uDEF9\\uDF00-\\uDF03\\uDF05-\\uDF0C\\uDF0F\\uDF10\\uDF13-\\uDF28\\uDF2A-\\uDF30\\uDF32\\uDF33\\uDF35-\\uDF39\\uDF3C-\\uDF44\\uDF47\\uDF48\\uDF4B-\\uDF4D\\uDF50\\uDF57\\uDF5D-\\uDF63\\uDF66-\\uDF6C\\uDF70-\\uDF74]|\\uD805[\\uDC00-\\uDC4A\\uDC50-\\uDC59\\uDC80-\\uDCC5\\uDCC7\\uDCD0-\\uDCD9\\uDD80-\\uDDB5\\uDDB8-\\uDDC0\\uDDD8-\\uDDDD\\uDE00-\\uDE40\\uDE44\\uDE50-\\uDE59\\uDE80-\\uDEB7\\uDEC0-\\uDEC9\\uDF00-\\uDF19\\uDF1D-\\uDF2B\\uDF30-\\uDF39]|\\uD806[\\uDCA0-\\uDCE9\\uDCFF\\uDEC0-\\uDEF8]|\\uD807[\\uDC00-\\uDC08\\uDC0A-\\uDC36\\uDC38-\\uDC40\\uDC50-\\uDC59\\uDC72-\\uDC8F\\uDC92-\\uDCA7\\uDCA9-\\uDCB6]|\\uD808[\\uDC00-\\uDF99]|\\uD809[\\uDC00-\\uDC6E\\uDC80-\\uDD43]|[\\uD80C\\uD81C-\\uD820\\uD840-\\uD868\\uD86A-\\uD86C\\uD86F-\\uD872][\\uDC00-\\uDFFF]|\\uD80D[\\uDC00-\\uDC2E]|\\uD811[\\uDC00-\\uDE46]|\\uD81A[\\uDC00-\\uDE38\\uDE40-\\uDE5E\\uDE60-\\uDE69\\uDED0-\\uDEED\\uDEF0-\\uDEF4\\uDF00-\\uDF36\\uDF40-\\uDF43\\uDF50-\\uDF59\\uDF63-\\uDF77\\uDF7D-\\uDF8F]|\\uD81B[\\uDF00-\\uDF44\\uDF50-\\uDF7E\\uDF8F-\\uDF9F\\uDFE0]|\\uD821[\\uDC00-\\uDFEC]|\\uD822[\\uDC00-\\uDEF2]|\\uD82C[\\uDC00\\uDC01]|\\uD82F[\\uDC00-\\uDC6A\\uDC70-\\uDC7C\\uDC80-\\uDC88\\uDC90-\\uDC99\\uDC9D\\uDC9E]|\\uD834[\\uDD65-\\uDD69\\uDD6D-\\uDD72\\uDD7B-\\uDD82\\uDD85-\\uDD8B\\uDDAA-\\uDDAD\\uDE42-\\uDE44]|\\uD835[\\uDC00-\\uDC54\\uDC56-\\uDC9C\\uDC9E\\uDC9F\\uDCA2\\uDCA5\\uDCA6\\uDCA9-\\uDCAC\\uDCAE-\\uDCB9\\uDCBB\\uDCBD-\\uDCC3\\uDCC5-\\uDD05\\uDD07-\\uDD0A\\uDD0D-\\uDD14\\uDD16-\\uDD1C\\uDD1E-\\uDD39\\uDD3B-\\uDD3E\\uDD40-\\uDD44\\uDD46\\uDD4A-\\uDD50\\uDD52-\\uDEA5\\uDEA8-\\uDEC0\\uDEC2-\\uDEDA\\uDEDC-\\uDEFA\\uDEFC-\\uDF14\\uDF16-\\uDF34\\uDF36-\\uDF4E\\uDF50-\\uDF6E\\uDF70-\\uDF88\\uDF8A-\\uDFA8\\uDFAA-\\uDFC2\\uDFC4-\\uDFCB\\uDFCE-\\uDFFF]|\\uD836[\\uDE00-\\uDE36\\uDE3B-\\uDE6C\\uDE75\\uDE84\\uDE9B-\\uDE9F\\uDEA1-\\uDEAF]|\\uD838[\\uDC00-\\uDC06\\uDC08-\\uDC18\\uDC1B-\\uDC21\\uDC23\\uDC24\\uDC26-\\uDC2A]|\\uD83A[\\uDC00-\\uDCC4\\uDCD0-\\uDCD6\\uDD00-\\uDD4A\\uDD50-\\uDD59]|\\uD83B[\\uDE00-\\uDE03\\uDE05-\\uDE1F\\uDE21\\uDE22\\uDE24\\uDE27\\uDE29-\\uDE32\\uDE34-\\uDE37\\uDE39\\uDE3B\\uDE42\\uDE47\\uDE49\\uDE4B\\uDE4D-\\uDE4F\\uDE51\\uDE52\\uDE54\\uDE57\\uDE59\\uDE5B\\uDE5D\\uDE5F\\uDE61\\uDE62\\uDE64\\uDE67-\\uDE6A\\uDE6C-\\uDE72\\uDE74-\\uDE77\\uDE79-\\uDE7C\\uDE7E\\uDE80-\\uDE89\\uDE8B-\\uDE9B\\uDEA1-\\uDEA3\\uDEA5-\\uDEA9\\uDEAB-\\uDEBB]|\\uD869[\\uDC00-\\uDED6\\uDF00-\\uDFFF]|\\uD86D[\\uDC00-\\uDF34\\uDF40-\\uDFFF]|\\uD86E[\\uDC00-\\uDC1D\\uDC20-\\uDFFF]|\\uD873[\\uDC00-\\uDEA1]|\\uD87E[\\uDC00-\\uDE1D]|\\uDB40[\\uDD00-\\uDDEF]/\n    };\n\n    function isDecimalDigit(ch) {\n        return 0x30 <= ch && ch <= 0x39;  // 0..9\n    }\n\n    function isHexDigit(ch) {\n        return 0x30 <= ch && ch <= 0x39 ||  // 0..9\n            0x61 <= ch && ch <= 0x66 ||     // a..f\n            0x41 <= ch && ch <= 0x46;       // A..F\n    }\n\n    function isOctalDigit(ch) {\n        return ch >= 0x30 && ch <= 0x37;  // 0..7\n    }\n\n    // 7.2 White Space\n\n    NON_ASCII_WHITESPACES = [\n        0x1680,\n        0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A,\n        0x202F, 0x205F,\n        0x3000,\n        0xFEFF\n    ];\n\n    function isWhiteSpace(ch) {\n        return ch === 0x20 || ch === 0x09 || ch === 0x0B || ch === 0x0C || ch === 0xA0 ||\n            ch >= 0x1680 && NON_ASCII_WHITESPACES.indexOf(ch) >= 0;\n    }\n\n    // 7.3 Line Terminators\n\n    function isLineTerminator(ch) {\n        return ch === 0x0A || ch === 0x0D || ch === 0x2028 || ch === 0x2029;\n    }\n\n    // 7.6 Identifier Names and Identifiers\n\n    function fromCodePoint(cp) {\n        if (cp <= 0xFFFF) { return String.fromCharCode(cp); }\n        var cu1 = String.fromCharCode(Math.floor((cp - 0x10000) / 0x400) + 0xD800);\n        var cu2 = String.fromCharCode(((cp - 0x10000) % 0x400) + 0xDC00);\n        return cu1 + cu2;\n    }\n\n    IDENTIFIER_START = new Array(0x80);\n    for(ch = 0; ch < 0x80; ++ch) {\n        IDENTIFIER_START[ch] =\n            ch >= 0x61 && ch <= 0x7A ||  // a..z\n            ch >= 0x41 && ch <= 0x5A ||  // A..Z\n            ch === 0x24 || ch === 0x5F;  // $ (dollar) and _ (underscore)\n    }\n\n    IDENTIFIER_PART = new Array(0x80);\n    for(ch = 0; ch < 0x80; ++ch) {\n        IDENTIFIER_PART[ch] =\n            ch >= 0x61 && ch <= 0x7A ||  // a..z\n            ch >= 0x41 && ch <= 0x5A ||  // A..Z\n            ch >= 0x30 && ch <= 0x39 ||  // 0..9\n            ch === 0x24 || ch === 0x5F;  // $ (dollar) and _ (underscore)\n    }\n\n    function isIdentifierStartES5(ch) {\n        return ch < 0x80 ? IDENTIFIER_START[ch] : ES5Regex.NonAsciiIdentifierStart.test(fromCodePoint(ch));\n    }\n\n    function isIdentifierPartES5(ch) {\n        return ch < 0x80 ? IDENTIFIER_PART[ch] : ES5Regex.NonAsciiIdentifierPart.test(fromCodePoint(ch));\n    }\n\n    function isIdentifierStartES6(ch) {\n        return ch < 0x80 ? IDENTIFIER_START[ch] : ES6Regex.NonAsciiIdentifierStart.test(fromCodePoint(ch));\n    }\n\n    function isIdentifierPartES6(ch) {\n        return ch < 0x80 ? IDENTIFIER_PART[ch] : ES6Regex.NonAsciiIdentifierPart.test(fromCodePoint(ch));\n    }\n\n    module.exports = {\n        isDecimalDigit: isDecimalDigit,\n        isHexDigit: isHexDigit,\n        isOctalDigit: isOctalDigit,\n        isWhiteSpace: isWhiteSpace,\n        isLineTerminator: isLineTerminator,\n        isIdentifierStartES5: isIdentifierStartES5,\n        isIdentifierPartES5: isIdentifierPartES5,\n        isIdentifierStartES6: isIdentifierStartES6,\n        isIdentifierPartES6: isIdentifierPartES6\n    };\n}());\n/* vim: set sw=4 ts=4 et tw=80 : */\n\n\n//# sourceURL=webpack://javascript/./node_modules/esutils/lib/code.js?");

/***/ }),

/***/ "./node_modules/esutils/lib/keyword.js":
/*!*********************************************!*\
  !*** ./node_modules/esutils/lib/keyword.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*\n  Copyright (C) 2013 Yusuke Suzuki <utatane.tea@gmail.com>\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n(function () {\n    'use strict';\n\n    var code = __webpack_require__(/*! ./code */ \"./node_modules/esutils/lib/code.js\");\n\n    function isStrictModeReservedWordES6(id) {\n        switch (id) {\n        case 'implements':\n        case 'interface':\n        case 'package':\n        case 'private':\n        case 'protected':\n        case 'public':\n        case 'static':\n        case 'let':\n            return true;\n        default:\n            return false;\n        }\n    }\n\n    function isKeywordES5(id, strict) {\n        // yield should not be treated as keyword under non-strict mode.\n        if (!strict && id === 'yield') {\n            return false;\n        }\n        return isKeywordES6(id, strict);\n    }\n\n    function isKeywordES6(id, strict) {\n        if (strict && isStrictModeReservedWordES6(id)) {\n            return true;\n        }\n\n        switch (id.length) {\n        case 2:\n            return (id === 'if') || (id === 'in') || (id === 'do');\n        case 3:\n            return (id === 'var') || (id === 'for') || (id === 'new') || (id === 'try');\n        case 4:\n            return (id === 'this') || (id === 'else') || (id === 'case') ||\n                (id === 'void') || (id === 'with') || (id === 'enum');\n        case 5:\n            return (id === 'while') || (id === 'break') || (id === 'catch') ||\n                (id === 'throw') || (id === 'const') || (id === 'yield') ||\n                (id === 'class') || (id === 'super');\n        case 6:\n            return (id === 'return') || (id === 'typeof') || (id === 'delete') ||\n                (id === 'switch') || (id === 'export') || (id === 'import');\n        case 7:\n            return (id === 'default') || (id === 'finally') || (id === 'extends');\n        case 8:\n            return (id === 'function') || (id === 'continue') || (id === 'debugger');\n        case 10:\n            return (id === 'instanceof');\n        default:\n            return false;\n        }\n    }\n\n    function isReservedWordES5(id, strict) {\n        return id === 'null' || id === 'true' || id === 'false' || isKeywordES5(id, strict);\n    }\n\n    function isReservedWordES6(id, strict) {\n        return id === 'null' || id === 'true' || id === 'false' || isKeywordES6(id, strict);\n    }\n\n    function isRestrictedWord(id) {\n        return id === 'eval' || id === 'arguments';\n    }\n\n    function isIdentifierNameES5(id) {\n        var i, iz, ch;\n\n        if (id.length === 0) { return false; }\n\n        ch = id.charCodeAt(0);\n        if (!code.isIdentifierStartES5(ch)) {\n            return false;\n        }\n\n        for (i = 1, iz = id.length; i < iz; ++i) {\n            ch = id.charCodeAt(i);\n            if (!code.isIdentifierPartES5(ch)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    function decodeUtf16(lead, trail) {\n        return (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;\n    }\n\n    function isIdentifierNameES6(id) {\n        var i, iz, ch, lowCh, check;\n\n        if (id.length === 0) { return false; }\n\n        check = code.isIdentifierStartES6;\n        for (i = 0, iz = id.length; i < iz; ++i) {\n            ch = id.charCodeAt(i);\n            if (0xD800 <= ch && ch <= 0xDBFF) {\n                ++i;\n                if (i >= iz) { return false; }\n                lowCh = id.charCodeAt(i);\n                if (!(0xDC00 <= lowCh && lowCh <= 0xDFFF)) {\n                    return false;\n                }\n                ch = decodeUtf16(ch, lowCh);\n            }\n            if (!check(ch)) {\n                return false;\n            }\n            check = code.isIdentifierPartES6;\n        }\n        return true;\n    }\n\n    function isIdentifierES5(id, strict) {\n        return isIdentifierNameES5(id) && !isReservedWordES5(id, strict);\n    }\n\n    function isIdentifierES6(id, strict) {\n        return isIdentifierNameES6(id) && !isReservedWordES6(id, strict);\n    }\n\n    module.exports = {\n        isKeywordES5: isKeywordES5,\n        isKeywordES6: isKeywordES6,\n        isReservedWordES5: isReservedWordES5,\n        isReservedWordES6: isReservedWordES6,\n        isRestrictedWord: isRestrictedWord,\n        isIdentifierNameES5: isIdentifierNameES5,\n        isIdentifierNameES6: isIdentifierNameES6,\n        isIdentifierES5: isIdentifierES5,\n        isIdentifierES6: isIdentifierES6\n    };\n}());\n/* vim: set sw=4 ts=4 et tw=80 : */\n\n\n//# sourceURL=webpack://javascript/./node_modules/esutils/lib/keyword.js?");

/***/ }),

/***/ "./node_modules/esutils/lib/utils.js":
/*!*******************************************!*\
  !*** ./node_modules/esutils/lib/utils.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/*\n  Copyright (C) 2013 Yusuke Suzuki <utatane.tea@gmail.com>\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n\n(function () {\n    'use strict';\n\n    exports.ast = __webpack_require__(/*! ./ast */ \"./node_modules/esutils/lib/ast.js\");\n    exports.code = __webpack_require__(/*! ./code */ \"./node_modules/esutils/lib/code.js\");\n    exports.keyword = __webpack_require__(/*! ./keyword */ \"./node_modules/esutils/lib/keyword.js\");\n}());\n/* vim: set sw=4 ts=4 et tw=80 : */\n\n\n//# sourceURL=webpack://javascript/./node_modules/esutils/lib/utils.js?");

/***/ }),

/***/ "./node_modules/fast-deep-equal/index.js":
/*!***********************************************!*\
  !*** ./node_modules/fast-deep-equal/index.js ***!
  \***********************************************/
/***/ ((module) => {

"use strict";
eval("\n\n// do not edit .js files directly - edit src/index.jst\n\n\n\nmodule.exports = function equal(a, b) {\n  if (a === b) return true;\n\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    if (a.constructor !== b.constructor) return false;\n\n    var length, i, keys;\n    if (Array.isArray(a)) {\n      length = a.length;\n      if (length != b.length) return false;\n      for (i = length; i-- !== 0;)\n        if (!equal(a[i], b[i])) return false;\n      return true;\n    }\n\n\n\n    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;\n    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();\n    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();\n\n    keys = Object.keys(a);\n    length = keys.length;\n    if (length !== Object.keys(b).length) return false;\n\n    for (i = length; i-- !== 0;)\n      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n\n    for (i = length; i-- !== 0;) {\n      var key = keys[i];\n\n      if (!equal(a[key], b[key])) return false;\n    }\n\n    return true;\n  }\n\n  // true if both NaN, false otherwise\n  return a!==a && b!==b;\n};\n\n\n//# sourceURL=webpack://javascript/./node_modules/fast-deep-equal/index.js?");

/***/ }),

/***/ "./node_modules/fast-json-stable-stringify/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/fast-json-stable-stringify/index.js ***!
  \**********************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = function (data, opts) {\n    if (!opts) opts = {};\n    if (typeof opts === 'function') opts = { cmp: opts };\n    var cycles = (typeof opts.cycles === 'boolean') ? opts.cycles : false;\n\n    var cmp = opts.cmp && (function (f) {\n        return function (node) {\n            return function (a, b) {\n                var aobj = { key: a, value: node[a] };\n                var bobj = { key: b, value: node[b] };\n                return f(aobj, bobj);\n            };\n        };\n    })(opts.cmp);\n\n    var seen = [];\n    return (function stringify (node) {\n        if (node && node.toJSON && typeof node.toJSON === 'function') {\n            node = node.toJSON();\n        }\n\n        if (node === undefined) return;\n        if (typeof node == 'number') return isFinite(node) ? '' + node : 'null';\n        if (typeof node !== 'object') return JSON.stringify(node);\n\n        var i, out;\n        if (Array.isArray(node)) {\n            out = '[';\n            for (i = 0; i < node.length; i++) {\n                if (i) out += ',';\n                out += stringify(node[i]) || 'null';\n            }\n            return out + ']';\n        }\n\n        if (node === null) return 'null';\n\n        if (seen.indexOf(node) !== -1) {\n            if (cycles) return JSON.stringify('__cycle__');\n            throw new TypeError('Converting circular structure to JSON');\n        }\n\n        var seenIndex = seen.push(node) - 1;\n        var keys = Object.keys(node).sort(cmp && cmp(node));\n        out = '';\n        for (i = 0; i < keys.length; i++) {\n            var key = keys[i];\n            var value = stringify(node[key]);\n\n            if (!value) continue;\n            if (out) out += ',';\n            out += JSON.stringify(key) + ':' + value;\n        }\n        seen.splice(seenIndex, 1);\n        return '{' + out + '}';\n    })(data);\n};\n\n\n//# sourceURL=webpack://javascript/./node_modules/fast-json-stable-stringify/index.js?");

/***/ }),

/***/ "./node_modules/foreach/index.js":
/*!***************************************!*\
  !*** ./node_modules/foreach/index.js ***!
  \***************************************/
/***/ ((module) => {

eval("\nvar hasOwn = Object.prototype.hasOwnProperty;\nvar toString = Object.prototype.toString;\n\nmodule.exports = function forEach (obj, fn, ctx) {\n    if (toString.call(fn) !== '[object Function]') {\n        throw new TypeError('iterator must be a function');\n    }\n    var l = obj.length;\n    if (l === +l) {\n        for (var i = 0; i < l; i++) {\n            fn.call(ctx, obj[i], i, obj);\n        }\n    } else {\n        for (var k in obj) {\n            if (hasOwn.call(obj, k)) {\n                fn.call(ctx, obj[k], k, obj);\n            }\n        }\n    }\n};\n\n\n\n//# sourceURL=webpack://javascript/./node_modules/foreach/index.js?");

/***/ }),

/***/ "./node_modules/function-bind/implementation.js":
/*!******************************************************!*\
  !*** ./node_modules/function-bind/implementation.js ***!
  \******************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/* eslint no-invalid-this: 1 */\n\nvar ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';\nvar slice = Array.prototype.slice;\nvar toStr = Object.prototype.toString;\nvar funcType = '[object Function]';\n\nmodule.exports = function bind(that) {\n    var target = this;\n    if (typeof target !== 'function' || toStr.call(target) !== funcType) {\n        throw new TypeError(ERROR_MESSAGE + target);\n    }\n    var args = slice.call(arguments, 1);\n\n    var bound;\n    var binder = function () {\n        if (this instanceof bound) {\n            var result = target.apply(\n                this,\n                args.concat(slice.call(arguments))\n            );\n            if (Object(result) === result) {\n                return result;\n            }\n            return this;\n        } else {\n            return target.apply(\n                that,\n                args.concat(slice.call(arguments))\n            );\n        }\n    };\n\n    var boundLength = Math.max(0, target.length - args.length);\n    var boundArgs = [];\n    for (var i = 0; i < boundLength; i++) {\n        boundArgs.push('$' + i);\n    }\n\n    bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this,arguments); }')(binder);\n\n    if (target.prototype) {\n        var Empty = function Empty() {};\n        Empty.prototype = target.prototype;\n        bound.prototype = new Empty();\n        Empty.prototype = null;\n    }\n\n    return bound;\n};\n\n\n//# sourceURL=webpack://javascript/./node_modules/function-bind/implementation.js?");

/***/ }),

/***/ "./node_modules/function-bind/index.js":
/*!*********************************************!*\
  !*** ./node_modules/function-bind/index.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar implementation = __webpack_require__(/*! ./implementation */ \"./node_modules/function-bind/implementation.js\");\n\nmodule.exports = Function.prototype.bind || implementation;\n\n\n//# sourceURL=webpack://javascript/./node_modules/function-bind/index.js?");

/***/ }),

/***/ "./node_modules/functional-red-black-tree/rbtree.js":
/*!**********************************************************!*\
  !*** ./node_modules/functional-red-black-tree/rbtree.js ***!
  \**********************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = createRBTree\n\nvar RED   = 0\nvar BLACK = 1\n\nfunction RBNode(color, key, value, left, right, count) {\n  this._color = color\n  this.key = key\n  this.value = value\n  this.left = left\n  this.right = right\n  this._count = count\n}\n\nfunction cloneNode(node) {\n  return new RBNode(node._color, node.key, node.value, node.left, node.right, node._count)\n}\n\nfunction repaint(color, node) {\n  return new RBNode(color, node.key, node.value, node.left, node.right, node._count)\n}\n\nfunction recount(node) {\n  node._count = 1 + (node.left ? node.left._count : 0) + (node.right ? node.right._count : 0)\n}\n\nfunction RedBlackTree(compare, root) {\n  this._compare = compare\n  this.root = root\n}\n\nvar proto = RedBlackTree.prototype\n\nObject.defineProperty(proto, \"keys\", {\n  get: function() {\n    var result = []\n    this.forEach(function(k,v) {\n      result.push(k)\n    })\n    return result\n  }\n})\n\nObject.defineProperty(proto, \"values\", {\n  get: function() {\n    var result = []\n    this.forEach(function(k,v) {\n      result.push(v)\n    })\n    return result\n  }\n})\n\n//Returns the number of nodes in the tree\nObject.defineProperty(proto, \"length\", {\n  get: function() {\n    if(this.root) {\n      return this.root._count\n    }\n    return 0\n  }\n})\n\n//Insert a new item into the tree\nproto.insert = function(key, value) {\n  var cmp = this._compare\n  //Find point to insert new node at\n  var n = this.root\n  var n_stack = []\n  var d_stack = []\n  while(n) {\n    var d = cmp(key, n.key)\n    n_stack.push(n)\n    d_stack.push(d)\n    if(d <= 0) {\n      n = n.left\n    } else {\n      n = n.right\n    }\n  }\n  //Rebuild path to leaf node\n  n_stack.push(new RBNode(RED, key, value, null, null, 1))\n  for(var s=n_stack.length-2; s>=0; --s) {\n    var n = n_stack[s]\n    if(d_stack[s] <= 0) {\n      n_stack[s] = new RBNode(n._color, n.key, n.value, n_stack[s+1], n.right, n._count+1)\n    } else {\n      n_stack[s] = new RBNode(n._color, n.key, n.value, n.left, n_stack[s+1], n._count+1)\n    }\n  }\n  //Rebalance tree using rotations\n  //console.log(\"start insert\", key, d_stack)\n  for(var s=n_stack.length-1; s>1; --s) {\n    var p = n_stack[s-1]\n    var n = n_stack[s]\n    if(p._color === BLACK || n._color === BLACK) {\n      break\n    }\n    var pp = n_stack[s-2]\n    if(pp.left === p) {\n      if(p.left === n) {\n        var y = pp.right\n        if(y && y._color === RED) {\n          //console.log(\"LLr\")\n          p._color = BLACK\n          pp.right = repaint(BLACK, y)\n          pp._color = RED\n          s -= 1\n        } else {\n          //console.log(\"LLb\")\n          pp._color = RED\n          pp.left = p.right\n          p._color = BLACK\n          p.right = pp\n          n_stack[s-2] = p\n          n_stack[s-1] = n\n          recount(pp)\n          recount(p)\n          if(s >= 3) {\n            var ppp = n_stack[s-3]\n            if(ppp.left === pp) {\n              ppp.left = p\n            } else {\n              ppp.right = p\n            }\n          }\n          break\n        }\n      } else {\n        var y = pp.right\n        if(y && y._color === RED) {\n          //console.log(\"LRr\")\n          p._color = BLACK\n          pp.right = repaint(BLACK, y)\n          pp._color = RED\n          s -= 1\n        } else {\n          //console.log(\"LRb\")\n          p.right = n.left\n          pp._color = RED\n          pp.left = n.right\n          n._color = BLACK\n          n.left = p\n          n.right = pp\n          n_stack[s-2] = n\n          n_stack[s-1] = p\n          recount(pp)\n          recount(p)\n          recount(n)\n          if(s >= 3) {\n            var ppp = n_stack[s-3]\n            if(ppp.left === pp) {\n              ppp.left = n\n            } else {\n              ppp.right = n\n            }\n          }\n          break\n        }\n      }\n    } else {\n      if(p.right === n) {\n        var y = pp.left\n        if(y && y._color === RED) {\n          //console.log(\"RRr\", y.key)\n          p._color = BLACK\n          pp.left = repaint(BLACK, y)\n          pp._color = RED\n          s -= 1\n        } else {\n          //console.log(\"RRb\")\n          pp._color = RED\n          pp.right = p.left\n          p._color = BLACK\n          p.left = pp\n          n_stack[s-2] = p\n          n_stack[s-1] = n\n          recount(pp)\n          recount(p)\n          if(s >= 3) {\n            var ppp = n_stack[s-3]\n            if(ppp.right === pp) {\n              ppp.right = p\n            } else {\n              ppp.left = p\n            }\n          }\n          break\n        }\n      } else {\n        var y = pp.left\n        if(y && y._color === RED) {\n          //console.log(\"RLr\")\n          p._color = BLACK\n          pp.left = repaint(BLACK, y)\n          pp._color = RED\n          s -= 1\n        } else {\n          //console.log(\"RLb\")\n          p.left = n.right\n          pp._color = RED\n          pp.right = n.left\n          n._color = BLACK\n          n.right = p\n          n.left = pp\n          n_stack[s-2] = n\n          n_stack[s-1] = p\n          recount(pp)\n          recount(p)\n          recount(n)\n          if(s >= 3) {\n            var ppp = n_stack[s-3]\n            if(ppp.right === pp) {\n              ppp.right = n\n            } else {\n              ppp.left = n\n            }\n          }\n          break\n        }\n      }\n    }\n  }\n  //Return new tree\n  n_stack[0]._color = BLACK\n  return new RedBlackTree(cmp, n_stack[0])\n}\n\n\n//Visit all nodes inorder\nfunction doVisitFull(visit, node) {\n  if(node.left) {\n    var v = doVisitFull(visit, node.left)\n    if(v) { return v }\n  }\n  var v = visit(node.key, node.value)\n  if(v) { return v }\n  if(node.right) {\n    return doVisitFull(visit, node.right)\n  }\n}\n\n//Visit half nodes in order\nfunction doVisitHalf(lo, compare, visit, node) {\n  var l = compare(lo, node.key)\n  if(l <= 0) {\n    if(node.left) {\n      var v = doVisitHalf(lo, compare, visit, node.left)\n      if(v) { return v }\n    }\n    var v = visit(node.key, node.value)\n    if(v) { return v }\n  }\n  if(node.right) {\n    return doVisitHalf(lo, compare, visit, node.right)\n  }\n}\n\n//Visit all nodes within a range\nfunction doVisit(lo, hi, compare, visit, node) {\n  var l = compare(lo, node.key)\n  var h = compare(hi, node.key)\n  var v\n  if(l <= 0) {\n    if(node.left) {\n      v = doVisit(lo, hi, compare, visit, node.left)\n      if(v) { return v }\n    }\n    if(h > 0) {\n      v = visit(node.key, node.value)\n      if(v) { return v }\n    }\n  }\n  if(h > 0 && node.right) {\n    return doVisit(lo, hi, compare, visit, node.right)\n  }\n}\n\n\nproto.forEach = function rbTreeForEach(visit, lo, hi) {\n  if(!this.root) {\n    return\n  }\n  switch(arguments.length) {\n    case 1:\n      return doVisitFull(visit, this.root)\n    break\n\n    case 2:\n      return doVisitHalf(lo, this._compare, visit, this.root)\n    break\n\n    case 3:\n      if(this._compare(lo, hi) >= 0) {\n        return\n      }\n      return doVisit(lo, hi, this._compare, visit, this.root)\n    break\n  }\n}\n\n//First item in list\nObject.defineProperty(proto, \"begin\", {\n  get: function() {\n    var stack = []\n    var n = this.root\n    while(n) {\n      stack.push(n)\n      n = n.left\n    }\n    return new RedBlackTreeIterator(this, stack)\n  }\n})\n\n//Last item in list\nObject.defineProperty(proto, \"end\", {\n  get: function() {\n    var stack = []\n    var n = this.root\n    while(n) {\n      stack.push(n)\n      n = n.right\n    }\n    return new RedBlackTreeIterator(this, stack)\n  }\n})\n\n//Find the ith item in the tree\nproto.at = function(idx) {\n  if(idx < 0) {\n    return new RedBlackTreeIterator(this, [])\n  }\n  var n = this.root\n  var stack = []\n  while(true) {\n    stack.push(n)\n    if(n.left) {\n      if(idx < n.left._count) {\n        n = n.left\n        continue\n      }\n      idx -= n.left._count\n    }\n    if(!idx) {\n      return new RedBlackTreeIterator(this, stack)\n    }\n    idx -= 1\n    if(n.right) {\n      if(idx >= n.right._count) {\n        break\n      }\n      n = n.right\n    } else {\n      break\n    }\n  }\n  return new RedBlackTreeIterator(this, [])\n}\n\nproto.ge = function(key) {\n  var cmp = this._compare\n  var n = this.root\n  var stack = []\n  var last_ptr = 0\n  while(n) {\n    var d = cmp(key, n.key)\n    stack.push(n)\n    if(d <= 0) {\n      last_ptr = stack.length\n    }\n    if(d <= 0) {\n      n = n.left\n    } else {\n      n = n.right\n    }\n  }\n  stack.length = last_ptr\n  return new RedBlackTreeIterator(this, stack)\n}\n\nproto.gt = function(key) {\n  var cmp = this._compare\n  var n = this.root\n  var stack = []\n  var last_ptr = 0\n  while(n) {\n    var d = cmp(key, n.key)\n    stack.push(n)\n    if(d < 0) {\n      last_ptr = stack.length\n    }\n    if(d < 0) {\n      n = n.left\n    } else {\n      n = n.right\n    }\n  }\n  stack.length = last_ptr\n  return new RedBlackTreeIterator(this, stack)\n}\n\nproto.lt = function(key) {\n  var cmp = this._compare\n  var n = this.root\n  var stack = []\n  var last_ptr = 0\n  while(n) {\n    var d = cmp(key, n.key)\n    stack.push(n)\n    if(d > 0) {\n      last_ptr = stack.length\n    }\n    if(d <= 0) {\n      n = n.left\n    } else {\n      n = n.right\n    }\n  }\n  stack.length = last_ptr\n  return new RedBlackTreeIterator(this, stack)\n}\n\nproto.le = function(key) {\n  var cmp = this._compare\n  var n = this.root\n  var stack = []\n  var last_ptr = 0\n  while(n) {\n    var d = cmp(key, n.key)\n    stack.push(n)\n    if(d >= 0) {\n      last_ptr = stack.length\n    }\n    if(d < 0) {\n      n = n.left\n    } else {\n      n = n.right\n    }\n  }\n  stack.length = last_ptr\n  return new RedBlackTreeIterator(this, stack)\n}\n\n//Finds the item with key if it exists\nproto.find = function(key) {\n  var cmp = this._compare\n  var n = this.root\n  var stack = []\n  while(n) {\n    var d = cmp(key, n.key)\n    stack.push(n)\n    if(d === 0) {\n      return new RedBlackTreeIterator(this, stack)\n    }\n    if(d <= 0) {\n      n = n.left\n    } else {\n      n = n.right\n    }\n  }\n  return new RedBlackTreeIterator(this, [])\n}\n\n//Removes item with key from tree\nproto.remove = function(key) {\n  var iter = this.find(key)\n  if(iter) {\n    return iter.remove()\n  }\n  return this\n}\n\n//Returns the item at `key`\nproto.get = function(key) {\n  var cmp = this._compare\n  var n = this.root\n  while(n) {\n    var d = cmp(key, n.key)\n    if(d === 0) {\n      return n.value\n    }\n    if(d <= 0) {\n      n = n.left\n    } else {\n      n = n.right\n    }\n  }\n  return\n}\n\n//Iterator for red black tree\nfunction RedBlackTreeIterator(tree, stack) {\n  this.tree = tree\n  this._stack = stack\n}\n\nvar iproto = RedBlackTreeIterator.prototype\n\n//Test if iterator is valid\nObject.defineProperty(iproto, \"valid\", {\n  get: function() {\n    return this._stack.length > 0\n  }\n})\n\n//Node of the iterator\nObject.defineProperty(iproto, \"node\", {\n  get: function() {\n    if(this._stack.length > 0) {\n      return this._stack[this._stack.length-1]\n    }\n    return null\n  },\n  enumerable: true\n})\n\n//Makes a copy of an iterator\niproto.clone = function() {\n  return new RedBlackTreeIterator(this.tree, this._stack.slice())\n}\n\n//Swaps two nodes\nfunction swapNode(n, v) {\n  n.key = v.key\n  n.value = v.value\n  n.left = v.left\n  n.right = v.right\n  n._color = v._color\n  n._count = v._count\n}\n\n//Fix up a double black node in a tree\nfunction fixDoubleBlack(stack) {\n  var n, p, s, z\n  for(var i=stack.length-1; i>=0; --i) {\n    n = stack[i]\n    if(i === 0) {\n      n._color = BLACK\n      return\n    }\n    //console.log(\"visit node:\", n.key, i, stack[i].key, stack[i-1].key)\n    p = stack[i-1]\n    if(p.left === n) {\n      //console.log(\"left child\")\n      s = p.right\n      if(s.right && s.right._color === RED) {\n        //console.log(\"case 1: right sibling child red\")\n        s = p.right = cloneNode(s)\n        z = s.right = cloneNode(s.right)\n        p.right = s.left\n        s.left = p\n        s.right = z\n        s._color = p._color\n        n._color = BLACK\n        p._color = BLACK\n        z._color = BLACK\n        recount(p)\n        recount(s)\n        if(i > 1) {\n          var pp = stack[i-2]\n          if(pp.left === p) {\n            pp.left = s\n          } else {\n            pp.right = s\n          }\n        }\n        stack[i-1] = s\n        return\n      } else if(s.left && s.left._color === RED) {\n        //console.log(\"case 1: left sibling child red\")\n        s = p.right = cloneNode(s)\n        z = s.left = cloneNode(s.left)\n        p.right = z.left\n        s.left = z.right\n        z.left = p\n        z.right = s\n        z._color = p._color\n        p._color = BLACK\n        s._color = BLACK\n        n._color = BLACK\n        recount(p)\n        recount(s)\n        recount(z)\n        if(i > 1) {\n          var pp = stack[i-2]\n          if(pp.left === p) {\n            pp.left = z\n          } else {\n            pp.right = z\n          }\n        }\n        stack[i-1] = z\n        return\n      }\n      if(s._color === BLACK) {\n        if(p._color === RED) {\n          //console.log(\"case 2: black sibling, red parent\", p.right.value)\n          p._color = BLACK\n          p.right = repaint(RED, s)\n          return\n        } else {\n          //console.log(\"case 2: black sibling, black parent\", p.right.value)\n          p.right = repaint(RED, s)\n          continue  \n        }\n      } else {\n        //console.log(\"case 3: red sibling\")\n        s = cloneNode(s)\n        p.right = s.left\n        s.left = p\n        s._color = p._color\n        p._color = RED\n        recount(p)\n        recount(s)\n        if(i > 1) {\n          var pp = stack[i-2]\n          if(pp.left === p) {\n            pp.left = s\n          } else {\n            pp.right = s\n          }\n        }\n        stack[i-1] = s\n        stack[i] = p\n        if(i+1 < stack.length) {\n          stack[i+1] = n\n        } else {\n          stack.push(n)\n        }\n        i = i+2\n      }\n    } else {\n      //console.log(\"right child\")\n      s = p.left\n      if(s.left && s.left._color === RED) {\n        //console.log(\"case 1: left sibling child red\", p.value, p._color)\n        s = p.left = cloneNode(s)\n        z = s.left = cloneNode(s.left)\n        p.left = s.right\n        s.right = p\n        s.left = z\n        s._color = p._color\n        n._color = BLACK\n        p._color = BLACK\n        z._color = BLACK\n        recount(p)\n        recount(s)\n        if(i > 1) {\n          var pp = stack[i-2]\n          if(pp.right === p) {\n            pp.right = s\n          } else {\n            pp.left = s\n          }\n        }\n        stack[i-1] = s\n        return\n      } else if(s.right && s.right._color === RED) {\n        //console.log(\"case 1: right sibling child red\")\n        s = p.left = cloneNode(s)\n        z = s.right = cloneNode(s.right)\n        p.left = z.right\n        s.right = z.left\n        z.right = p\n        z.left = s\n        z._color = p._color\n        p._color = BLACK\n        s._color = BLACK\n        n._color = BLACK\n        recount(p)\n        recount(s)\n        recount(z)\n        if(i > 1) {\n          var pp = stack[i-2]\n          if(pp.right === p) {\n            pp.right = z\n          } else {\n            pp.left = z\n          }\n        }\n        stack[i-1] = z\n        return\n      }\n      if(s._color === BLACK) {\n        if(p._color === RED) {\n          //console.log(\"case 2: black sibling, red parent\")\n          p._color = BLACK\n          p.left = repaint(RED, s)\n          return\n        } else {\n          //console.log(\"case 2: black sibling, black parent\")\n          p.left = repaint(RED, s)\n          continue  \n        }\n      } else {\n        //console.log(\"case 3: red sibling\")\n        s = cloneNode(s)\n        p.left = s.right\n        s.right = p\n        s._color = p._color\n        p._color = RED\n        recount(p)\n        recount(s)\n        if(i > 1) {\n          var pp = stack[i-2]\n          if(pp.right === p) {\n            pp.right = s\n          } else {\n            pp.left = s\n          }\n        }\n        stack[i-1] = s\n        stack[i] = p\n        if(i+1 < stack.length) {\n          stack[i+1] = n\n        } else {\n          stack.push(n)\n        }\n        i = i+2\n      }\n    }\n  }\n}\n\n//Removes item at iterator from tree\niproto.remove = function() {\n  var stack = this._stack\n  if(stack.length === 0) {\n    return this.tree\n  }\n  //First copy path to node\n  var cstack = new Array(stack.length)\n  var n = stack[stack.length-1]\n  cstack[cstack.length-1] = new RBNode(n._color, n.key, n.value, n.left, n.right, n._count)\n  for(var i=stack.length-2; i>=0; --i) {\n    var n = stack[i]\n    if(n.left === stack[i+1]) {\n      cstack[i] = new RBNode(n._color, n.key, n.value, cstack[i+1], n.right, n._count)\n    } else {\n      cstack[i] = new RBNode(n._color, n.key, n.value, n.left, cstack[i+1], n._count)\n    }\n  }\n\n  //Get node\n  n = cstack[cstack.length-1]\n  //console.log(\"start remove: \", n.value)\n\n  //If not leaf, then swap with previous node\n  if(n.left && n.right) {\n    //console.log(\"moving to leaf\")\n\n    //First walk to previous leaf\n    var split = cstack.length\n    n = n.left\n    while(n.right) {\n      cstack.push(n)\n      n = n.right\n    }\n    //Copy path to leaf\n    var v = cstack[split-1]\n    cstack.push(new RBNode(n._color, v.key, v.value, n.left, n.right, n._count))\n    cstack[split-1].key = n.key\n    cstack[split-1].value = n.value\n\n    //Fix up stack\n    for(var i=cstack.length-2; i>=split; --i) {\n      n = cstack[i]\n      cstack[i] = new RBNode(n._color, n.key, n.value, n.left, cstack[i+1], n._count)\n    }\n    cstack[split-1].left = cstack[split]\n  }\n  //console.log(\"stack=\", cstack.map(function(v) { return v.value }))\n\n  //Remove leaf node\n  n = cstack[cstack.length-1]\n  if(n._color === RED) {\n    //Easy case: removing red leaf\n    //console.log(\"RED leaf\")\n    var p = cstack[cstack.length-2]\n    if(p.left === n) {\n      p.left = null\n    } else if(p.right === n) {\n      p.right = null\n    }\n    cstack.pop()\n    for(var i=0; i<cstack.length; ++i) {\n      cstack[i]._count--\n    }\n    return new RedBlackTree(this.tree._compare, cstack[0])\n  } else {\n    if(n.left || n.right) {\n      //Second easy case:  Single child black parent\n      //console.log(\"BLACK single child\")\n      if(n.left) {\n        swapNode(n, n.left)\n      } else if(n.right) {\n        swapNode(n, n.right)\n      }\n      //Child must be red, so repaint it black to balance color\n      n._color = BLACK\n      for(var i=0; i<cstack.length-1; ++i) {\n        cstack[i]._count--\n      }\n      return new RedBlackTree(this.tree._compare, cstack[0])\n    } else if(cstack.length === 1) {\n      //Third easy case: root\n      //console.log(\"ROOT\")\n      return new RedBlackTree(this.tree._compare, null)\n    } else {\n      //Hard case: Repaint n, and then do some nasty stuff\n      //console.log(\"BLACK leaf no children\")\n      for(var i=0; i<cstack.length; ++i) {\n        cstack[i]._count--\n      }\n      var parent = cstack[cstack.length-2]\n      fixDoubleBlack(cstack)\n      //Fix up links\n      if(parent.left === n) {\n        parent.left = null\n      } else {\n        parent.right = null\n      }\n    }\n  }\n  return new RedBlackTree(this.tree._compare, cstack[0])\n}\n\n//Returns key\nObject.defineProperty(iproto, \"key\", {\n  get: function() {\n    if(this._stack.length > 0) {\n      return this._stack[this._stack.length-1].key\n    }\n    return\n  },\n  enumerable: true\n})\n\n//Returns value\nObject.defineProperty(iproto, \"value\", {\n  get: function() {\n    if(this._stack.length > 0) {\n      return this._stack[this._stack.length-1].value\n    }\n    return\n  },\n  enumerable: true\n})\n\n\n//Returns the position of this iterator in the sorted list\nObject.defineProperty(iproto, \"index\", {\n  get: function() {\n    var idx = 0\n    var stack = this._stack\n    if(stack.length === 0) {\n      var r = this.tree.root\n      if(r) {\n        return r._count\n      }\n      return 0\n    } else if(stack[stack.length-1].left) {\n      idx = stack[stack.length-1].left._count\n    }\n    for(var s=stack.length-2; s>=0; --s) {\n      if(stack[s+1] === stack[s].right) {\n        ++idx\n        if(stack[s].left) {\n          idx += stack[s].left._count\n        }\n      }\n    }\n    return idx\n  },\n  enumerable: true\n})\n\n//Advances iterator to next element in list\niproto.next = function() {\n  var stack = this._stack\n  if(stack.length === 0) {\n    return\n  }\n  var n = stack[stack.length-1]\n  if(n.right) {\n    n = n.right\n    while(n) {\n      stack.push(n)\n      n = n.left\n    }\n  } else {\n    stack.pop()\n    while(stack.length > 0 && stack[stack.length-1].right === n) {\n      n = stack[stack.length-1]\n      stack.pop()\n    }\n  }\n}\n\n//Checks if iterator is at end of tree\nObject.defineProperty(iproto, \"hasNext\", {\n  get: function() {\n    var stack = this._stack\n    if(stack.length === 0) {\n      return false\n    }\n    if(stack[stack.length-1].right) {\n      return true\n    }\n    for(var s=stack.length-1; s>0; --s) {\n      if(stack[s-1].left === stack[s]) {\n        return true\n      }\n    }\n    return false\n  }\n})\n\n//Update value\niproto.update = function(value) {\n  var stack = this._stack\n  if(stack.length === 0) {\n    throw new Error(\"Can't update empty node!\")\n  }\n  var cstack = new Array(stack.length)\n  var n = stack[stack.length-1]\n  cstack[cstack.length-1] = new RBNode(n._color, n.key, value, n.left, n.right, n._count)\n  for(var i=stack.length-2; i>=0; --i) {\n    n = stack[i]\n    if(n.left === stack[i+1]) {\n      cstack[i] = new RBNode(n._color, n.key, n.value, cstack[i+1], n.right, n._count)\n    } else {\n      cstack[i] = new RBNode(n._color, n.key, n.value, n.left, cstack[i+1], n._count)\n    }\n  }\n  return new RedBlackTree(this.tree._compare, cstack[0])\n}\n\n//Moves iterator backward one element\niproto.prev = function() {\n  var stack = this._stack\n  if(stack.length === 0) {\n    return\n  }\n  var n = stack[stack.length-1]\n  if(n.left) {\n    n = n.left\n    while(n) {\n      stack.push(n)\n      n = n.right\n    }\n  } else {\n    stack.pop()\n    while(stack.length > 0 && stack[stack.length-1].left === n) {\n      n = stack[stack.length-1]\n      stack.pop()\n    }\n  }\n}\n\n//Checks if iterator is at start of tree\nObject.defineProperty(iproto, \"hasPrev\", {\n  get: function() {\n    var stack = this._stack\n    if(stack.length === 0) {\n      return false\n    }\n    if(stack[stack.length-1].left) {\n      return true\n    }\n    for(var s=stack.length-1; s>0; --s) {\n      if(stack[s-1].right === stack[s]) {\n        return true\n      }\n    }\n    return false\n  }\n})\n\n//Default comparison function\nfunction defaultCompare(a, b) {\n  if(a < b) {\n    return -1\n  }\n  if(a > b) {\n    return 1\n  }\n  return 0\n}\n\n//Build a tree\nfunction createRBTree(compare) {\n  return new RedBlackTree(compare || defaultCompare, null)\n}\n\n//# sourceURL=webpack://javascript/./node_modules/functional-red-black-tree/rbtree.js?");

/***/ }),

/***/ "./node_modules/get-intrinsic/index.js":
/*!*********************************************!*\
  !*** ./node_modules/get-intrinsic/index.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar undefined;\n\nvar $SyntaxError = SyntaxError;\nvar $Function = Function;\nvar $TypeError = TypeError;\n\n// eslint-disable-next-line consistent-return\nvar getEvalledConstructor = function (expressionSyntax) {\n\ttry {\n\t\treturn $Function('\"use strict\"; return (' + expressionSyntax + ').constructor;')();\n\t} catch (e) {}\n};\n\nvar $gOPD = Object.getOwnPropertyDescriptor;\nif ($gOPD) {\n\ttry {\n\t\t$gOPD({}, '');\n\t} catch (e) {\n\t\t$gOPD = null; // this is IE 8, which has a broken gOPD\n\t}\n}\n\nvar throwTypeError = function () {\n\tthrow new $TypeError();\n};\nvar ThrowTypeError = $gOPD\n\t? (function () {\n\t\ttry {\n\t\t\t// eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties\n\t\t\targuments.callee; // IE 8 does not throw here\n\t\t\treturn throwTypeError;\n\t\t} catch (calleeThrows) {\n\t\t\ttry {\n\t\t\t\t// IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')\n\t\t\t\treturn $gOPD(arguments, 'callee').get;\n\t\t\t} catch (gOPDthrows) {\n\t\t\t\treturn throwTypeError;\n\t\t\t}\n\t\t}\n\t}())\n\t: throwTypeError;\n\nvar hasSymbols = __webpack_require__(/*! has-symbols */ \"./node_modules/has-symbols/index.js\")();\n\nvar getProto = Object.getPrototypeOf || function (x) { return x.__proto__; }; // eslint-disable-line no-proto\n\nvar needsEval = {};\n\nvar TypedArray = typeof Uint8Array === 'undefined' ? undefined : getProto(Uint8Array);\n\nvar INTRINSICS = {\n\t'%AggregateError%': typeof AggregateError === 'undefined' ? undefined : AggregateError,\n\t'%Array%': Array,\n\t'%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,\n\t'%ArrayIteratorPrototype%': hasSymbols ? getProto([][Symbol.iterator]()) : undefined,\n\t'%AsyncFromSyncIteratorPrototype%': undefined,\n\t'%AsyncFunction%': needsEval,\n\t'%AsyncGenerator%': needsEval,\n\t'%AsyncGeneratorFunction%': needsEval,\n\t'%AsyncIteratorPrototype%': needsEval,\n\t'%Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,\n\t'%BigInt%': typeof BigInt === 'undefined' ? undefined : BigInt,\n\t'%Boolean%': Boolean,\n\t'%DataView%': typeof DataView === 'undefined' ? undefined : DataView,\n\t'%Date%': Date,\n\t'%decodeURI%': decodeURI,\n\t'%decodeURIComponent%': decodeURIComponent,\n\t'%encodeURI%': encodeURI,\n\t'%encodeURIComponent%': encodeURIComponent,\n\t'%Error%': Error,\n\t'%eval%': eval, // eslint-disable-line no-eval\n\t'%EvalError%': EvalError,\n\t'%Float32Array%': typeof Float32Array === 'undefined' ? undefined : Float32Array,\n\t'%Float64Array%': typeof Float64Array === 'undefined' ? undefined : Float64Array,\n\t'%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined : FinalizationRegistry,\n\t'%Function%': $Function,\n\t'%GeneratorFunction%': needsEval,\n\t'%Int8Array%': typeof Int8Array === 'undefined' ? undefined : Int8Array,\n\t'%Int16Array%': typeof Int16Array === 'undefined' ? undefined : Int16Array,\n\t'%Int32Array%': typeof Int32Array === 'undefined' ? undefined : Int32Array,\n\t'%isFinite%': isFinite,\n\t'%isNaN%': isNaN,\n\t'%IteratorPrototype%': hasSymbols ? getProto(getProto([][Symbol.iterator]())) : undefined,\n\t'%JSON%': typeof JSON === 'object' ? JSON : undefined,\n\t'%Map%': typeof Map === 'undefined' ? undefined : Map,\n\t'%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols ? undefined : getProto(new Map()[Symbol.iterator]()),\n\t'%Math%': Math,\n\t'%Number%': Number,\n\t'%Object%': Object,\n\t'%parseFloat%': parseFloat,\n\t'%parseInt%': parseInt,\n\t'%Promise%': typeof Promise === 'undefined' ? undefined : Promise,\n\t'%Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,\n\t'%RangeError%': RangeError,\n\t'%ReferenceError%': ReferenceError,\n\t'%Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,\n\t'%RegExp%': RegExp,\n\t'%Set%': typeof Set === 'undefined' ? undefined : Set,\n\t'%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols ? undefined : getProto(new Set()[Symbol.iterator]()),\n\t'%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer,\n\t'%String%': String,\n\t'%StringIteratorPrototype%': hasSymbols ? getProto(''[Symbol.iterator]()) : undefined,\n\t'%Symbol%': hasSymbols ? Symbol : undefined,\n\t'%SyntaxError%': $SyntaxError,\n\t'%ThrowTypeError%': ThrowTypeError,\n\t'%TypedArray%': TypedArray,\n\t'%TypeError%': $TypeError,\n\t'%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array,\n\t'%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray,\n\t'%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array,\n\t'%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array,\n\t'%URIError%': URIError,\n\t'%WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,\n\t'%WeakRef%': typeof WeakRef === 'undefined' ? undefined : WeakRef,\n\t'%WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet\n};\n\nvar doEval = function doEval(name) {\n\tvar value;\n\tif (name === '%AsyncFunction%') {\n\t\tvalue = getEvalledConstructor('async function () {}');\n\t} else if (name === '%GeneratorFunction%') {\n\t\tvalue = getEvalledConstructor('function* () {}');\n\t} else if (name === '%AsyncGeneratorFunction%') {\n\t\tvalue = getEvalledConstructor('async function* () {}');\n\t} else if (name === '%AsyncGenerator%') {\n\t\tvar fn = doEval('%AsyncGeneratorFunction%');\n\t\tif (fn) {\n\t\t\tvalue = fn.prototype;\n\t\t}\n\t} else if (name === '%AsyncIteratorPrototype%') {\n\t\tvar gen = doEval('%AsyncGenerator%');\n\t\tif (gen) {\n\t\t\tvalue = getProto(gen.prototype);\n\t\t}\n\t}\n\n\tINTRINSICS[name] = value;\n\n\treturn value;\n};\n\nvar LEGACY_ALIASES = {\n\t'%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],\n\t'%ArrayPrototype%': ['Array', 'prototype'],\n\t'%ArrayProto_entries%': ['Array', 'prototype', 'entries'],\n\t'%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],\n\t'%ArrayProto_keys%': ['Array', 'prototype', 'keys'],\n\t'%ArrayProto_values%': ['Array', 'prototype', 'values'],\n\t'%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],\n\t'%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],\n\t'%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],\n\t'%BooleanPrototype%': ['Boolean', 'prototype'],\n\t'%DataViewPrototype%': ['DataView', 'prototype'],\n\t'%DatePrototype%': ['Date', 'prototype'],\n\t'%ErrorPrototype%': ['Error', 'prototype'],\n\t'%EvalErrorPrototype%': ['EvalError', 'prototype'],\n\t'%Float32ArrayPrototype%': ['Float32Array', 'prototype'],\n\t'%Float64ArrayPrototype%': ['Float64Array', 'prototype'],\n\t'%FunctionPrototype%': ['Function', 'prototype'],\n\t'%Generator%': ['GeneratorFunction', 'prototype'],\n\t'%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],\n\t'%Int8ArrayPrototype%': ['Int8Array', 'prototype'],\n\t'%Int16ArrayPrototype%': ['Int16Array', 'prototype'],\n\t'%Int32ArrayPrototype%': ['Int32Array', 'prototype'],\n\t'%JSONParse%': ['JSON', 'parse'],\n\t'%JSONStringify%': ['JSON', 'stringify'],\n\t'%MapPrototype%': ['Map', 'prototype'],\n\t'%NumberPrototype%': ['Number', 'prototype'],\n\t'%ObjectPrototype%': ['Object', 'prototype'],\n\t'%ObjProto_toString%': ['Object', 'prototype', 'toString'],\n\t'%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],\n\t'%PromisePrototype%': ['Promise', 'prototype'],\n\t'%PromiseProto_then%': ['Promise', 'prototype', 'then'],\n\t'%Promise_all%': ['Promise', 'all'],\n\t'%Promise_reject%': ['Promise', 'reject'],\n\t'%Promise_resolve%': ['Promise', 'resolve'],\n\t'%RangeErrorPrototype%': ['RangeError', 'prototype'],\n\t'%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],\n\t'%RegExpPrototype%': ['RegExp', 'prototype'],\n\t'%SetPrototype%': ['Set', 'prototype'],\n\t'%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],\n\t'%StringPrototype%': ['String', 'prototype'],\n\t'%SymbolPrototype%': ['Symbol', 'prototype'],\n\t'%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],\n\t'%TypedArrayPrototype%': ['TypedArray', 'prototype'],\n\t'%TypeErrorPrototype%': ['TypeError', 'prototype'],\n\t'%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],\n\t'%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],\n\t'%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],\n\t'%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],\n\t'%URIErrorPrototype%': ['URIError', 'prototype'],\n\t'%WeakMapPrototype%': ['WeakMap', 'prototype'],\n\t'%WeakSetPrototype%': ['WeakSet', 'prototype']\n};\n\nvar bind = __webpack_require__(/*! function-bind */ \"./node_modules/function-bind/index.js\");\nvar hasOwn = __webpack_require__(/*! has */ \"./node_modules/has/src/index.js\");\nvar $concat = bind.call(Function.call, Array.prototype.concat);\nvar $spliceApply = bind.call(Function.apply, Array.prototype.splice);\nvar $replace = bind.call(Function.call, String.prototype.replace);\nvar $strSlice = bind.call(Function.call, String.prototype.slice);\n\n/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */\nvar rePropName = /[^%.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|%$))/g;\nvar reEscapeChar = /\\\\(\\\\)?/g; /** Used to match backslashes in property paths. */\nvar stringToPath = function stringToPath(string) {\n\tvar first = $strSlice(string, 0, 1);\n\tvar last = $strSlice(string, -1);\n\tif (first === '%' && last !== '%') {\n\t\tthrow new $SyntaxError('invalid intrinsic syntax, expected closing `%`');\n\t} else if (last === '%' && first !== '%') {\n\t\tthrow new $SyntaxError('invalid intrinsic syntax, expected opening `%`');\n\t}\n\tvar result = [];\n\t$replace(string, rePropName, function (match, number, quote, subString) {\n\t\tresult[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;\n\t});\n\treturn result;\n};\n/* end adaptation */\n\nvar getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {\n\tvar intrinsicName = name;\n\tvar alias;\n\tif (hasOwn(LEGACY_ALIASES, intrinsicName)) {\n\t\talias = LEGACY_ALIASES[intrinsicName];\n\t\tintrinsicName = '%' + alias[0] + '%';\n\t}\n\n\tif (hasOwn(INTRINSICS, intrinsicName)) {\n\t\tvar value = INTRINSICS[intrinsicName];\n\t\tif (value === needsEval) {\n\t\t\tvalue = doEval(intrinsicName);\n\t\t}\n\t\tif (typeof value === 'undefined' && !allowMissing) {\n\t\t\tthrow new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');\n\t\t}\n\n\t\treturn {\n\t\t\talias: alias,\n\t\t\tname: intrinsicName,\n\t\t\tvalue: value\n\t\t};\n\t}\n\n\tthrow new $SyntaxError('intrinsic ' + name + ' does not exist!');\n};\n\nmodule.exports = function GetIntrinsic(name, allowMissing) {\n\tif (typeof name !== 'string' || name.length === 0) {\n\t\tthrow new $TypeError('intrinsic name must be a non-empty string');\n\t}\n\tif (arguments.length > 1 && typeof allowMissing !== 'boolean') {\n\t\tthrow new $TypeError('\"allowMissing\" argument must be a boolean');\n\t}\n\n\tvar parts = stringToPath(name);\n\tvar intrinsicBaseName = parts.length > 0 ? parts[0] : '';\n\n\tvar intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);\n\tvar intrinsicRealName = intrinsic.name;\n\tvar value = intrinsic.value;\n\tvar skipFurtherCaching = false;\n\n\tvar alias = intrinsic.alias;\n\tif (alias) {\n\t\tintrinsicBaseName = alias[0];\n\t\t$spliceApply(parts, $concat([0, 1], alias));\n\t}\n\n\tfor (var i = 1, isOwn = true; i < parts.length; i += 1) {\n\t\tvar part = parts[i];\n\t\tvar first = $strSlice(part, 0, 1);\n\t\tvar last = $strSlice(part, -1);\n\t\tif (\n\t\t\t(\n\t\t\t\t(first === '\"' || first === \"'\" || first === '`')\n\t\t\t\t|| (last === '\"' || last === \"'\" || last === '`')\n\t\t\t)\n\t\t\t&& first !== last\n\t\t) {\n\t\t\tthrow new $SyntaxError('property names with quotes must have matching quotes');\n\t\t}\n\t\tif (part === 'constructor' || !isOwn) {\n\t\t\tskipFurtherCaching = true;\n\t\t}\n\n\t\tintrinsicBaseName += '.' + part;\n\t\tintrinsicRealName = '%' + intrinsicBaseName + '%';\n\n\t\tif (hasOwn(INTRINSICS, intrinsicRealName)) {\n\t\t\tvalue = INTRINSICS[intrinsicRealName];\n\t\t} else if (value != null) {\n\t\t\tif (!(part in value)) {\n\t\t\t\tif (!allowMissing) {\n\t\t\t\t\tthrow new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');\n\t\t\t\t}\n\t\t\t\treturn void undefined;\n\t\t\t}\n\t\t\tif ($gOPD && (i + 1) >= parts.length) {\n\t\t\t\tvar desc = $gOPD(value, part);\n\t\t\t\tisOwn = !!desc;\n\n\t\t\t\t// By convention, when a data property is converted to an accessor\n\t\t\t\t// property to emulate a data property that does not suffer from\n\t\t\t\t// the override mistake, that accessor's getter is marked with\n\t\t\t\t// an `originalValue` property. Here, when we detect this, we\n\t\t\t\t// uphold the illusion by pretending to see that original data\n\t\t\t\t// property, i.e., returning the value rather than the getter\n\t\t\t\t// itself.\n\t\t\t\tif (isOwn && 'get' in desc && !('originalValue' in desc.get)) {\n\t\t\t\t\tvalue = desc.get;\n\t\t\t\t} else {\n\t\t\t\t\tvalue = value[part];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tisOwn = hasOwn(value, part);\n\t\t\t\tvalue = value[part];\n\t\t\t}\n\n\t\t\tif (isOwn && !skipFurtherCaching) {\n\t\t\t\tINTRINSICS[intrinsicRealName] = value;\n\t\t\t}\n\t\t}\n\t}\n\treturn value;\n};\n\n\n//# sourceURL=webpack://javascript/./node_modules/get-intrinsic/index.js?");

/***/ }),

/***/ "./node_modules/globals/index.js":
/*!***************************************!*\
  !*** ./node_modules/globals/index.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nmodule.exports = __webpack_require__(/*! ./globals.json */ \"./node_modules/globals/globals.json\");\n\n\n//# sourceURL=webpack://javascript/./node_modules/globals/index.js?");

/***/ }),

/***/ "./node_modules/has-property-descriptors/index.js":
/*!********************************************************!*\
  !*** ./node_modules/has-property-descriptors/index.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar GetIntrinsic = __webpack_require__(/*! get-intrinsic */ \"./node_modules/get-intrinsic/index.js\");\n\nvar $defineProperty = GetIntrinsic('%Object.defineProperty%', true);\n\nvar hasPropertyDescriptors = function hasPropertyDescriptors() {\n\tif ($defineProperty) {\n\t\ttry {\n\t\t\t$defineProperty({}, 'a', { value: 1 });\n\t\t\treturn true;\n\t\t} catch (e) {\n\t\t\t// IE 8 has a broken defineProperty\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn false;\n};\n\nhasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {\n\t// node v0.6 has a bug where array lengths can be Set but not Defined\n\tif (!hasPropertyDescriptors()) {\n\t\treturn null;\n\t}\n\ttry {\n\t\treturn $defineProperty([], 'length', { value: 1 }).length !== 1;\n\t} catch (e) {\n\t\t// In Firefox 4-22, defining length on an array throws an exception.\n\t\treturn true;\n\t}\n};\n\nmodule.exports = hasPropertyDescriptors;\n\n\n//# sourceURL=webpack://javascript/./node_modules/has-property-descriptors/index.js?");

/***/ }),

/***/ "./node_modules/has-symbols/index.js":
/*!*******************************************!*\
  !*** ./node_modules/has-symbols/index.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar origSymbol = typeof Symbol !== 'undefined' && Symbol;\nvar hasSymbolSham = __webpack_require__(/*! ./shams */ \"./node_modules/has-symbols/shams.js\");\n\nmodule.exports = function hasNativeSymbols() {\n\tif (typeof origSymbol !== 'function') { return false; }\n\tif (typeof Symbol !== 'function') { return false; }\n\tif (typeof origSymbol('foo') !== 'symbol') { return false; }\n\tif (typeof Symbol('bar') !== 'symbol') { return false; }\n\n\treturn hasSymbolSham();\n};\n\n\n//# sourceURL=webpack://javascript/./node_modules/has-symbols/index.js?");

/***/ }),

/***/ "./node_modules/has-symbols/shams.js":
/*!*******************************************!*\
  !*** ./node_modules/has-symbols/shams.js ***!
  \*******************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/* eslint complexity: [2, 18], max-statements: [2, 33] */\nmodule.exports = function hasSymbols() {\n\tif (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') { return false; }\n\tif (typeof Symbol.iterator === 'symbol') { return true; }\n\n\tvar obj = {};\n\tvar sym = Symbol('test');\n\tvar symObj = Object(sym);\n\tif (typeof sym === 'string') { return false; }\n\n\tif (Object.prototype.toString.call(sym) !== '[object Symbol]') { return false; }\n\tif (Object.prototype.toString.call(symObj) !== '[object Symbol]') { return false; }\n\n\t// temp disabled per https://github.com/ljharb/object.assign/issues/17\n\t// if (sym instanceof Symbol) { return false; }\n\t// temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4\n\t// if (!(symObj instanceof Symbol)) { return false; }\n\n\t// if (typeof Symbol.prototype.toString !== 'function') { return false; }\n\t// if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }\n\n\tvar symVal = 42;\n\tobj[sym] = symVal;\n\tfor (sym in obj) { return false; } // eslint-disable-line no-restricted-syntax, no-unreachable-loop\n\tif (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) { return false; }\n\n\tif (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) { return false; }\n\n\tvar syms = Object.getOwnPropertySymbols(obj);\n\tif (syms.length !== 1 || syms[0] !== sym) { return false; }\n\n\tif (!Object.prototype.propertyIsEnumerable.call(obj, sym)) { return false; }\n\n\tif (typeof Object.getOwnPropertyDescriptor === 'function') {\n\t\tvar descriptor = Object.getOwnPropertyDescriptor(obj, sym);\n\t\tif (descriptor.value !== symVal || descriptor.enumerable !== true) { return false; }\n\t}\n\n\treturn true;\n};\n\n\n//# sourceURL=webpack://javascript/./node_modules/has-symbols/shams.js?");

/***/ }),

/***/ "./node_modules/has-tostringtag/shams.js":
/*!***********************************************!*\
  !*** ./node_modules/has-tostringtag/shams.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar hasSymbols = __webpack_require__(/*! has-symbols/shams */ \"./node_modules/has-symbols/shams.js\");\n\nmodule.exports = function hasToStringTagShams() {\n\treturn hasSymbols() && !!Symbol.toStringTag;\n};\n\n\n//# sourceURL=webpack://javascript/./node_modules/has-tostringtag/shams.js?");

/***/ }),

/***/ "./node_modules/has/src/index.js":
/*!***************************************!*\
  !*** ./node_modules/has/src/index.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar bind = __webpack_require__(/*! function-bind */ \"./node_modules/function-bind/index.js\");\n\nmodule.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);\n\n\n//# sourceURL=webpack://javascript/./node_modules/has/src/index.js?");

/***/ }),

/***/ "./node_modules/ignore/index.js":
/*!**************************************!*\
  !*** ./node_modules/ignore/index.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* provided dependency */ var process = __webpack_require__(/*! ./node_modules/process/browser.js */ \"./node_modules/process/browser.js\");\n// A simple implementation of make-array\nfunction make_array (subject) {\n  return Array.isArray(subject)\n    ? subject\n    : [subject]\n}\n\nconst REGEX_BLANK_LINE = /^\\s+$/\nconst REGEX_LEADING_EXCAPED_EXCLAMATION = /^\\\\!/\nconst REGEX_LEADING_EXCAPED_HASH = /^\\\\#/\nconst SLASH = '/'\nconst KEY_IGNORE = typeof Symbol !== 'undefined'\n  ? Symbol.for('node-ignore')\n  /* istanbul ignore next */\n  : 'node-ignore'\n\nconst define = (object, key, value) =>\n  Object.defineProperty(object, key, {value})\n\nconst REGEX_REGEXP_RANGE = /([0-z])-([0-z])/g\n\n// Sanitize the range of a regular expression\n// The cases are complicated, see test cases for details\nconst sanitizeRange = range => range.replace(\n  REGEX_REGEXP_RANGE,\n  (match, from, to) => from.charCodeAt(0) <= to.charCodeAt(0)\n    ? match\n    // Invalid range (out of order) which is ok for gitignore rules but\n    //   fatal for JavaScript regular expression, so eliminate it.\n    : ''\n)\n\n// > If the pattern ends with a slash,\n// > it is removed for the purpose of the following description,\n// > but it would only find a match with a directory.\n// > In other words, foo/ will match a directory foo and paths underneath it,\n// > but will not match a regular file or a symbolic link foo\n// >  (this is consistent with the way how pathspec works in general in Git).\n// '`foo/`' will not match regular file '`foo`' or symbolic link '`foo`'\n// -> ignore-rules will not deal with it, because it costs extra `fs.stat` call\n//      you could use option `mark: true` with `glob`\n\n// '`foo/`' should not continue with the '`..`'\nconst DEFAULT_REPLACER_PREFIX = [\n\n  // > Trailing spaces are ignored unless they are quoted with backslash (\"\\\")\n  [\n    // (a\\ ) -> (a )\n    // (a  ) -> (a)\n    // (a \\ ) -> (a  )\n    /\\\\?\\s+$/,\n    match => match.indexOf('\\\\') === 0\n      ? ' '\n      : ''\n  ],\n\n  // replace (\\ ) with ' '\n  [\n    /\\\\\\s/g,\n    () => ' '\n  ],\n\n  // Escape metacharacters\n  // which is written down by users but means special for regular expressions.\n\n  // > There are 12 characters with special meanings:\n  // > - the backslash \\,\n  // > - the caret ^,\n  // > - the dollar sign $,\n  // > - the period or dot .,\n  // > - the vertical bar or pipe symbol |,\n  // > - the question mark ?,\n  // > - the asterisk or star *,\n  // > - the plus sign +,\n  // > - the opening parenthesis (,\n  // > - the closing parenthesis ),\n  // > - and the opening square bracket [,\n  // > - the opening curly brace {,\n  // > These special characters are often called \"metacharacters\".\n  [\n    /[\\\\^$.|*+(){]/g,\n    match => `\\\\${match}`\n  ],\n\n  [\n    // > [abc] matches any character inside the brackets\n    // >    (in this case a, b, or c);\n    /\\[([^\\]/]*)($|\\])/g,\n    (match, p1, p2) => p2 === ']'\n      ? `[${sanitizeRange(p1)}]`\n      : `\\\\${match}`\n  ],\n\n  [\n    // > a question mark (?) matches a single character\n    /(?!\\\\)\\?/g,\n    () => '[^/]'\n  ],\n\n  // leading slash\n  [\n\n    // > A leading slash matches the beginning of the pathname.\n    // > For example, \"/*.c\" matches \"cat-file.c\" but not \"mozilla-sha1/sha1.c\".\n    // A leading slash matches the beginning of the pathname\n    /^\\//,\n    () => '^'\n  ],\n\n  // replace special metacharacter slash after the leading slash\n  [\n    /\\//g,\n    () => '\\\\/'\n  ],\n\n  [\n    // > A leading \"**\" followed by a slash means match in all directories.\n    // > For example, \"**/foo\" matches file or directory \"foo\" anywhere,\n    // > the same as pattern \"foo\".\n    // > \"**/foo/bar\" matches file or directory \"bar\" anywhere that is directly\n    // >   under directory \"foo\".\n    // Notice that the '*'s have been replaced as '\\\\*'\n    /^\\^*\\\\\\*\\\\\\*\\\\\\//,\n\n    // '**/foo' <-> 'foo'\n    () => '^(?:.*\\\\/)?'\n  ]\n]\n\nconst DEFAULT_REPLACER_SUFFIX = [\n  // starting\n  [\n    // there will be no leading '/'\n    //   (which has been replaced by section \"leading slash\")\n    // If starts with '**', adding a '^' to the regular expression also works\n    /^(?=[^^])/,\n    function startingReplacer () {\n      return !/\\/(?!$)/.test(this)\n        // > If the pattern does not contain a slash /,\n        // >   Git treats it as a shell glob pattern\n        // Actually, if there is only a trailing slash,\n        //   git also treats it as a shell glob pattern\n        ? '(?:^|\\\\/)'\n\n        // > Otherwise, Git treats the pattern as a shell glob suitable for\n        // >   consumption by fnmatch(3)\n        : '^'\n    }\n  ],\n\n  // two globstars\n  [\n    // Use lookahead assertions so that we could match more than one `'/**'`\n    /\\\\\\/\\\\\\*\\\\\\*(?=\\\\\\/|$)/g,\n\n    // Zero, one or several directories\n    // should not use '*', or it will be replaced by the next replacer\n\n    // Check if it is not the last `'/**'`\n    (match, index, str) => index + 6 < str.length\n\n      // case: /**/\n      // > A slash followed by two consecutive asterisks then a slash matches\n      // >   zero or more directories.\n      // > For example, \"a/**/b\" matches \"a/b\", \"a/x/b\", \"a/x/y/b\" and so on.\n      // '/**/'\n      ? '(?:\\\\/[^\\\\/]+)*'\n\n      // case: /**\n      // > A trailing `\"/**\"` matches everything inside.\n\n      // #21: everything inside but it should not include the current folder\n      : '\\\\/.+'\n  ],\n\n  // intermediate wildcards\n  [\n    // Never replace escaped '*'\n    // ignore rule '\\*' will match the path '*'\n\n    // 'abc.*/' -> go\n    // 'abc.*'  -> skip this rule\n    /(^|[^\\\\]+)\\\\\\*(?=.+)/g,\n\n    // '*.js' matches '.js'\n    // '*.js' doesn't match 'abc'\n    (match, p1) => `${p1}[^\\\\/]*`\n  ],\n\n  // trailing wildcard\n  [\n    /(\\^|\\\\\\/)?\\\\\\*$/,\n    (match, p1) => {\n      const prefix = p1\n        // '\\^':\n        // '/*' does not match ''\n        // '/*' does not match everything\n\n        // '\\\\\\/':\n        // 'abc/*' does not match 'abc/'\n        ? `${p1}[^/]+`\n\n        // 'a*' matches 'a'\n        // 'a*' matches 'aa'\n        : '[^/]*'\n\n      return `${prefix}(?=$|\\\\/$)`\n    }\n  ],\n\n  [\n    // unescape\n    /\\\\\\\\\\\\/g,\n    () => '\\\\'\n  ]\n]\n\nconst POSITIVE_REPLACERS = [\n  ...DEFAULT_REPLACER_PREFIX,\n\n  // 'f'\n  // matches\n  // - /f(end)\n  // - /f/\n  // - (start)f(end)\n  // - (start)f/\n  // doesn't match\n  // - oof\n  // - foo\n  // pseudo:\n  // -> (^|/)f(/|$)\n\n  // ending\n  [\n    // 'js' will not match 'js.'\n    // 'ab' will not match 'abc'\n    /(?:[^*/])$/,\n\n    // 'js*' will not match 'a.js'\n    // 'js/' will not match 'a.js'\n    // 'js' will match 'a.js' and 'a.js/'\n    match => `${match}(?=$|\\\\/)`\n  ],\n\n  ...DEFAULT_REPLACER_SUFFIX\n]\n\nconst NEGATIVE_REPLACERS = [\n  ...DEFAULT_REPLACER_PREFIX,\n\n  // #24, #38\n  // The MISSING rule of [gitignore docs](https://git-scm.com/docs/gitignore)\n  // A negative pattern without a trailing wildcard should not\n  // re-include the things inside that directory.\n\n  // eg:\n  // ['node_modules/*', '!node_modules']\n  // should ignore `node_modules/a.js`\n  [\n    /(?:[^*])$/,\n    match => `${match}(?=$|\\\\/$)`\n  ],\n\n  ...DEFAULT_REPLACER_SUFFIX\n]\n\n// A simple cache, because an ignore rule only has only one certain meaning\nconst cache = Object.create(null)\n\n// @param {pattern}\nconst make_regex = (pattern, negative, ignorecase) => {\n  const r = cache[pattern]\n  if (r) {\n    return r\n  }\n\n  const replacers = negative\n    ? NEGATIVE_REPLACERS\n    : POSITIVE_REPLACERS\n\n  const source = replacers.reduce(\n    (prev, current) => prev.replace(current[0], current[1].bind(pattern)),\n    pattern\n  )\n\n  return cache[pattern] = ignorecase\n    ? new RegExp(source, 'i')\n    : new RegExp(source)\n}\n\n// > A blank line matches no files, so it can serve as a separator for readability.\nconst checkPattern = pattern => pattern\n  && typeof pattern === 'string'\n  && !REGEX_BLANK_LINE.test(pattern)\n\n  // > A line starting with # serves as a comment.\n  && pattern.indexOf('#') !== 0\n\nconst createRule = (pattern, ignorecase) => {\n  const origin = pattern\n  let negative = false\n\n  // > An optional prefix \"!\" which negates the pattern;\n  if (pattern.indexOf('!') === 0) {\n    negative = true\n    pattern = pattern.substr(1)\n  }\n\n  pattern = pattern\n  // > Put a backslash (\"\\\") in front of the first \"!\" for patterns that\n  // >   begin with a literal \"!\", for example, `\"\\!important!.txt\"`.\n  .replace(REGEX_LEADING_EXCAPED_EXCLAMATION, '!')\n  // > Put a backslash (\"\\\") in front of the first hash for patterns that\n  // >   begin with a hash.\n  .replace(REGEX_LEADING_EXCAPED_HASH, '#')\n\n  const regex = make_regex(pattern, negative, ignorecase)\n\n  return {\n    origin,\n    pattern,\n    negative,\n    regex\n  }\n}\n\nclass IgnoreBase {\n  constructor ({\n    ignorecase = true\n  } = {}) {\n    this._rules = []\n    this._ignorecase = ignorecase\n    define(this, KEY_IGNORE, true)\n    this._initCache()\n  }\n\n  _initCache () {\n    this._cache = Object.create(null)\n  }\n\n  // @param {Array.<string>|string|Ignore} pattern\n  add (pattern) {\n    this._added = false\n\n    if (typeof pattern === 'string') {\n      pattern = pattern.split(/\\r?\\n/g)\n    }\n\n    make_array(pattern).forEach(this._addPattern, this)\n\n    // Some rules have just added to the ignore,\n    // making the behavior changed.\n    if (this._added) {\n      this._initCache()\n    }\n\n    return this\n  }\n\n  // legacy\n  addPattern (pattern) {\n    return this.add(pattern)\n  }\n\n  _addPattern (pattern) {\n    // #32\n    if (pattern && pattern[KEY_IGNORE]) {\n      this._rules = this._rules.concat(pattern._rules)\n      this._added = true\n      return\n    }\n\n    if (checkPattern(pattern)) {\n      const rule = createRule(pattern, this._ignorecase)\n      this._added = true\n      this._rules.push(rule)\n    }\n  }\n\n  filter (paths) {\n    return make_array(paths).filter(path => this._filter(path))\n  }\n\n  createFilter () {\n    return path => this._filter(path)\n  }\n\n  ignores (path) {\n    return !this._filter(path)\n  }\n\n  // @returns `Boolean` true if the `path` is NOT ignored\n  _filter (path, slices) {\n    if (!path) {\n      return false\n    }\n\n    if (path in this._cache) {\n      return this._cache[path]\n    }\n\n    if (!slices) {\n      // path/to/a.js\n      // ['path', 'to', 'a.js']\n      slices = path.split(SLASH)\n    }\n\n    slices.pop()\n\n    return this._cache[path] = slices.length\n      // > It is not possible to re-include a file if a parent directory of\n      // >   that file is excluded.\n      // If the path contains a parent directory, check the parent first\n      ? this._filter(slices.join(SLASH) + SLASH, slices)\n        && this._test(path)\n\n      // Or only test the path\n      : this._test(path)\n  }\n\n  // @returns {Boolean} true if a file is NOT ignored\n  _test (path) {\n    // Explicitly define variable type by setting matched to `0`\n    let matched = 0\n\n    this._rules.forEach(rule => {\n      // if matched = true, then we only test negative rules\n      // if matched = false, then we test non-negative rules\n      if (!(matched ^ rule.negative)) {\n        matched = rule.negative ^ rule.regex.test(path)\n      }\n    })\n\n    return !matched\n  }\n}\n\n// Windows\n// --------------------------------------------------------------\n/* istanbul ignore if  */\nif (\n  // Detect `process` so that it can run in browsers.\n  typeof process !== 'undefined'\n  && (\n    process.env && process.env.IGNORE_TEST_WIN32\n    || process.platform === 'win32'\n  )\n) {\n  const filter = IgnoreBase.prototype._filter\n\n  /* eslint no-control-regex: \"off\" */\n  const make_posix = str => /^\\\\\\\\\\?\\\\/.test(str)\n  || /[^\\x00-\\x80]+/.test(str)\n    ? str\n    : str.replace(/\\\\/g, '/')\n\n  IgnoreBase.prototype._filter = function filterWin32 (path, slices) {\n    path = make_posix(path)\n    return filter.call(this, path, slices)\n  }\n}\n\nmodule.exports = options => new IgnoreBase(options)\n\n\n//# sourceURL=webpack://javascript/./node_modules/ignore/index.js?");

/***/ }),

/***/ "./node_modules/inherits/inherits_browser.js":
/*!***************************************************!*\
  !*** ./node_modules/inherits/inherits_browser.js ***!
  \***************************************************/
/***/ ((module) => {

eval("if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      ctor.prototype = Object.create(superCtor.prototype, {\n        constructor: {\n          value: ctor,\n          enumerable: false,\n          writable: true,\n          configurable: true\n        }\n      })\n    }\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      var TempCtor = function () {}\n      TempCtor.prototype = superCtor.prototype\n      ctor.prototype = new TempCtor()\n      ctor.prototype.constructor = ctor\n    }\n  }\n}\n\n\n//# sourceURL=webpack://javascript/./node_modules/inherits/inherits_browser.js?");

/***/ }),

/***/ "./node_modules/is-arguments/index.js":
/*!********************************************!*\
  !*** ./node_modules/is-arguments/index.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar hasToStringTag = __webpack_require__(/*! has-tostringtag/shams */ \"./node_modules/has-tostringtag/shams.js\")();\nvar callBound = __webpack_require__(/*! call-bind/callBound */ \"./node_modules/call-bind/callBound.js\");\n\nvar $toString = callBound('Object.prototype.toString');\n\nvar isStandardArguments = function isArguments(value) {\n\tif (hasToStringTag && value && typeof value === 'object' && Symbol.toStringTag in value) {\n\t\treturn false;\n\t}\n\treturn $toString(value) === '[object Arguments]';\n};\n\nvar isLegacyArguments = function isArguments(value) {\n\tif (isStandardArguments(value)) {\n\t\treturn true;\n\t}\n\treturn value !== null &&\n\t\ttypeof value === 'object' &&\n\t\ttypeof value.length === 'number' &&\n\t\tvalue.length >= 0 &&\n\t\t$toString(value) !== '[object Array]' &&\n\t\t$toString(value.callee) === '[object Function]';\n};\n\nvar supportsStandardArguments = (function () {\n\treturn isStandardArguments(arguments);\n}());\n\nisStandardArguments.isLegacyArguments = isLegacyArguments; // for tests\n\nmodule.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;\n\n\n//# sourceURL=webpack://javascript/./node_modules/is-arguments/index.js?");

/***/ }),

/***/ "./node_modules/is-generator-function/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/is-generator-function/index.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar toStr = Object.prototype.toString;\nvar fnToStr = Function.prototype.toString;\nvar isFnRegex = /^\\s*(?:function)?\\*/;\nvar hasToStringTag = __webpack_require__(/*! has-tostringtag/shams */ \"./node_modules/has-tostringtag/shams.js\")();\nvar getProto = Object.getPrototypeOf;\nvar getGeneratorFunc = function () { // eslint-disable-line consistent-return\n\tif (!hasToStringTag) {\n\t\treturn false;\n\t}\n\ttry {\n\t\treturn Function('return function*() {}')();\n\t} catch (e) {\n\t}\n};\nvar GeneratorFunction;\n\nmodule.exports = function isGeneratorFunction(fn) {\n\tif (typeof fn !== 'function') {\n\t\treturn false;\n\t}\n\tif (isFnRegex.test(fnToStr.call(fn))) {\n\t\treturn true;\n\t}\n\tif (!hasToStringTag) {\n\t\tvar str = toStr.call(fn);\n\t\treturn str === '[object GeneratorFunction]';\n\t}\n\tif (!getProto) {\n\t\treturn false;\n\t}\n\tif (typeof GeneratorFunction === 'undefined') {\n\t\tvar generatorFunc = getGeneratorFunc();\n\t\tGeneratorFunction = generatorFunc ? getProto(generatorFunc) : false;\n\t}\n\treturn getProto(fn) === GeneratorFunction;\n};\n\n\n//# sourceURL=webpack://javascript/./node_modules/is-generator-function/index.js?");

/***/ }),

/***/ "./node_modules/is-nan/implementation.js":
/*!***********************************************!*\
  !*** ./node_modules/is-nan/implementation.js ***!
  \***********************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/* http://www.ecma-international.org/ecma-262/6.0/#sec-number.isnan */\n\nmodule.exports = function isNaN(value) {\n\treturn value !== value;\n};\n\n\n//# sourceURL=webpack://javascript/./node_modules/is-nan/implementation.js?");

/***/ }),

/***/ "./node_modules/is-nan/index.js":
/*!**************************************!*\
  !*** ./node_modules/is-nan/index.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar callBind = __webpack_require__(/*! call-bind */ \"./node_modules/call-bind/index.js\");\nvar define = __webpack_require__(/*! define-properties */ \"./node_modules/define-properties/index.js\");\n\nvar implementation = __webpack_require__(/*! ./implementation */ \"./node_modules/is-nan/implementation.js\");\nvar getPolyfill = __webpack_require__(/*! ./polyfill */ \"./node_modules/is-nan/polyfill.js\");\nvar shim = __webpack_require__(/*! ./shim */ \"./node_modules/is-nan/shim.js\");\n\nvar polyfill = callBind(getPolyfill(), Number);\n\n/* http://www.ecma-international.org/ecma-262/6.0/#sec-number.isnan */\n\ndefine(polyfill, {\n\tgetPolyfill: getPolyfill,\n\timplementation: implementation,\n\tshim: shim\n});\n\nmodule.exports = polyfill;\n\n\n//# sourceURL=webpack://javascript/./node_modules/is-nan/index.js?");

/***/ }),

/***/ "./node_modules/is-nan/polyfill.js":
/*!*****************************************!*\
  !*** ./node_modules/is-nan/polyfill.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar implementation = __webpack_require__(/*! ./implementation */ \"./node_modules/is-nan/implementation.js\");\n\nmodule.exports = function getPolyfill() {\n\tif (Number.isNaN && Number.isNaN(NaN) && !Number.isNaN('a')) {\n\t\treturn Number.isNaN;\n\t}\n\treturn implementation;\n};\n\n\n//# sourceURL=webpack://javascript/./node_modules/is-nan/polyfill.js?");

/***/ }),

/***/ "./node_modules/is-nan/shim.js":
/*!*************************************!*\
  !*** ./node_modules/is-nan/shim.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar define = __webpack_require__(/*! define-properties */ \"./node_modules/define-properties/index.js\");\nvar getPolyfill = __webpack_require__(/*! ./polyfill */ \"./node_modules/is-nan/polyfill.js\");\n\n/* http://www.ecma-international.org/ecma-262/6.0/#sec-number.isnan */\n\nmodule.exports = function shimNumberIsNaN() {\n\tvar polyfill = getPolyfill();\n\tdefine(Number, { isNaN: polyfill }, {\n\t\tisNaN: function testIsNaN() {\n\t\t\treturn Number.isNaN !== polyfill;\n\t\t}\n\t});\n\treturn polyfill;\n};\n\n\n//# sourceURL=webpack://javascript/./node_modules/is-nan/shim.js?");

/***/ }),

/***/ "./node_modules/is-typed-array/index.js":
/*!**********************************************!*\
  !*** ./node_modules/is-typed-array/index.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar forEach = __webpack_require__(/*! foreach */ \"./node_modules/foreach/index.js\");\nvar availableTypedArrays = __webpack_require__(/*! available-typed-arrays */ \"./node_modules/available-typed-arrays/index.js\");\nvar callBound = __webpack_require__(/*! call-bind/callBound */ \"./node_modules/call-bind/callBound.js\");\n\nvar $toString = callBound('Object.prototype.toString');\nvar hasToStringTag = __webpack_require__(/*! has-tostringtag/shams */ \"./node_modules/has-tostringtag/shams.js\")();\n\nvar g = typeof globalThis === 'undefined' ? __webpack_require__.g : globalThis;\nvar typedArrays = availableTypedArrays();\n\nvar $indexOf = callBound('Array.prototype.indexOf', true) || function indexOf(array, value) {\n\tfor (var i = 0; i < array.length; i += 1) {\n\t\tif (array[i] === value) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n};\nvar $slice = callBound('String.prototype.slice');\nvar toStrTags = {};\nvar gOPD = __webpack_require__(/*! es-abstract/helpers/getOwnPropertyDescriptor */ \"./node_modules/es-abstract/helpers/getOwnPropertyDescriptor.js\");\nvar getPrototypeOf = Object.getPrototypeOf; // require('getprototypeof');\nif (hasToStringTag && gOPD && getPrototypeOf) {\n\tforEach(typedArrays, function (typedArray) {\n\t\tvar arr = new g[typedArray]();\n\t\tif (Symbol.toStringTag in arr) {\n\t\t\tvar proto = getPrototypeOf(arr);\n\t\t\tvar descriptor = gOPD(proto, Symbol.toStringTag);\n\t\t\tif (!descriptor) {\n\t\t\t\tvar superProto = getPrototypeOf(proto);\n\t\t\t\tdescriptor = gOPD(superProto, Symbol.toStringTag);\n\t\t\t}\n\t\t\ttoStrTags[typedArray] = descriptor.get;\n\t\t}\n\t});\n}\n\nvar tryTypedArrays = function tryAllTypedArrays(value) {\n\tvar anyTrue = false;\n\tforEach(toStrTags, function (getter, typedArray) {\n\t\tif (!anyTrue) {\n\t\t\ttry {\n\t\t\t\tanyTrue = getter.call(value) === typedArray;\n\t\t\t} catch (e) { /**/ }\n\t\t}\n\t});\n\treturn anyTrue;\n};\n\nmodule.exports = function isTypedArray(value) {\n\tif (!value || typeof value !== 'object') { return false; }\n\tif (!hasToStringTag || !(Symbol.toStringTag in value)) {\n\t\tvar tag = $slice($toString(value), 8, -1);\n\t\treturn $indexOf(typedArrays, tag) > -1;\n\t}\n\tif (!gOPD) { return false; }\n\treturn tryTypedArrays(value);\n};\n\n\n//# sourceURL=webpack://javascript/./node_modules/is-typed-array/index.js?");

/***/ }),

/***/ "./node_modules/json-schema-traverse/index.js":
/*!****************************************************!*\
  !*** ./node_modules/json-schema-traverse/index.js ***!
  \****************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nvar traverse = module.exports = function (schema, opts, cb) {\n  // Legacy support for v0.3.1 and earlier.\n  if (typeof opts == 'function') {\n    cb = opts;\n    opts = {};\n  }\n\n  cb = opts.cb || cb;\n  var pre = (typeof cb == 'function') ? cb : cb.pre || function() {};\n  var post = cb.post || function() {};\n\n  _traverse(opts, pre, post, schema, '', schema);\n};\n\n\ntraverse.keywords = {\n  additionalItems: true,\n  items: true,\n  contains: true,\n  additionalProperties: true,\n  propertyNames: true,\n  not: true\n};\n\ntraverse.arrayKeywords = {\n  items: true,\n  allOf: true,\n  anyOf: true,\n  oneOf: true\n};\n\ntraverse.propsKeywords = {\n  definitions: true,\n  properties: true,\n  patternProperties: true,\n  dependencies: true\n};\n\ntraverse.skipKeywords = {\n  default: true,\n  enum: true,\n  const: true,\n  required: true,\n  maximum: true,\n  minimum: true,\n  exclusiveMaximum: true,\n  exclusiveMinimum: true,\n  multipleOf: true,\n  maxLength: true,\n  minLength: true,\n  pattern: true,\n  format: true,\n  maxItems: true,\n  minItems: true,\n  uniqueItems: true,\n  maxProperties: true,\n  minProperties: true\n};\n\n\nfunction _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {\n  if (schema && typeof schema == 'object' && !Array.isArray(schema)) {\n    pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);\n    for (var key in schema) {\n      var sch = schema[key];\n      if (Array.isArray(sch)) {\n        if (key in traverse.arrayKeywords) {\n          for (var i=0; i<sch.length; i++)\n            _traverse(opts, pre, post, sch[i], jsonPtr + '/' + key + '/' + i, rootSchema, jsonPtr, key, schema, i);\n        }\n      } else if (key in traverse.propsKeywords) {\n        if (sch && typeof sch == 'object') {\n          for (var prop in sch)\n            _traverse(opts, pre, post, sch[prop], jsonPtr + '/' + key + '/' + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);\n        }\n      } else if (key in traverse.keywords || (opts.allKeys && !(key in traverse.skipKeywords))) {\n        _traverse(opts, pre, post, sch, jsonPtr + '/' + key, rootSchema, jsonPtr, key, schema);\n      }\n    }\n    post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);\n  }\n}\n\n\nfunction escapeJsonPtr(str) {\n  return str.replace(/~/g, '~0').replace(/\\//g, '~1');\n}\n\n\n//# sourceURL=webpack://javascript/./node_modules/json-schema-traverse/index.js?");

/***/ }),

/***/ "./node_modules/levn/lib/cast.js":
/*!***************************************!*\
  !*** ./node_modules/levn/lib/cast.js ***!
  \***************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("// Generated by LiveScript 1.6.0\n(function(){\n  var parsedTypeCheck, types, toString$ = {}.toString;\n  parsedTypeCheck = (__webpack_require__(/*! type-check */ \"./node_modules/type-check/lib/index.js\").parsedTypeCheck);\n  types = {\n    '*': function(value, options){\n      switch (toString$.call(value).slice(8, -1)) {\n      case 'Array':\n        return typeCast(value, {\n          type: 'Array'\n        }, options);\n      case 'Object':\n        return typeCast(value, {\n          type: 'Object'\n        }, options);\n      default:\n        return {\n          type: 'Just',\n          value: typesCast(value, [\n            {\n              type: 'Undefined'\n            }, {\n              type: 'Null'\n            }, {\n              type: 'NaN'\n            }, {\n              type: 'Boolean'\n            }, {\n              type: 'Number'\n            }, {\n              type: 'Date'\n            }, {\n              type: 'RegExp'\n            }, {\n              type: 'Array'\n            }, {\n              type: 'Object'\n            }, {\n              type: 'String'\n            }\n          ], (options.explicit = true, options))\n        };\n      }\n    },\n    Undefined: function(it){\n      if (it === 'undefined' || it === void 8) {\n        return {\n          type: 'Just',\n          value: void 8\n        };\n      } else {\n        return {\n          type: 'Nothing'\n        };\n      }\n    },\n    Null: function(it){\n      if (it === 'null') {\n        return {\n          type: 'Just',\n          value: null\n        };\n      } else {\n        return {\n          type: 'Nothing'\n        };\n      }\n    },\n    NaN: function(it){\n      if (it === 'NaN') {\n        return {\n          type: 'Just',\n          value: NaN\n        };\n      } else {\n        return {\n          type: 'Nothing'\n        };\n      }\n    },\n    Boolean: function(it){\n      if (it === 'true') {\n        return {\n          type: 'Just',\n          value: true\n        };\n      } else if (it === 'false') {\n        return {\n          type: 'Just',\n          value: false\n        };\n      } else {\n        return {\n          type: 'Nothing'\n        };\n      }\n    },\n    Number: function(it){\n      return {\n        type: 'Just',\n        value: +it\n      };\n    },\n    Int: function(it){\n      return {\n        type: 'Just',\n        value: +it\n      };\n    },\n    Float: function(it){\n      return {\n        type: 'Just',\n        value: +it\n      };\n    },\n    Date: function(value, options){\n      var that;\n      if (that = /^\\#([\\s\\S]*)\\#$/.exec(value)) {\n        return {\n          type: 'Just',\n          value: new Date(+that[1] || that[1])\n        };\n      } else if (options.explicit) {\n        return {\n          type: 'Nothing'\n        };\n      } else {\n        return {\n          type: 'Just',\n          value: new Date(+value || value)\n        };\n      }\n    },\n    RegExp: function(value, options){\n      var that;\n      if (that = /^\\/([\\s\\S]*)\\/([gimy]*)$/.exec(value)) {\n        return {\n          type: 'Just',\n          value: new RegExp(that[1], that[2])\n        };\n      } else if (options.explicit) {\n        return {\n          type: 'Nothing'\n        };\n      } else {\n        return {\n          type: 'Just',\n          value: new RegExp(value)\n        };\n      }\n    },\n    Array: function(value, options){\n      return castArray(value, {\n        of: [{\n          type: '*'\n        }]\n      }, options);\n    },\n    Object: function(value, options){\n      return castFields(value, {\n        of: {}\n      }, options);\n    },\n    String: function(it){\n      var replace, that;\n      if (toString$.call(it).slice(8, -1) !== 'String') {\n        return {\n          type: 'Nothing'\n        };\n      }\n      replace = function(value, quote){\n        return value.replace(/\\\\([^u]|u[0-9a-fA-F]{4})/g, function(all, escaped){\n          switch (escaped[0]) {\n          case quote:\n            return quote;\n          case '\\\\':\n            return '\\\\';\n          case 'b':\n            return '\\b';\n          case 'f':\n            return '\\f';\n          case 'n':\n            return '\\n';\n          case 'r':\n            return '\\r';\n          case 't':\n            return '\\t';\n          case 'u':\n            return JSON.parse(\"\\\"\" + all + \"\\\"\");\n          default:\n            return escaped;\n          }\n        });\n      };\n      if (that = it.match(/^'([\\s\\S]*)'$/)) {\n        return {\n          type: 'Just',\n          value: replace(that[1], \"'\")\n        };\n      } else if (that = it.match(/^\"([\\s\\S]*)\"$/)) {\n        return {\n          type: 'Just',\n          value: replace(that[1], '\"')\n        };\n      } else {\n        return {\n          type: 'Just',\n          value: it\n        };\n      }\n    }\n  };\n  function castArray(node, type, options){\n    var typeOf, element;\n    if (toString$.call(node).slice(8, -1) !== 'Array') {\n      return {\n        type: 'Nothing'\n      };\n    }\n    typeOf = type.of;\n    return {\n      type: 'Just',\n      value: (function(){\n        var i$, ref$, len$, results$ = [];\n        for (i$ = 0, len$ = (ref$ = node).length; i$ < len$; ++i$) {\n          element = ref$[i$];\n          results$.push(typesCast(element, typeOf, options));\n        }\n        return results$;\n      }())\n    };\n  }\n  function castTuple(node, type, options){\n    var result, i, i$, ref$, len$, types, cast;\n    if (toString$.call(node).slice(8, -1) !== 'Array') {\n      return {\n        type: 'Nothing'\n      };\n    }\n    result = [];\n    i = 0;\n    for (i$ = 0, len$ = (ref$ = type.of).length; i$ < len$; ++i$) {\n      types = ref$[i$];\n      cast = typesCast(node[i], types, options);\n      if (toString$.call(cast).slice(8, -1) !== 'Undefined') {\n        result.push(cast);\n      }\n      i++;\n    }\n    if (node.length <= i) {\n      return {\n        type: 'Just',\n        value: result\n      };\n    } else {\n      return {\n        type: 'Nothing'\n      };\n    }\n  }\n  function castFields(node, type, options){\n    var typeOf, key, value;\n    if (toString$.call(node).slice(8, -1) !== 'Object') {\n      return {\n        type: 'Nothing'\n      };\n    }\n    typeOf = type.of;\n    return {\n      type: 'Just',\n      value: (function(){\n        var ref$, resultObj$ = {};\n        for (key in ref$ = node) {\n          value = ref$[key];\n          resultObj$[typesCast(key, [{\n            type: 'String'\n          }], options)] = typesCast(value, typeOf[key] || [{\n            type: '*'\n          }], options);\n        }\n        return resultObj$;\n      }())\n    };\n  }\n  function typeCast(node, typeObj, options){\n    var type, structure, castFunc, ref$;\n    type = typeObj.type, structure = typeObj.structure;\n    if (type) {\n      castFunc = ((ref$ = options.customTypes[type]) != null ? ref$.cast : void 8) || types[type];\n      if (!castFunc) {\n        throw new Error(\"Type not defined: \" + type + \".\");\n      }\n      return castFunc(node, options, typesCast);\n    } else {\n      switch (structure) {\n      case 'array':\n        return castArray(node, typeObj, options);\n      case 'tuple':\n        return castTuple(node, typeObj, options);\n      case 'fields':\n        return castFields(node, typeObj, options);\n      }\n    }\n  }\n  function typesCast(node, types, options){\n    var i$, len$, type, ref$, valueType, value;\n    for (i$ = 0, len$ = types.length; i$ < len$; ++i$) {\n      type = types[i$];\n      ref$ = typeCast(node, type, options), valueType = ref$.type, value = ref$.value;\n      if (valueType === 'Nothing') {\n        continue;\n      }\n      if (parsedTypeCheck([type], value, {\n        customTypes: options.customTypes\n      })) {\n        return value;\n      }\n    }\n    throw new Error(\"Value \" + JSON.stringify(node) + \" does not type check against \" + JSON.stringify(types) + \".\");\n  }\n  module.exports = function(node, types, options){\n    if (!options.explicit && types.length === 1 && types[0].type === 'String') {\n      return node;\n    }\n    return typesCast(node, types, options);\n  };\n}).call(this);\n\n\n//# sourceURL=webpack://javascript/./node_modules/levn/lib/cast.js?");

/***/ }),

/***/ "./node_modules/levn/lib/index.js":
/*!****************************************!*\
  !*** ./node_modules/levn/lib/index.js ***!
  \****************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("// Generated by LiveScript 1.6.0\n(function(){\n  var parseString, cast, parseType, VERSION, parsedTypeParse, parse;\n  parseString = __webpack_require__(/*! ./parse-string */ \"./node_modules/levn/lib/parse-string.js\");\n  cast = __webpack_require__(/*! ./cast */ \"./node_modules/levn/lib/cast.js\");\n  parseType = (__webpack_require__(/*! type-check */ \"./node_modules/type-check/lib/index.js\").parseType);\n  VERSION = '0.4.1';\n  parsedTypeParse = function(parsedType, string, options){\n    options == null && (options = {});\n    options.explicit == null && (options.explicit = false);\n    options.customTypes == null && (options.customTypes = {});\n    return cast(parseString(parsedType, string, options), parsedType, options);\n  };\n  parse = function(type, string, options){\n    return parsedTypeParse(parseType(type), string, options);\n  };\n  module.exports = {\n    VERSION: VERSION,\n    parse: parse,\n    parsedTypeParse: parsedTypeParse\n  };\n}).call(this);\n\n\n//# sourceURL=webpack://javascript/./node_modules/levn/lib/index.js?");

/***/ }),

/***/ "./node_modules/levn/lib/parse-string.js":
/*!***********************************************!*\
  !*** ./node_modules/levn/lib/parse-string.js ***!
  \***********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("// Generated by LiveScript 1.6.0\n(function(){\n  var reject, special, tokenRegex;\n  reject = (__webpack_require__(/*! prelude-ls */ \"./node_modules/prelude-ls/lib/index.js\").reject);\n  function consumeOp(tokens, op){\n    if (tokens[0] === op) {\n      return tokens.shift();\n    } else {\n      throw new Error(\"Expected '\" + op + \"', but got '\" + tokens[0] + \"' instead in \" + JSON.stringify(tokens) + \".\");\n    }\n  }\n  function maybeConsumeOp(tokens, op){\n    if (tokens[0] === op) {\n      return tokens.shift();\n    }\n  }\n  function consumeList(tokens, arg$, hasDelimiters){\n    var open, close, result, untilTest;\n    open = arg$[0], close = arg$[1];\n    if (hasDelimiters) {\n      consumeOp(tokens, open);\n    }\n    result = [];\n    untilTest = \",\" + (hasDelimiters ? close : '');\n    while (tokens.length && (hasDelimiters && tokens[0] !== close)) {\n      result.push(consumeElement(tokens, untilTest));\n      maybeConsumeOp(tokens, ',');\n    }\n    if (hasDelimiters) {\n      consumeOp(tokens, close);\n    }\n    return result;\n  }\n  function consumeArray(tokens, hasDelimiters){\n    return consumeList(tokens, ['[', ']'], hasDelimiters);\n  }\n  function consumeTuple(tokens, hasDelimiters){\n    return consumeList(tokens, ['(', ')'], hasDelimiters);\n  }\n  function consumeFields(tokens, hasDelimiters){\n    var result, untilTest, key;\n    if (hasDelimiters) {\n      consumeOp(tokens, '{');\n    }\n    result = {};\n    untilTest = \",\" + (hasDelimiters ? '}' : '');\n    while (tokens.length && (!hasDelimiters || tokens[0] !== '}')) {\n      key = consumeValue(tokens, ':');\n      consumeOp(tokens, ':');\n      result[key] = consumeElement(tokens, untilTest);\n      maybeConsumeOp(tokens, ',');\n    }\n    if (hasDelimiters) {\n      consumeOp(tokens, '}');\n    }\n    return result;\n  }\n  function consumeValue(tokens, untilTest){\n    var out;\n    untilTest == null && (untilTest = '');\n    out = '';\n    while (tokens.length && -1 === untilTest.indexOf(tokens[0])) {\n      out += tokens.shift();\n    }\n    return out;\n  }\n  function consumeElement(tokens, untilTest){\n    switch (tokens[0]) {\n    case '[':\n      return consumeArray(tokens, true);\n    case '(':\n      return consumeTuple(tokens, true);\n    case '{':\n      return consumeFields(tokens, true);\n    default:\n      return consumeValue(tokens, untilTest);\n    }\n  }\n  function consumeTopLevel(tokens, types, options){\n    var ref$, type, structure, origTokens, result, finalResult, x$, y$;\n    ref$ = types[0], type = ref$.type, structure = ref$.structure;\n    origTokens = tokens.concat();\n    if (!options.explicit && types.length === 1 && ((!type && structure) || (type === 'Array' || type === 'Object'))) {\n      result = structure === 'array' || type === 'Array'\n        ? consumeArray(tokens, tokens[0] === '[')\n        : structure === 'tuple'\n          ? consumeTuple(tokens, tokens[0] === '(')\n          : consumeFields(tokens, tokens[0] === '{');\n      finalResult = tokens.length ? consumeElement(structure === 'array' || type === 'Array'\n        ? (x$ = origTokens, x$.unshift('['), x$.push(']'), x$)\n        : (y$ = origTokens, y$.unshift('('), y$.push(')'), y$)) : result;\n    } else {\n      finalResult = consumeElement(tokens);\n    }\n    return finalResult;\n  }\n  special = /\\[\\]\\(\\)}{:,/.source;\n  tokenRegex = RegExp('(\"(?:\\\\\\\\\"|[^\"])*\")|(\\'(?:\\\\\\\\\\'|[^\\'])*\\')|(/(?:\\\\\\\\/|[^/])*/[a-zA-Z]*)|(#.*#)|([' + special + '])|([^\\\\s' + special + '](?:\\\\s*[^\\\\s' + special + ']+)*)|\\\\s*');\n  module.exports = function(types, string, options){\n    var tokens, node;\n    options == null && (options = {});\n    if (!options.explicit && types.length === 1 && types[0].type === 'String') {\n      return string;\n    }\n    tokens = reject(not$, string.split(tokenRegex));\n    node = consumeTopLevel(tokens, types, options);\n    if (!node) {\n      throw new Error(\"Error parsing '\" + string + \"'.\");\n    }\n    return node;\n  };\n  function not$(x){ return !x; }\n}).call(this);\n\n\n//# sourceURL=webpack://javascript/./node_modules/levn/lib/parse-string.js?");

/***/ }),

/***/ "./node_modules/lodash.merge/index.js":
/*!********************************************!*\
  !*** ./node_modules/lodash.merge/index.js ***!
  \********************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\n/**\n * Lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the size to enable large array optimizations. */\nvar LARGE_ARRAY_SIZE = 200;\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used to detect hot functions by number of calls within a span of milliseconds. */\nvar HOT_COUNT = 800,\n    HOT_SPAN = 16;\n\n/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    asyncTag = '[object AsyncFunction]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    nullTag = '[object Null]',\n    objectTag = '[object Object]',\n    proxyTag = '[object Proxy]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    undefinedTag = '[object Undefined]',\n    weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n/** Used to identify `toStringTag` values of typed arrays. */\nvar typedArrayTags = {};\ntypedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\ntypedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\ntypedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\ntypedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\ntypedArrayTags[uint32Tag] = true;\ntypedArrayTags[argsTag] = typedArrayTags[arrayTag] =\ntypedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\ntypedArrayTags[dataViewTag] = typedArrayTags[dateTag] =\ntypedArrayTags[errorTag] = typedArrayTags[funcTag] =\ntypedArrayTags[mapTag] = typedArrayTags[numberTag] =\ntypedArrayTags[objectTag] = typedArrayTags[regexpTag] =\ntypedArrayTags[setTag] = typedArrayTags[stringTag] =\ntypedArrayTags[weakMapTag] = false;\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof __webpack_require__.g == 'object' && __webpack_require__.g && __webpack_require__.g.Object === Object && __webpack_require__.g;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/** Detect free variable `exports`. */\nvar freeExports =  true && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && \"object\" == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Detect free variable `process` from Node.js. */\nvar freeProcess = moduleExports && freeGlobal.process;\n\n/** Used to access faster Node.js helpers. */\nvar nodeUtil = (function() {\n  try {\n    // Use `util.types` for Node.js 10+.\n    var types = freeModule && freeModule.require && freeModule.require('util').types;\n\n    if (types) {\n      return types;\n    }\n\n    // Legacy `process.binding('util')` for Node.js < 10.\n    return freeProcess && freeProcess.binding && freeProcess.binding('util');\n  } catch (e) {}\n}());\n\n/* Node.js helper references. */\nvar nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n\n/**\n * A faster alternative to `Function#apply`, this function invokes `func`\n * with the `this` binding of `thisArg` and the arguments of `args`.\n *\n * @private\n * @param {Function} func The function to invoke.\n * @param {*} thisArg The `this` binding of `func`.\n * @param {Array} args The arguments to invoke `func` with.\n * @returns {*} Returns the result of `func`.\n */\nfunction apply(func, thisArg, args) {\n  switch (args.length) {\n    case 0: return func.call(thisArg);\n    case 1: return func.call(thisArg, args[0]);\n    case 2: return func.call(thisArg, args[0], args[1]);\n    case 3: return func.call(thisArg, args[0], args[1], args[2]);\n  }\n  return func.apply(thisArg, args);\n}\n\n/**\n * The base implementation of `_.times` without support for iteratee shorthands\n * or max array length checks.\n *\n * @private\n * @param {number} n The number of times to invoke `iteratee`.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the array of results.\n */\nfunction baseTimes(n, iteratee) {\n  var index = -1,\n      result = Array(n);\n\n  while (++index < n) {\n    result[index] = iteratee(index);\n  }\n  return result;\n}\n\n/**\n * The base implementation of `_.unary` without support for storing metadata.\n *\n * @private\n * @param {Function} func The function to cap arguments for.\n * @returns {Function} Returns the new capped function.\n */\nfunction baseUnary(func) {\n  return function(value) {\n    return func(value);\n  };\n}\n\n/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\n/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype,\n    funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Used to infer the `Object` constructor. */\nvar objectCtorString = funcToString.call(Object);\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/** Built-in value references. */\nvar Buffer = moduleExports ? root.Buffer : undefined,\n    Symbol = root.Symbol,\n    Uint8Array = root.Uint8Array,\n    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined,\n    getPrototype = overArg(Object.getPrototypeOf, Object),\n    objectCreate = Object.create,\n    propertyIsEnumerable = objectProto.propertyIsEnumerable,\n    splice = arrayProto.splice,\n    symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\nvar defineProperty = (function() {\n  try {\n    var func = getNative(Object, 'defineProperty');\n    func({}, '', {});\n    return func;\n  } catch (e) {}\n}());\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,\n    nativeMax = Math.max,\n    nativeNow = Date.now;\n\n/* Built-in method references that are verified to be native. */\nvar Map = getNative(root, 'Map'),\n    nativeCreate = getNative(Object, 'create');\n\n/**\n * The base implementation of `_.create` without support for assigning\n * properties to the created object.\n *\n * @private\n * @param {Object} proto The object to inherit from.\n * @returns {Object} Returns the new object.\n */\nvar baseCreate = (function() {\n  function object() {}\n  return function(proto) {\n    if (!isObject(proto)) {\n      return {};\n    }\n    if (objectCreate) {\n      return objectCreate(proto);\n    }\n    object.prototype = proto;\n    var result = new object;\n    object.prototype = undefined;\n    return result;\n  };\n}());\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n  this.size = 0;\n}\n\n/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  var result = this.has(key) && delete this.__data__[key];\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);\n}\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  this.size += this.has(key) ? 0 : 1;\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n  this.size = 0;\n}\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  --this.size;\n  return true;\n}\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    ++this.size;\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.size = 0;\n  this.__data__ = {\n    'hash': new Hash,\n    'map': new (Map || ListCache),\n    'string': new Hash\n  };\n}\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  var result = getMapData(this, key)['delete'](key);\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  var data = getMapData(this, key),\n      size = data.size;\n\n  data.set(key, value);\n  this.size += data.size == size ? 0 : 1;\n  return this;\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\n/**\n * Creates a stack cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Stack(entries) {\n  var data = this.__data__ = new ListCache(entries);\n  this.size = data.size;\n}\n\n/**\n * Removes all key-value entries from the stack.\n *\n * @private\n * @name clear\n * @memberOf Stack\n */\nfunction stackClear() {\n  this.__data__ = new ListCache;\n  this.size = 0;\n}\n\n/**\n * Removes `key` and its value from the stack.\n *\n * @private\n * @name delete\n * @memberOf Stack\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction stackDelete(key) {\n  var data = this.__data__,\n      result = data['delete'](key);\n\n  this.size = data.size;\n  return result;\n}\n\n/**\n * Gets the stack value for `key`.\n *\n * @private\n * @name get\n * @memberOf Stack\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction stackGet(key) {\n  return this.__data__.get(key);\n}\n\n/**\n * Checks if a stack value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Stack\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction stackHas(key) {\n  return this.__data__.has(key);\n}\n\n/**\n * Sets the stack `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Stack\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the stack cache instance.\n */\nfunction stackSet(key, value) {\n  var data = this.__data__;\n  if (data instanceof ListCache) {\n    var pairs = data.__data__;\n    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {\n      pairs.push([key, value]);\n      this.size = ++data.size;\n      return this;\n    }\n    data = this.__data__ = new MapCache(pairs);\n  }\n  data.set(key, value);\n  this.size = data.size;\n  return this;\n}\n\n// Add methods to `Stack`.\nStack.prototype.clear = stackClear;\nStack.prototype['delete'] = stackDelete;\nStack.prototype.get = stackGet;\nStack.prototype.has = stackHas;\nStack.prototype.set = stackSet;\n\n/**\n * Creates an array of the enumerable property names of the array-like `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @param {boolean} inherited Specify returning inherited property names.\n * @returns {Array} Returns the array of property names.\n */\nfunction arrayLikeKeys(value, inherited) {\n  var isArr = isArray(value),\n      isArg = !isArr && isArguments(value),\n      isBuff = !isArr && !isArg && isBuffer(value),\n      isType = !isArr && !isArg && !isBuff && isTypedArray(value),\n      skipIndexes = isArr || isArg || isBuff || isType,\n      result = skipIndexes ? baseTimes(value.length, String) : [],\n      length = result.length;\n\n  for (var key in value) {\n    if ((inherited || hasOwnProperty.call(value, key)) &&\n        !(skipIndexes && (\n           // Safari 9 has enumerable `arguments.length` in strict mode.\n           key == 'length' ||\n           // Node.js 0.10 has enumerable non-index properties on buffers.\n           (isBuff && (key == 'offset' || key == 'parent')) ||\n           // PhantomJS 2 has enumerable non-index properties on typed arrays.\n           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||\n           // Skip index properties.\n           isIndex(key, length)\n        ))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * This function is like `assignValue` except that it doesn't assign\n * `undefined` values.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */\nfunction assignMergeValue(object, key, value) {\n  if ((value !== undefined && !eq(object[key], value)) ||\n      (value === undefined && !(key in object))) {\n    baseAssignValue(object, key, value);\n  }\n}\n\n/**\n * Assigns `value` to `key` of `object` if the existing value is not equivalent\n * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * for equality comparisons.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */\nfunction assignValue(object, key, value) {\n  var objValue = object[key];\n  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||\n      (value === undefined && !(key in object))) {\n    baseAssignValue(object, key, value);\n  }\n}\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\n/**\n * The base implementation of `assignValue` and `assignMergeValue` without\n * value checks.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */\nfunction baseAssignValue(object, key, value) {\n  if (key == '__proto__' && defineProperty) {\n    defineProperty(object, key, {\n      'configurable': true,\n      'enumerable': true,\n      'value': value,\n      'writable': true\n    });\n  } else {\n    object[key] = value;\n  }\n}\n\n/**\n * The base implementation of `baseForOwn` which iterates over `object`\n * properties returned by `keysFunc` and invokes `iteratee` for each property.\n * Iteratee functions may exit iteration early by explicitly returning `false`.\n *\n * @private\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @returns {Object} Returns `object`.\n */\nvar baseFor = createBaseFor();\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\n/**\n * The base implementation of `_.isArguments`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n */\nfunction baseIsArguments(value) {\n  return isObjectLike(value) && baseGetTag(value) == argsTag;\n}\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\n/**\n * The base implementation of `_.isTypedArray` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n */\nfunction baseIsTypedArray(value) {\n  return isObjectLike(value) &&\n    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];\n}\n\n/**\n * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeysIn(object) {\n  if (!isObject(object)) {\n    return nativeKeysIn(object);\n  }\n  var isProto = isPrototype(object),\n      result = [];\n\n  for (var key in object) {\n    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * The base implementation of `_.merge` without support for multiple sources.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @param {number} srcIndex The index of `source`.\n * @param {Function} [customizer] The function to customize merged values.\n * @param {Object} [stack] Tracks traversed source values and their merged\n *  counterparts.\n */\nfunction baseMerge(object, source, srcIndex, customizer, stack) {\n  if (object === source) {\n    return;\n  }\n  baseFor(source, function(srcValue, key) {\n    stack || (stack = new Stack);\n    if (isObject(srcValue)) {\n      baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);\n    }\n    else {\n      var newValue = customizer\n        ? customizer(safeGet(object, key), srcValue, (key + ''), object, source, stack)\n        : undefined;\n\n      if (newValue === undefined) {\n        newValue = srcValue;\n      }\n      assignMergeValue(object, key, newValue);\n    }\n  }, keysIn);\n}\n\n/**\n * A specialized version of `baseMerge` for arrays and objects which performs\n * deep merges and tracks traversed objects enabling objects with circular\n * references to be merged.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @param {string} key The key of the value to merge.\n * @param {number} srcIndex The index of `source`.\n * @param {Function} mergeFunc The function to merge values.\n * @param {Function} [customizer] The function to customize assigned values.\n * @param {Object} [stack] Tracks traversed source values and their merged\n *  counterparts.\n */\nfunction baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {\n  var objValue = safeGet(object, key),\n      srcValue = safeGet(source, key),\n      stacked = stack.get(srcValue);\n\n  if (stacked) {\n    assignMergeValue(object, key, stacked);\n    return;\n  }\n  var newValue = customizer\n    ? customizer(objValue, srcValue, (key + ''), object, source, stack)\n    : undefined;\n\n  var isCommon = newValue === undefined;\n\n  if (isCommon) {\n    var isArr = isArray(srcValue),\n        isBuff = !isArr && isBuffer(srcValue),\n        isTyped = !isArr && !isBuff && isTypedArray(srcValue);\n\n    newValue = srcValue;\n    if (isArr || isBuff || isTyped) {\n      if (isArray(objValue)) {\n        newValue = objValue;\n      }\n      else if (isArrayLikeObject(objValue)) {\n        newValue = copyArray(objValue);\n      }\n      else if (isBuff) {\n        isCommon = false;\n        newValue = cloneBuffer(srcValue, true);\n      }\n      else if (isTyped) {\n        isCommon = false;\n        newValue = cloneTypedArray(srcValue, true);\n      }\n      else {\n        newValue = [];\n      }\n    }\n    else if (isPlainObject(srcValue) || isArguments(srcValue)) {\n      newValue = objValue;\n      if (isArguments(objValue)) {\n        newValue = toPlainObject(objValue);\n      }\n      else if (!isObject(objValue) || isFunction(objValue)) {\n        newValue = initCloneObject(srcValue);\n      }\n    }\n    else {\n      isCommon = false;\n    }\n  }\n  if (isCommon) {\n    // Recursively merge objects and arrays (susceptible to call stack limits).\n    stack.set(srcValue, newValue);\n    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);\n    stack['delete'](srcValue);\n  }\n  assignMergeValue(object, key, newValue);\n}\n\n/**\n * The base implementation of `_.rest` which doesn't validate or coerce arguments.\n *\n * @private\n * @param {Function} func The function to apply a rest parameter to.\n * @param {number} [start=func.length-1] The start position of the rest parameter.\n * @returns {Function} Returns the new function.\n */\nfunction baseRest(func, start) {\n  return setToString(overRest(func, start, identity), func + '');\n}\n\n/**\n * The base implementation of `setToString` without support for hot loop shorting.\n *\n * @private\n * @param {Function} func The function to modify.\n * @param {Function} string The `toString` result.\n * @returns {Function} Returns `func`.\n */\nvar baseSetToString = !defineProperty ? identity : function(func, string) {\n  return defineProperty(func, 'toString', {\n    'configurable': true,\n    'enumerable': false,\n    'value': constant(string),\n    'writable': true\n  });\n};\n\n/**\n * Creates a clone of  `buffer`.\n *\n * @private\n * @param {Buffer} buffer The buffer to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Buffer} Returns the cloned buffer.\n */\nfunction cloneBuffer(buffer, isDeep) {\n  if (isDeep) {\n    return buffer.slice();\n  }\n  var length = buffer.length,\n      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);\n\n  buffer.copy(result);\n  return result;\n}\n\n/**\n * Creates a clone of `arrayBuffer`.\n *\n * @private\n * @param {ArrayBuffer} arrayBuffer The array buffer to clone.\n * @returns {ArrayBuffer} Returns the cloned array buffer.\n */\nfunction cloneArrayBuffer(arrayBuffer) {\n  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);\n  new Uint8Array(result).set(new Uint8Array(arrayBuffer));\n  return result;\n}\n\n/**\n * Creates a clone of `typedArray`.\n *\n * @private\n * @param {Object} typedArray The typed array to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned typed array.\n */\nfunction cloneTypedArray(typedArray, isDeep) {\n  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;\n  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);\n}\n\n/**\n * Copies the values of `source` to `array`.\n *\n * @private\n * @param {Array} source The array to copy values from.\n * @param {Array} [array=[]] The array to copy values to.\n * @returns {Array} Returns `array`.\n */\nfunction copyArray(source, array) {\n  var index = -1,\n      length = source.length;\n\n  array || (array = Array(length));\n  while (++index < length) {\n    array[index] = source[index];\n  }\n  return array;\n}\n\n/**\n * Copies properties of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy properties from.\n * @param {Array} props The property identifiers to copy.\n * @param {Object} [object={}] The object to copy properties to.\n * @param {Function} [customizer] The function to customize copied values.\n * @returns {Object} Returns `object`.\n */\nfunction copyObject(source, props, object, customizer) {\n  var isNew = !object;\n  object || (object = {});\n\n  var index = -1,\n      length = props.length;\n\n  while (++index < length) {\n    var key = props[index];\n\n    var newValue = customizer\n      ? customizer(object[key], source[key], key, object, source)\n      : undefined;\n\n    if (newValue === undefined) {\n      newValue = source[key];\n    }\n    if (isNew) {\n      baseAssignValue(object, key, newValue);\n    } else {\n      assignValue(object, key, newValue);\n    }\n  }\n  return object;\n}\n\n/**\n * Creates a function like `_.assign`.\n *\n * @private\n * @param {Function} assigner The function to assign values.\n * @returns {Function} Returns the new assigner function.\n */\nfunction createAssigner(assigner) {\n  return baseRest(function(object, sources) {\n    var index = -1,\n        length = sources.length,\n        customizer = length > 1 ? sources[length - 1] : undefined,\n        guard = length > 2 ? sources[2] : undefined;\n\n    customizer = (assigner.length > 3 && typeof customizer == 'function')\n      ? (length--, customizer)\n      : undefined;\n\n    if (guard && isIterateeCall(sources[0], sources[1], guard)) {\n      customizer = length < 3 ? undefined : customizer;\n      length = 1;\n    }\n    object = Object(object);\n    while (++index < length) {\n      var source = sources[index];\n      if (source) {\n        assigner(object, source, index, customizer);\n      }\n    }\n    return object;\n  });\n}\n\n/**\n * Creates a base function for methods like `_.forIn` and `_.forOwn`.\n *\n * @private\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Function} Returns the new base function.\n */\nfunction createBaseFor(fromRight) {\n  return function(object, iteratee, keysFunc) {\n    var index = -1,\n        iterable = Object(object),\n        props = keysFunc(object),\n        length = props.length;\n\n    while (length--) {\n      var key = props[fromRight ? length : ++index];\n      if (iteratee(iterable[key], key, iterable) === false) {\n        break;\n      }\n    }\n    return object;\n  };\n}\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\n/**\n * Initializes an object clone.\n *\n * @private\n * @param {Object} object The object to clone.\n * @returns {Object} Returns the initialized clone.\n */\nfunction initCloneObject(object) {\n  return (typeof object.constructor == 'function' && !isPrototype(object))\n    ? baseCreate(getPrototype(object))\n    : {};\n}\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  var type = typeof value;\n  length = length == null ? MAX_SAFE_INTEGER : length;\n\n  return !!length &&\n    (type == 'number' ||\n      (type != 'symbol' && reIsUint.test(value))) &&\n        (value > -1 && value % 1 == 0 && value < length);\n}\n\n/**\n * Checks if the given arguments are from an iteratee call.\n *\n * @private\n * @param {*} value The potential iteratee value argument.\n * @param {*} index The potential iteratee index or key argument.\n * @param {*} object The potential iteratee object argument.\n * @returns {boolean} Returns `true` if the arguments are from an iteratee call,\n *  else `false`.\n */\nfunction isIterateeCall(value, index, object) {\n  if (!isObject(object)) {\n    return false;\n  }\n  var type = typeof index;\n  if (type == 'number'\n        ? (isArrayLike(object) && isIndex(index, object.length))\n        : (type == 'string' && index in object)\n      ) {\n    return eq(object[index], value);\n  }\n  return false;\n}\n\n/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\n/**\n * Checks if `value` is likely a prototype object.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n */\nfunction isPrototype(value) {\n  var Ctor = value && value.constructor,\n      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;\n\n  return value === proto;\n}\n\n/**\n * This function is like\n * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * except that it includes inherited enumerable properties.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction nativeKeysIn(object) {\n  var result = [];\n  if (object != null) {\n    for (var key in Object(object)) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\n/**\n * A specialized version of `baseRest` which transforms the rest array.\n *\n * @private\n * @param {Function} func The function to apply a rest parameter to.\n * @param {number} [start=func.length-1] The start position of the rest parameter.\n * @param {Function} transform The rest array transform.\n * @returns {Function} Returns the new function.\n */\nfunction overRest(func, start, transform) {\n  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);\n  return function() {\n    var args = arguments,\n        index = -1,\n        length = nativeMax(args.length - start, 0),\n        array = Array(length);\n\n    while (++index < length) {\n      array[index] = args[start + index];\n    }\n    index = -1;\n    var otherArgs = Array(start + 1);\n    while (++index < start) {\n      otherArgs[index] = args[index];\n    }\n    otherArgs[start] = transform(array);\n    return apply(func, this, otherArgs);\n  };\n}\n\n/**\n * Gets the value at `key`, unless `key` is \"__proto__\" or \"constructor\".\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction safeGet(object, key) {\n  if (key === 'constructor' && typeof object[key] === 'function') {\n    return;\n  }\n\n  if (key == '__proto__') {\n    return;\n  }\n\n  return object[key];\n}\n\n/**\n * Sets the `toString` method of `func` to return `string`.\n *\n * @private\n * @param {Function} func The function to modify.\n * @param {Function} string The `toString` result.\n * @returns {Function} Returns `func`.\n */\nvar setToString = shortOut(baseSetToString);\n\n/**\n * Creates a function that'll short out and invoke `identity` instead\n * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`\n * milliseconds.\n *\n * @private\n * @param {Function} func The function to restrict.\n * @returns {Function} Returns the new shortable function.\n */\nfunction shortOut(func) {\n  var count = 0,\n      lastCalled = 0;\n\n  return function() {\n    var stamp = nativeNow(),\n        remaining = HOT_SPAN - (stamp - lastCalled);\n\n    lastCalled = stamp;\n    if (remaining > 0) {\n      if (++count >= HOT_COUNT) {\n        return arguments[0];\n      }\n    } else {\n      count = 0;\n    }\n    return func.apply(undefined, arguments);\n  };\n}\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to convert.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\n/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\n/**\n * Checks if `value` is likely an `arguments` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n *  else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nvar isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {\n  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&\n    !propertyIsEnumerable.call(value, 'callee');\n};\n\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\n/**\n * Checks if `value` is array-like. A value is considered array-like if it's\n * not a function and has a `value.length` that's an integer greater than or\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n * @example\n *\n * _.isArrayLike([1, 2, 3]);\n * // => true\n *\n * _.isArrayLike(document.body.children);\n * // => true\n *\n * _.isArrayLike('abc');\n * // => true\n *\n * _.isArrayLike(_.noop);\n * // => false\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(value.length) && !isFunction(value);\n}\n\n/**\n * This method is like `_.isArrayLike` except that it also checks if `value`\n * is an object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array-like object,\n *  else `false`.\n * @example\n *\n * _.isArrayLikeObject([1, 2, 3]);\n * // => true\n *\n * _.isArrayLikeObject(document.body.children);\n * // => true\n *\n * _.isArrayLikeObject('abc');\n * // => false\n *\n * _.isArrayLikeObject(_.noop);\n * // => false\n */\nfunction isArrayLikeObject(value) {\n  return isObjectLike(value) && isArrayLike(value);\n}\n\n/**\n * Checks if `value` is a buffer.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n * @example\n *\n * _.isBuffer(new Buffer(2));\n * // => true\n *\n * _.isBuffer(new Uint8Array(2));\n * // => false\n */\nvar isBuffer = nativeIsBuffer || stubFalse;\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  if (!isObject(value)) {\n    return false;\n  }\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 9 which returns 'object' for typed arrays and other constructors.\n  var tag = baseGetTag(value);\n  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n}\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This method is loosely based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3);\n * // => true\n *\n * _.isLength(Number.MIN_VALUE);\n * // => false\n *\n * _.isLength(Infinity);\n * // => false\n *\n * _.isLength('3');\n * // => false\n */\nfunction isLength(value) {\n  return typeof value == 'number' &&\n    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\n/**\n * Checks if `value` is a plain object, that is, an object created by the\n * `Object` constructor or one with a `[[Prototype]]` of `null`.\n *\n * @static\n * @memberOf _\n * @since 0.8.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n * }\n *\n * _.isPlainObject(new Foo);\n * // => false\n *\n * _.isPlainObject([1, 2, 3]);\n * // => false\n *\n * _.isPlainObject({ 'x': 0, 'y': 0 });\n * // => true\n *\n * _.isPlainObject(Object.create(null));\n * // => true\n */\nfunction isPlainObject(value) {\n  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {\n    return false;\n  }\n  var proto = getPrototype(value);\n  if (proto === null) {\n    return true;\n  }\n  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;\n  return typeof Ctor == 'function' && Ctor instanceof Ctor &&\n    funcToString.call(Ctor) == objectCtorString;\n}\n\n/**\n * Checks if `value` is classified as a typed array.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n * @example\n *\n * _.isTypedArray(new Uint8Array);\n * // => true\n *\n * _.isTypedArray([]);\n * // => false\n */\nvar isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n\n/**\n * Converts `value` to a plain object flattening inherited enumerable string\n * keyed properties of `value` to own properties of the plain object.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {Object} Returns the converted plain object.\n * @example\n *\n * function Foo() {\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.assign({ 'a': 1 }, new Foo);\n * // => { 'a': 1, 'b': 2 }\n *\n * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));\n * // => { 'a': 1, 'b': 2, 'c': 3 }\n */\nfunction toPlainObject(value) {\n  return copyObject(value, keysIn(value));\n}\n\n/**\n * Creates an array of the own and inherited enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keysIn(new Foo);\n * // => ['a', 'b', 'c'] (iteration order is not guaranteed)\n */\nfunction keysIn(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);\n}\n\n/**\n * This method is like `_.assign` except that it recursively merges own and\n * inherited enumerable string keyed properties of source objects into the\n * destination object. Source properties that resolve to `undefined` are\n * skipped if a destination value exists. Array and plain object properties\n * are merged recursively. Other objects and value types are overridden by\n * assignment. Source objects are applied from left to right. Subsequent\n * sources overwrite property assignments of previous sources.\n *\n * **Note:** This method mutates `object`.\n *\n * @static\n * @memberOf _\n * @since 0.5.0\n * @category Object\n * @param {Object} object The destination object.\n * @param {...Object} [sources] The source objects.\n * @returns {Object} Returns `object`.\n * @example\n *\n * var object = {\n *   'a': [{ 'b': 2 }, { 'd': 4 }]\n * };\n *\n * var other = {\n *   'a': [{ 'c': 3 }, { 'e': 5 }]\n * };\n *\n * _.merge(object, other);\n * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }\n */\nvar merge = createAssigner(function(object, source, srcIndex) {\n  baseMerge(object, source, srcIndex);\n});\n\n/**\n * Creates a function that returns `value`.\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Util\n * @param {*} value The value to return from the new function.\n * @returns {Function} Returns the new constant function.\n * @example\n *\n * var objects = _.times(2, _.constant({ 'a': 1 }));\n *\n * console.log(objects);\n * // => [{ 'a': 1 }, { 'a': 1 }]\n *\n * console.log(objects[0] === objects[1]);\n * // => true\n */\nfunction constant(value) {\n  return function() {\n    return value;\n  };\n}\n\n/**\n * This method returns the first argument it receives.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Util\n * @param {*} value Any value.\n * @returns {*} Returns `value`.\n * @example\n *\n * var object = { 'a': 1 };\n *\n * console.log(_.identity(object) === object);\n * // => true\n */\nfunction identity(value) {\n  return value;\n}\n\n/**\n * This method returns `false`.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {boolean} Returns `false`.\n * @example\n *\n * _.times(2, _.stubFalse);\n * // => [false, false]\n */\nfunction stubFalse() {\n  return false;\n}\n\nmodule.exports = merge;\n\n\n//# sourceURL=webpack://javascript/./node_modules/lodash.merge/index.js?");

/***/ }),

/***/ "./node_modules/natural-compare/index.js":
/*!***********************************************!*\
  !*** ./node_modules/natural-compare/index.js ***!
  \***********************************************/
/***/ ((module) => {

eval("\n\n\n/*\n * @version    1.4.0\n * @date       2015-10-26\n * @stability  3 - Stable\n * @author     Lauri Rooden (https://github.com/litejs/natural-compare-lite)\n * @license    MIT License\n */\n\n\nvar naturalCompare = function(a, b) {\n\tvar i, codeA\n\t, codeB = 1\n\t, posA = 0\n\t, posB = 0\n\t, alphabet = String.alphabet\n\n\tfunction getCode(str, pos, code) {\n\t\tif (code) {\n\t\t\tfor (i = pos; code = getCode(str, i), code < 76 && code > 65;) ++i;\n\t\t\treturn +str.slice(pos - 1, i)\n\t\t}\n\t\tcode = alphabet && alphabet.indexOf(str.charAt(pos))\n\t\treturn code > -1 ? code + 76 : ((code = str.charCodeAt(pos) || 0), code < 45 || code > 127) ? code\n\t\t\t: code < 46 ? 65               // -\n\t\t\t: code < 48 ? code - 1\n\t\t\t: code < 58 ? code + 18        // 0-9\n\t\t\t: code < 65 ? code - 11\n\t\t\t: code < 91 ? code + 11        // A-Z\n\t\t\t: code < 97 ? code - 37\n\t\t\t: code < 123 ? code + 5        // a-z\n\t\t\t: code - 63\n\t}\n\n\n\tif ((a+=\"\") != (b+=\"\")) for (;codeB;) {\n\t\tcodeA = getCode(a, posA++)\n\t\tcodeB = getCode(b, posB++)\n\n\t\tif (codeA < 76 && codeB < 76 && codeA > 66 && codeB > 66) {\n\t\t\tcodeA = getCode(a, posA, posA)\n\t\t\tcodeB = getCode(b, posB, posA = i)\n\t\t\tposB = i\n\t\t}\n\n\t\tif (codeA != codeB) return (codeA < codeB) ? -1 : 1\n\t}\n\treturn 0\n}\n\ntry {\n\tmodule.exports = naturalCompare;\n} catch (e) {\n\tString.naturalCompare = naturalCompare;\n}\n\n\n//# sourceURL=webpack://javascript/./node_modules/natural-compare/index.js?");

/***/ }),

/***/ "./node_modules/object-is/implementation.js":
/*!**************************************************!*\
  !*** ./node_modules/object-is/implementation.js ***!
  \**************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nvar numberIsNaN = function (value) {\n\treturn value !== value;\n};\n\nmodule.exports = function is(a, b) {\n\tif (a === 0 && b === 0) {\n\t\treturn 1 / a === 1 / b;\n\t}\n\tif (a === b) {\n\t\treturn true;\n\t}\n\tif (numberIsNaN(a) && numberIsNaN(b)) {\n\t\treturn true;\n\t}\n\treturn false;\n};\n\n\n\n//# sourceURL=webpack://javascript/./node_modules/object-is/implementation.js?");

/***/ }),

/***/ "./node_modules/object-is/index.js":
/*!*****************************************!*\
  !*** ./node_modules/object-is/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar define = __webpack_require__(/*! define-properties */ \"./node_modules/define-properties/index.js\");\nvar callBind = __webpack_require__(/*! call-bind */ \"./node_modules/call-bind/index.js\");\n\nvar implementation = __webpack_require__(/*! ./implementation */ \"./node_modules/object-is/implementation.js\");\nvar getPolyfill = __webpack_require__(/*! ./polyfill */ \"./node_modules/object-is/polyfill.js\");\nvar shim = __webpack_require__(/*! ./shim */ \"./node_modules/object-is/shim.js\");\n\nvar polyfill = callBind(getPolyfill(), Object);\n\ndefine(polyfill, {\n\tgetPolyfill: getPolyfill,\n\timplementation: implementation,\n\tshim: shim\n});\n\nmodule.exports = polyfill;\n\n\n//# sourceURL=webpack://javascript/./node_modules/object-is/index.js?");

/***/ }),

/***/ "./node_modules/object-is/polyfill.js":
/*!********************************************!*\
  !*** ./node_modules/object-is/polyfill.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar implementation = __webpack_require__(/*! ./implementation */ \"./node_modules/object-is/implementation.js\");\n\nmodule.exports = function getPolyfill() {\n\treturn typeof Object.is === 'function' ? Object.is : implementation;\n};\n\n\n//# sourceURL=webpack://javascript/./node_modules/object-is/polyfill.js?");

/***/ }),

/***/ "./node_modules/object-is/shim.js":
/*!****************************************!*\
  !*** ./node_modules/object-is/shim.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar getPolyfill = __webpack_require__(/*! ./polyfill */ \"./node_modules/object-is/polyfill.js\");\nvar define = __webpack_require__(/*! define-properties */ \"./node_modules/define-properties/index.js\");\n\nmodule.exports = function shimObjectIs() {\n\tvar polyfill = getPolyfill();\n\tdefine(Object, { is: polyfill }, {\n\t\tis: function testObjectIs() {\n\t\t\treturn Object.is !== polyfill;\n\t\t}\n\t});\n\treturn polyfill;\n};\n\n\n//# sourceURL=webpack://javascript/./node_modules/object-is/shim.js?");

/***/ }),

/***/ "./node_modules/object-keys/implementation.js":
/*!****************************************************!*\
  !*** ./node_modules/object-keys/implementation.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar keysShim;\nif (!Object.keys) {\n\t// modified from https://github.com/es-shims/es5-shim\n\tvar has = Object.prototype.hasOwnProperty;\n\tvar toStr = Object.prototype.toString;\n\tvar isArgs = __webpack_require__(/*! ./isArguments */ \"./node_modules/object-keys/isArguments.js\"); // eslint-disable-line global-require\n\tvar isEnumerable = Object.prototype.propertyIsEnumerable;\n\tvar hasDontEnumBug = !isEnumerable.call({ toString: null }, 'toString');\n\tvar hasProtoEnumBug = isEnumerable.call(function () {}, 'prototype');\n\tvar dontEnums = [\n\t\t'toString',\n\t\t'toLocaleString',\n\t\t'valueOf',\n\t\t'hasOwnProperty',\n\t\t'isPrototypeOf',\n\t\t'propertyIsEnumerable',\n\t\t'constructor'\n\t];\n\tvar equalsConstructorPrototype = function (o) {\n\t\tvar ctor = o.constructor;\n\t\treturn ctor && ctor.prototype === o;\n\t};\n\tvar excludedKeys = {\n\t\t$applicationCache: true,\n\t\t$console: true,\n\t\t$external: true,\n\t\t$frame: true,\n\t\t$frameElement: true,\n\t\t$frames: true,\n\t\t$innerHeight: true,\n\t\t$innerWidth: true,\n\t\t$onmozfullscreenchange: true,\n\t\t$onmozfullscreenerror: true,\n\t\t$outerHeight: true,\n\t\t$outerWidth: true,\n\t\t$pageXOffset: true,\n\t\t$pageYOffset: true,\n\t\t$parent: true,\n\t\t$scrollLeft: true,\n\t\t$scrollTop: true,\n\t\t$scrollX: true,\n\t\t$scrollY: true,\n\t\t$self: true,\n\t\t$webkitIndexedDB: true,\n\t\t$webkitStorageInfo: true,\n\t\t$window: true\n\t};\n\tvar hasAutomationEqualityBug = (function () {\n\t\t/* global window */\n\t\tif (typeof window === 'undefined') { return false; }\n\t\tfor (var k in window) {\n\t\t\ttry {\n\t\t\t\tif (!excludedKeys['$' + k] && has.call(window, k) && window[k] !== null && typeof window[k] === 'object') {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tequalsConstructorPrototype(window[k]);\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}());\n\tvar equalsConstructorPrototypeIfNotBuggy = function (o) {\n\t\t/* global window */\n\t\tif (typeof window === 'undefined' || !hasAutomationEqualityBug) {\n\t\t\treturn equalsConstructorPrototype(o);\n\t\t}\n\t\ttry {\n\t\t\treturn equalsConstructorPrototype(o);\n\t\t} catch (e) {\n\t\t\treturn false;\n\t\t}\n\t};\n\n\tkeysShim = function keys(object) {\n\t\tvar isObject = object !== null && typeof object === 'object';\n\t\tvar isFunction = toStr.call(object) === '[object Function]';\n\t\tvar isArguments = isArgs(object);\n\t\tvar isString = isObject && toStr.call(object) === '[object String]';\n\t\tvar theKeys = [];\n\n\t\tif (!isObject && !isFunction && !isArguments) {\n\t\t\tthrow new TypeError('Object.keys called on a non-object');\n\t\t}\n\n\t\tvar skipProto = hasProtoEnumBug && isFunction;\n\t\tif (isString && object.length > 0 && !has.call(object, 0)) {\n\t\t\tfor (var i = 0; i < object.length; ++i) {\n\t\t\t\ttheKeys.push(String(i));\n\t\t\t}\n\t\t}\n\n\t\tif (isArguments && object.length > 0) {\n\t\t\tfor (var j = 0; j < object.length; ++j) {\n\t\t\t\ttheKeys.push(String(j));\n\t\t\t}\n\t\t} else {\n\t\t\tfor (var name in object) {\n\t\t\t\tif (!(skipProto && name === 'prototype') && has.call(object, name)) {\n\t\t\t\t\ttheKeys.push(String(name));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (hasDontEnumBug) {\n\t\t\tvar skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);\n\n\t\t\tfor (var k = 0; k < dontEnums.length; ++k) {\n\t\t\t\tif (!(skipConstructor && dontEnums[k] === 'constructor') && has.call(object, dontEnums[k])) {\n\t\t\t\t\ttheKeys.push(dontEnums[k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn theKeys;\n\t};\n}\nmodule.exports = keysShim;\n\n\n//# sourceURL=webpack://javascript/./node_modules/object-keys/implementation.js?");

/***/ }),

/***/ "./node_modules/object-keys/index.js":
/*!*******************************************!*\
  !*** ./node_modules/object-keys/index.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar slice = Array.prototype.slice;\nvar isArgs = __webpack_require__(/*! ./isArguments */ \"./node_modules/object-keys/isArguments.js\");\n\nvar origKeys = Object.keys;\nvar keysShim = origKeys ? function keys(o) { return origKeys(o); } : __webpack_require__(/*! ./implementation */ \"./node_modules/object-keys/implementation.js\");\n\nvar originalKeys = Object.keys;\n\nkeysShim.shim = function shimObjectKeys() {\n\tif (Object.keys) {\n\t\tvar keysWorksWithArguments = (function () {\n\t\t\t// Safari 5.0 bug\n\t\t\tvar args = Object.keys(arguments);\n\t\t\treturn args && args.length === arguments.length;\n\t\t}(1, 2));\n\t\tif (!keysWorksWithArguments) {\n\t\t\tObject.keys = function keys(object) { // eslint-disable-line func-name-matching\n\t\t\t\tif (isArgs(object)) {\n\t\t\t\t\treturn originalKeys(slice.call(object));\n\t\t\t\t}\n\t\t\t\treturn originalKeys(object);\n\t\t\t};\n\t\t}\n\t} else {\n\t\tObject.keys = keysShim;\n\t}\n\treturn Object.keys || keysShim;\n};\n\nmodule.exports = keysShim;\n\n\n//# sourceURL=webpack://javascript/./node_modules/object-keys/index.js?");

/***/ }),

/***/ "./node_modules/object-keys/isArguments.js":
/*!*************************************************!*\
  !*** ./node_modules/object-keys/isArguments.js ***!
  \*************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nvar toStr = Object.prototype.toString;\n\nmodule.exports = function isArguments(value) {\n\tvar str = toStr.call(value);\n\tvar isArgs = str === '[object Arguments]';\n\tif (!isArgs) {\n\t\tisArgs = str !== '[object Array]' &&\n\t\t\tvalue !== null &&\n\t\t\ttypeof value === 'object' &&\n\t\t\ttypeof value.length === 'number' &&\n\t\t\tvalue.length >= 0 &&\n\t\t\ttoStr.call(value.callee) === '[object Function]';\n\t}\n\treturn isArgs;\n};\n\n\n//# sourceURL=webpack://javascript/./node_modules/object-keys/isArguments.js?");

/***/ }),

/***/ "./node_modules/path-browserify/index.js":
/*!***********************************************!*\
  !*** ./node_modules/path-browserify/index.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* provided dependency */ var process = __webpack_require__(/*! ./node_modules/process/browser.js */ \"./node_modules/process/browser.js\");\n// 'path' module extracted from Node.js v8.11.1 (only the posix part)\n// transplited with Babel\n\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\nfunction assertPath(path) {\n  if (typeof path !== 'string') {\n    throw new TypeError('Path must be a string. Received ' + JSON.stringify(path));\n  }\n}\n\n// Resolves . and .. elements in a path with directory names\nfunction normalizeStringPosix(path, allowAboveRoot) {\n  var res = '';\n  var lastSegmentLength = 0;\n  var lastSlash = -1;\n  var dots = 0;\n  var code;\n  for (var i = 0; i <= path.length; ++i) {\n    if (i < path.length)\n      code = path.charCodeAt(i);\n    else if (code === 47 /*/*/)\n      break;\n    else\n      code = 47 /*/*/;\n    if (code === 47 /*/*/) {\n      if (lastSlash === i - 1 || dots === 1) {\n        // NOOP\n      } else if (lastSlash !== i - 1 && dots === 2) {\n        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 /*.*/ || res.charCodeAt(res.length - 2) !== 46 /*.*/) {\n          if (res.length > 2) {\n            var lastSlashIndex = res.lastIndexOf('/');\n            if (lastSlashIndex !== res.length - 1) {\n              if (lastSlashIndex === -1) {\n                res = '';\n                lastSegmentLength = 0;\n              } else {\n                res = res.slice(0, lastSlashIndex);\n                lastSegmentLength = res.length - 1 - res.lastIndexOf('/');\n              }\n              lastSlash = i;\n              dots = 0;\n              continue;\n            }\n          } else if (res.length === 2 || res.length === 1) {\n            res = '';\n            lastSegmentLength = 0;\n            lastSlash = i;\n            dots = 0;\n            continue;\n          }\n        }\n        if (allowAboveRoot) {\n          if (res.length > 0)\n            res += '/..';\n          else\n            res = '..';\n          lastSegmentLength = 2;\n        }\n      } else {\n        if (res.length > 0)\n          res += '/' + path.slice(lastSlash + 1, i);\n        else\n          res = path.slice(lastSlash + 1, i);\n        lastSegmentLength = i - lastSlash - 1;\n      }\n      lastSlash = i;\n      dots = 0;\n    } else if (code === 46 /*.*/ && dots !== -1) {\n      ++dots;\n    } else {\n      dots = -1;\n    }\n  }\n  return res;\n}\n\nfunction _format(sep, pathObject) {\n  var dir = pathObject.dir || pathObject.root;\n  var base = pathObject.base || (pathObject.name || '') + (pathObject.ext || '');\n  if (!dir) {\n    return base;\n  }\n  if (dir === pathObject.root) {\n    return dir + base;\n  }\n  return dir + sep + base;\n}\n\nvar posix = {\n  // path.resolve([from ...], to)\n  resolve: function resolve() {\n    var resolvedPath = '';\n    var resolvedAbsolute = false;\n    var cwd;\n\n    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n      var path;\n      if (i >= 0)\n        path = arguments[i];\n      else {\n        if (cwd === undefined)\n          cwd = process.cwd();\n        path = cwd;\n      }\n\n      assertPath(path);\n\n      // Skip empty entries\n      if (path.length === 0) {\n        continue;\n      }\n\n      resolvedPath = path + '/' + resolvedPath;\n      resolvedAbsolute = path.charCodeAt(0) === 47 /*/*/;\n    }\n\n    // At this point the path should be resolved to a full absolute path, but\n    // handle relative paths to be safe (might happen when process.cwd() fails)\n\n    // Normalize the path\n    resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);\n\n    if (resolvedAbsolute) {\n      if (resolvedPath.length > 0)\n        return '/' + resolvedPath;\n      else\n        return '/';\n    } else if (resolvedPath.length > 0) {\n      return resolvedPath;\n    } else {\n      return '.';\n    }\n  },\n\n  normalize: function normalize(path) {\n    assertPath(path);\n\n    if (path.length === 0) return '.';\n\n    var isAbsolute = path.charCodeAt(0) === 47 /*/*/;\n    var trailingSeparator = path.charCodeAt(path.length - 1) === 47 /*/*/;\n\n    // Normalize the path\n    path = normalizeStringPosix(path, !isAbsolute);\n\n    if (path.length === 0 && !isAbsolute) path = '.';\n    if (path.length > 0 && trailingSeparator) path += '/';\n\n    if (isAbsolute) return '/' + path;\n    return path;\n  },\n\n  isAbsolute: function isAbsolute(path) {\n    assertPath(path);\n    return path.length > 0 && path.charCodeAt(0) === 47 /*/*/;\n  },\n\n  join: function join() {\n    if (arguments.length === 0)\n      return '.';\n    var joined;\n    for (var i = 0; i < arguments.length; ++i) {\n      var arg = arguments[i];\n      assertPath(arg);\n      if (arg.length > 0) {\n        if (joined === undefined)\n          joined = arg;\n        else\n          joined += '/' + arg;\n      }\n    }\n    if (joined === undefined)\n      return '.';\n    return posix.normalize(joined);\n  },\n\n  relative: function relative(from, to) {\n    assertPath(from);\n    assertPath(to);\n\n    if (from === to) return '';\n\n    from = posix.resolve(from);\n    to = posix.resolve(to);\n\n    if (from === to) return '';\n\n    // Trim any leading backslashes\n    var fromStart = 1;\n    for (; fromStart < from.length; ++fromStart) {\n      if (from.charCodeAt(fromStart) !== 47 /*/*/)\n        break;\n    }\n    var fromEnd = from.length;\n    var fromLen = fromEnd - fromStart;\n\n    // Trim any leading backslashes\n    var toStart = 1;\n    for (; toStart < to.length; ++toStart) {\n      if (to.charCodeAt(toStart) !== 47 /*/*/)\n        break;\n    }\n    var toEnd = to.length;\n    var toLen = toEnd - toStart;\n\n    // Compare paths to find the longest common path from root\n    var length = fromLen < toLen ? fromLen : toLen;\n    var lastCommonSep = -1;\n    var i = 0;\n    for (; i <= length; ++i) {\n      if (i === length) {\n        if (toLen > length) {\n          if (to.charCodeAt(toStart + i) === 47 /*/*/) {\n            // We get here if `from` is the exact base path for `to`.\n            // For example: from='/foo/bar'; to='/foo/bar/baz'\n            return to.slice(toStart + i + 1);\n          } else if (i === 0) {\n            // We get here if `from` is the root\n            // For example: from='/'; to='/foo'\n            return to.slice(toStart + i);\n          }\n        } else if (fromLen > length) {\n          if (from.charCodeAt(fromStart + i) === 47 /*/*/) {\n            // We get here if `to` is the exact base path for `from`.\n            // For example: from='/foo/bar/baz'; to='/foo/bar'\n            lastCommonSep = i;\n          } else if (i === 0) {\n            // We get here if `to` is the root.\n            // For example: from='/foo'; to='/'\n            lastCommonSep = 0;\n          }\n        }\n        break;\n      }\n      var fromCode = from.charCodeAt(fromStart + i);\n      var toCode = to.charCodeAt(toStart + i);\n      if (fromCode !== toCode)\n        break;\n      else if (fromCode === 47 /*/*/)\n        lastCommonSep = i;\n    }\n\n    var out = '';\n    // Generate the relative path based on the path difference between `to`\n    // and `from`\n    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n      if (i === fromEnd || from.charCodeAt(i) === 47 /*/*/) {\n        if (out.length === 0)\n          out += '..';\n        else\n          out += '/..';\n      }\n    }\n\n    // Lastly, append the rest of the destination (`to`) path that comes after\n    // the common path parts\n    if (out.length > 0)\n      return out + to.slice(toStart + lastCommonSep);\n    else {\n      toStart += lastCommonSep;\n      if (to.charCodeAt(toStart) === 47 /*/*/)\n        ++toStart;\n      return to.slice(toStart);\n    }\n  },\n\n  _makeLong: function _makeLong(path) {\n    return path;\n  },\n\n  dirname: function dirname(path) {\n    assertPath(path);\n    if (path.length === 0) return '.';\n    var code = path.charCodeAt(0);\n    var hasRoot = code === 47 /*/*/;\n    var end = -1;\n    var matchedSlash = true;\n    for (var i = path.length - 1; i >= 1; --i) {\n      code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          if (!matchedSlash) {\n            end = i;\n            break;\n          }\n        } else {\n        // We saw the first non-path separator\n        matchedSlash = false;\n      }\n    }\n\n    if (end === -1) return hasRoot ? '/' : '.';\n    if (hasRoot && end === 1) return '//';\n    return path.slice(0, end);\n  },\n\n  basename: function basename(path, ext) {\n    if (ext !== undefined && typeof ext !== 'string') throw new TypeError('\"ext\" argument must be a string');\n    assertPath(path);\n\n    var start = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i;\n\n    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n      if (ext.length === path.length && ext === path) return '';\n      var extIdx = ext.length - 1;\n      var firstNonSlashEnd = -1;\n      for (i = path.length - 1; i >= 0; --i) {\n        var code = path.charCodeAt(i);\n        if (code === 47 /*/*/) {\n            // If we reached a path separator that was not part of a set of path\n            // separators at the end of the string, stop now\n            if (!matchedSlash) {\n              start = i + 1;\n              break;\n            }\n          } else {\n          if (firstNonSlashEnd === -1) {\n            // We saw the first non-path separator, remember this index in case\n            // we need it if the extension ends up not matching\n            matchedSlash = false;\n            firstNonSlashEnd = i + 1;\n          }\n          if (extIdx >= 0) {\n            // Try to match the explicit extension\n            if (code === ext.charCodeAt(extIdx)) {\n              if (--extIdx === -1) {\n                // We matched the extension, so mark this as the end of our path\n                // component\n                end = i;\n              }\n            } else {\n              // Extension does not match, so our result is the entire path\n              // component\n              extIdx = -1;\n              end = firstNonSlashEnd;\n            }\n          }\n        }\n      }\n\n      if (start === end) end = firstNonSlashEnd;else if (end === -1) end = path.length;\n      return path.slice(start, end);\n    } else {\n      for (i = path.length - 1; i >= 0; --i) {\n        if (path.charCodeAt(i) === 47 /*/*/) {\n            // If we reached a path separator that was not part of a set of path\n            // separators at the end of the string, stop now\n            if (!matchedSlash) {\n              start = i + 1;\n              break;\n            }\n          } else if (end === -1) {\n          // We saw the first non-path separator, mark this as the end of our\n          // path component\n          matchedSlash = false;\n          end = i + 1;\n        }\n      }\n\n      if (end === -1) return '';\n      return path.slice(start, end);\n    }\n  },\n\n  extname: function extname(path) {\n    assertPath(path);\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0;\n    for (var i = path.length - 1; i >= 0; --i) {\n      var code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            startPart = i + 1;\n            break;\n          }\n          continue;\n        }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46 /*.*/) {\n          // If this is our first dot, mark it as the start of our extension\n          if (startDot === -1)\n            startDot = i;\n          else if (preDotState !== 1)\n            preDotState = 1;\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 || end === -1 ||\n        // We saw a non-dot character immediately before the dot\n        preDotState === 0 ||\n        // The (right-most) trimmed path component is exactly '..'\n        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      return '';\n    }\n    return path.slice(startDot, end);\n  },\n\n  format: function format(pathObject) {\n    if (pathObject === null || typeof pathObject !== 'object') {\n      throw new TypeError('The \"pathObject\" argument must be of type Object. Received type ' + typeof pathObject);\n    }\n    return _format('/', pathObject);\n  },\n\n  parse: function parse(path) {\n    assertPath(path);\n\n    var ret = { root: '', dir: '', base: '', ext: '', name: '' };\n    if (path.length === 0) return ret;\n    var code = path.charCodeAt(0);\n    var isAbsolute = code === 47 /*/*/;\n    var start;\n    if (isAbsolute) {\n      ret.root = '/';\n      start = 1;\n    } else {\n      start = 0;\n    }\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i = path.length - 1;\n\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0;\n\n    // Get non-dir info\n    for (; i >= start; --i) {\n      code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            startPart = i + 1;\n            break;\n          }\n          continue;\n        }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46 /*.*/) {\n          // If this is our first dot, mark it as the start of our extension\n          if (startDot === -1) startDot = i;else if (preDotState !== 1) preDotState = 1;\n        } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 || end === -1 ||\n    // We saw a non-dot character immediately before the dot\n    preDotState === 0 ||\n    // The (right-most) trimmed path component is exactly '..'\n    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      if (end !== -1) {\n        if (startPart === 0 && isAbsolute) ret.base = ret.name = path.slice(1, end);else ret.base = ret.name = path.slice(startPart, end);\n      }\n    } else {\n      if (startPart === 0 && isAbsolute) {\n        ret.name = path.slice(1, startDot);\n        ret.base = path.slice(1, end);\n      } else {\n        ret.name = path.slice(startPart, startDot);\n        ret.base = path.slice(startPart, end);\n      }\n      ret.ext = path.slice(startDot, end);\n    }\n\n    if (startPart > 0) ret.dir = path.slice(0, startPart - 1);else if (isAbsolute) ret.dir = '/';\n\n    return ret;\n  },\n\n  sep: '/',\n  delimiter: ':',\n  win32: null,\n  posix: null\n};\n\nposix.posix = posix;\n\nmodule.exports = posix;\n\n\n//# sourceURL=webpack://javascript/./node_modules/path-browserify/index.js?");

/***/ }),

/***/ "./node_modules/prelude-ls/lib/Func.js":
/*!*********************************************!*\
  !*** ./node_modules/prelude-ls/lib/Func.js ***!
  \*********************************************/
/***/ ((module) => {

eval("// Generated by LiveScript 1.6.0\nvar apply, curry, flip, fix, over, memoize, toString$ = {}.toString;\napply = curry$(function(f, list){\n  return f.apply(null, list);\n});\ncurry = function(f){\n  return curry$(f);\n};\nflip = curry$(function(f, x, y){\n  return f(y, x);\n});\nfix = function(f){\n  return function(g){\n    return function(){\n      return f(g(g)).apply(null, arguments);\n    };\n  }(function(g){\n    return function(){\n      return f(g(g)).apply(null, arguments);\n    };\n  });\n};\nover = curry$(function(f, g, x, y){\n  return f(g(x), g(y));\n});\nmemoize = function(f){\n  var memo;\n  memo = {};\n  return function(){\n    var args, res$, i$, to$, key, arg;\n    res$ = [];\n    for (i$ = 0, to$ = arguments.length; i$ < to$; ++i$) {\n      res$.push(arguments[i$]);\n    }\n    args = res$;\n    key = (function(){\n      var i$, ref$, len$, results$ = [];\n      for (i$ = 0, len$ = (ref$ = args).length; i$ < len$; ++i$) {\n        arg = ref$[i$];\n        results$.push(arg + toString$.call(arg).slice(8, -1));\n      }\n      return results$;\n    }()).join('');\n    return memo[key] = key in memo\n      ? memo[key]\n      : f.apply(null, args);\n  };\n};\nmodule.exports = {\n  curry: curry,\n  flip: flip,\n  fix: fix,\n  apply: apply,\n  over: over,\n  memoize: memoize\n};\nfunction curry$(f, bound){\n  var context,\n  _curry = function(args) {\n    return f.length > 1 ? function(){\n      var params = args ? args.concat() : [];\n      context = bound ? context || this : this;\n      return params.push.apply(params, arguments) <\n          f.length && arguments.length ?\n        _curry.call(context, params) : f.apply(context, params);\n    } : f;\n  };\n  return _curry();\n}\n\n//# sourceURL=webpack://javascript/./node_modules/prelude-ls/lib/Func.js?");

/***/ }),

/***/ "./node_modules/prelude-ls/lib/List.js":
/*!*********************************************!*\
  !*** ./node_modules/prelude-ls/lib/List.js ***!
  \*********************************************/
/***/ ((module) => {

eval("// Generated by LiveScript 1.6.0\nvar each, map, compact, filter, reject, remove, partition, find, head, first, tail, last, initial, empty, reverse, unique, uniqueBy, fold, foldl, fold1, foldl1, foldr, foldr1, unfoldr, concat, concatMap, flatten, difference, intersection, union, countBy, groupBy, andList, orList, any, all, sort, sortWith, sortBy, sum, product, mean, average, maximum, minimum, maximumBy, minimumBy, scan, scanl, scan1, scanl1, scanr, scanr1, slice, take, drop, splitAt, takeWhile, dropWhile, span, breakList, zip, zipWith, zipAll, zipAllWith, at, elemIndex, elemIndices, findIndex, findIndices, toString$ = {}.toString;\neach = curry$(function(f, xs){\n  var i$, len$, x;\n  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {\n    x = xs[i$];\n    f(x);\n  }\n  return xs;\n});\nmap = curry$(function(f, xs){\n  var i$, len$, x, results$ = [];\n  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {\n    x = xs[i$];\n    results$.push(f(x));\n  }\n  return results$;\n});\ncompact = function(xs){\n  var i$, len$, x, results$ = [];\n  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {\n    x = xs[i$];\n    if (x) {\n      results$.push(x);\n    }\n  }\n  return results$;\n};\nfilter = curry$(function(f, xs){\n  var i$, len$, x, results$ = [];\n  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {\n    x = xs[i$];\n    if (f(x)) {\n      results$.push(x);\n    }\n  }\n  return results$;\n});\nreject = curry$(function(f, xs){\n  var i$, len$, x, results$ = [];\n  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {\n    x = xs[i$];\n    if (!f(x)) {\n      results$.push(x);\n    }\n  }\n  return results$;\n});\nremove = curry$(function(el, xs){\n  var i, x$;\n  i = elemIndex(el, xs);\n  x$ = xs.slice();\n  if (i != null) {\n    x$.splice(i, 1);\n  }\n  return x$;\n});\npartition = curry$(function(f, xs){\n  var passed, failed, i$, len$, x;\n  passed = [];\n  failed = [];\n  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {\n    x = xs[i$];\n    (f(x) ? passed : failed).push(x);\n  }\n  return [passed, failed];\n});\nfind = curry$(function(f, xs){\n  var i$, len$, x;\n  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {\n    x = xs[i$];\n    if (f(x)) {\n      return x;\n    }\n  }\n});\nhead = first = function(xs){\n  return xs[0];\n};\ntail = function(xs){\n  if (!xs.length) {\n    return;\n  }\n  return xs.slice(1);\n};\nlast = function(xs){\n  return xs[xs.length - 1];\n};\ninitial = function(xs){\n  if (!xs.length) {\n    return;\n  }\n  return xs.slice(0, -1);\n};\nempty = function(xs){\n  return !xs.length;\n};\nreverse = function(xs){\n  return xs.concat().reverse();\n};\nunique = function(xs){\n  var result, i$, len$, x;\n  result = [];\n  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {\n    x = xs[i$];\n    if (!in$(x, result)) {\n      result.push(x);\n    }\n  }\n  return result;\n};\nuniqueBy = curry$(function(f, xs){\n  var seen, i$, len$, x, val, results$ = [];\n  seen = [];\n  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {\n    x = xs[i$];\n    val = f(x);\n    if (in$(val, seen)) {\n      continue;\n    }\n    seen.push(val);\n    results$.push(x);\n  }\n  return results$;\n});\nfold = foldl = curry$(function(f, memo, xs){\n  var i$, len$, x;\n  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {\n    x = xs[i$];\n    memo = f(memo, x);\n  }\n  return memo;\n});\nfold1 = foldl1 = curry$(function(f, xs){\n  return fold(f, xs[0], xs.slice(1));\n});\nfoldr = curry$(function(f, memo, xs){\n  var i$, x;\n  for (i$ = xs.length - 1; i$ >= 0; --i$) {\n    x = xs[i$];\n    memo = f(x, memo);\n  }\n  return memo;\n});\nfoldr1 = curry$(function(f, xs){\n  return foldr(f, xs[xs.length - 1], xs.slice(0, -1));\n});\nunfoldr = curry$(function(f, b){\n  var result, x, that;\n  result = [];\n  x = b;\n  while ((that = f(x)) != null) {\n    result.push(that[0]);\n    x = that[1];\n  }\n  return result;\n});\nconcat = function(xss){\n  return [].concat.apply([], xss);\n};\nconcatMap = curry$(function(f, xs){\n  var x;\n  return [].concat.apply([], (function(){\n    var i$, ref$, len$, results$ = [];\n    for (i$ = 0, len$ = (ref$ = xs).length; i$ < len$; ++i$) {\n      x = ref$[i$];\n      results$.push(f(x));\n    }\n    return results$;\n  }()));\n});\nflatten = function(xs){\n  var x;\n  return [].concat.apply([], (function(){\n    var i$, ref$, len$, results$ = [];\n    for (i$ = 0, len$ = (ref$ = xs).length; i$ < len$; ++i$) {\n      x = ref$[i$];\n      if (toString$.call(x).slice(8, -1) === 'Array') {\n        results$.push(flatten(x));\n      } else {\n        results$.push(x);\n      }\n    }\n    return results$;\n  }()));\n};\ndifference = function(xs){\n  var yss, res$, i$, to$, results, len$, x, j$, len1$, ys;\n  res$ = [];\n  for (i$ = 1, to$ = arguments.length; i$ < to$; ++i$) {\n    res$.push(arguments[i$]);\n  }\n  yss = res$;\n  results = [];\n  outer: for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {\n    x = xs[i$];\n    for (j$ = 0, len1$ = yss.length; j$ < len1$; ++j$) {\n      ys = yss[j$];\n      if (in$(x, ys)) {\n        continue outer;\n      }\n    }\n    results.push(x);\n  }\n  return results;\n};\nintersection = function(xs){\n  var yss, res$, i$, to$, results, len$, x, j$, len1$, ys;\n  res$ = [];\n  for (i$ = 1, to$ = arguments.length; i$ < to$; ++i$) {\n    res$.push(arguments[i$]);\n  }\n  yss = res$;\n  results = [];\n  outer: for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {\n    x = xs[i$];\n    for (j$ = 0, len1$ = yss.length; j$ < len1$; ++j$) {\n      ys = yss[j$];\n      if (!in$(x, ys)) {\n        continue outer;\n      }\n    }\n    results.push(x);\n  }\n  return results;\n};\nunion = function(){\n  var xss, res$, i$, to$, results, len$, xs, j$, len1$, x;\n  res$ = [];\n  for (i$ = 0, to$ = arguments.length; i$ < to$; ++i$) {\n    res$.push(arguments[i$]);\n  }\n  xss = res$;\n  results = [];\n  for (i$ = 0, len$ = xss.length; i$ < len$; ++i$) {\n    xs = xss[i$];\n    for (j$ = 0, len1$ = xs.length; j$ < len1$; ++j$) {\n      x = xs[j$];\n      if (!in$(x, results)) {\n        results.push(x);\n      }\n    }\n  }\n  return results;\n};\ncountBy = curry$(function(f, xs){\n  var results, i$, len$, x, key;\n  results = {};\n  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {\n    x = xs[i$];\n    key = f(x);\n    if (key in results) {\n      results[key] += 1;\n    } else {\n      results[key] = 1;\n    }\n  }\n  return results;\n});\ngroupBy = curry$(function(f, xs){\n  var results, i$, len$, x, key;\n  results = {};\n  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {\n    x = xs[i$];\n    key = f(x);\n    if (key in results) {\n      results[key].push(x);\n    } else {\n      results[key] = [x];\n    }\n  }\n  return results;\n});\nandList = function(xs){\n  var i$, len$, x;\n  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {\n    x = xs[i$];\n    if (!x) {\n      return false;\n    }\n  }\n  return true;\n};\norList = function(xs){\n  var i$, len$, x;\n  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {\n    x = xs[i$];\n    if (x) {\n      return true;\n    }\n  }\n  return false;\n};\nany = curry$(function(f, xs){\n  var i$, len$, x;\n  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {\n    x = xs[i$];\n    if (f(x)) {\n      return true;\n    }\n  }\n  return false;\n});\nall = curry$(function(f, xs){\n  var i$, len$, x;\n  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {\n    x = xs[i$];\n    if (!f(x)) {\n      return false;\n    }\n  }\n  return true;\n});\nsort = function(xs){\n  return xs.concat().sort(function(x, y){\n    if (x > y) {\n      return 1;\n    } else if (x < y) {\n      return -1;\n    } else {\n      return 0;\n    }\n  });\n};\nsortWith = curry$(function(f, xs){\n  return xs.concat().sort(f);\n});\nsortBy = curry$(function(f, xs){\n  return xs.concat().sort(function(x, y){\n    if (f(x) > f(y)) {\n      return 1;\n    } else if (f(x) < f(y)) {\n      return -1;\n    } else {\n      return 0;\n    }\n  });\n});\nsum = function(xs){\n  var result, i$, len$, x;\n  result = 0;\n  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {\n    x = xs[i$];\n    result += x;\n  }\n  return result;\n};\nproduct = function(xs){\n  var result, i$, len$, x;\n  result = 1;\n  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {\n    x = xs[i$];\n    result *= x;\n  }\n  return result;\n};\nmean = average = function(xs){\n  var sum, i$, len$, x;\n  sum = 0;\n  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {\n    x = xs[i$];\n    sum += x;\n  }\n  return sum / xs.length;\n};\nmaximum = function(xs){\n  var max, i$, ref$, len$, x;\n  max = xs[0];\n  for (i$ = 0, len$ = (ref$ = xs.slice(1)).length; i$ < len$; ++i$) {\n    x = ref$[i$];\n    if (x > max) {\n      max = x;\n    }\n  }\n  return max;\n};\nminimum = function(xs){\n  var min, i$, ref$, len$, x;\n  min = xs[0];\n  for (i$ = 0, len$ = (ref$ = xs.slice(1)).length; i$ < len$; ++i$) {\n    x = ref$[i$];\n    if (x < min) {\n      min = x;\n    }\n  }\n  return min;\n};\nmaximumBy = curry$(function(f, xs){\n  var max, i$, ref$, len$, x;\n  max = xs[0];\n  for (i$ = 0, len$ = (ref$ = xs.slice(1)).length; i$ < len$; ++i$) {\n    x = ref$[i$];\n    if (f(x) > f(max)) {\n      max = x;\n    }\n  }\n  return max;\n});\nminimumBy = curry$(function(f, xs){\n  var min, i$, ref$, len$, x;\n  min = xs[0];\n  for (i$ = 0, len$ = (ref$ = xs.slice(1)).length; i$ < len$; ++i$) {\n    x = ref$[i$];\n    if (f(x) < f(min)) {\n      min = x;\n    }\n  }\n  return min;\n});\nscan = scanl = curry$(function(f, memo, xs){\n  var last, x;\n  last = memo;\n  return [memo].concat((function(){\n    var i$, ref$, len$, results$ = [];\n    for (i$ = 0, len$ = (ref$ = xs).length; i$ < len$; ++i$) {\n      x = ref$[i$];\n      results$.push(last = f(last, x));\n    }\n    return results$;\n  }()));\n});\nscan1 = scanl1 = curry$(function(f, xs){\n  if (!xs.length) {\n    return;\n  }\n  return scan(f, xs[0], xs.slice(1));\n});\nscanr = curry$(function(f, memo, xs){\n  xs = xs.concat().reverse();\n  return scan(f, memo, xs).reverse();\n});\nscanr1 = curry$(function(f, xs){\n  if (!xs.length) {\n    return;\n  }\n  xs = xs.concat().reverse();\n  return scan(f, xs[0], xs.slice(1)).reverse();\n});\nslice = curry$(function(x, y, xs){\n  return xs.slice(x, y);\n});\ntake = curry$(function(n, xs){\n  if (n <= 0) {\n    return xs.slice(0, 0);\n  } else {\n    return xs.slice(0, n);\n  }\n});\ndrop = curry$(function(n, xs){\n  if (n <= 0) {\n    return xs;\n  } else {\n    return xs.slice(n);\n  }\n});\nsplitAt = curry$(function(n, xs){\n  return [take(n, xs), drop(n, xs)];\n});\ntakeWhile = curry$(function(p, xs){\n  var len, i;\n  len = xs.length;\n  if (!len) {\n    return xs;\n  }\n  i = 0;\n  while (i < len && p(xs[i])) {\n    i += 1;\n  }\n  return xs.slice(0, i);\n});\ndropWhile = curry$(function(p, xs){\n  var len, i;\n  len = xs.length;\n  if (!len) {\n    return xs;\n  }\n  i = 0;\n  while (i < len && p(xs[i])) {\n    i += 1;\n  }\n  return xs.slice(i);\n});\nspan = curry$(function(p, xs){\n  return [takeWhile(p, xs), dropWhile(p, xs)];\n});\nbreakList = curry$(function(p, xs){\n  return span(compose$(p, not$), xs);\n});\nzip = curry$(function(xs, ys){\n  var result, len, i$, len$, i, x;\n  result = [];\n  len = ys.length;\n  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {\n    i = i$;\n    x = xs[i$];\n    if (i === len) {\n      break;\n    }\n    result.push([x, ys[i]]);\n  }\n  return result;\n});\nzipWith = curry$(function(f, xs, ys){\n  var result, len, i$, len$, i, x;\n  result = [];\n  len = ys.length;\n  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {\n    i = i$;\n    x = xs[i$];\n    if (i === len) {\n      break;\n    }\n    result.push(f(x, ys[i]));\n  }\n  return result;\n});\nzipAll = function(){\n  var xss, res$, i$, to$, minLength, len$, xs, ref$, i, lresult$, j$, results$ = [];\n  res$ = [];\n  for (i$ = 0, to$ = arguments.length; i$ < to$; ++i$) {\n    res$.push(arguments[i$]);\n  }\n  xss = res$;\n  minLength = undefined;\n  for (i$ = 0, len$ = xss.length; i$ < len$; ++i$) {\n    xs = xss[i$];\n    minLength <= (ref$ = xs.length) || (minLength = ref$);\n  }\n  for (i$ = 0; i$ < minLength; ++i$) {\n    i = i$;\n    lresult$ = [];\n    for (j$ = 0, len$ = xss.length; j$ < len$; ++j$) {\n      xs = xss[j$];\n      lresult$.push(xs[i]);\n    }\n    results$.push(lresult$);\n  }\n  return results$;\n};\nzipAllWith = function(f){\n  var xss, res$, i$, to$, minLength, len$, xs, ref$, i, results$ = [];\n  res$ = [];\n  for (i$ = 1, to$ = arguments.length; i$ < to$; ++i$) {\n    res$.push(arguments[i$]);\n  }\n  xss = res$;\n  minLength = undefined;\n  for (i$ = 0, len$ = xss.length; i$ < len$; ++i$) {\n    xs = xss[i$];\n    minLength <= (ref$ = xs.length) || (minLength = ref$);\n  }\n  for (i$ = 0; i$ < minLength; ++i$) {\n    i = i$;\n    results$.push(f.apply(null, (fn$())));\n  }\n  return results$;\n  function fn$(){\n    var i$, ref$, len$, results$ = [];\n    for (i$ = 0, len$ = (ref$ = xss).length; i$ < len$; ++i$) {\n      xs = ref$[i$];\n      results$.push(xs[i]);\n    }\n    return results$;\n  }\n};\nat = curry$(function(n, xs){\n  if (n < 0) {\n    return xs[xs.length + n];\n  } else {\n    return xs[n];\n  }\n});\nelemIndex = curry$(function(el, xs){\n  var i$, len$, i, x;\n  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {\n    i = i$;\n    x = xs[i$];\n    if (x === el) {\n      return i;\n    }\n  }\n});\nelemIndices = curry$(function(el, xs){\n  var i$, len$, i, x, results$ = [];\n  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {\n    i = i$;\n    x = xs[i$];\n    if (x === el) {\n      results$.push(i);\n    }\n  }\n  return results$;\n});\nfindIndex = curry$(function(f, xs){\n  var i$, len$, i, x;\n  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {\n    i = i$;\n    x = xs[i$];\n    if (f(x)) {\n      return i;\n    }\n  }\n});\nfindIndices = curry$(function(f, xs){\n  var i$, len$, i, x, results$ = [];\n  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {\n    i = i$;\n    x = xs[i$];\n    if (f(x)) {\n      results$.push(i);\n    }\n  }\n  return results$;\n});\nmodule.exports = {\n  each: each,\n  map: map,\n  filter: filter,\n  compact: compact,\n  reject: reject,\n  remove: remove,\n  partition: partition,\n  find: find,\n  head: head,\n  first: first,\n  tail: tail,\n  last: last,\n  initial: initial,\n  empty: empty,\n  reverse: reverse,\n  difference: difference,\n  intersection: intersection,\n  union: union,\n  countBy: countBy,\n  groupBy: groupBy,\n  fold: fold,\n  fold1: fold1,\n  foldl: foldl,\n  foldl1: foldl1,\n  foldr: foldr,\n  foldr1: foldr1,\n  unfoldr: unfoldr,\n  andList: andList,\n  orList: orList,\n  any: any,\n  all: all,\n  unique: unique,\n  uniqueBy: uniqueBy,\n  sort: sort,\n  sortWith: sortWith,\n  sortBy: sortBy,\n  sum: sum,\n  product: product,\n  mean: mean,\n  average: average,\n  concat: concat,\n  concatMap: concatMap,\n  flatten: flatten,\n  maximum: maximum,\n  minimum: minimum,\n  maximumBy: maximumBy,\n  minimumBy: minimumBy,\n  scan: scan,\n  scan1: scan1,\n  scanl: scanl,\n  scanl1: scanl1,\n  scanr: scanr,\n  scanr1: scanr1,\n  slice: slice,\n  take: take,\n  drop: drop,\n  splitAt: splitAt,\n  takeWhile: takeWhile,\n  dropWhile: dropWhile,\n  span: span,\n  breakList: breakList,\n  zip: zip,\n  zipWith: zipWith,\n  zipAll: zipAll,\n  zipAllWith: zipAllWith,\n  at: at,\n  elemIndex: elemIndex,\n  elemIndices: elemIndices,\n  findIndex: findIndex,\n  findIndices: findIndices\n};\nfunction curry$(f, bound){\n  var context,\n  _curry = function(args) {\n    return f.length > 1 ? function(){\n      var params = args ? args.concat() : [];\n      context = bound ? context || this : this;\n      return params.push.apply(params, arguments) <\n          f.length && arguments.length ?\n        _curry.call(context, params) : f.apply(context, params);\n    } : f;\n  };\n  return _curry();\n}\nfunction in$(x, xs){\n  var i = -1, l = xs.length >>> 0;\n  while (++i < l) if (x === xs[i]) return true;\n  return false;\n}\nfunction compose$() {\n  var functions = arguments;\n  return function() {\n    var i, result;\n    result = functions[0].apply(this, arguments);\n    for (i = 1; i < functions.length; ++i) {\n      result = functions[i](result);\n    }\n    return result;\n  };\n}\nfunction not$(x){ return !x; }\n\n//# sourceURL=webpack://javascript/./node_modules/prelude-ls/lib/List.js?");

/***/ }),

/***/ "./node_modules/prelude-ls/lib/Num.js":
/*!********************************************!*\
  !*** ./node_modules/prelude-ls/lib/Num.js ***!
  \********************************************/
/***/ ((module) => {

eval("// Generated by LiveScript 1.6.0\nvar max, min, negate, abs, signum, quot, rem, div, mod, recip, pi, tau, exp, sqrt, ln, pow, sin, tan, cos, asin, acos, atan, atan2, truncate, round, ceiling, floor, isItNaN, even, odd, gcd, lcm;\nmax = curry$(function(x$, y$){\n  return x$ > y$ ? x$ : y$;\n});\nmin = curry$(function(x$, y$){\n  return x$ < y$ ? x$ : y$;\n});\nnegate = function(x){\n  return -x;\n};\nabs = Math.abs;\nsignum = function(x){\n  if (x < 0) {\n    return -1;\n  } else if (x > 0) {\n    return 1;\n  } else {\n    return 0;\n  }\n};\nquot = curry$(function(x, y){\n  return ~~(x / y);\n});\nrem = curry$(function(x$, y$){\n  return x$ % y$;\n});\ndiv = curry$(function(x, y){\n  return Math.floor(x / y);\n});\nmod = curry$(function(x$, y$){\n  var ref$;\n  return ((x$) % (ref$ = y$) + ref$) % ref$;\n});\nrecip = (function(it){\n  return 1 / it;\n});\npi = Math.PI;\ntau = pi * 2;\nexp = Math.exp;\nsqrt = Math.sqrt;\nln = Math.log;\npow = curry$(function(x$, y$){\n  return Math.pow(x$, y$);\n});\nsin = Math.sin;\ntan = Math.tan;\ncos = Math.cos;\nasin = Math.asin;\nacos = Math.acos;\natan = Math.atan;\natan2 = curry$(function(x, y){\n  return Math.atan2(x, y);\n});\ntruncate = function(x){\n  return ~~x;\n};\nround = Math.round;\nceiling = Math.ceil;\nfloor = Math.floor;\nisItNaN = function(x){\n  return x !== x;\n};\neven = function(x){\n  return x % 2 === 0;\n};\nodd = function(x){\n  return x % 2 !== 0;\n};\ngcd = curry$(function(x, y){\n  var z;\n  x = Math.abs(x);\n  y = Math.abs(y);\n  while (y !== 0) {\n    z = x % y;\n    x = y;\n    y = z;\n  }\n  return x;\n});\nlcm = curry$(function(x, y){\n  return Math.abs(Math.floor(x / gcd(x, y) * y));\n});\nmodule.exports = {\n  max: max,\n  min: min,\n  negate: negate,\n  abs: abs,\n  signum: signum,\n  quot: quot,\n  rem: rem,\n  div: div,\n  mod: mod,\n  recip: recip,\n  pi: pi,\n  tau: tau,\n  exp: exp,\n  sqrt: sqrt,\n  ln: ln,\n  pow: pow,\n  sin: sin,\n  tan: tan,\n  cos: cos,\n  acos: acos,\n  asin: asin,\n  atan: atan,\n  atan2: atan2,\n  truncate: truncate,\n  round: round,\n  ceiling: ceiling,\n  floor: floor,\n  isItNaN: isItNaN,\n  even: even,\n  odd: odd,\n  gcd: gcd,\n  lcm: lcm\n};\nfunction curry$(f, bound){\n  var context,\n  _curry = function(args) {\n    return f.length > 1 ? function(){\n      var params = args ? args.concat() : [];\n      context = bound ? context || this : this;\n      return params.push.apply(params, arguments) <\n          f.length && arguments.length ?\n        _curry.call(context, params) : f.apply(context, params);\n    } : f;\n  };\n  return _curry();\n}\n\n//# sourceURL=webpack://javascript/./node_modules/prelude-ls/lib/Num.js?");

/***/ }),

/***/ "./node_modules/prelude-ls/lib/Obj.js":
/*!********************************************!*\
  !*** ./node_modules/prelude-ls/lib/Obj.js ***!
  \********************************************/
/***/ ((module) => {

eval("// Generated by LiveScript 1.6.0\nvar values, keys, pairsToObj, objToPairs, listsToObj, objToLists, empty, each, map, compact, filter, reject, partition, find;\nvalues = function(object){\n  var i$, x, results$ = [];\n  for (i$ in object) {\n    x = object[i$];\n    results$.push(x);\n  }\n  return results$;\n};\nkeys = function(object){\n  var x, results$ = [];\n  for (x in object) {\n    results$.push(x);\n  }\n  return results$;\n};\npairsToObj = function(object){\n  var i$, len$, x, resultObj$ = {};\n  for (i$ = 0, len$ = object.length; i$ < len$; ++i$) {\n    x = object[i$];\n    resultObj$[x[0]] = x[1];\n  }\n  return resultObj$;\n};\nobjToPairs = function(object){\n  var key, value, results$ = [];\n  for (key in object) {\n    value = object[key];\n    results$.push([key, value]);\n  }\n  return results$;\n};\nlistsToObj = curry$(function(keys, values){\n  var i$, len$, i, key, resultObj$ = {};\n  for (i$ = 0, len$ = keys.length; i$ < len$; ++i$) {\n    i = i$;\n    key = keys[i$];\n    resultObj$[key] = values[i];\n  }\n  return resultObj$;\n});\nobjToLists = function(object){\n  var keys, values, key, value;\n  keys = [];\n  values = [];\n  for (key in object) {\n    value = object[key];\n    keys.push(key);\n    values.push(value);\n  }\n  return [keys, values];\n};\nempty = function(object){\n  var x;\n  for (x in object) {\n    return false;\n  }\n  return true;\n};\neach = curry$(function(f, object){\n  var i$, x;\n  for (i$ in object) {\n    x = object[i$];\n    f(x);\n  }\n  return object;\n});\nmap = curry$(function(f, object){\n  var k, x, resultObj$ = {};\n  for (k in object) {\n    x = object[k];\n    resultObj$[k] = f(x);\n  }\n  return resultObj$;\n});\ncompact = function(object){\n  var k, x, resultObj$ = {};\n  for (k in object) {\n    x = object[k];\n    if (x) {\n      resultObj$[k] = x;\n    }\n  }\n  return resultObj$;\n};\nfilter = curry$(function(f, object){\n  var k, x, resultObj$ = {};\n  for (k in object) {\n    x = object[k];\n    if (f(x)) {\n      resultObj$[k] = x;\n    }\n  }\n  return resultObj$;\n});\nreject = curry$(function(f, object){\n  var k, x, resultObj$ = {};\n  for (k in object) {\n    x = object[k];\n    if (!f(x)) {\n      resultObj$[k] = x;\n    }\n  }\n  return resultObj$;\n});\npartition = curry$(function(f, object){\n  var passed, failed, k, x;\n  passed = {};\n  failed = {};\n  for (k in object) {\n    x = object[k];\n    (f(x) ? passed : failed)[k] = x;\n  }\n  return [passed, failed];\n});\nfind = curry$(function(f, object){\n  var i$, x;\n  for (i$ in object) {\n    x = object[i$];\n    if (f(x)) {\n      return x;\n    }\n  }\n});\nmodule.exports = {\n  values: values,\n  keys: keys,\n  pairsToObj: pairsToObj,\n  objToPairs: objToPairs,\n  listsToObj: listsToObj,\n  objToLists: objToLists,\n  empty: empty,\n  each: each,\n  map: map,\n  filter: filter,\n  compact: compact,\n  reject: reject,\n  partition: partition,\n  find: find\n};\nfunction curry$(f, bound){\n  var context,\n  _curry = function(args) {\n    return f.length > 1 ? function(){\n      var params = args ? args.concat() : [];\n      context = bound ? context || this : this;\n      return params.push.apply(params, arguments) <\n          f.length && arguments.length ?\n        _curry.call(context, params) : f.apply(context, params);\n    } : f;\n  };\n  return _curry();\n}\n\n//# sourceURL=webpack://javascript/./node_modules/prelude-ls/lib/Obj.js?");

/***/ }),

/***/ "./node_modules/prelude-ls/lib/Str.js":
/*!********************************************!*\
  !*** ./node_modules/prelude-ls/lib/Str.js ***!
  \********************************************/
/***/ ((module) => {

eval("// Generated by LiveScript 1.6.0\nvar split, join, lines, unlines, words, unwords, chars, unchars, reverse, repeat, capitalize, camelize, dasherize;\nsplit = curry$(function(sep, str){\n  return str.split(sep);\n});\njoin = curry$(function(sep, xs){\n  return xs.join(sep);\n});\nlines = function(str){\n  if (!str.length) {\n    return [];\n  }\n  return str.split('\\n');\n};\nunlines = function(it){\n  return it.join('\\n');\n};\nwords = function(str){\n  if (!str.length) {\n    return [];\n  }\n  return str.split(/[ ]+/);\n};\nunwords = function(it){\n  return it.join(' ');\n};\nchars = function(it){\n  return it.split('');\n};\nunchars = function(it){\n  return it.join('');\n};\nreverse = function(str){\n  return str.split('').reverse().join('');\n};\nrepeat = curry$(function(n, str){\n  var result, i$;\n  result = '';\n  for (i$ = 0; i$ < n; ++i$) {\n    result += str;\n  }\n  return result;\n});\ncapitalize = function(str){\n  return str.charAt(0).toUpperCase() + str.slice(1);\n};\ncamelize = function(it){\n  return it.replace(/[-_]+(.)?/g, function(arg$, c){\n    return (c != null ? c : '').toUpperCase();\n  });\n};\ndasherize = function(str){\n  return str.replace(/([^-A-Z])([A-Z]+)/g, function(arg$, lower, upper){\n    return lower + \"-\" + (upper.length > 1\n      ? upper\n      : upper.toLowerCase());\n  }).replace(/^([A-Z]+)/, function(arg$, upper){\n    if (upper.length > 1) {\n      return upper + \"-\";\n    } else {\n      return upper.toLowerCase();\n    }\n  });\n};\nmodule.exports = {\n  split: split,\n  join: join,\n  lines: lines,\n  unlines: unlines,\n  words: words,\n  unwords: unwords,\n  chars: chars,\n  unchars: unchars,\n  reverse: reverse,\n  repeat: repeat,\n  capitalize: capitalize,\n  camelize: camelize,\n  dasherize: dasherize\n};\nfunction curry$(f, bound){\n  var context,\n  _curry = function(args) {\n    return f.length > 1 ? function(){\n      var params = args ? args.concat() : [];\n      context = bound ? context || this : this;\n      return params.push.apply(params, arguments) <\n          f.length && arguments.length ?\n        _curry.call(context, params) : f.apply(context, params);\n    } : f;\n  };\n  return _curry();\n}\n\n//# sourceURL=webpack://javascript/./node_modules/prelude-ls/lib/Str.js?");

/***/ }),

/***/ "./node_modules/prelude-ls/lib/index.js":
/*!**********************************************!*\
  !*** ./node_modules/prelude-ls/lib/index.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Generated by LiveScript 1.6.0\nvar Func, List, Obj, Str, Num, id, isType, replicate, prelude, toString$ = {}.toString;\nFunc = __webpack_require__(/*! ./Func.js */ \"./node_modules/prelude-ls/lib/Func.js\");\nList = __webpack_require__(/*! ./List.js */ \"./node_modules/prelude-ls/lib/List.js\");\nObj = __webpack_require__(/*! ./Obj.js */ \"./node_modules/prelude-ls/lib/Obj.js\");\nStr = __webpack_require__(/*! ./Str.js */ \"./node_modules/prelude-ls/lib/Str.js\");\nNum = __webpack_require__(/*! ./Num.js */ \"./node_modules/prelude-ls/lib/Num.js\");\nid = function(x){\n  return x;\n};\nisType = curry$(function(type, x){\n  return toString$.call(x).slice(8, -1) === type;\n});\nreplicate = curry$(function(n, x){\n  var i$, results$ = [];\n  for (i$ = 0; i$ < n; ++i$) {\n    results$.push(x);\n  }\n  return results$;\n});\nStr.empty = List.empty;\nStr.slice = List.slice;\nStr.take = List.take;\nStr.drop = List.drop;\nStr.splitAt = List.splitAt;\nStr.takeWhile = List.takeWhile;\nStr.dropWhile = List.dropWhile;\nStr.span = List.span;\nStr.breakStr = List.breakList;\nprelude = {\n  Func: Func,\n  List: List,\n  Obj: Obj,\n  Str: Str,\n  Num: Num,\n  id: id,\n  isType: isType,\n  replicate: replicate\n};\nprelude.each = List.each;\nprelude.map = List.map;\nprelude.filter = List.filter;\nprelude.compact = List.compact;\nprelude.reject = List.reject;\nprelude.partition = List.partition;\nprelude.find = List.find;\nprelude.head = List.head;\nprelude.first = List.first;\nprelude.tail = List.tail;\nprelude.last = List.last;\nprelude.initial = List.initial;\nprelude.empty = List.empty;\nprelude.reverse = List.reverse;\nprelude.difference = List.difference;\nprelude.intersection = List.intersection;\nprelude.union = List.union;\nprelude.countBy = List.countBy;\nprelude.groupBy = List.groupBy;\nprelude.fold = List.fold;\nprelude.foldl = List.foldl;\nprelude.fold1 = List.fold1;\nprelude.foldl1 = List.foldl1;\nprelude.foldr = List.foldr;\nprelude.foldr1 = List.foldr1;\nprelude.unfoldr = List.unfoldr;\nprelude.andList = List.andList;\nprelude.orList = List.orList;\nprelude.any = List.any;\nprelude.all = List.all;\nprelude.unique = List.unique;\nprelude.uniqueBy = List.uniqueBy;\nprelude.sort = List.sort;\nprelude.sortWith = List.sortWith;\nprelude.sortBy = List.sortBy;\nprelude.sum = List.sum;\nprelude.product = List.product;\nprelude.mean = List.mean;\nprelude.average = List.average;\nprelude.concat = List.concat;\nprelude.concatMap = List.concatMap;\nprelude.flatten = List.flatten;\nprelude.maximum = List.maximum;\nprelude.minimum = List.minimum;\nprelude.maximumBy = List.maximumBy;\nprelude.minimumBy = List.minimumBy;\nprelude.scan = List.scan;\nprelude.scanl = List.scanl;\nprelude.scan1 = List.scan1;\nprelude.scanl1 = List.scanl1;\nprelude.scanr = List.scanr;\nprelude.scanr1 = List.scanr1;\nprelude.slice = List.slice;\nprelude.take = List.take;\nprelude.drop = List.drop;\nprelude.splitAt = List.splitAt;\nprelude.takeWhile = List.takeWhile;\nprelude.dropWhile = List.dropWhile;\nprelude.span = List.span;\nprelude.breakList = List.breakList;\nprelude.zip = List.zip;\nprelude.zipWith = List.zipWith;\nprelude.zipAll = List.zipAll;\nprelude.zipAllWith = List.zipAllWith;\nprelude.at = List.at;\nprelude.elemIndex = List.elemIndex;\nprelude.elemIndices = List.elemIndices;\nprelude.findIndex = List.findIndex;\nprelude.findIndices = List.findIndices;\nprelude.apply = Func.apply;\nprelude.curry = Func.curry;\nprelude.flip = Func.flip;\nprelude.fix = Func.fix;\nprelude.over = Func.over;\nprelude.split = Str.split;\nprelude.join = Str.join;\nprelude.lines = Str.lines;\nprelude.unlines = Str.unlines;\nprelude.words = Str.words;\nprelude.unwords = Str.unwords;\nprelude.chars = Str.chars;\nprelude.unchars = Str.unchars;\nprelude.repeat = Str.repeat;\nprelude.capitalize = Str.capitalize;\nprelude.camelize = Str.camelize;\nprelude.dasherize = Str.dasherize;\nprelude.values = Obj.values;\nprelude.keys = Obj.keys;\nprelude.pairsToObj = Obj.pairsToObj;\nprelude.objToPairs = Obj.objToPairs;\nprelude.listsToObj = Obj.listsToObj;\nprelude.objToLists = Obj.objToLists;\nprelude.max = Num.max;\nprelude.min = Num.min;\nprelude.negate = Num.negate;\nprelude.abs = Num.abs;\nprelude.signum = Num.signum;\nprelude.quot = Num.quot;\nprelude.rem = Num.rem;\nprelude.div = Num.div;\nprelude.mod = Num.mod;\nprelude.recip = Num.recip;\nprelude.pi = Num.pi;\nprelude.tau = Num.tau;\nprelude.exp = Num.exp;\nprelude.sqrt = Num.sqrt;\nprelude.ln = Num.ln;\nprelude.pow = Num.pow;\nprelude.sin = Num.sin;\nprelude.tan = Num.tan;\nprelude.cos = Num.cos;\nprelude.acos = Num.acos;\nprelude.asin = Num.asin;\nprelude.atan = Num.atan;\nprelude.atan2 = Num.atan2;\nprelude.truncate = Num.truncate;\nprelude.round = Num.round;\nprelude.ceiling = Num.ceiling;\nprelude.floor = Num.floor;\nprelude.isItNaN = Num.isItNaN;\nprelude.even = Num.even;\nprelude.odd = Num.odd;\nprelude.gcd = Num.gcd;\nprelude.lcm = Num.lcm;\nprelude.VERSION = '1.2.1';\nmodule.exports = prelude;\nfunction curry$(f, bound){\n  var context,\n  _curry = function(args) {\n    return f.length > 1 ? function(){\n      var params = args ? args.concat() : [];\n      context = bound ? context || this : this;\n      return params.push.apply(params, arguments) <\n          f.length && arguments.length ?\n        _curry.call(context, params) : f.apply(context, params);\n    } : f;\n  };\n  return _curry();\n}\n\n//# sourceURL=webpack://javascript/./node_modules/prelude-ls/lib/index.js?");

/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/***/ ((module) => {

eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n//# sourceURL=webpack://javascript/./node_modules/process/browser.js?");

/***/ }),

/***/ "./node_modules/regexpp/index.js":
/*!***************************************!*\
  !*** ./node_modules/regexpp/index.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("/*! @author Toru Nagashima <https://github.com/mysticatea> */\n\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\n\n\nvar ast = /*#__PURE__*/Object.freeze({\n\n});\n\nlet largeIdStartRanges = undefined;\nlet largeIdContinueRanges = undefined;\nfunction isIdStart(cp) {\n    if (cp < 0x41)\n        return false;\n    if (cp < 0x5b)\n        return true;\n    if (cp < 0x61)\n        return false;\n    if (cp < 0x7b)\n        return true;\n    return isLargeIdStart(cp);\n}\nfunction isIdContinue(cp) {\n    if (cp < 0x30)\n        return false;\n    if (cp < 0x3a)\n        return true;\n    if (cp < 0x41)\n        return false;\n    if (cp < 0x5b)\n        return true;\n    if (cp === 0x5f)\n        return true;\n    if (cp < 0x61)\n        return false;\n    if (cp < 0x7b)\n        return true;\n    return isLargeIdStart(cp) || isLargeIdContinue(cp);\n}\nfunction isLargeIdStart(cp) {\n    return isInRange(cp, largeIdStartRanges || (largeIdStartRanges = initLargeIdStartRanges()));\n}\nfunction isLargeIdContinue(cp) {\n    return isInRange(cp, largeIdContinueRanges ||\n        (largeIdContinueRanges = initLargeIdContinueRanges()));\n}\nfunction initLargeIdStartRanges() {\n    return restoreRanges(\"4q 0 b 0 5 0 6 m 2 u 2 cp 5 b f 4 8 0 2 0 3m 4 2 1 3 3 2 0 7 0 2 2 2 0 2 j 2 2a 2 3u 9 4l 2 11 3 0 7 14 20 q 5 3 1a 16 10 1 2 2q 2 0 g 1 8 1 b 2 3 0 h 0 2 t u 2g c 0 p w a 1 5 0 6 l 5 0 a 0 4 0 o o 8 a 1i k 2 h 1p 1h 4 0 j 0 8 9 g f 5 7 3 1 3 l 2 6 2 0 4 3 4 0 h 0 e 1 2 2 f 1 b 0 9 5 5 1 3 l 2 6 2 1 2 1 2 1 w 3 2 0 k 2 h 8 2 2 2 l 2 6 2 1 2 4 4 0 j 0 g 1 o 0 c 7 3 1 3 l 2 6 2 1 2 4 4 0 v 1 2 2 g 0 i 0 2 5 4 2 2 3 4 1 2 0 2 1 4 1 4 2 4 b n 0 1h 7 2 2 2 m 2 f 4 0 r 2 6 1 v 0 5 7 2 2 2 m 2 9 2 4 4 0 x 0 2 1 g 1 i 8 2 2 2 14 3 0 h 0 6 2 9 2 p 5 6 h 4 n 2 8 2 0 3 6 1n 1b 2 1 d 6 1n 1 2 0 2 4 2 n 2 0 2 9 2 1 a 0 3 4 2 0 m 3 x 0 1s 7 2 z s 4 38 16 l 0 h 5 5 3 4 0 4 1 8 2 5 c d 0 i 11 2 0 6 0 3 16 2 98 2 3 3 6 2 0 2 3 3 14 2 3 3 w 2 3 3 6 2 0 2 3 3 e 2 1k 2 3 3 1u 12 f h 2d 3 5 4 h7 3 g 2 p 6 22 4 a 8 c 2 3 f h f h f c 2 2 g 1f 10 0 5 0 1w 2g 8 14 2 0 6 1x b u 1e t 3 4 c 17 5 p 1j m a 1g 2b 0 2m 1a i 6 1k t e 1 b 17 r z 16 2 b z 3 8 8 16 3 2 16 3 2 5 2 1 4 0 6 5b 1t 7p 3 5 3 11 3 5 3 7 2 0 2 0 2 0 2 u 3 1g 2 6 2 0 4 2 2 6 4 3 3 5 5 c 6 2 2 6 39 0 e 0 h c 2u 0 5 0 3 9 2 0 3 5 7 0 2 0 2 0 2 f 3 3 6 4 5 0 i 14 22g 1a 2 1a 2 3o 7 3 4 1 d 11 2 0 6 0 3 1j 8 0 h m a 6 2 6 2 6 2 6 2 6 2 6 2 6 2 6 fb 2 q 8 8 4 3 4 5 2d 5 4 2 2h 2 3 6 16 2 2l i v 1d f e9 533 1t g70 4 wc 1w 19 3 7g 4 f b 1 l 1a h u 3 27 14 8 3 2u 3 1g 3 8 17 c 2 2 2 3 2 m u 1f f 1d 1r 5 4 0 2 1 c r b m q s 8 1a t 0 h 4 2 9 b 4 2 14 o 2 2 7 l m 4 0 4 1d 2 0 4 1 3 4 3 0 2 0 p 2 3 a 8 2 d 5 3 5 3 5 a 6 2 6 2 16 2 d 7 36 u 8mb d m 5 1c 6it a5 3 2x 13 6 d 4 6 0 2 9 2 c 2 4 2 0 2 1 2 1 2 2z y a2 j 1r 3 1h 15 b 39 4 2 3q 11 p 7 p c 2g 4 5 3 5 3 5 3 2 10 b 2 p 2 i 2 1 2 e 3 d z 3e 1y 1g 7g s 4 1c 1c v e t 6 11 b t 3 z 5 7 2 4 17 4d j z 5 z 5 13 9 1f 4d 8m a l b 7 49 5 3 0 2 17 2 1 4 0 3 m b m a u 1u i 2 1 b l b p 1z 1j 7 1 1t 0 g 3 2 2 2 s 17 s 4 s 10 7 2 r s 1h b l b i e h 33 20 1k 1e e 1e e z 9p 15 7 1 27 s b 0 9 l 2z k s m d 1g 24 18 x o r z u 0 3 0 9 y 4 0 d 1b f 3 m 0 2 0 10 h 2 o 2d 6 2 0 2 3 2 e 2 9 8 1a 13 7 3 1 3 l 2 6 2 1 2 4 4 0 j 0 d 4 4f 1g j 3 l 2 v 1b l 1 2 0 55 1a 16 3 11 1b l 0 1o 16 e 0 20 q 6e 17 39 1r w 7 3 0 3 7 2 1 2 n g 0 2 0 2n 7 3 12 h 0 2 0 t 0 b 13 8 0 m 0 c 19 k 0 z 1k 7c 8 2 10 i 0 1e t 35 6 2 1 2 11 m 0 q 5 2 1 2 v f 0 94 i 5a 0 28 pl 2v 32 i 5f 24d tq 34i g6 6nu fs 8 u 36 t j 1b h 3 w k 6 i j5 1r 3l 22 6 0 1v c 1t 1 2 0 t 4qf 9 yd 17 8 6wo 7y 1e 2 i 3 9 az 1s5 2y 6 c 4 8 8 9 4mf 2c 2 1y 2 1 3 0 3 1 3 3 2 b 2 0 2 6 2 1s 2 3 3 7 2 6 2 r 2 3 2 4 2 0 4 6 2 9f 3 o 2 o 2 u 2 o 2 u 2 o 2 u 2 o 2 u 2 o 2 7 1th 18 b 6 h 0 aa 17 105 5g 1o 1v 8 0 xh 3 2 q 2 1 2 0 3 0 2 9 2 3 2 0 2 0 7 0 5 0 2 0 2 0 2 2 2 1 2 0 3 0 2 0 2 0 2 0 2 0 2 1 2 0 3 3 2 6 2 3 2 3 2 0 2 9 2 g 6 2 2 4 2 g 3et wyl z 378 c 65 3 4g1 f 5rk 2e8 f1 15v 3t6\");\n}\nfunction initLargeIdContinueRanges() {\n    return restoreRanges(\"53 0 g9 33 o 0 70 4 7e 18 2 0 2 1 2 1 2 0 21 a 1d u 7 0 2u 6 3 5 3 1 2 3 3 9 o 0 v q 2k a g 9 y 8 a 0 p 3 2 8 2 2 2 4 18 2 3c e 2 w 1j 2 2 h 2 6 b 1 3 9 i 2 1l 0 2 6 3 1 3 2 a 0 b 1 3 9 f 0 3 2 1l 0 2 4 5 1 3 2 4 0 l b 4 0 c 2 1l 0 2 7 2 2 2 2 l 1 3 9 b 5 2 2 1l 0 2 6 3 1 3 2 8 2 b 1 3 9 j 0 1o 4 4 2 2 3 a 0 f 9 h 4 1m 6 2 2 2 3 8 1 c 1 3 9 i 2 1l 0 2 6 2 2 2 3 8 1 c 1 3 9 h 3 1k 1 2 6 2 2 2 3 a 0 b 1 3 9 i 2 1z 0 5 5 2 0 2 7 7 9 3 1 1q 0 3 6 d 7 2 9 2g 0 3 8 c 5 3 9 1r 1 7 9 c 0 2 0 2 0 5 1 1e j 2 1 6 a 2 z a 0 2t j 2 9 d 3 5 2 2 2 3 6 4 3 e b 2 e jk 2 a 8 pt 2 u 2 u 1 v 1 1t v a 0 3 9 y 2 3 9 40 0 3b b 5 b b 9 3l a 1p 4 1m 9 2 s 3 a 7 9 n d 2 1 1s 4 1c g c 9 i 8 d 2 v c 3 9 19 d 1d j 9 9 7 9 3b 2 2 k 5 0 7 0 3 2 5j 1l 2 4 g0 1 k 0 3g c 5 0 4 b 2db 2 3y 0 2p v ff 5 2y 1 n7q 9 1y 0 5 9 x 1 29 1 7l 0 4 0 5 0 o 4 5 0 2c 1 1f h b 9 7 h e a t 7 q c 19 3 1c d g 9 c 0 b 9 1c d d 0 9 1 3 9 y 2 1f 0 2 2 3 1 6 1 2 0 16 4 6 1 6l 7 2 1 3 9 fmt 0 ki f h f 4 1 p 2 5d 9 12 0 ji 0 6b 0 46 4 86 9 120 2 2 1 6 3 15 2 5 0 4m 1 fy 3 9 9 aa 1 4a a 4w 2 1i e w 9 g 3 1a a 1i 9 7 2 11 d 2 9 6 1 19 0 d 2 1d d 9 3 2 b 2b b 7 0 4h b 6 9 7 3 1k 1 2 6 3 1 3 2 a 0 b 1 3 6 4 4 5d h a 9 5 0 2a j d 9 5y 6 3 8 s 1 2b g g 9 2a c 9 9 2c e 5 9 6r e 4m 9 1z 5 2 1 3 3 2 0 2 1 d 9 3c 6 3 6 4 0 t 9 15 6 2 3 9 0 a a 1b f ba 7 2 7 h 9 1l l 2 d 3f 5 4 0 2 1 2 6 2 0 9 9 1d 4 2 1 2 4 9 9 96 3 ewa 9 3r 4 1o 6 q 9 s6 0 2 1i 8 3 2a 0 c 1 f58 1 43r 4 4 5 9 7 3 6 v 3 45 2 13e 1d e9 1i 5 1d 9 0 f 0 n 4 2 e 11t 6 2 g 3 6 2 1 2 4 7a 6 a 9 bn d 15j 6 32 6 6 9 3o7 9 gvt3 6n\");\n}\nfunction isInRange(cp, ranges) {\n    let l = 0, r = (ranges.length / 2) | 0, i = 0, min = 0, max = 0;\n    while (l < r) {\n        i = ((l + r) / 2) | 0;\n        min = ranges[2 * i];\n        max = ranges[2 * i + 1];\n        if (cp < min) {\n            r = i;\n        }\n        else if (cp > max) {\n            l = i + 1;\n        }\n        else {\n            return true;\n        }\n    }\n    return false;\n}\nfunction restoreRanges(data) {\n    let last = 0;\n    return data.split(\" \").map(s => (last += parseInt(s, 36) | 0));\n}\n\nclass DataSet {\n    constructor(raw2018, raw2019, raw2020, raw2021) {\n        this._raw2018 = raw2018;\n        this._raw2019 = raw2019;\n        this._raw2020 = raw2020;\n        this._raw2021 = raw2021;\n    }\n    get es2018() {\n        return (this._set2018 || (this._set2018 = new Set(this._raw2018.split(\" \"))));\n    }\n    get es2019() {\n        return (this._set2019 || (this._set2019 = new Set(this._raw2019.split(\" \"))));\n    }\n    get es2020() {\n        return (this._set2020 || (this._set2020 = new Set(this._raw2020.split(\" \"))));\n    }\n    get es2021() {\n        return (this._set2021 || (this._set2021 = new Set(this._raw2021.split(\" \"))));\n    }\n}\nconst gcNameSet = new Set([\"General_Category\", \"gc\"]);\nconst scNameSet = new Set([\"Script\", \"Script_Extensions\", \"sc\", \"scx\"]);\nconst gcValueSets = new DataSet(\"C Cased_Letter Cc Cf Close_Punctuation Cn Co Combining_Mark Connector_Punctuation Control Cs Currency_Symbol Dash_Punctuation Decimal_Number Enclosing_Mark Final_Punctuation Format Initial_Punctuation L LC Letter Letter_Number Line_Separator Ll Lm Lo Lowercase_Letter Lt Lu M Mark Math_Symbol Mc Me Mn Modifier_Letter Modifier_Symbol N Nd Nl No Nonspacing_Mark Number Open_Punctuation Other Other_Letter Other_Number Other_Punctuation Other_Symbol P Paragraph_Separator Pc Pd Pe Pf Pi Po Private_Use Ps Punctuation S Sc Separator Sk Sm So Space_Separator Spacing_Mark Surrogate Symbol Titlecase_Letter Unassigned Uppercase_Letter Z Zl Zp Zs cntrl digit punct\", \"\", \"\", \"\");\nconst scValueSets = new DataSet(\"Adlam Adlm Aghb Ahom Anatolian_Hieroglyphs Arab Arabic Armenian Armi Armn Avestan Avst Bali Balinese Bamu Bamum Bass Bassa_Vah Batak Batk Beng Bengali Bhaiksuki Bhks Bopo Bopomofo Brah Brahmi Brai Braille Bugi Buginese Buhd Buhid Cakm Canadian_Aboriginal Cans Cari Carian Caucasian_Albanian Chakma Cham Cher Cherokee Common Copt Coptic Cprt Cuneiform Cypriot Cyrillic Cyrl Deseret Deva Devanagari Dsrt Dupl Duployan Egyp Egyptian_Hieroglyphs Elba Elbasan Ethi Ethiopic Geor Georgian Glag Glagolitic Gonm Goth Gothic Gran Grantha Greek Grek Gujarati Gujr Gurmukhi Guru Han Hang Hangul Hani Hano Hanunoo Hatr Hatran Hebr Hebrew Hira Hiragana Hluw Hmng Hung Imperial_Aramaic Inherited Inscriptional_Pahlavi Inscriptional_Parthian Ital Java Javanese Kaithi Kali Kana Kannada Katakana Kayah_Li Khar Kharoshthi Khmer Khmr Khoj Khojki Khudawadi Knda Kthi Lana Lao Laoo Latin Latn Lepc Lepcha Limb Limbu Lina Linb Linear_A Linear_B Lisu Lyci Lycian Lydi Lydian Mahajani Mahj Malayalam Mand Mandaic Mani Manichaean Marc Marchen Masaram_Gondi Meetei_Mayek Mend Mende_Kikakui Merc Mero Meroitic_Cursive Meroitic_Hieroglyphs Miao Mlym Modi Mong Mongolian Mro Mroo Mtei Mult Multani Myanmar Mymr Nabataean Narb Nbat New_Tai_Lue Newa Nko Nkoo Nshu Nushu Ogam Ogham Ol_Chiki Olck Old_Hungarian Old_Italic Old_North_Arabian Old_Permic Old_Persian Old_South_Arabian Old_Turkic Oriya Orkh Orya Osage Osge Osma Osmanya Pahawh_Hmong Palm Palmyrene Pau_Cin_Hau Pauc Perm Phag Phags_Pa Phli Phlp Phnx Phoenician Plrd Prti Psalter_Pahlavi Qaac Qaai Rejang Rjng Runic Runr Samaritan Samr Sarb Saur Saurashtra Sgnw Sharada Shavian Shaw Shrd Sidd Siddham SignWriting Sind Sinh Sinhala Sora Sora_Sompeng Soyo Soyombo Sund Sundanese Sylo Syloti_Nagri Syrc Syriac Tagalog Tagb Tagbanwa Tai_Le Tai_Tham Tai_Viet Takr Takri Tale Talu Tamil Taml Tang Tangut Tavt Telu Telugu Tfng Tglg Thaa Thaana Thai Tibetan Tibt Tifinagh Tirh Tirhuta Ugar Ugaritic Vai Vaii Wara Warang_Citi Xpeo Xsux Yi Yiii Zanabazar_Square Zanb Zinh Zyyy\", \"Dogr Dogra Gong Gunjala_Gondi Hanifi_Rohingya Maka Makasar Medefaidrin Medf Old_Sogdian Rohg Sogd Sogdian Sogo\", \"Elym Elymaic Hmnp Nand Nandinagari Nyiakeng_Puachue_Hmong Wancho Wcho\", \"Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi\");\nconst binPropertySets = new DataSet(\"AHex ASCII ASCII_Hex_Digit Alpha Alphabetic Any Assigned Bidi_C Bidi_Control Bidi_M Bidi_Mirrored CI CWCF CWCM CWKCF CWL CWT CWU Case_Ignorable Cased Changes_When_Casefolded Changes_When_Casemapped Changes_When_Lowercased Changes_When_NFKC_Casefolded Changes_When_Titlecased Changes_When_Uppercased DI Dash Default_Ignorable_Code_Point Dep Deprecated Dia Diacritic Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Ext Extender Gr_Base Gr_Ext Grapheme_Base Grapheme_Extend Hex Hex_Digit IDC IDS IDSB IDST IDS_Binary_Operator IDS_Trinary_Operator ID_Continue ID_Start Ideo Ideographic Join_C Join_Control LOE Logical_Order_Exception Lower Lowercase Math NChar Noncharacter_Code_Point Pat_Syn Pat_WS Pattern_Syntax Pattern_White_Space QMark Quotation_Mark RI Radical Regional_Indicator SD STerm Sentence_Terminal Soft_Dotted Term Terminal_Punctuation UIdeo Unified_Ideograph Upper Uppercase VS Variation_Selector White_Space XIDC XIDS XID_Continue XID_Start space\", \"Extended_Pictographic\", \"\", \"EBase EComp EMod EPres ExtPict\");\nfunction isValidUnicodeProperty(version, name, value) {\n    if (gcNameSet.has(name)) {\n        return version >= 2018 && gcValueSets.es2018.has(value);\n    }\n    if (scNameSet.has(name)) {\n        return ((version >= 2018 && scValueSets.es2018.has(value)) ||\n            (version >= 2019 && scValueSets.es2019.has(value)) ||\n            (version >= 2020 && scValueSets.es2020.has(value)) ||\n            (version >= 2021 && scValueSets.es2021.has(value)));\n    }\n    return false;\n}\nfunction isValidLoneUnicodeProperty(version, value) {\n    return ((version >= 2018 && binPropertySets.es2018.has(value)) ||\n        (version >= 2019 && binPropertySets.es2019.has(value)) ||\n        (version >= 2021 && binPropertySets.es2021.has(value)));\n}\n\nconst Backspace = 0x08;\nconst CharacterTabulation = 0x09;\nconst LineFeed = 0x0a;\nconst LineTabulation = 0x0b;\nconst FormFeed = 0x0c;\nconst CarriageReturn = 0x0d;\nconst ExclamationMark = 0x21;\nconst DollarSign = 0x24;\nconst LeftParenthesis = 0x28;\nconst RightParenthesis = 0x29;\nconst Asterisk = 0x2a;\nconst PlusSign = 0x2b;\nconst Comma = 0x2c;\nconst HyphenMinus = 0x2d;\nconst FullStop = 0x2e;\nconst Solidus = 0x2f;\nconst DigitZero = 0x30;\nconst DigitOne = 0x31;\nconst DigitSeven = 0x37;\nconst DigitNine = 0x39;\nconst Colon = 0x3a;\nconst LessThanSign = 0x3c;\nconst EqualsSign = 0x3d;\nconst GreaterThanSign = 0x3e;\nconst QuestionMark = 0x3f;\nconst LatinCapitalLetterA = 0x41;\nconst LatinCapitalLetterB = 0x42;\nconst LatinCapitalLetterD = 0x44;\nconst LatinCapitalLetterF = 0x46;\nconst LatinCapitalLetterP = 0x50;\nconst LatinCapitalLetterS = 0x53;\nconst LatinCapitalLetterW = 0x57;\nconst LatinCapitalLetterZ = 0x5a;\nconst LowLine = 0x5f;\nconst LatinSmallLetterA = 0x61;\nconst LatinSmallLetterB = 0x62;\nconst LatinSmallLetterC = 0x63;\nconst LatinSmallLetterD = 0x64;\nconst LatinSmallLetterF = 0x66;\nconst LatinSmallLetterG = 0x67;\nconst LatinSmallLetterI = 0x69;\nconst LatinSmallLetterK = 0x6b;\nconst LatinSmallLetterM = 0x6d;\nconst LatinSmallLetterN = 0x6e;\nconst LatinSmallLetterP = 0x70;\nconst LatinSmallLetterR = 0x72;\nconst LatinSmallLetterS = 0x73;\nconst LatinSmallLetterT = 0x74;\nconst LatinSmallLetterU = 0x75;\nconst LatinSmallLetterV = 0x76;\nconst LatinSmallLetterW = 0x77;\nconst LatinSmallLetterX = 0x78;\nconst LatinSmallLetterY = 0x79;\nconst LatinSmallLetterZ = 0x7a;\nconst LeftSquareBracket = 0x5b;\nconst ReverseSolidus = 0x5c;\nconst RightSquareBracket = 0x5d;\nconst CircumflexAccent = 0x5e;\nconst LeftCurlyBracket = 0x7b;\nconst VerticalLine = 0x7c;\nconst RightCurlyBracket = 0x7d;\nconst ZeroWidthNonJoiner = 0x200c;\nconst ZeroWidthJoiner = 0x200d;\nconst LineSeparator = 0x2028;\nconst ParagraphSeparator = 0x2029;\nconst MinCodePoint = 0x00;\nconst MaxCodePoint = 0x10ffff;\nfunction isLatinLetter(code) {\n    return ((code >= LatinCapitalLetterA && code <= LatinCapitalLetterZ) ||\n        (code >= LatinSmallLetterA && code <= LatinSmallLetterZ));\n}\nfunction isDecimalDigit(code) {\n    return code >= DigitZero && code <= DigitNine;\n}\nfunction isOctalDigit(code) {\n    return code >= DigitZero && code <= DigitSeven;\n}\nfunction isHexDigit(code) {\n    return ((code >= DigitZero && code <= DigitNine) ||\n        (code >= LatinCapitalLetterA && code <= LatinCapitalLetterF) ||\n        (code >= LatinSmallLetterA && code <= LatinSmallLetterF));\n}\nfunction isLineTerminator(code) {\n    return (code === LineFeed ||\n        code === CarriageReturn ||\n        code === LineSeparator ||\n        code === ParagraphSeparator);\n}\nfunction isValidUnicode(code) {\n    return code >= MinCodePoint && code <= MaxCodePoint;\n}\nfunction digitToInt(code) {\n    if (code >= LatinSmallLetterA && code <= LatinSmallLetterF) {\n        return code - LatinSmallLetterA + 10;\n    }\n    if (code >= LatinCapitalLetterA && code <= LatinCapitalLetterF) {\n        return code - LatinCapitalLetterA + 10;\n    }\n    return code - DigitZero;\n}\nfunction isLeadSurrogate(code) {\n    return code >= 0xd800 && code <= 0xdbff;\n}\nfunction isTrailSurrogate(code) {\n    return code >= 0xdc00 && code <= 0xdfff;\n}\nfunction combineSurrogatePair(lead, trail) {\n    return (lead - 0xd800) * 0x400 + (trail - 0xdc00) + 0x10000;\n}\n\nconst legacyImpl = {\n    at(s, end, i) {\n        return i < end ? s.charCodeAt(i) : -1;\n    },\n    width(c) {\n        return 1;\n    },\n};\nconst unicodeImpl = {\n    at(s, end, i) {\n        return i < end ? s.codePointAt(i) : -1;\n    },\n    width(c) {\n        return c > 0xffff ? 2 : 1;\n    },\n};\nclass Reader {\n    constructor() {\n        this._impl = legacyImpl;\n        this._s = \"\";\n        this._i = 0;\n        this._end = 0;\n        this._cp1 = -1;\n        this._w1 = 1;\n        this._cp2 = -1;\n        this._w2 = 1;\n        this._cp3 = -1;\n        this._w3 = 1;\n        this._cp4 = -1;\n    }\n    get source() {\n        return this._s;\n    }\n    get index() {\n        return this._i;\n    }\n    get currentCodePoint() {\n        return this._cp1;\n    }\n    get nextCodePoint() {\n        return this._cp2;\n    }\n    get nextCodePoint2() {\n        return this._cp3;\n    }\n    get nextCodePoint3() {\n        return this._cp4;\n    }\n    reset(source, start, end, uFlag) {\n        this._impl = uFlag ? unicodeImpl : legacyImpl;\n        this._s = source;\n        this._end = end;\n        this.rewind(start);\n    }\n    rewind(index) {\n        const impl = this._impl;\n        this._i = index;\n        this._cp1 = impl.at(this._s, this._end, index);\n        this._w1 = impl.width(this._cp1);\n        this._cp2 = impl.at(this._s, this._end, index + this._w1);\n        this._w2 = impl.width(this._cp2);\n        this._cp3 = impl.at(this._s, this._end, index + this._w1 + this._w2);\n        this._w3 = impl.width(this._cp3);\n        this._cp4 = impl.at(this._s, this._end, index + this._w1 + this._w2 + this._w3);\n    }\n    advance() {\n        if (this._cp1 !== -1) {\n            const impl = this._impl;\n            this._i += this._w1;\n            this._cp1 = this._cp2;\n            this._w1 = this._w2;\n            this._cp2 = this._cp3;\n            this._w2 = impl.width(this._cp2);\n            this._cp3 = this._cp4;\n            this._w3 = impl.width(this._cp3);\n            this._cp4 = impl.at(this._s, this._end, this._i + this._w1 + this._w2 + this._w3);\n        }\n    }\n    eat(cp) {\n        if (this._cp1 === cp) {\n            this.advance();\n            return true;\n        }\n        return false;\n    }\n    eat2(cp1, cp2) {\n        if (this._cp1 === cp1 && this._cp2 === cp2) {\n            this.advance();\n            this.advance();\n            return true;\n        }\n        return false;\n    }\n    eat3(cp1, cp2, cp3) {\n        if (this._cp1 === cp1 && this._cp2 === cp2 && this._cp3 === cp3) {\n            this.advance();\n            this.advance();\n            this.advance();\n            return true;\n        }\n        return false;\n    }\n}\n\nclass RegExpSyntaxError extends SyntaxError {\n    constructor(source, uFlag, index, message) {\n        if (source) {\n            if (!source.startsWith(\"/\")) {\n                source = `/${source}/${uFlag ? \"u\" : \"\"}`;\n            }\n            source = `: ${source}`;\n        }\n        super(`Invalid regular expression${source}: ${message}`);\n        this.index = index;\n    }\n}\n\nfunction isSyntaxCharacter(cp) {\n    return (cp === CircumflexAccent ||\n        cp === DollarSign ||\n        cp === ReverseSolidus ||\n        cp === FullStop ||\n        cp === Asterisk ||\n        cp === PlusSign ||\n        cp === QuestionMark ||\n        cp === LeftParenthesis ||\n        cp === RightParenthesis ||\n        cp === LeftSquareBracket ||\n        cp === RightSquareBracket ||\n        cp === LeftCurlyBracket ||\n        cp === RightCurlyBracket ||\n        cp === VerticalLine);\n}\nfunction isRegExpIdentifierStart(cp) {\n    return isIdStart(cp) || cp === DollarSign || cp === LowLine;\n}\nfunction isRegExpIdentifierPart(cp) {\n    return (isIdContinue(cp) ||\n        cp === DollarSign ||\n        cp === LowLine ||\n        cp === ZeroWidthNonJoiner ||\n        cp === ZeroWidthJoiner);\n}\nfunction isUnicodePropertyNameCharacter(cp) {\n    return isLatinLetter(cp) || cp === LowLine;\n}\nfunction isUnicodePropertyValueCharacter(cp) {\n    return isUnicodePropertyNameCharacter(cp) || isDecimalDigit(cp);\n}\nclass RegExpValidator {\n    constructor(options) {\n        this._reader = new Reader();\n        this._uFlag = false;\n        this._nFlag = false;\n        this._lastIntValue = 0;\n        this._lastMinValue = 0;\n        this._lastMaxValue = 0;\n        this._lastStrValue = \"\";\n        this._lastKeyValue = \"\";\n        this._lastValValue = \"\";\n        this._lastAssertionIsQuantifiable = false;\n        this._numCapturingParens = 0;\n        this._groupNames = new Set();\n        this._backreferenceNames = new Set();\n        this._options = options || {};\n    }\n    validateLiteral(source, start = 0, end = source.length) {\n        this._uFlag = this._nFlag = false;\n        this.reset(source, start, end);\n        this.onLiteralEnter(start);\n        if (this.eat(Solidus) && this.eatRegExpBody() && this.eat(Solidus)) {\n            const flagStart = this.index;\n            const uFlag = source.includes(\"u\", flagStart);\n            this.validateFlags(source, flagStart, end);\n            this.validatePattern(source, start + 1, flagStart - 1, uFlag);\n        }\n        else if (start >= end) {\n            this.raise(\"Empty\");\n        }\n        else {\n            const c = String.fromCodePoint(this.currentCodePoint);\n            this.raise(`Unexpected character '${c}'`);\n        }\n        this.onLiteralLeave(start, end);\n    }\n    validateFlags(source, start = 0, end = source.length) {\n        const existingFlags = new Set();\n        let global = false;\n        let ignoreCase = false;\n        let multiline = false;\n        let sticky = false;\n        let unicode = false;\n        let dotAll = false;\n        let hasIndices = false;\n        for (let i = start; i < end; ++i) {\n            const flag = source.charCodeAt(i);\n            if (existingFlags.has(flag)) {\n                this.raise(`Duplicated flag '${source[i]}'`);\n            }\n            existingFlags.add(flag);\n            if (flag === LatinSmallLetterG) {\n                global = true;\n            }\n            else if (flag === LatinSmallLetterI) {\n                ignoreCase = true;\n            }\n            else if (flag === LatinSmallLetterM) {\n                multiline = true;\n            }\n            else if (flag === LatinSmallLetterU && this.ecmaVersion >= 2015) {\n                unicode = true;\n            }\n            else if (flag === LatinSmallLetterY && this.ecmaVersion >= 2015) {\n                sticky = true;\n            }\n            else if (flag === LatinSmallLetterS && this.ecmaVersion >= 2018) {\n                dotAll = true;\n            }\n            else if (flag === LatinSmallLetterD && this.ecmaVersion >= 2022) {\n                hasIndices = true;\n            }\n            else {\n                this.raise(`Invalid flag '${source[i]}'`);\n            }\n        }\n        this.onFlags(start, end, global, ignoreCase, multiline, unicode, sticky, dotAll, hasIndices);\n    }\n    validatePattern(source, start = 0, end = source.length, uFlag = false) {\n        this._uFlag = uFlag && this.ecmaVersion >= 2015;\n        this._nFlag = uFlag && this.ecmaVersion >= 2018;\n        this.reset(source, start, end);\n        this.consumePattern();\n        if (!this._nFlag &&\n            this.ecmaVersion >= 2018 &&\n            this._groupNames.size > 0) {\n            this._nFlag = true;\n            this.rewind(start);\n            this.consumePattern();\n        }\n    }\n    get strict() {\n        return Boolean(this._options.strict || this._uFlag);\n    }\n    get ecmaVersion() {\n        return this._options.ecmaVersion || 2022;\n    }\n    onLiteralEnter(start) {\n        if (this._options.onLiteralEnter) {\n            this._options.onLiteralEnter(start);\n        }\n    }\n    onLiteralLeave(start, end) {\n        if (this._options.onLiteralLeave) {\n            this._options.onLiteralLeave(start, end);\n        }\n    }\n    onFlags(start, end, global, ignoreCase, multiline, unicode, sticky, dotAll, hasIndices) {\n        if (this._options.onFlags) {\n            this._options.onFlags(start, end, global, ignoreCase, multiline, unicode, sticky, dotAll, hasIndices);\n        }\n    }\n    onPatternEnter(start) {\n        if (this._options.onPatternEnter) {\n            this._options.onPatternEnter(start);\n        }\n    }\n    onPatternLeave(start, end) {\n        if (this._options.onPatternLeave) {\n            this._options.onPatternLeave(start, end);\n        }\n    }\n    onDisjunctionEnter(start) {\n        if (this._options.onDisjunctionEnter) {\n            this._options.onDisjunctionEnter(start);\n        }\n    }\n    onDisjunctionLeave(start, end) {\n        if (this._options.onDisjunctionLeave) {\n            this._options.onDisjunctionLeave(start, end);\n        }\n    }\n    onAlternativeEnter(start, index) {\n        if (this._options.onAlternativeEnter) {\n            this._options.onAlternativeEnter(start, index);\n        }\n    }\n    onAlternativeLeave(start, end, index) {\n        if (this._options.onAlternativeLeave) {\n            this._options.onAlternativeLeave(start, end, index);\n        }\n    }\n    onGroupEnter(start) {\n        if (this._options.onGroupEnter) {\n            this._options.onGroupEnter(start);\n        }\n    }\n    onGroupLeave(start, end) {\n        if (this._options.onGroupLeave) {\n            this._options.onGroupLeave(start, end);\n        }\n    }\n    onCapturingGroupEnter(start, name) {\n        if (this._options.onCapturingGroupEnter) {\n            this._options.onCapturingGroupEnter(start, name);\n        }\n    }\n    onCapturingGroupLeave(start, end, name) {\n        if (this._options.onCapturingGroupLeave) {\n            this._options.onCapturingGroupLeave(start, end, name);\n        }\n    }\n    onQuantifier(start, end, min, max, greedy) {\n        if (this._options.onQuantifier) {\n            this._options.onQuantifier(start, end, min, max, greedy);\n        }\n    }\n    onLookaroundAssertionEnter(start, kind, negate) {\n        if (this._options.onLookaroundAssertionEnter) {\n            this._options.onLookaroundAssertionEnter(start, kind, negate);\n        }\n    }\n    onLookaroundAssertionLeave(start, end, kind, negate) {\n        if (this._options.onLookaroundAssertionLeave) {\n            this._options.onLookaroundAssertionLeave(start, end, kind, negate);\n        }\n    }\n    onEdgeAssertion(start, end, kind) {\n        if (this._options.onEdgeAssertion) {\n            this._options.onEdgeAssertion(start, end, kind);\n        }\n    }\n    onWordBoundaryAssertion(start, end, kind, negate) {\n        if (this._options.onWordBoundaryAssertion) {\n            this._options.onWordBoundaryAssertion(start, end, kind, negate);\n        }\n    }\n    onAnyCharacterSet(start, end, kind) {\n        if (this._options.onAnyCharacterSet) {\n            this._options.onAnyCharacterSet(start, end, kind);\n        }\n    }\n    onEscapeCharacterSet(start, end, kind, negate) {\n        if (this._options.onEscapeCharacterSet) {\n            this._options.onEscapeCharacterSet(start, end, kind, negate);\n        }\n    }\n    onUnicodePropertyCharacterSet(start, end, kind, key, value, negate) {\n        if (this._options.onUnicodePropertyCharacterSet) {\n            this._options.onUnicodePropertyCharacterSet(start, end, kind, key, value, negate);\n        }\n    }\n    onCharacter(start, end, value) {\n        if (this._options.onCharacter) {\n            this._options.onCharacter(start, end, value);\n        }\n    }\n    onBackreference(start, end, ref) {\n        if (this._options.onBackreference) {\n            this._options.onBackreference(start, end, ref);\n        }\n    }\n    onCharacterClassEnter(start, negate) {\n        if (this._options.onCharacterClassEnter) {\n            this._options.onCharacterClassEnter(start, negate);\n        }\n    }\n    onCharacterClassLeave(start, end, negate) {\n        if (this._options.onCharacterClassLeave) {\n            this._options.onCharacterClassLeave(start, end, negate);\n        }\n    }\n    onCharacterClassRange(start, end, min, max) {\n        if (this._options.onCharacterClassRange) {\n            this._options.onCharacterClassRange(start, end, min, max);\n        }\n    }\n    get source() {\n        return this._reader.source;\n    }\n    get index() {\n        return this._reader.index;\n    }\n    get currentCodePoint() {\n        return this._reader.currentCodePoint;\n    }\n    get nextCodePoint() {\n        return this._reader.nextCodePoint;\n    }\n    get nextCodePoint2() {\n        return this._reader.nextCodePoint2;\n    }\n    get nextCodePoint3() {\n        return this._reader.nextCodePoint3;\n    }\n    reset(source, start, end) {\n        this._reader.reset(source, start, end, this._uFlag);\n    }\n    rewind(index) {\n        this._reader.rewind(index);\n    }\n    advance() {\n        this._reader.advance();\n    }\n    eat(cp) {\n        return this._reader.eat(cp);\n    }\n    eat2(cp1, cp2) {\n        return this._reader.eat2(cp1, cp2);\n    }\n    eat3(cp1, cp2, cp3) {\n        return this._reader.eat3(cp1, cp2, cp3);\n    }\n    raise(message) {\n        throw new RegExpSyntaxError(this.source, this._uFlag, this.index, message);\n    }\n    eatRegExpBody() {\n        const start = this.index;\n        let inClass = false;\n        let escaped = false;\n        for (;;) {\n            const cp = this.currentCodePoint;\n            if (cp === -1 || isLineTerminator(cp)) {\n                const kind = inClass ? \"character class\" : \"regular expression\";\n                this.raise(`Unterminated ${kind}`);\n            }\n            if (escaped) {\n                escaped = false;\n            }\n            else if (cp === ReverseSolidus) {\n                escaped = true;\n            }\n            else if (cp === LeftSquareBracket) {\n                inClass = true;\n            }\n            else if (cp === RightSquareBracket) {\n                inClass = false;\n            }\n            else if ((cp === Solidus && !inClass) ||\n                (cp === Asterisk && this.index === start)) {\n                break;\n            }\n            this.advance();\n        }\n        return this.index !== start;\n    }\n    consumePattern() {\n        const start = this.index;\n        this._numCapturingParens = this.countCapturingParens();\n        this._groupNames.clear();\n        this._backreferenceNames.clear();\n        this.onPatternEnter(start);\n        this.consumeDisjunction();\n        const cp = this.currentCodePoint;\n        if (this.currentCodePoint !== -1) {\n            if (cp === RightParenthesis) {\n                this.raise(\"Unmatched ')'\");\n            }\n            if (cp === ReverseSolidus) {\n                this.raise(\"\\\\ at end of pattern\");\n            }\n            if (cp === RightSquareBracket || cp === RightCurlyBracket) {\n                this.raise(\"Lone quantifier brackets\");\n            }\n            const c = String.fromCodePoint(cp);\n            this.raise(`Unexpected character '${c}'`);\n        }\n        for (const name of this._backreferenceNames) {\n            if (!this._groupNames.has(name)) {\n                this.raise(\"Invalid named capture referenced\");\n            }\n        }\n        this.onPatternLeave(start, this.index);\n    }\n    countCapturingParens() {\n        const start = this.index;\n        let inClass = false;\n        let escaped = false;\n        let count = 0;\n        let cp = 0;\n        while ((cp = this.currentCodePoint) !== -1) {\n            if (escaped) {\n                escaped = false;\n            }\n            else if (cp === ReverseSolidus) {\n                escaped = true;\n            }\n            else if (cp === LeftSquareBracket) {\n                inClass = true;\n            }\n            else if (cp === RightSquareBracket) {\n                inClass = false;\n            }\n            else if (cp === LeftParenthesis &&\n                !inClass &&\n                (this.nextCodePoint !== QuestionMark ||\n                    (this.nextCodePoint2 === LessThanSign &&\n                        this.nextCodePoint3 !== EqualsSign &&\n                        this.nextCodePoint3 !== ExclamationMark))) {\n                count += 1;\n            }\n            this.advance();\n        }\n        this.rewind(start);\n        return count;\n    }\n    consumeDisjunction() {\n        const start = this.index;\n        let i = 0;\n        this.onDisjunctionEnter(start);\n        do {\n            this.consumeAlternative(i++);\n        } while (this.eat(VerticalLine));\n        if (this.consumeQuantifier(true)) {\n            this.raise(\"Nothing to repeat\");\n        }\n        if (this.eat(LeftCurlyBracket)) {\n            this.raise(\"Lone quantifier brackets\");\n        }\n        this.onDisjunctionLeave(start, this.index);\n    }\n    consumeAlternative(i) {\n        const start = this.index;\n        this.onAlternativeEnter(start, i);\n        while (this.currentCodePoint !== -1 && this.consumeTerm()) {\n        }\n        this.onAlternativeLeave(start, this.index, i);\n    }\n    consumeTerm() {\n        if (this._uFlag || this.strict) {\n            return (this.consumeAssertion() ||\n                (this.consumeAtom() && this.consumeOptionalQuantifier()));\n        }\n        return ((this.consumeAssertion() &&\n            (!this._lastAssertionIsQuantifiable ||\n                this.consumeOptionalQuantifier())) ||\n            (this.consumeExtendedAtom() && this.consumeOptionalQuantifier()));\n    }\n    consumeOptionalQuantifier() {\n        this.consumeQuantifier();\n        return true;\n    }\n    consumeAssertion() {\n        const start = this.index;\n        this._lastAssertionIsQuantifiable = false;\n        if (this.eat(CircumflexAccent)) {\n            this.onEdgeAssertion(start, this.index, \"start\");\n            return true;\n        }\n        if (this.eat(DollarSign)) {\n            this.onEdgeAssertion(start, this.index, \"end\");\n            return true;\n        }\n        if (this.eat2(ReverseSolidus, LatinCapitalLetterB)) {\n            this.onWordBoundaryAssertion(start, this.index, \"word\", true);\n            return true;\n        }\n        if (this.eat2(ReverseSolidus, LatinSmallLetterB)) {\n            this.onWordBoundaryAssertion(start, this.index, \"word\", false);\n            return true;\n        }\n        if (this.eat2(LeftParenthesis, QuestionMark)) {\n            const lookbehind = this.ecmaVersion >= 2018 && this.eat(LessThanSign);\n            let negate = false;\n            if (this.eat(EqualsSign) || (negate = this.eat(ExclamationMark))) {\n                const kind = lookbehind ? \"lookbehind\" : \"lookahead\";\n                this.onLookaroundAssertionEnter(start, kind, negate);\n                this.consumeDisjunction();\n                if (!this.eat(RightParenthesis)) {\n                    this.raise(\"Unterminated group\");\n                }\n                this._lastAssertionIsQuantifiable = !lookbehind && !this.strict;\n                this.onLookaroundAssertionLeave(start, this.index, kind, negate);\n                return true;\n            }\n            this.rewind(start);\n        }\n        return false;\n    }\n    consumeQuantifier(noConsume = false) {\n        const start = this.index;\n        let min = 0;\n        let max = 0;\n        let greedy = false;\n        if (this.eat(Asterisk)) {\n            min = 0;\n            max = Number.POSITIVE_INFINITY;\n        }\n        else if (this.eat(PlusSign)) {\n            min = 1;\n            max = Number.POSITIVE_INFINITY;\n        }\n        else if (this.eat(QuestionMark)) {\n            min = 0;\n            max = 1;\n        }\n        else if (this.eatBracedQuantifier(noConsume)) {\n            min = this._lastMinValue;\n            max = this._lastMaxValue;\n        }\n        else {\n            return false;\n        }\n        greedy = !this.eat(QuestionMark);\n        if (!noConsume) {\n            this.onQuantifier(start, this.index, min, max, greedy);\n        }\n        return true;\n    }\n    eatBracedQuantifier(noError) {\n        const start = this.index;\n        if (this.eat(LeftCurlyBracket)) {\n            this._lastMinValue = 0;\n            this._lastMaxValue = Number.POSITIVE_INFINITY;\n            if (this.eatDecimalDigits()) {\n                this._lastMinValue = this._lastMaxValue = this._lastIntValue;\n                if (this.eat(Comma)) {\n                    this._lastMaxValue = this.eatDecimalDigits()\n                        ? this._lastIntValue\n                        : Number.POSITIVE_INFINITY;\n                }\n                if (this.eat(RightCurlyBracket)) {\n                    if (!noError && this._lastMaxValue < this._lastMinValue) {\n                        this.raise(\"numbers out of order in {} quantifier\");\n                    }\n                    return true;\n                }\n            }\n            if (!noError && (this._uFlag || this.strict)) {\n                this.raise(\"Incomplete quantifier\");\n            }\n            this.rewind(start);\n        }\n        return false;\n    }\n    consumeAtom() {\n        return (this.consumePatternCharacter() ||\n            this.consumeDot() ||\n            this.consumeReverseSolidusAtomEscape() ||\n            this.consumeCharacterClass() ||\n            this.consumeUncapturingGroup() ||\n            this.consumeCapturingGroup());\n    }\n    consumeDot() {\n        if (this.eat(FullStop)) {\n            this.onAnyCharacterSet(this.index - 1, this.index, \"any\");\n            return true;\n        }\n        return false;\n    }\n    consumeReverseSolidusAtomEscape() {\n        const start = this.index;\n        if (this.eat(ReverseSolidus)) {\n            if (this.consumeAtomEscape()) {\n                return true;\n            }\n            this.rewind(start);\n        }\n        return false;\n    }\n    consumeUncapturingGroup() {\n        const start = this.index;\n        if (this.eat3(LeftParenthesis, QuestionMark, Colon)) {\n            this.onGroupEnter(start);\n            this.consumeDisjunction();\n            if (!this.eat(RightParenthesis)) {\n                this.raise(\"Unterminated group\");\n            }\n            this.onGroupLeave(start, this.index);\n            return true;\n        }\n        return false;\n    }\n    consumeCapturingGroup() {\n        const start = this.index;\n        if (this.eat(LeftParenthesis)) {\n            let name = null;\n            if (this.ecmaVersion >= 2018) {\n                if (this.consumeGroupSpecifier()) {\n                    name = this._lastStrValue;\n                }\n            }\n            else if (this.currentCodePoint === QuestionMark) {\n                this.raise(\"Invalid group\");\n            }\n            this.onCapturingGroupEnter(start, name);\n            this.consumeDisjunction();\n            if (!this.eat(RightParenthesis)) {\n                this.raise(\"Unterminated group\");\n            }\n            this.onCapturingGroupLeave(start, this.index, name);\n            return true;\n        }\n        return false;\n    }\n    consumeExtendedAtom() {\n        return (this.consumeDot() ||\n            this.consumeReverseSolidusAtomEscape() ||\n            this.consumeReverseSolidusFollowedByC() ||\n            this.consumeCharacterClass() ||\n            this.consumeUncapturingGroup() ||\n            this.consumeCapturingGroup() ||\n            this.consumeInvalidBracedQuantifier() ||\n            this.consumeExtendedPatternCharacter());\n    }\n    consumeReverseSolidusFollowedByC() {\n        const start = this.index;\n        if (this.currentCodePoint === ReverseSolidus &&\n            this.nextCodePoint === LatinSmallLetterC) {\n            this._lastIntValue = this.currentCodePoint;\n            this.advance();\n            this.onCharacter(start, this.index, ReverseSolidus);\n            return true;\n        }\n        return false;\n    }\n    consumeInvalidBracedQuantifier() {\n        if (this.eatBracedQuantifier(true)) {\n            this.raise(\"Nothing to repeat\");\n        }\n        return false;\n    }\n    consumePatternCharacter() {\n        const start = this.index;\n        const cp = this.currentCodePoint;\n        if (cp !== -1 && !isSyntaxCharacter(cp)) {\n            this.advance();\n            this.onCharacter(start, this.index, cp);\n            return true;\n        }\n        return false;\n    }\n    consumeExtendedPatternCharacter() {\n        const start = this.index;\n        const cp = this.currentCodePoint;\n        if (cp !== -1 &&\n            cp !== CircumflexAccent &&\n            cp !== DollarSign &&\n            cp !== ReverseSolidus &&\n            cp !== FullStop &&\n            cp !== Asterisk &&\n            cp !== PlusSign &&\n            cp !== QuestionMark &&\n            cp !== LeftParenthesis &&\n            cp !== RightParenthesis &&\n            cp !== LeftSquareBracket &&\n            cp !== VerticalLine) {\n            this.advance();\n            this.onCharacter(start, this.index, cp);\n            return true;\n        }\n        return false;\n    }\n    consumeGroupSpecifier() {\n        if (this.eat(QuestionMark)) {\n            if (this.eatGroupName()) {\n                if (!this._groupNames.has(this._lastStrValue)) {\n                    this._groupNames.add(this._lastStrValue);\n                    return true;\n                }\n                this.raise(\"Duplicate capture group name\");\n            }\n            this.raise(\"Invalid group\");\n        }\n        return false;\n    }\n    consumeAtomEscape() {\n        if (this.consumeBackreference() ||\n            this.consumeCharacterClassEscape() ||\n            this.consumeCharacterEscape() ||\n            (this._nFlag && this.consumeKGroupName())) {\n            return true;\n        }\n        if (this.strict || this._uFlag) {\n            this.raise(\"Invalid escape\");\n        }\n        return false;\n    }\n    consumeBackreference() {\n        const start = this.index;\n        if (this.eatDecimalEscape()) {\n            const n = this._lastIntValue;\n            if (n <= this._numCapturingParens) {\n                this.onBackreference(start - 1, this.index, n);\n                return true;\n            }\n            if (this.strict || this._uFlag) {\n                this.raise(\"Invalid escape\");\n            }\n            this.rewind(start);\n        }\n        return false;\n    }\n    consumeCharacterClassEscape() {\n        const start = this.index;\n        if (this.eat(LatinSmallLetterD)) {\n            this._lastIntValue = -1;\n            this.onEscapeCharacterSet(start - 1, this.index, \"digit\", false);\n            return true;\n        }\n        if (this.eat(LatinCapitalLetterD)) {\n            this._lastIntValue = -1;\n            this.onEscapeCharacterSet(start - 1, this.index, \"digit\", true);\n            return true;\n        }\n        if (this.eat(LatinSmallLetterS)) {\n            this._lastIntValue = -1;\n            this.onEscapeCharacterSet(start - 1, this.index, \"space\", false);\n            return true;\n        }\n        if (this.eat(LatinCapitalLetterS)) {\n            this._lastIntValue = -1;\n            this.onEscapeCharacterSet(start - 1, this.index, \"space\", true);\n            return true;\n        }\n        if (this.eat(LatinSmallLetterW)) {\n            this._lastIntValue = -1;\n            this.onEscapeCharacterSet(start - 1, this.index, \"word\", false);\n            return true;\n        }\n        if (this.eat(LatinCapitalLetterW)) {\n            this._lastIntValue = -1;\n            this.onEscapeCharacterSet(start - 1, this.index, \"word\", true);\n            return true;\n        }\n        let negate = false;\n        if (this._uFlag &&\n            this.ecmaVersion >= 2018 &&\n            (this.eat(LatinSmallLetterP) ||\n                (negate = this.eat(LatinCapitalLetterP)))) {\n            this._lastIntValue = -1;\n            if (this.eat(LeftCurlyBracket) &&\n                this.eatUnicodePropertyValueExpression() &&\n                this.eat(RightCurlyBracket)) {\n                this.onUnicodePropertyCharacterSet(start - 1, this.index, \"property\", this._lastKeyValue, this._lastValValue || null, negate);\n                return true;\n            }\n            this.raise(\"Invalid property name\");\n        }\n        return false;\n    }\n    consumeCharacterEscape() {\n        const start = this.index;\n        if (this.eatControlEscape() ||\n            this.eatCControlLetter() ||\n            this.eatZero() ||\n            this.eatHexEscapeSequence() ||\n            this.eatRegExpUnicodeEscapeSequence() ||\n            (!this.strict &&\n                !this._uFlag &&\n                this.eatLegacyOctalEscapeSequence()) ||\n            this.eatIdentityEscape()) {\n            this.onCharacter(start - 1, this.index, this._lastIntValue);\n            return true;\n        }\n        return false;\n    }\n    consumeKGroupName() {\n        const start = this.index;\n        if (this.eat(LatinSmallLetterK)) {\n            if (this.eatGroupName()) {\n                const groupName = this._lastStrValue;\n                this._backreferenceNames.add(groupName);\n                this.onBackreference(start - 1, this.index, groupName);\n                return true;\n            }\n            this.raise(\"Invalid named reference\");\n        }\n        return false;\n    }\n    consumeCharacterClass() {\n        const start = this.index;\n        if (this.eat(LeftSquareBracket)) {\n            const negate = this.eat(CircumflexAccent);\n            this.onCharacterClassEnter(start, negate);\n            this.consumeClassRanges();\n            if (!this.eat(RightSquareBracket)) {\n                this.raise(\"Unterminated character class\");\n            }\n            this.onCharacterClassLeave(start, this.index, negate);\n            return true;\n        }\n        return false;\n    }\n    consumeClassRanges() {\n        const strict = this.strict || this._uFlag;\n        for (;;) {\n            const rangeStart = this.index;\n            if (!this.consumeClassAtom()) {\n                break;\n            }\n            const min = this._lastIntValue;\n            if (!this.eat(HyphenMinus)) {\n                continue;\n            }\n            this.onCharacter(this.index - 1, this.index, HyphenMinus);\n            if (!this.consumeClassAtom()) {\n                break;\n            }\n            const max = this._lastIntValue;\n            if (min === -1 || max === -1) {\n                if (strict) {\n                    this.raise(\"Invalid character class\");\n                }\n                continue;\n            }\n            if (min > max) {\n                this.raise(\"Range out of order in character class\");\n            }\n            this.onCharacterClassRange(rangeStart, this.index, min, max);\n        }\n    }\n    consumeClassAtom() {\n        const start = this.index;\n        const cp = this.currentCodePoint;\n        if (cp !== -1 && cp !== ReverseSolidus && cp !== RightSquareBracket) {\n            this.advance();\n            this._lastIntValue = cp;\n            this.onCharacter(start, this.index, this._lastIntValue);\n            return true;\n        }\n        if (this.eat(ReverseSolidus)) {\n            if (this.consumeClassEscape()) {\n                return true;\n            }\n            if (!this.strict && this.currentCodePoint === LatinSmallLetterC) {\n                this._lastIntValue = ReverseSolidus;\n                this.onCharacter(start, this.index, this._lastIntValue);\n                return true;\n            }\n            if (this.strict || this._uFlag) {\n                this.raise(\"Invalid escape\");\n            }\n            this.rewind(start);\n        }\n        return false;\n    }\n    consumeClassEscape() {\n        const start = this.index;\n        if (this.eat(LatinSmallLetterB)) {\n            this._lastIntValue = Backspace;\n            this.onCharacter(start - 1, this.index, this._lastIntValue);\n            return true;\n        }\n        if (this._uFlag && this.eat(HyphenMinus)) {\n            this._lastIntValue = HyphenMinus;\n            this.onCharacter(start - 1, this.index, this._lastIntValue);\n            return true;\n        }\n        let cp = 0;\n        if (!this.strict &&\n            !this._uFlag &&\n            this.currentCodePoint === LatinSmallLetterC &&\n            (isDecimalDigit((cp = this.nextCodePoint)) || cp === LowLine)) {\n            this.advance();\n            this.advance();\n            this._lastIntValue = cp % 0x20;\n            this.onCharacter(start - 1, this.index, this._lastIntValue);\n            return true;\n        }\n        return (this.consumeCharacterClassEscape() || this.consumeCharacterEscape());\n    }\n    eatGroupName() {\n        if (this.eat(LessThanSign)) {\n            if (this.eatRegExpIdentifierName() && this.eat(GreaterThanSign)) {\n                return true;\n            }\n            this.raise(\"Invalid capture group name\");\n        }\n        return false;\n    }\n    eatRegExpIdentifierName() {\n        if (this.eatRegExpIdentifierStart()) {\n            this._lastStrValue = String.fromCodePoint(this._lastIntValue);\n            while (this.eatRegExpIdentifierPart()) {\n                this._lastStrValue += String.fromCodePoint(this._lastIntValue);\n            }\n            return true;\n        }\n        return false;\n    }\n    eatRegExpIdentifierStart() {\n        const start = this.index;\n        const forceUFlag = !this._uFlag && this.ecmaVersion >= 2020;\n        let cp = this.currentCodePoint;\n        this.advance();\n        if (cp === ReverseSolidus &&\n            this.eatRegExpUnicodeEscapeSequence(forceUFlag)) {\n            cp = this._lastIntValue;\n        }\n        else if (forceUFlag &&\n            isLeadSurrogate(cp) &&\n            isTrailSurrogate(this.currentCodePoint)) {\n            cp = combineSurrogatePair(cp, this.currentCodePoint);\n            this.advance();\n        }\n        if (isRegExpIdentifierStart(cp)) {\n            this._lastIntValue = cp;\n            return true;\n        }\n        if (this.index !== start) {\n            this.rewind(start);\n        }\n        return false;\n    }\n    eatRegExpIdentifierPart() {\n        const start = this.index;\n        const forceUFlag = !this._uFlag && this.ecmaVersion >= 2020;\n        let cp = this.currentCodePoint;\n        this.advance();\n        if (cp === ReverseSolidus &&\n            this.eatRegExpUnicodeEscapeSequence(forceUFlag)) {\n            cp = this._lastIntValue;\n        }\n        else if (forceUFlag &&\n            isLeadSurrogate(cp) &&\n            isTrailSurrogate(this.currentCodePoint)) {\n            cp = combineSurrogatePair(cp, this.currentCodePoint);\n            this.advance();\n        }\n        if (isRegExpIdentifierPart(cp)) {\n            this._lastIntValue = cp;\n            return true;\n        }\n        if (this.index !== start) {\n            this.rewind(start);\n        }\n        return false;\n    }\n    eatCControlLetter() {\n        const start = this.index;\n        if (this.eat(LatinSmallLetterC)) {\n            if (this.eatControlLetter()) {\n                return true;\n            }\n            this.rewind(start);\n        }\n        return false;\n    }\n    eatZero() {\n        if (this.currentCodePoint === DigitZero &&\n            !isDecimalDigit(this.nextCodePoint)) {\n            this._lastIntValue = 0;\n            this.advance();\n            return true;\n        }\n        return false;\n    }\n    eatControlEscape() {\n        if (this.eat(LatinSmallLetterF)) {\n            this._lastIntValue = FormFeed;\n            return true;\n        }\n        if (this.eat(LatinSmallLetterN)) {\n            this._lastIntValue = LineFeed;\n            return true;\n        }\n        if (this.eat(LatinSmallLetterR)) {\n            this._lastIntValue = CarriageReturn;\n            return true;\n        }\n        if (this.eat(LatinSmallLetterT)) {\n            this._lastIntValue = CharacterTabulation;\n            return true;\n        }\n        if (this.eat(LatinSmallLetterV)) {\n            this._lastIntValue = LineTabulation;\n            return true;\n        }\n        return false;\n    }\n    eatControlLetter() {\n        const cp = this.currentCodePoint;\n        if (isLatinLetter(cp)) {\n            this.advance();\n            this._lastIntValue = cp % 0x20;\n            return true;\n        }\n        return false;\n    }\n    eatRegExpUnicodeEscapeSequence(forceUFlag = false) {\n        const start = this.index;\n        const uFlag = forceUFlag || this._uFlag;\n        if (this.eat(LatinSmallLetterU)) {\n            if ((uFlag && this.eatRegExpUnicodeSurrogatePairEscape()) ||\n                this.eatFixedHexDigits(4) ||\n                (uFlag && this.eatRegExpUnicodeCodePointEscape())) {\n                return true;\n            }\n            if (this.strict || uFlag) {\n                this.raise(\"Invalid unicode escape\");\n            }\n            this.rewind(start);\n        }\n        return false;\n    }\n    eatRegExpUnicodeSurrogatePairEscape() {\n        const start = this.index;\n        if (this.eatFixedHexDigits(4)) {\n            const lead = this._lastIntValue;\n            if (isLeadSurrogate(lead) &&\n                this.eat(ReverseSolidus) &&\n                this.eat(LatinSmallLetterU) &&\n                this.eatFixedHexDigits(4)) {\n                const trail = this._lastIntValue;\n                if (isTrailSurrogate(trail)) {\n                    this._lastIntValue = combineSurrogatePair(lead, trail);\n                    return true;\n                }\n            }\n            this.rewind(start);\n        }\n        return false;\n    }\n    eatRegExpUnicodeCodePointEscape() {\n        const start = this.index;\n        if (this.eat(LeftCurlyBracket) &&\n            this.eatHexDigits() &&\n            this.eat(RightCurlyBracket) &&\n            isValidUnicode(this._lastIntValue)) {\n            return true;\n        }\n        this.rewind(start);\n        return false;\n    }\n    eatIdentityEscape() {\n        const cp = this.currentCodePoint;\n        if (this.isValidIdentityEscape(cp)) {\n            this._lastIntValue = cp;\n            this.advance();\n            return true;\n        }\n        return false;\n    }\n    isValidIdentityEscape(cp) {\n        if (cp === -1) {\n            return false;\n        }\n        if (this._uFlag) {\n            return isSyntaxCharacter(cp) || cp === Solidus;\n        }\n        if (this.strict) {\n            return !isIdContinue(cp);\n        }\n        if (this._nFlag) {\n            return !(cp === LatinSmallLetterC || cp === LatinSmallLetterK);\n        }\n        return cp !== LatinSmallLetterC;\n    }\n    eatDecimalEscape() {\n        this._lastIntValue = 0;\n        let cp = this.currentCodePoint;\n        if (cp >= DigitOne && cp <= DigitNine) {\n            do {\n                this._lastIntValue = 10 * this._lastIntValue + (cp - DigitZero);\n                this.advance();\n            } while ((cp = this.currentCodePoint) >= DigitZero &&\n                cp <= DigitNine);\n            return true;\n        }\n        return false;\n    }\n    eatUnicodePropertyValueExpression() {\n        const start = this.index;\n        if (this.eatUnicodePropertyName() && this.eat(EqualsSign)) {\n            this._lastKeyValue = this._lastStrValue;\n            if (this.eatUnicodePropertyValue()) {\n                this._lastValValue = this._lastStrValue;\n                if (isValidUnicodeProperty(this.ecmaVersion, this._lastKeyValue, this._lastValValue)) {\n                    return true;\n                }\n                this.raise(\"Invalid property name\");\n            }\n        }\n        this.rewind(start);\n        if (this.eatLoneUnicodePropertyNameOrValue()) {\n            const nameOrValue = this._lastStrValue;\n            if (isValidUnicodeProperty(this.ecmaVersion, \"General_Category\", nameOrValue)) {\n                this._lastKeyValue = \"General_Category\";\n                this._lastValValue = nameOrValue;\n                return true;\n            }\n            if (isValidLoneUnicodeProperty(this.ecmaVersion, nameOrValue)) {\n                this._lastKeyValue = nameOrValue;\n                this._lastValValue = \"\";\n                return true;\n            }\n            this.raise(\"Invalid property name\");\n        }\n        return false;\n    }\n    eatUnicodePropertyName() {\n        this._lastStrValue = \"\";\n        while (isUnicodePropertyNameCharacter(this.currentCodePoint)) {\n            this._lastStrValue += String.fromCodePoint(this.currentCodePoint);\n            this.advance();\n        }\n        return this._lastStrValue !== \"\";\n    }\n    eatUnicodePropertyValue() {\n        this._lastStrValue = \"\";\n        while (isUnicodePropertyValueCharacter(this.currentCodePoint)) {\n            this._lastStrValue += String.fromCodePoint(this.currentCodePoint);\n            this.advance();\n        }\n        return this._lastStrValue !== \"\";\n    }\n    eatLoneUnicodePropertyNameOrValue() {\n        return this.eatUnicodePropertyValue();\n    }\n    eatHexEscapeSequence() {\n        const start = this.index;\n        if (this.eat(LatinSmallLetterX)) {\n            if (this.eatFixedHexDigits(2)) {\n                return true;\n            }\n            if (this._uFlag || this.strict) {\n                this.raise(\"Invalid escape\");\n            }\n            this.rewind(start);\n        }\n        return false;\n    }\n    eatDecimalDigits() {\n        const start = this.index;\n        this._lastIntValue = 0;\n        while (isDecimalDigit(this.currentCodePoint)) {\n            this._lastIntValue =\n                10 * this._lastIntValue + digitToInt(this.currentCodePoint);\n            this.advance();\n        }\n        return this.index !== start;\n    }\n    eatHexDigits() {\n        const start = this.index;\n        this._lastIntValue = 0;\n        while (isHexDigit(this.currentCodePoint)) {\n            this._lastIntValue =\n                16 * this._lastIntValue + digitToInt(this.currentCodePoint);\n            this.advance();\n        }\n        return this.index !== start;\n    }\n    eatLegacyOctalEscapeSequence() {\n        if (this.eatOctalDigit()) {\n            const n1 = this._lastIntValue;\n            if (this.eatOctalDigit()) {\n                const n2 = this._lastIntValue;\n                if (n1 <= 3 && this.eatOctalDigit()) {\n                    this._lastIntValue = n1 * 64 + n2 * 8 + this._lastIntValue;\n                }\n                else {\n                    this._lastIntValue = n1 * 8 + n2;\n                }\n            }\n            else {\n                this._lastIntValue = n1;\n            }\n            return true;\n        }\n        return false;\n    }\n    eatOctalDigit() {\n        const cp = this.currentCodePoint;\n        if (isOctalDigit(cp)) {\n            this.advance();\n            this._lastIntValue = cp - DigitZero;\n            return true;\n        }\n        this._lastIntValue = 0;\n        return false;\n    }\n    eatFixedHexDigits(length) {\n        const start = this.index;\n        this._lastIntValue = 0;\n        for (let i = 0; i < length; ++i) {\n            const cp = this.currentCodePoint;\n            if (!isHexDigit(cp)) {\n                this.rewind(start);\n                return false;\n            }\n            this._lastIntValue = 16 * this._lastIntValue + digitToInt(cp);\n            this.advance();\n        }\n        return true;\n    }\n}\n\nconst DummyPattern = {};\nconst DummyFlags = {};\nconst DummyCapturingGroup = {};\nclass RegExpParserState {\n    constructor(options) {\n        this._node = DummyPattern;\n        this._flags = DummyFlags;\n        this._backreferences = [];\n        this._capturingGroups = [];\n        this.source = \"\";\n        this.strict = Boolean(options && options.strict);\n        this.ecmaVersion = (options && options.ecmaVersion) || 2022;\n    }\n    get pattern() {\n        if (this._node.type !== \"Pattern\") {\n            throw new Error(\"UnknownError\");\n        }\n        return this._node;\n    }\n    get flags() {\n        if (this._flags.type !== \"Flags\") {\n            throw new Error(\"UnknownError\");\n        }\n        return this._flags;\n    }\n    onFlags(start, end, global, ignoreCase, multiline, unicode, sticky, dotAll, hasIndices) {\n        this._flags = {\n            type: \"Flags\",\n            parent: null,\n            start,\n            end,\n            raw: this.source.slice(start, end),\n            global,\n            ignoreCase,\n            multiline,\n            unicode,\n            sticky,\n            dotAll,\n            hasIndices,\n        };\n    }\n    onPatternEnter(start) {\n        this._node = {\n            type: \"Pattern\",\n            parent: null,\n            start,\n            end: start,\n            raw: \"\",\n            alternatives: [],\n        };\n        this._backreferences.length = 0;\n        this._capturingGroups.length = 0;\n    }\n    onPatternLeave(start, end) {\n        this._node.end = end;\n        this._node.raw = this.source.slice(start, end);\n        for (const reference of this._backreferences) {\n            const ref = reference.ref;\n            const group = typeof ref === \"number\"\n                ? this._capturingGroups[ref - 1]\n                : this._capturingGroups.find(g => g.name === ref);\n            reference.resolved = group;\n            group.references.push(reference);\n        }\n    }\n    onAlternativeEnter(start) {\n        const parent = this._node;\n        if (parent.type !== \"Assertion\" &&\n            parent.type !== \"CapturingGroup\" &&\n            parent.type !== \"Group\" &&\n            parent.type !== \"Pattern\") {\n            throw new Error(\"UnknownError\");\n        }\n        this._node = {\n            type: \"Alternative\",\n            parent,\n            start,\n            end: start,\n            raw: \"\",\n            elements: [],\n        };\n        parent.alternatives.push(this._node);\n    }\n    onAlternativeLeave(start, end) {\n        const node = this._node;\n        if (node.type !== \"Alternative\") {\n            throw new Error(\"UnknownError\");\n        }\n        node.end = end;\n        node.raw = this.source.slice(start, end);\n        this._node = node.parent;\n    }\n    onGroupEnter(start) {\n        const parent = this._node;\n        if (parent.type !== \"Alternative\") {\n            throw new Error(\"UnknownError\");\n        }\n        this._node = {\n            type: \"Group\",\n            parent,\n            start,\n            end: start,\n            raw: \"\",\n            alternatives: [],\n        };\n        parent.elements.push(this._node);\n    }\n    onGroupLeave(start, end) {\n        const node = this._node;\n        if (node.type !== \"Group\" || node.parent.type !== \"Alternative\") {\n            throw new Error(\"UnknownError\");\n        }\n        node.end = end;\n        node.raw = this.source.slice(start, end);\n        this._node = node.parent;\n    }\n    onCapturingGroupEnter(start, name) {\n        const parent = this._node;\n        if (parent.type !== \"Alternative\") {\n            throw new Error(\"UnknownError\");\n        }\n        this._node = {\n            type: \"CapturingGroup\",\n            parent,\n            start,\n            end: start,\n            raw: \"\",\n            name,\n            alternatives: [],\n            references: [],\n        };\n        parent.elements.push(this._node);\n        this._capturingGroups.push(this._node);\n    }\n    onCapturingGroupLeave(start, end) {\n        const node = this._node;\n        if (node.type !== \"CapturingGroup\" ||\n            node.parent.type !== \"Alternative\") {\n            throw new Error(\"UnknownError\");\n        }\n        node.end = end;\n        node.raw = this.source.slice(start, end);\n        this._node = node.parent;\n    }\n    onQuantifier(start, end, min, max, greedy) {\n        const parent = this._node;\n        if (parent.type !== \"Alternative\") {\n            throw new Error(\"UnknownError\");\n        }\n        const element = parent.elements.pop();\n        if (element == null ||\n            element.type === \"Quantifier\" ||\n            (element.type === \"Assertion\" && element.kind !== \"lookahead\")) {\n            throw new Error(\"UnknownError\");\n        }\n        const node = {\n            type: \"Quantifier\",\n            parent,\n            start: element.start,\n            end,\n            raw: this.source.slice(element.start, end),\n            min,\n            max,\n            greedy,\n            element,\n        };\n        parent.elements.push(node);\n        element.parent = node;\n    }\n    onLookaroundAssertionEnter(start, kind, negate) {\n        const parent = this._node;\n        if (parent.type !== \"Alternative\") {\n            throw new Error(\"UnknownError\");\n        }\n        const node = (this._node = {\n            type: \"Assertion\",\n            parent,\n            start,\n            end: start,\n            raw: \"\",\n            kind,\n            negate,\n            alternatives: [],\n        });\n        parent.elements.push(node);\n    }\n    onLookaroundAssertionLeave(start, end) {\n        const node = this._node;\n        if (node.type !== \"Assertion\" || node.parent.type !== \"Alternative\") {\n            throw new Error(\"UnknownError\");\n        }\n        node.end = end;\n        node.raw = this.source.slice(start, end);\n        this._node = node.parent;\n    }\n    onEdgeAssertion(start, end, kind) {\n        const parent = this._node;\n        if (parent.type !== \"Alternative\") {\n            throw new Error(\"UnknownError\");\n        }\n        parent.elements.push({\n            type: \"Assertion\",\n            parent,\n            start,\n            end,\n            raw: this.source.slice(start, end),\n            kind,\n        });\n    }\n    onWordBoundaryAssertion(start, end, kind, negate) {\n        const parent = this._node;\n        if (parent.type !== \"Alternative\") {\n            throw new Error(\"UnknownError\");\n        }\n        parent.elements.push({\n            type: \"Assertion\",\n            parent,\n            start,\n            end,\n            raw: this.source.slice(start, end),\n            kind,\n            negate,\n        });\n    }\n    onAnyCharacterSet(start, end, kind) {\n        const parent = this._node;\n        if (parent.type !== \"Alternative\") {\n            throw new Error(\"UnknownError\");\n        }\n        parent.elements.push({\n            type: \"CharacterSet\",\n            parent,\n            start,\n            end,\n            raw: this.source.slice(start, end),\n            kind,\n        });\n    }\n    onEscapeCharacterSet(start, end, kind, negate) {\n        const parent = this._node;\n        if (parent.type !== \"Alternative\" && parent.type !== \"CharacterClass\") {\n            throw new Error(\"UnknownError\");\n        }\n        parent.elements.push({\n            type: \"CharacterSet\",\n            parent,\n            start,\n            end,\n            raw: this.source.slice(start, end),\n            kind,\n            negate,\n        });\n    }\n    onUnicodePropertyCharacterSet(start, end, kind, key, value, negate) {\n        const parent = this._node;\n        if (parent.type !== \"Alternative\" && parent.type !== \"CharacterClass\") {\n            throw new Error(\"UnknownError\");\n        }\n        parent.elements.push({\n            type: \"CharacterSet\",\n            parent,\n            start,\n            end,\n            raw: this.source.slice(start, end),\n            kind,\n            key,\n            value,\n            negate,\n        });\n    }\n    onCharacter(start, end, value) {\n        const parent = this._node;\n        if (parent.type !== \"Alternative\" && parent.type !== \"CharacterClass\") {\n            throw new Error(\"UnknownError\");\n        }\n        parent.elements.push({\n            type: \"Character\",\n            parent,\n            start,\n            end,\n            raw: this.source.slice(start, end),\n            value,\n        });\n    }\n    onBackreference(start, end, ref) {\n        const parent = this._node;\n        if (parent.type !== \"Alternative\") {\n            throw new Error(\"UnknownError\");\n        }\n        const node = {\n            type: \"Backreference\",\n            parent,\n            start,\n            end,\n            raw: this.source.slice(start, end),\n            ref,\n            resolved: DummyCapturingGroup,\n        };\n        parent.elements.push(node);\n        this._backreferences.push(node);\n    }\n    onCharacterClassEnter(start, negate) {\n        const parent = this._node;\n        if (parent.type !== \"Alternative\") {\n            throw new Error(\"UnknownError\");\n        }\n        this._node = {\n            type: \"CharacterClass\",\n            parent,\n            start,\n            end: start,\n            raw: \"\",\n            negate,\n            elements: [],\n        };\n        parent.elements.push(this._node);\n    }\n    onCharacterClassLeave(start, end) {\n        const node = this._node;\n        if (node.type !== \"CharacterClass\" ||\n            node.parent.type !== \"Alternative\") {\n            throw new Error(\"UnknownError\");\n        }\n        node.end = end;\n        node.raw = this.source.slice(start, end);\n        this._node = node.parent;\n    }\n    onCharacterClassRange(start, end) {\n        const parent = this._node;\n        if (parent.type !== \"CharacterClass\") {\n            throw new Error(\"UnknownError\");\n        }\n        const elements = parent.elements;\n        const max = elements.pop();\n        const hyphen = elements.pop();\n        const min = elements.pop();\n        if (!min ||\n            !max ||\n            !hyphen ||\n            min.type !== \"Character\" ||\n            max.type !== \"Character\" ||\n            hyphen.type !== \"Character\" ||\n            hyphen.value !== HyphenMinus) {\n            throw new Error(\"UnknownError\");\n        }\n        const node = {\n            type: \"CharacterClassRange\",\n            parent,\n            start,\n            end,\n            raw: this.source.slice(start, end),\n            min,\n            max,\n        };\n        min.parent = node;\n        max.parent = node;\n        elements.push(node);\n    }\n}\nclass RegExpParser {\n    constructor(options) {\n        this._state = new RegExpParserState(options);\n        this._validator = new RegExpValidator(this._state);\n    }\n    parseLiteral(source, start = 0, end = source.length) {\n        this._state.source = source;\n        this._validator.validateLiteral(source, start, end);\n        const pattern = this._state.pattern;\n        const flags = this._state.flags;\n        const literal = {\n            type: \"RegExpLiteral\",\n            parent: null,\n            start,\n            end,\n            raw: source,\n            pattern,\n            flags,\n        };\n        pattern.parent = literal;\n        flags.parent = literal;\n        return literal;\n    }\n    parseFlags(source, start = 0, end = source.length) {\n        this._state.source = source;\n        this._validator.validateFlags(source, start, end);\n        return this._state.flags;\n    }\n    parsePattern(source, start = 0, end = source.length, uFlag = false) {\n        this._state.source = source;\n        this._validator.validatePattern(source, start, end, uFlag);\n        return this._state.pattern;\n    }\n}\n\nclass RegExpVisitor {\n    constructor(handlers) {\n        this._handlers = handlers;\n    }\n    visit(node) {\n        switch (node.type) {\n            case \"Alternative\":\n                this.visitAlternative(node);\n                break;\n            case \"Assertion\":\n                this.visitAssertion(node);\n                break;\n            case \"Backreference\":\n                this.visitBackreference(node);\n                break;\n            case \"CapturingGroup\":\n                this.visitCapturingGroup(node);\n                break;\n            case \"Character\":\n                this.visitCharacter(node);\n                break;\n            case \"CharacterClass\":\n                this.visitCharacterClass(node);\n                break;\n            case \"CharacterClassRange\":\n                this.visitCharacterClassRange(node);\n                break;\n            case \"CharacterSet\":\n                this.visitCharacterSet(node);\n                break;\n            case \"Flags\":\n                this.visitFlags(node);\n                break;\n            case \"Group\":\n                this.visitGroup(node);\n                break;\n            case \"Pattern\":\n                this.visitPattern(node);\n                break;\n            case \"Quantifier\":\n                this.visitQuantifier(node);\n                break;\n            case \"RegExpLiteral\":\n                this.visitRegExpLiteral(node);\n                break;\n            default:\n                throw new Error(`Unknown type: ${node.type}`);\n        }\n    }\n    visitAlternative(node) {\n        if (this._handlers.onAlternativeEnter) {\n            this._handlers.onAlternativeEnter(node);\n        }\n        node.elements.forEach(this.visit, this);\n        if (this._handlers.onAlternativeLeave) {\n            this._handlers.onAlternativeLeave(node);\n        }\n    }\n    visitAssertion(node) {\n        if (this._handlers.onAssertionEnter) {\n            this._handlers.onAssertionEnter(node);\n        }\n        if (node.kind === \"lookahead\" || node.kind === \"lookbehind\") {\n            node.alternatives.forEach(this.visit, this);\n        }\n        if (this._handlers.onAssertionLeave) {\n            this._handlers.onAssertionLeave(node);\n        }\n    }\n    visitBackreference(node) {\n        if (this._handlers.onBackreferenceEnter) {\n            this._handlers.onBackreferenceEnter(node);\n        }\n        if (this._handlers.onBackreferenceLeave) {\n            this._handlers.onBackreferenceLeave(node);\n        }\n    }\n    visitCapturingGroup(node) {\n        if (this._handlers.onCapturingGroupEnter) {\n            this._handlers.onCapturingGroupEnter(node);\n        }\n        node.alternatives.forEach(this.visit, this);\n        if (this._handlers.onCapturingGroupLeave) {\n            this._handlers.onCapturingGroupLeave(node);\n        }\n    }\n    visitCharacter(node) {\n        if (this._handlers.onCharacterEnter) {\n            this._handlers.onCharacterEnter(node);\n        }\n        if (this._handlers.onCharacterLeave) {\n            this._handlers.onCharacterLeave(node);\n        }\n    }\n    visitCharacterClass(node) {\n        if (this._handlers.onCharacterClassEnter) {\n            this._handlers.onCharacterClassEnter(node);\n        }\n        node.elements.forEach(this.visit, this);\n        if (this._handlers.onCharacterClassLeave) {\n            this._handlers.onCharacterClassLeave(node);\n        }\n    }\n    visitCharacterClassRange(node) {\n        if (this._handlers.onCharacterClassRangeEnter) {\n            this._handlers.onCharacterClassRangeEnter(node);\n        }\n        this.visitCharacter(node.min);\n        this.visitCharacter(node.max);\n        if (this._handlers.onCharacterClassRangeLeave) {\n            this._handlers.onCharacterClassRangeLeave(node);\n        }\n    }\n    visitCharacterSet(node) {\n        if (this._handlers.onCharacterSetEnter) {\n            this._handlers.onCharacterSetEnter(node);\n        }\n        if (this._handlers.onCharacterSetLeave) {\n            this._handlers.onCharacterSetLeave(node);\n        }\n    }\n    visitFlags(node) {\n        if (this._handlers.onFlagsEnter) {\n            this._handlers.onFlagsEnter(node);\n        }\n        if (this._handlers.onFlagsLeave) {\n            this._handlers.onFlagsLeave(node);\n        }\n    }\n    visitGroup(node) {\n        if (this._handlers.onGroupEnter) {\n            this._handlers.onGroupEnter(node);\n        }\n        node.alternatives.forEach(this.visit, this);\n        if (this._handlers.onGroupLeave) {\n            this._handlers.onGroupLeave(node);\n        }\n    }\n    visitPattern(node) {\n        if (this._handlers.onPatternEnter) {\n            this._handlers.onPatternEnter(node);\n        }\n        node.alternatives.forEach(this.visit, this);\n        if (this._handlers.onPatternLeave) {\n            this._handlers.onPatternLeave(node);\n        }\n    }\n    visitQuantifier(node) {\n        if (this._handlers.onQuantifierEnter) {\n            this._handlers.onQuantifierEnter(node);\n        }\n        this.visit(node.element);\n        if (this._handlers.onQuantifierLeave) {\n            this._handlers.onQuantifierLeave(node);\n        }\n    }\n    visitRegExpLiteral(node) {\n        if (this._handlers.onRegExpLiteralEnter) {\n            this._handlers.onRegExpLiteralEnter(node);\n        }\n        this.visitPattern(node.pattern);\n        this.visitFlags(node.flags);\n        if (this._handlers.onRegExpLiteralLeave) {\n            this._handlers.onRegExpLiteralLeave(node);\n        }\n    }\n}\n\nfunction parseRegExpLiteral(source, options) {\n    return new RegExpParser(options).parseLiteral(String(source));\n}\nfunction validateRegExpLiteral(source, options) {\n    return new RegExpValidator(options).validateLiteral(source);\n}\nfunction visitRegExpAST(node, handlers) {\n    new RegExpVisitor(handlers).visit(node);\n}\n\nexports.AST = ast;\nexports.RegExpParser = RegExpParser;\nexports.RegExpValidator = RegExpValidator;\nexports.parseRegExpLiteral = parseRegExpLiteral;\nexports.validateRegExpLiteral = validateRegExpLiteral;\nexports.visitRegExpAST = visitRegExpAST;\n//# sourceMappingURL=index.js.map\n\n\n//# sourceURL=webpack://javascript/./node_modules/regexpp/index.js?");

/***/ }),

/***/ "./node_modules/type-check/lib/check.js":
/*!**********************************************!*\
  !*** ./node_modules/type-check/lib/check.js ***!
  \**********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("// Generated by LiveScript 1.6.0\n(function(){\n  var ref$, any, all, isItNaN, types, defaultType, toString$ = {}.toString;\n  ref$ = __webpack_require__(/*! prelude-ls */ \"./node_modules/prelude-ls/lib/index.js\"), any = ref$.any, all = ref$.all, isItNaN = ref$.isItNaN;\n  types = {\n    Number: {\n      typeOf: 'Number',\n      validate: function(it){\n        return !isItNaN(it);\n      }\n    },\n    NaN: {\n      typeOf: 'Number',\n      validate: isItNaN\n    },\n    Int: {\n      typeOf: 'Number',\n      validate: function(it){\n        return !isItNaN(it) && it % 1 === 0;\n      }\n    },\n    Float: {\n      typeOf: 'Number',\n      validate: function(it){\n        return !isItNaN(it);\n      }\n    },\n    Date: {\n      typeOf: 'Date',\n      validate: function(it){\n        return !isItNaN(it.getTime());\n      }\n    }\n  };\n  defaultType = {\n    array: 'Array',\n    tuple: 'Array'\n  };\n  function checkArray(input, type, options){\n    return all(function(it){\n      return checkMultiple(it, type.of, options);\n    }, input);\n  }\n  function checkTuple(input, type, options){\n    var i, i$, ref$, len$, types;\n    i = 0;\n    for (i$ = 0, len$ = (ref$ = type.of).length; i$ < len$; ++i$) {\n      types = ref$[i$];\n      if (!checkMultiple(input[i], types, options)) {\n        return false;\n      }\n      i++;\n    }\n    return input.length <= i;\n  }\n  function checkFields(input, type, options){\n    var inputKeys, numInputKeys, k, numOfKeys, key, ref$, types;\n    inputKeys = {};\n    numInputKeys = 0;\n    for (k in input) {\n      inputKeys[k] = true;\n      numInputKeys++;\n    }\n    numOfKeys = 0;\n    for (key in ref$ = type.of) {\n      types = ref$[key];\n      if (!checkMultiple(input[key], types, options)) {\n        return false;\n      }\n      if (inputKeys[key]) {\n        numOfKeys++;\n      }\n    }\n    return type.subset || numInputKeys === numOfKeys;\n  }\n  function checkStructure(input, type, options){\n    if (!(input instanceof Object)) {\n      return false;\n    }\n    switch (type.structure) {\n    case 'fields':\n      return checkFields(input, type, options);\n    case 'array':\n      return checkArray(input, type, options);\n    case 'tuple':\n      return checkTuple(input, type, options);\n    }\n  }\n  function check(input, typeObj, options){\n    var type, structure, setting, that;\n    type = typeObj.type, structure = typeObj.structure;\n    if (type) {\n      if (type === '*') {\n        return true;\n      }\n      setting = options.customTypes[type] || types[type];\n      if (setting) {\n        return (setting.typeOf === void 8 || setting.typeOf === toString$.call(input).slice(8, -1)) && setting.validate(input);\n      } else {\n        return type === toString$.call(input).slice(8, -1) && (!structure || checkStructure(input, typeObj, options));\n      }\n    } else if (structure) {\n      if (that = defaultType[structure]) {\n        if (that !== toString$.call(input).slice(8, -1)) {\n          return false;\n        }\n      }\n      return checkStructure(input, typeObj, options);\n    } else {\n      throw new Error(\"No type defined. Input: \" + input + \".\");\n    }\n  }\n  function checkMultiple(input, types, options){\n    if (toString$.call(types).slice(8, -1) !== 'Array') {\n      throw new Error(\"Types must be in an array. Input: \" + input + \".\");\n    }\n    return any(function(it){\n      return check(input, it, options);\n    }, types);\n  }\n  module.exports = function(parsedType, input, options){\n    options == null && (options = {});\n    if (options.customTypes == null) {\n      options.customTypes = {};\n    }\n    return checkMultiple(input, parsedType, options);\n  };\n}).call(this);\n\n\n//# sourceURL=webpack://javascript/./node_modules/type-check/lib/check.js?");

/***/ }),

/***/ "./node_modules/type-check/lib/index.js":
/*!**********************************************!*\
  !*** ./node_modules/type-check/lib/index.js ***!
  \**********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("// Generated by LiveScript 1.6.0\n(function(){\n  var VERSION, parseType, parsedTypeCheck, typeCheck;\n  VERSION = '0.4.0';\n  parseType = __webpack_require__(/*! ./parse-type */ \"./node_modules/type-check/lib/parse-type.js\");\n  parsedTypeCheck = __webpack_require__(/*! ./check */ \"./node_modules/type-check/lib/check.js\");\n  typeCheck = function(type, input, options){\n    return parsedTypeCheck(parseType(type), input, options);\n  };\n  module.exports = {\n    VERSION: VERSION,\n    typeCheck: typeCheck,\n    parsedTypeCheck: parsedTypeCheck,\n    parseType: parseType\n  };\n}).call(this);\n\n\n//# sourceURL=webpack://javascript/./node_modules/type-check/lib/index.js?");

/***/ }),

/***/ "./node_modules/type-check/lib/parse-type.js":
/*!***************************************************!*\
  !*** ./node_modules/type-check/lib/parse-type.js ***!
  \***************************************************/
/***/ (function(module) {

eval("// Generated by LiveScript 1.6.0\n(function(){\n  var identifierRegex, tokenRegex;\n  identifierRegex = /[\\$\\w]+/;\n  function peek(tokens){\n    var token;\n    token = tokens[0];\n    if (token == null) {\n      throw new Error('Unexpected end of input.');\n    }\n    return token;\n  }\n  function consumeIdent(tokens){\n    var token;\n    token = peek(tokens);\n    if (!identifierRegex.test(token)) {\n      throw new Error(\"Expected text, got '\" + token + \"' instead.\");\n    }\n    return tokens.shift();\n  }\n  function consumeOp(tokens, op){\n    var token;\n    token = peek(tokens);\n    if (token !== op) {\n      throw new Error(\"Expected '\" + op + \"', got '\" + token + \"' instead.\");\n    }\n    return tokens.shift();\n  }\n  function maybeConsumeOp(tokens, op){\n    var token;\n    token = tokens[0];\n    if (token === op) {\n      return tokens.shift();\n    } else {\n      return null;\n    }\n  }\n  function consumeArray(tokens){\n    var types;\n    consumeOp(tokens, '[');\n    if (peek(tokens) === ']') {\n      throw new Error(\"Must specify type of Array - eg. [Type], got [] instead.\");\n    }\n    types = consumeTypes(tokens);\n    consumeOp(tokens, ']');\n    return {\n      structure: 'array',\n      of: types\n    };\n  }\n  function consumeTuple(tokens){\n    var components;\n    components = [];\n    consumeOp(tokens, '(');\n    if (peek(tokens) === ')') {\n      throw new Error(\"Tuple must be of at least length 1 - eg. (Type), got () instead.\");\n    }\n    for (;;) {\n      components.push(consumeTypes(tokens));\n      maybeConsumeOp(tokens, ',');\n      if (')' === peek(tokens)) {\n        break;\n      }\n    }\n    consumeOp(tokens, ')');\n    return {\n      structure: 'tuple',\n      of: components\n    };\n  }\n  function consumeFields(tokens){\n    var fields, subset, ref$, key, types;\n    fields = {};\n    consumeOp(tokens, '{');\n    subset = false;\n    for (;;) {\n      if (maybeConsumeOp(tokens, '...')) {\n        subset = true;\n        break;\n      }\n      ref$ = consumeField(tokens), key = ref$[0], types = ref$[1];\n      fields[key] = types;\n      maybeConsumeOp(tokens, ',');\n      if ('}' === peek(tokens)) {\n        break;\n      }\n    }\n    consumeOp(tokens, '}');\n    return {\n      structure: 'fields',\n      of: fields,\n      subset: subset\n    };\n  }\n  function consumeField(tokens){\n    var key, types;\n    key = consumeIdent(tokens);\n    consumeOp(tokens, ':');\n    types = consumeTypes(tokens);\n    return [key, types];\n  }\n  function maybeConsumeStructure(tokens){\n    switch (tokens[0]) {\n    case '[':\n      return consumeArray(tokens);\n    case '(':\n      return consumeTuple(tokens);\n    case '{':\n      return consumeFields(tokens);\n    }\n  }\n  function consumeType(tokens){\n    var token, wildcard, type, structure;\n    token = peek(tokens);\n    wildcard = token === '*';\n    if (wildcard || identifierRegex.test(token)) {\n      type = wildcard\n        ? consumeOp(tokens, '*')\n        : consumeIdent(tokens);\n      structure = maybeConsumeStructure(tokens);\n      if (structure) {\n        return structure.type = type, structure;\n      } else {\n        return {\n          type: type\n        };\n      }\n    } else {\n      structure = maybeConsumeStructure(tokens);\n      if (!structure) {\n        throw new Error(\"Unexpected character: \" + token);\n      }\n      return structure;\n    }\n  }\n  function consumeTypes(tokens){\n    var lookahead, types, typesSoFar, typeObj, type, structure;\n    if ('::' === peek(tokens)) {\n      throw new Error(\"No comment before comment separator '::' found.\");\n    }\n    lookahead = tokens[1];\n    if (lookahead != null && lookahead === '::') {\n      tokens.shift();\n      tokens.shift();\n    }\n    types = [];\n    typesSoFar = {};\n    if ('Maybe' === peek(tokens)) {\n      tokens.shift();\n      types = [\n        {\n          type: 'Undefined'\n        }, {\n          type: 'Null'\n        }\n      ];\n      typesSoFar = {\n        Undefined: true,\n        Null: true\n      };\n    }\n    for (;;) {\n      typeObj = consumeType(tokens), type = typeObj.type, structure = typeObj.structure;\n      if (!typesSoFar[type]) {\n        types.push(typeObj);\n      }\n      if (structure == null) {\n        typesSoFar[type] = true;\n      }\n      if (!maybeConsumeOp(tokens, '|')) {\n        break;\n      }\n    }\n    return types;\n  }\n  tokenRegex = RegExp('\\\\.\\\\.\\\\.|::|->|' + identifierRegex.source + '|\\\\S', 'g');\n  module.exports = function(input){\n    var tokens, e;\n    if (!input.length) {\n      throw new Error('No type specified.');\n    }\n    tokens = input.match(tokenRegex) || [];\n    if (in$('->', tokens)) {\n      throw new Error(\"Function types are not supported.\\ To validate that something is a function, you may use 'Function'.\");\n    }\n    try {\n      return consumeTypes(tokens);\n    } catch (e$) {\n      e = e$;\n      throw new Error(e.message + \" - Remaining tokens: \" + JSON.stringify(tokens) + \" - Initial input: '\" + input + \"'\");\n    }\n  };\n  function in$(x, xs){\n    var i = -1, l = xs.length >>> 0;\n    while (++i < l) if (x === xs[i]) return true;\n    return false;\n  }\n}).call(this);\n\n\n//# sourceURL=webpack://javascript/./node_modules/type-check/lib/parse-type.js?");

/***/ }),

/***/ "./node_modules/uri-js/dist/es5/uri.all.js":
/*!*************************************************!*\
  !*** ./node_modules/uri-js/dist/es5/uri.all.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("/** @license URI.js v4.4.1 (c) 2011 Gary Court. License: http://github.com/garycourt/uri-js */\n(function (global, factory) {\n\t true ? factory(exports) :\n\t0;\n}(this, (function (exports) { 'use strict';\n\nfunction merge() {\n    for (var _len = arguments.length, sets = Array(_len), _key = 0; _key < _len; _key++) {\n        sets[_key] = arguments[_key];\n    }\n\n    if (sets.length > 1) {\n        sets[0] = sets[0].slice(0, -1);\n        var xl = sets.length - 1;\n        for (var x = 1; x < xl; ++x) {\n            sets[x] = sets[x].slice(1, -1);\n        }\n        sets[xl] = sets[xl].slice(1);\n        return sets.join('');\n    } else {\n        return sets[0];\n    }\n}\nfunction subexp(str) {\n    return \"(?:\" + str + \")\";\n}\nfunction typeOf(o) {\n    return o === undefined ? \"undefined\" : o === null ? \"null\" : Object.prototype.toString.call(o).split(\" \").pop().split(\"]\").shift().toLowerCase();\n}\nfunction toUpperCase(str) {\n    return str.toUpperCase();\n}\nfunction toArray(obj) {\n    return obj !== undefined && obj !== null ? obj instanceof Array ? obj : typeof obj.length !== \"number\" || obj.split || obj.setInterval || obj.call ? [obj] : Array.prototype.slice.call(obj) : [];\n}\nfunction assign(target, source) {\n    var obj = target;\n    if (source) {\n        for (var key in source) {\n            obj[key] = source[key];\n        }\n    }\n    return obj;\n}\n\nfunction buildExps(isIRI) {\n    var ALPHA$$ = \"[A-Za-z]\",\n        CR$ = \"[\\\\x0D]\",\n        DIGIT$$ = \"[0-9]\",\n        DQUOTE$$ = \"[\\\\x22]\",\n        HEXDIG$$ = merge(DIGIT$$, \"[A-Fa-f]\"),\n        //case-insensitive\n    LF$$ = \"[\\\\x0A]\",\n        SP$$ = \"[\\\\x20]\",\n        PCT_ENCODED$ = subexp(subexp(\"%[EFef]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%[89A-Fa-f]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%\" + HEXDIG$$ + HEXDIG$$)),\n        //expanded\n    GEN_DELIMS$$ = \"[\\\\:\\\\/\\\\?\\\\#\\\\[\\\\]\\\\@]\",\n        SUB_DELIMS$$ = \"[\\\\!\\\\$\\\\&\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\;\\\\=]\",\n        RESERVED$$ = merge(GEN_DELIMS$$, SUB_DELIMS$$),\n        UCSCHAR$$ = isIRI ? \"[\\\\xA0-\\\\u200D\\\\u2010-\\\\u2029\\\\u202F-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFEF]\" : \"[]\",\n        //subset, excludes bidi control characters\n    IPRIVATE$$ = isIRI ? \"[\\\\uE000-\\\\uF8FF]\" : \"[]\",\n        //subset\n    UNRESERVED$$ = merge(ALPHA$$, DIGIT$$, \"[\\\\-\\\\.\\\\_\\\\~]\", UCSCHAR$$),\n        SCHEME$ = subexp(ALPHA$$ + merge(ALPHA$$, DIGIT$$, \"[\\\\+\\\\-\\\\.]\") + \"*\"),\n        USERINFO$ = subexp(subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:]\")) + \"*\"),\n        DEC_OCTET$ = subexp(subexp(\"25[0-5]\") + \"|\" + subexp(\"2[0-4]\" + DIGIT$$) + \"|\" + subexp(\"1\" + DIGIT$$ + DIGIT$$) + \"|\" + subexp(\"[1-9]\" + DIGIT$$) + \"|\" + DIGIT$$),\n        DEC_OCTET_RELAXED$ = subexp(subexp(\"25[0-5]\") + \"|\" + subexp(\"2[0-4]\" + DIGIT$$) + \"|\" + subexp(\"1\" + DIGIT$$ + DIGIT$$) + \"|\" + subexp(\"0?[1-9]\" + DIGIT$$) + \"|0?0?\" + DIGIT$$),\n        //relaxed parsing rules\n    IPV4ADDRESS$ = subexp(DEC_OCTET_RELAXED$ + \"\\\\.\" + DEC_OCTET_RELAXED$ + \"\\\\.\" + DEC_OCTET_RELAXED$ + \"\\\\.\" + DEC_OCTET_RELAXED$),\n        H16$ = subexp(HEXDIG$$ + \"{1,4}\"),\n        LS32$ = subexp(subexp(H16$ + \"\\\\:\" + H16$) + \"|\" + IPV4ADDRESS$),\n        IPV6ADDRESS1$ = subexp(subexp(H16$ + \"\\\\:\") + \"{6}\" + LS32$),\n        //                           6( h16 \":\" ) ls32\n    IPV6ADDRESS2$ = subexp(\"\\\\:\\\\:\" + subexp(H16$ + \"\\\\:\") + \"{5}\" + LS32$),\n        //                      \"::\" 5( h16 \":\" ) ls32\n    IPV6ADDRESS3$ = subexp(subexp(H16$) + \"?\\\\:\\\\:\" + subexp(H16$ + \"\\\\:\") + \"{4}\" + LS32$),\n        //[               h16 ] \"::\" 4( h16 \":\" ) ls32\n    IPV6ADDRESS4$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,1}\" + H16$) + \"?\\\\:\\\\:\" + subexp(H16$ + \"\\\\:\") + \"{3}\" + LS32$),\n        //[ *1( h16 \":\" ) h16 ] \"::\" 3( h16 \":\" ) ls32\n    IPV6ADDRESS5$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,2}\" + H16$) + \"?\\\\:\\\\:\" + subexp(H16$ + \"\\\\:\") + \"{2}\" + LS32$),\n        //[ *2( h16 \":\" ) h16 ] \"::\" 2( h16 \":\" ) ls32\n    IPV6ADDRESS6$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,3}\" + H16$) + \"?\\\\:\\\\:\" + H16$ + \"\\\\:\" + LS32$),\n        //[ *3( h16 \":\" ) h16 ] \"::\"    h16 \":\"   ls32\n    IPV6ADDRESS7$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,4}\" + H16$) + \"?\\\\:\\\\:\" + LS32$),\n        //[ *4( h16 \":\" ) h16 ] \"::\"              ls32\n    IPV6ADDRESS8$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,5}\" + H16$) + \"?\\\\:\\\\:\" + H16$),\n        //[ *5( h16 \":\" ) h16 ] \"::\"              h16\n    IPV6ADDRESS9$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,6}\" + H16$) + \"?\\\\:\\\\:\"),\n        //[ *6( h16 \":\" ) h16 ] \"::\"\n    IPV6ADDRESS$ = subexp([IPV6ADDRESS1$, IPV6ADDRESS2$, IPV6ADDRESS3$, IPV6ADDRESS4$, IPV6ADDRESS5$, IPV6ADDRESS6$, IPV6ADDRESS7$, IPV6ADDRESS8$, IPV6ADDRESS9$].join(\"|\")),\n        ZONEID$ = subexp(subexp(UNRESERVED$$ + \"|\" + PCT_ENCODED$) + \"+\"),\n        //RFC 6874\n    IPV6ADDRZ$ = subexp(IPV6ADDRESS$ + \"\\\\%25\" + ZONEID$),\n        //RFC 6874\n    IPV6ADDRZ_RELAXED$ = subexp(IPV6ADDRESS$ + subexp(\"\\\\%25|\\\\%(?!\" + HEXDIG$$ + \"{2})\") + ZONEID$),\n        //RFC 6874, with relaxed parsing rules\n    IPVFUTURE$ = subexp(\"[vV]\" + HEXDIG$$ + \"+\\\\.\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:]\") + \"+\"),\n        IP_LITERAL$ = subexp(\"\\\\[\" + subexp(IPV6ADDRZ_RELAXED$ + \"|\" + IPV6ADDRESS$ + \"|\" + IPVFUTURE$) + \"\\\\]\"),\n        //RFC 6874\n    REG_NAME$ = subexp(subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$)) + \"*\"),\n        HOST$ = subexp(IP_LITERAL$ + \"|\" + IPV4ADDRESS$ + \"(?!\" + REG_NAME$ + \")\" + \"|\" + REG_NAME$),\n        PORT$ = subexp(DIGIT$$ + \"*\"),\n        AUTHORITY$ = subexp(subexp(USERINFO$ + \"@\") + \"?\" + HOST$ + subexp(\"\\\\:\" + PORT$) + \"?\"),\n        PCHAR$ = subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:\\\\@]\")),\n        SEGMENT$ = subexp(PCHAR$ + \"*\"),\n        SEGMENT_NZ$ = subexp(PCHAR$ + \"+\"),\n        SEGMENT_NZ_NC$ = subexp(subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\@]\")) + \"+\"),\n        PATH_ABEMPTY$ = subexp(subexp(\"\\\\/\" + SEGMENT$) + \"*\"),\n        PATH_ABSOLUTE$ = subexp(\"\\\\/\" + subexp(SEGMENT_NZ$ + PATH_ABEMPTY$) + \"?\"),\n        //simplified\n    PATH_NOSCHEME$ = subexp(SEGMENT_NZ_NC$ + PATH_ABEMPTY$),\n        //simplified\n    PATH_ROOTLESS$ = subexp(SEGMENT_NZ$ + PATH_ABEMPTY$),\n        //simplified\n    PATH_EMPTY$ = \"(?!\" + PCHAR$ + \")\",\n        PATH$ = subexp(PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_NOSCHEME$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$),\n        QUERY$ = subexp(subexp(PCHAR$ + \"|\" + merge(\"[\\\\/\\\\?]\", IPRIVATE$$)) + \"*\"),\n        FRAGMENT$ = subexp(subexp(PCHAR$ + \"|[\\\\/\\\\?]\") + \"*\"),\n        HIER_PART$ = subexp(subexp(\"\\\\/\\\\/\" + AUTHORITY$ + PATH_ABEMPTY$) + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$),\n        URI$ = subexp(SCHEME$ + \"\\\\:\" + HIER_PART$ + subexp(\"\\\\?\" + QUERY$) + \"?\" + subexp(\"\\\\#\" + FRAGMENT$) + \"?\"),\n        RELATIVE_PART$ = subexp(subexp(\"\\\\/\\\\/\" + AUTHORITY$ + PATH_ABEMPTY$) + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_NOSCHEME$ + \"|\" + PATH_EMPTY$),\n        RELATIVE$ = subexp(RELATIVE_PART$ + subexp(\"\\\\?\" + QUERY$) + \"?\" + subexp(\"\\\\#\" + FRAGMENT$) + \"?\"),\n        URI_REFERENCE$ = subexp(URI$ + \"|\" + RELATIVE$),\n        ABSOLUTE_URI$ = subexp(SCHEME$ + \"\\\\:\" + HIER_PART$ + subexp(\"\\\\?\" + QUERY$) + \"?\"),\n        GENERIC_REF$ = \"^(\" + SCHEME$ + \")\\\\:\" + subexp(subexp(\"\\\\/\\\\/(\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?)\") + \"?(\" + PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$ + \")\") + subexp(\"\\\\?(\" + QUERY$ + \")\") + \"?\" + subexp(\"\\\\#(\" + FRAGMENT$ + \")\") + \"?$\",\n        RELATIVE_REF$ = \"^(){0}\" + subexp(subexp(\"\\\\/\\\\/(\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?)\") + \"?(\" + PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_NOSCHEME$ + \"|\" + PATH_EMPTY$ + \")\") + subexp(\"\\\\?(\" + QUERY$ + \")\") + \"?\" + subexp(\"\\\\#(\" + FRAGMENT$ + \")\") + \"?$\",\n        ABSOLUTE_REF$ = \"^(\" + SCHEME$ + \")\\\\:\" + subexp(subexp(\"\\\\/\\\\/(\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?)\") + \"?(\" + PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$ + \")\") + subexp(\"\\\\?(\" + QUERY$ + \")\") + \"?$\",\n        SAMEDOC_REF$ = \"^\" + subexp(\"\\\\#(\" + FRAGMENT$ + \")\") + \"?$\",\n        AUTHORITY_REF$ = \"^\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?$\";\n    return {\n        NOT_SCHEME: new RegExp(merge(\"[^]\", ALPHA$$, DIGIT$$, \"[\\\\+\\\\-\\\\.]\"), \"g\"),\n        NOT_USERINFO: new RegExp(merge(\"[^\\\\%\\\\:]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n        NOT_HOST: new RegExp(merge(\"[^\\\\%\\\\[\\\\]\\\\:]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n        NOT_PATH: new RegExp(merge(\"[^\\\\%\\\\/\\\\:\\\\@]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n        NOT_PATH_NOSCHEME: new RegExp(merge(\"[^\\\\%\\\\/\\\\@]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n        NOT_QUERY: new RegExp(merge(\"[^\\\\%]\", UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:\\\\@\\\\/\\\\?]\", IPRIVATE$$), \"g\"),\n        NOT_FRAGMENT: new RegExp(merge(\"[^\\\\%]\", UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:\\\\@\\\\/\\\\?]\"), \"g\"),\n        ESCAPE: new RegExp(merge(\"[^]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n        UNRESERVED: new RegExp(UNRESERVED$$, \"g\"),\n        OTHER_CHARS: new RegExp(merge(\"[^\\\\%]\", UNRESERVED$$, RESERVED$$), \"g\"),\n        PCT_ENCODED: new RegExp(PCT_ENCODED$, \"g\"),\n        IPV4ADDRESS: new RegExp(\"^(\" + IPV4ADDRESS$ + \")$\"),\n        IPV6ADDRESS: new RegExp(\"^\\\\[?(\" + IPV6ADDRESS$ + \")\" + subexp(subexp(\"\\\\%25|\\\\%(?!\" + HEXDIG$$ + \"{2})\") + \"(\" + ZONEID$ + \")\") + \"?\\\\]?$\") //RFC 6874, with relaxed parsing rules\n    };\n}\nvar URI_PROTOCOL = buildExps(false);\n\nvar IRI_PROTOCOL = buildExps(true);\n\nvar slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar toConsumableArray = function (arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n};\n\n/** Highest positive signed 32-bit float value */\n\nvar maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1\n\n/** Bootstring parameters */\nvar base = 36;\nvar tMin = 1;\nvar tMax = 26;\nvar skew = 38;\nvar damp = 700;\nvar initialBias = 72;\nvar initialN = 128; // 0x80\nvar delimiter = '-'; // '\\x2D'\n\n/** Regular expressions */\nvar regexPunycode = /^xn--/;\nvar regexNonASCII = /[^\\0-\\x7E]/; // non-ASCII chars\nvar regexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g; // RFC 3490 separators\n\n/** Error messages */\nvar errors = {\n\t'overflow': 'Overflow: input needs wider integers to process',\n\t'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\n\t'invalid-input': 'Invalid input'\n};\n\n/** Convenience shortcuts */\nvar baseMinusTMin = base - tMin;\nvar floor = Math.floor;\nvar stringFromCharCode = String.fromCharCode;\n\n/*--------------------------------------------------------------------------*/\n\n/**\n * A generic error utility function.\n * @private\n * @param {String} type The error type.\n * @returns {Error} Throws a `RangeError` with the applicable error message.\n */\nfunction error$1(type) {\n\tthrow new RangeError(errors[type]);\n}\n\n/**\n * A generic `Array#map` utility function.\n * @private\n * @param {Array} array The array to iterate over.\n * @param {Function} callback The function that gets called for every array\n * item.\n * @returns {Array} A new array of values returned by the callback function.\n */\nfunction map(array, fn) {\n\tvar result = [];\n\tvar length = array.length;\n\twhile (length--) {\n\t\tresult[length] = fn(array[length]);\n\t}\n\treturn result;\n}\n\n/**\n * A simple `Array#map`-like wrapper to work with domain name strings or email\n * addresses.\n * @private\n * @param {String} domain The domain name or email address.\n * @param {Function} callback The function that gets called for every\n * character.\n * @returns {Array} A new string of characters returned by the callback\n * function.\n */\nfunction mapDomain(string, fn) {\n\tvar parts = string.split('@');\n\tvar result = '';\n\tif (parts.length > 1) {\n\t\t// In email addresses, only the domain name should be punycoded. Leave\n\t\t// the local part (i.e. everything up to `@`) intact.\n\t\tresult = parts[0] + '@';\n\t\tstring = parts[1];\n\t}\n\t// Avoid `split(regex)` for IE8 compatibility. See #17.\n\tstring = string.replace(regexSeparators, '\\x2E');\n\tvar labels = string.split('.');\n\tvar encoded = map(labels, fn).join('.');\n\treturn result + encoded;\n}\n\n/**\n * Creates an array containing the numeric code points of each Unicode\n * character in the string. While JavaScript uses UCS-2 internally,\n * this function will convert a pair of surrogate halves (each of which\n * UCS-2 exposes as separate characters) into a single code point,\n * matching UTF-16.\n * @see `punycode.ucs2.encode`\n * @see <https://mathiasbynens.be/notes/javascript-encoding>\n * @memberOf punycode.ucs2\n * @name decode\n * @param {String} string The Unicode input string (UCS-2).\n * @returns {Array} The new array of code points.\n */\nfunction ucs2decode(string) {\n\tvar output = [];\n\tvar counter = 0;\n\tvar length = string.length;\n\twhile (counter < length) {\n\t\tvar value = string.charCodeAt(counter++);\n\t\tif (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n\t\t\t// It's a high surrogate, and there is a next character.\n\t\t\tvar extra = string.charCodeAt(counter++);\n\t\t\tif ((extra & 0xFC00) == 0xDC00) {\n\t\t\t\t// Low surrogate.\n\t\t\t\toutput.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n\t\t\t} else {\n\t\t\t\t// It's an unmatched surrogate; only append this code unit, in case the\n\t\t\t\t// next code unit is the high surrogate of a surrogate pair.\n\t\t\t\toutput.push(value);\n\t\t\t\tcounter--;\n\t\t\t}\n\t\t} else {\n\t\t\toutput.push(value);\n\t\t}\n\t}\n\treturn output;\n}\n\n/**\n * Creates a string based on an array of numeric code points.\n * @see `punycode.ucs2.decode`\n * @memberOf punycode.ucs2\n * @name encode\n * @param {Array} codePoints The array of numeric code points.\n * @returns {String} The new Unicode string (UCS-2).\n */\nvar ucs2encode = function ucs2encode(array) {\n\treturn String.fromCodePoint.apply(String, toConsumableArray(array));\n};\n\n/**\n * Converts a basic code point into a digit/integer.\n * @see `digitToBasic()`\n * @private\n * @param {Number} codePoint The basic numeric code point value.\n * @returns {Number} The numeric value of a basic code point (for use in\n * representing integers) in the range `0` to `base - 1`, or `base` if\n * the code point does not represent a value.\n */\nvar basicToDigit = function basicToDigit(codePoint) {\n\tif (codePoint - 0x30 < 0x0A) {\n\t\treturn codePoint - 0x16;\n\t}\n\tif (codePoint - 0x41 < 0x1A) {\n\t\treturn codePoint - 0x41;\n\t}\n\tif (codePoint - 0x61 < 0x1A) {\n\t\treturn codePoint - 0x61;\n\t}\n\treturn base;\n};\n\n/**\n * Converts a digit/integer into a basic code point.\n * @see `basicToDigit()`\n * @private\n * @param {Number} digit The numeric value of a basic code point.\n * @returns {Number} The basic code point whose value (when used for\n * representing integers) is `digit`, which needs to be in the range\n * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\n * used; else, the lowercase form is used. The behavior is undefined\n * if `flag` is non-zero and `digit` has no uppercase form.\n */\nvar digitToBasic = function digitToBasic(digit, flag) {\n\t//  0..25 map to ASCII a..z or A..Z\n\t// 26..35 map to ASCII 0..9\n\treturn digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n};\n\n/**\n * Bias adaptation function as per section 3.4 of RFC 3492.\n * https://tools.ietf.org/html/rfc3492#section-3.4\n * @private\n */\nvar adapt = function adapt(delta, numPoints, firstTime) {\n\tvar k = 0;\n\tdelta = firstTime ? floor(delta / damp) : delta >> 1;\n\tdelta += floor(delta / numPoints);\n\tfor (; /* no initialization */delta > baseMinusTMin * tMax >> 1; k += base) {\n\t\tdelta = floor(delta / baseMinusTMin);\n\t}\n\treturn floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n};\n\n/**\n * Converts a Punycode string of ASCII-only symbols to a string of Unicode\n * symbols.\n * @memberOf punycode\n * @param {String} input The Punycode string of ASCII-only symbols.\n * @returns {String} The resulting string of Unicode symbols.\n */\nvar decode = function decode(input) {\n\t// Don't use UCS-2.\n\tvar output = [];\n\tvar inputLength = input.length;\n\tvar i = 0;\n\tvar n = initialN;\n\tvar bias = initialBias;\n\n\t// Handle the basic code points: let `basic` be the number of input code\n\t// points before the last delimiter, or `0` if there is none, then copy\n\t// the first basic code points to the output.\n\n\tvar basic = input.lastIndexOf(delimiter);\n\tif (basic < 0) {\n\t\tbasic = 0;\n\t}\n\n\tfor (var j = 0; j < basic; ++j) {\n\t\t// if it's not a basic code point\n\t\tif (input.charCodeAt(j) >= 0x80) {\n\t\t\terror$1('not-basic');\n\t\t}\n\t\toutput.push(input.charCodeAt(j));\n\t}\n\n\t// Main decoding loop: start just after the last delimiter if any basic code\n\t// points were copied; start at the beginning otherwise.\n\n\tfor (var index = basic > 0 ? basic + 1 : 0; index < inputLength;) /* no final expression */{\n\n\t\t// `index` is the index of the next character to be consumed.\n\t\t// Decode a generalized variable-length integer into `delta`,\n\t\t// which gets added to `i`. The overflow checking is easier\n\t\t// if we increase `i` as we go, then subtract off its starting\n\t\t// value at the end to obtain `delta`.\n\t\tvar oldi = i;\n\t\tfor (var w = 1, k = base;; /* no condition */k += base) {\n\n\t\t\tif (index >= inputLength) {\n\t\t\t\terror$1('invalid-input');\n\t\t\t}\n\n\t\t\tvar digit = basicToDigit(input.charCodeAt(index++));\n\n\t\t\tif (digit >= base || digit > floor((maxInt - i) / w)) {\n\t\t\t\terror$1('overflow');\n\t\t\t}\n\n\t\t\ti += digit * w;\n\t\t\tvar t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;\n\n\t\t\tif (digit < t) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tvar baseMinusT = base - t;\n\t\t\tif (w > floor(maxInt / baseMinusT)) {\n\t\t\t\terror$1('overflow');\n\t\t\t}\n\n\t\t\tw *= baseMinusT;\n\t\t}\n\n\t\tvar out = output.length + 1;\n\t\tbias = adapt(i - oldi, out, oldi == 0);\n\n\t\t// `i` was supposed to wrap around from `out` to `0`,\n\t\t// incrementing `n` each time, so we'll fix that now:\n\t\tif (floor(i / out) > maxInt - n) {\n\t\t\terror$1('overflow');\n\t\t}\n\n\t\tn += floor(i / out);\n\t\ti %= out;\n\n\t\t// Insert `n` at position `i` of the output.\n\t\toutput.splice(i++, 0, n);\n\t}\n\n\treturn String.fromCodePoint.apply(String, output);\n};\n\n/**\n * Converts a string of Unicode symbols (e.g. a domain name label) to a\n * Punycode string of ASCII-only symbols.\n * @memberOf punycode\n * @param {String} input The string of Unicode symbols.\n * @returns {String} The resulting Punycode string of ASCII-only symbols.\n */\nvar encode = function encode(input) {\n\tvar output = [];\n\n\t// Convert the input in UCS-2 to an array of Unicode code points.\n\tinput = ucs2decode(input);\n\n\t// Cache the length.\n\tvar inputLength = input.length;\n\n\t// Initialize the state.\n\tvar n = initialN;\n\tvar delta = 0;\n\tvar bias = initialBias;\n\n\t// Handle the basic code points.\n\tvar _iteratorNormalCompletion = true;\n\tvar _didIteratorError = false;\n\tvar _iteratorError = undefined;\n\n\ttry {\n\t\tfor (var _iterator = input[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t\t\tvar _currentValue2 = _step.value;\n\n\t\t\tif (_currentValue2 < 0x80) {\n\t\t\t\toutput.push(stringFromCharCode(_currentValue2));\n\t\t\t}\n\t\t}\n\t} catch (err) {\n\t\t_didIteratorError = true;\n\t\t_iteratorError = err;\n\t} finally {\n\t\ttry {\n\t\t\tif (!_iteratorNormalCompletion && _iterator.return) {\n\t\t\t\t_iterator.return();\n\t\t\t}\n\t\t} finally {\n\t\t\tif (_didIteratorError) {\n\t\t\t\tthrow _iteratorError;\n\t\t\t}\n\t\t}\n\t}\n\n\tvar basicLength = output.length;\n\tvar handledCPCount = basicLength;\n\n\t// `handledCPCount` is the number of code points that have been handled;\n\t// `basicLength` is the number of basic code points.\n\n\t// Finish the basic string with a delimiter unless it's empty.\n\tif (basicLength) {\n\t\toutput.push(delimiter);\n\t}\n\n\t// Main encoding loop:\n\twhile (handledCPCount < inputLength) {\n\n\t\t// All non-basic code points < n have been handled already. Find the next\n\t\t// larger one:\n\t\tvar m = maxInt;\n\t\tvar _iteratorNormalCompletion2 = true;\n\t\tvar _didIteratorError2 = false;\n\t\tvar _iteratorError2 = undefined;\n\n\t\ttry {\n\t\t\tfor (var _iterator2 = input[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n\t\t\t\tvar currentValue = _step2.value;\n\n\t\t\t\tif (currentValue >= n && currentValue < m) {\n\t\t\t\t\tm = currentValue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\n\t\t\t// but guard against overflow.\n\t\t} catch (err) {\n\t\t\t_didIteratorError2 = true;\n\t\t\t_iteratorError2 = err;\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tif (!_iteratorNormalCompletion2 && _iterator2.return) {\n\t\t\t\t\t_iterator2.return();\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tif (_didIteratorError2) {\n\t\t\t\t\tthrow _iteratorError2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvar handledCPCountPlusOne = handledCPCount + 1;\n\t\tif (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n\t\t\terror$1('overflow');\n\t\t}\n\n\t\tdelta += (m - n) * handledCPCountPlusOne;\n\t\tn = m;\n\n\t\tvar _iteratorNormalCompletion3 = true;\n\t\tvar _didIteratorError3 = false;\n\t\tvar _iteratorError3 = undefined;\n\n\t\ttry {\n\t\t\tfor (var _iterator3 = input[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n\t\t\t\tvar _currentValue = _step3.value;\n\n\t\t\t\tif (_currentValue < n && ++delta > maxInt) {\n\t\t\t\t\terror$1('overflow');\n\t\t\t\t}\n\t\t\t\tif (_currentValue == n) {\n\t\t\t\t\t// Represent delta as a generalized variable-length integer.\n\t\t\t\t\tvar q = delta;\n\t\t\t\t\tfor (var k = base;; /* no condition */k += base) {\n\t\t\t\t\t\tvar t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;\n\t\t\t\t\t\tif (q < t) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvar qMinusT = q - t;\n\t\t\t\t\t\tvar baseMinusT = base - t;\n\t\t\t\t\t\toutput.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));\n\t\t\t\t\t\tq = floor(qMinusT / baseMinusT);\n\t\t\t\t\t}\n\n\t\t\t\t\toutput.push(stringFromCharCode(digitToBasic(q, 0)));\n\t\t\t\t\tbias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n\t\t\t\t\tdelta = 0;\n\t\t\t\t\t++handledCPCount;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (err) {\n\t\t\t_didIteratorError3 = true;\n\t\t\t_iteratorError3 = err;\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tif (!_iteratorNormalCompletion3 && _iterator3.return) {\n\t\t\t\t\t_iterator3.return();\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tif (_didIteratorError3) {\n\t\t\t\t\tthrow _iteratorError3;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t++delta;\n\t\t++n;\n\t}\n\treturn output.join('');\n};\n\n/**\n * Converts a Punycode string representing a domain name or an email address\n * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\n * it doesn't matter if you call it on a string that has already been\n * converted to Unicode.\n * @memberOf punycode\n * @param {String} input The Punycoded domain name or email address to\n * convert to Unicode.\n * @returns {String} The Unicode representation of the given Punycode\n * string.\n */\nvar toUnicode = function toUnicode(input) {\n\treturn mapDomain(input, function (string) {\n\t\treturn regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;\n\t});\n};\n\n/**\n * Converts a Unicode string representing a domain name or an email address to\n * Punycode. Only the non-ASCII parts of the domain name will be converted,\n * i.e. it doesn't matter if you call it with a domain that's already in\n * ASCII.\n * @memberOf punycode\n * @param {String} input The domain name or email address to convert, as a\n * Unicode string.\n * @returns {String} The Punycode representation of the given domain name or\n * email address.\n */\nvar toASCII = function toASCII(input) {\n\treturn mapDomain(input, function (string) {\n\t\treturn regexNonASCII.test(string) ? 'xn--' + encode(string) : string;\n\t});\n};\n\n/*--------------------------------------------------------------------------*/\n\n/** Define the public API */\nvar punycode = {\n\t/**\n  * A string representing the current Punycode.js version number.\n  * @memberOf punycode\n  * @type String\n  */\n\t'version': '2.1.0',\n\t/**\n  * An object of methods to convert from JavaScript's internal character\n  * representation (UCS-2) to Unicode code points, and back.\n  * @see <https://mathiasbynens.be/notes/javascript-encoding>\n  * @memberOf punycode\n  * @type Object\n  */\n\t'ucs2': {\n\t\t'decode': ucs2decode,\n\t\t'encode': ucs2encode\n\t},\n\t'decode': decode,\n\t'encode': encode,\n\t'toASCII': toASCII,\n\t'toUnicode': toUnicode\n};\n\n/**\n * URI.js\n *\n * @fileoverview An RFC 3986 compliant, scheme extendable URI parsing/validating/resolving library for JavaScript.\n * @author <a href=\"mailto:gary.court@gmail.com\">Gary Court</a>\n * @see http://github.com/garycourt/uri-js\n */\n/**\n * Copyright 2011 Gary Court. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification, are\n * permitted provided that the following conditions are met:\n *\n *    1. Redistributions of source code must retain the above copyright notice, this list of\n *       conditions and the following disclaimer.\n *\n *    2. Redistributions in binary form must reproduce the above copyright notice, this list\n *       of conditions and the following disclaimer in the documentation and/or other materials\n *       provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY GARY COURT ``AS IS'' AND ANY EXPRESS OR IMPLIED\n * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GARY COURT OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\n * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * The views and conclusions contained in the software and documentation are those of the\n * authors and should not be interpreted as representing official policies, either expressed\n * or implied, of Gary Court.\n */\nvar SCHEMES = {};\nfunction pctEncChar(chr) {\n    var c = chr.charCodeAt(0);\n    var e = void 0;\n    if (c < 16) e = \"%0\" + c.toString(16).toUpperCase();else if (c < 128) e = \"%\" + c.toString(16).toUpperCase();else if (c < 2048) e = \"%\" + (c >> 6 | 192).toString(16).toUpperCase() + \"%\" + (c & 63 | 128).toString(16).toUpperCase();else e = \"%\" + (c >> 12 | 224).toString(16).toUpperCase() + \"%\" + (c >> 6 & 63 | 128).toString(16).toUpperCase() + \"%\" + (c & 63 | 128).toString(16).toUpperCase();\n    return e;\n}\nfunction pctDecChars(str) {\n    var newStr = \"\";\n    var i = 0;\n    var il = str.length;\n    while (i < il) {\n        var c = parseInt(str.substr(i + 1, 2), 16);\n        if (c < 128) {\n            newStr += String.fromCharCode(c);\n            i += 3;\n        } else if (c >= 194 && c < 224) {\n            if (il - i >= 6) {\n                var c2 = parseInt(str.substr(i + 4, 2), 16);\n                newStr += String.fromCharCode((c & 31) << 6 | c2 & 63);\n            } else {\n                newStr += str.substr(i, 6);\n            }\n            i += 6;\n        } else if (c >= 224) {\n            if (il - i >= 9) {\n                var _c = parseInt(str.substr(i + 4, 2), 16);\n                var c3 = parseInt(str.substr(i + 7, 2), 16);\n                newStr += String.fromCharCode((c & 15) << 12 | (_c & 63) << 6 | c3 & 63);\n            } else {\n                newStr += str.substr(i, 9);\n            }\n            i += 9;\n        } else {\n            newStr += str.substr(i, 3);\n            i += 3;\n        }\n    }\n    return newStr;\n}\nfunction _normalizeComponentEncoding(components, protocol) {\n    function decodeUnreserved(str) {\n        var decStr = pctDecChars(str);\n        return !decStr.match(protocol.UNRESERVED) ? str : decStr;\n    }\n    if (components.scheme) components.scheme = String(components.scheme).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_SCHEME, \"\");\n    if (components.userinfo !== undefined) components.userinfo = String(components.userinfo).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_USERINFO, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n    if (components.host !== undefined) components.host = String(components.host).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_HOST, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n    if (components.path !== undefined) components.path = String(components.path).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(components.scheme ? protocol.NOT_PATH : protocol.NOT_PATH_NOSCHEME, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n    if (components.query !== undefined) components.query = String(components.query).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_QUERY, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n    if (components.fragment !== undefined) components.fragment = String(components.fragment).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_FRAGMENT, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n    return components;\n}\n\nfunction _stripLeadingZeros(str) {\n    return str.replace(/^0*(.*)/, \"$1\") || \"0\";\n}\nfunction _normalizeIPv4(host, protocol) {\n    var matches = host.match(protocol.IPV4ADDRESS) || [];\n\n    var _matches = slicedToArray(matches, 2),\n        address = _matches[1];\n\n    if (address) {\n        return address.split(\".\").map(_stripLeadingZeros).join(\".\");\n    } else {\n        return host;\n    }\n}\nfunction _normalizeIPv6(host, protocol) {\n    var matches = host.match(protocol.IPV6ADDRESS) || [];\n\n    var _matches2 = slicedToArray(matches, 3),\n        address = _matches2[1],\n        zone = _matches2[2];\n\n    if (address) {\n        var _address$toLowerCase$ = address.toLowerCase().split('::').reverse(),\n            _address$toLowerCase$2 = slicedToArray(_address$toLowerCase$, 2),\n            last = _address$toLowerCase$2[0],\n            first = _address$toLowerCase$2[1];\n\n        var firstFields = first ? first.split(\":\").map(_stripLeadingZeros) : [];\n        var lastFields = last.split(\":\").map(_stripLeadingZeros);\n        var isLastFieldIPv4Address = protocol.IPV4ADDRESS.test(lastFields[lastFields.length - 1]);\n        var fieldCount = isLastFieldIPv4Address ? 7 : 8;\n        var lastFieldsStart = lastFields.length - fieldCount;\n        var fields = Array(fieldCount);\n        for (var x = 0; x < fieldCount; ++x) {\n            fields[x] = firstFields[x] || lastFields[lastFieldsStart + x] || '';\n        }\n        if (isLastFieldIPv4Address) {\n            fields[fieldCount - 1] = _normalizeIPv4(fields[fieldCount - 1], protocol);\n        }\n        var allZeroFields = fields.reduce(function (acc, field, index) {\n            if (!field || field === \"0\") {\n                var lastLongest = acc[acc.length - 1];\n                if (lastLongest && lastLongest.index + lastLongest.length === index) {\n                    lastLongest.length++;\n                } else {\n                    acc.push({ index: index, length: 1 });\n                }\n            }\n            return acc;\n        }, []);\n        var longestZeroFields = allZeroFields.sort(function (a, b) {\n            return b.length - a.length;\n        })[0];\n        var newHost = void 0;\n        if (longestZeroFields && longestZeroFields.length > 1) {\n            var newFirst = fields.slice(0, longestZeroFields.index);\n            var newLast = fields.slice(longestZeroFields.index + longestZeroFields.length);\n            newHost = newFirst.join(\":\") + \"::\" + newLast.join(\":\");\n        } else {\n            newHost = fields.join(\":\");\n        }\n        if (zone) {\n            newHost += \"%\" + zone;\n        }\n        return newHost;\n    } else {\n        return host;\n    }\n}\nvar URI_PARSE = /^(?:([^:\\/?#]+):)?(?:\\/\\/((?:([^\\/?#@]*)@)?(\\[[^\\/?#\\]]+\\]|[^\\/?#:]*)(?:\\:(\\d*))?))?([^?#]*)(?:\\?([^#]*))?(?:#((?:.|\\n|\\r)*))?/i;\nvar NO_MATCH_IS_UNDEFINED = \"\".match(/(){0}/)[1] === undefined;\nfunction parse(uriString) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    var components = {};\n    var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;\n    if (options.reference === \"suffix\") uriString = (options.scheme ? options.scheme + \":\" : \"\") + \"//\" + uriString;\n    var matches = uriString.match(URI_PARSE);\n    if (matches) {\n        if (NO_MATCH_IS_UNDEFINED) {\n            //store each component\n            components.scheme = matches[1];\n            components.userinfo = matches[3];\n            components.host = matches[4];\n            components.port = parseInt(matches[5], 10);\n            components.path = matches[6] || \"\";\n            components.query = matches[7];\n            components.fragment = matches[8];\n            //fix port number\n            if (isNaN(components.port)) {\n                components.port = matches[5];\n            }\n        } else {\n            //IE FIX for improper RegExp matching\n            //store each component\n            components.scheme = matches[1] || undefined;\n            components.userinfo = uriString.indexOf(\"@\") !== -1 ? matches[3] : undefined;\n            components.host = uriString.indexOf(\"//\") !== -1 ? matches[4] : undefined;\n            components.port = parseInt(matches[5], 10);\n            components.path = matches[6] || \"\";\n            components.query = uriString.indexOf(\"?\") !== -1 ? matches[7] : undefined;\n            components.fragment = uriString.indexOf(\"#\") !== -1 ? matches[8] : undefined;\n            //fix port number\n            if (isNaN(components.port)) {\n                components.port = uriString.match(/\\/\\/(?:.|\\n)*\\:(?:\\/|\\?|\\#|$)/) ? matches[4] : undefined;\n            }\n        }\n        if (components.host) {\n            //normalize IP hosts\n            components.host = _normalizeIPv6(_normalizeIPv4(components.host, protocol), protocol);\n        }\n        //determine reference type\n        if (components.scheme === undefined && components.userinfo === undefined && components.host === undefined && components.port === undefined && !components.path && components.query === undefined) {\n            components.reference = \"same-document\";\n        } else if (components.scheme === undefined) {\n            components.reference = \"relative\";\n        } else if (components.fragment === undefined) {\n            components.reference = \"absolute\";\n        } else {\n            components.reference = \"uri\";\n        }\n        //check for reference errors\n        if (options.reference && options.reference !== \"suffix\" && options.reference !== components.reference) {\n            components.error = components.error || \"URI is not a \" + options.reference + \" reference.\";\n        }\n        //find scheme handler\n        var schemeHandler = SCHEMES[(options.scheme || components.scheme || \"\").toLowerCase()];\n        //check if scheme can't handle IRIs\n        if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {\n            //if host component is a domain name\n            if (components.host && (options.domainHost || schemeHandler && schemeHandler.domainHost)) {\n                //convert Unicode IDN -> ASCII IDN\n                try {\n                    components.host = punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase());\n                } catch (e) {\n                    components.error = components.error || \"Host's domain name can not be converted to ASCII via punycode: \" + e;\n                }\n            }\n            //convert IRI -> URI\n            _normalizeComponentEncoding(components, URI_PROTOCOL);\n        } else {\n            //normalize encodings\n            _normalizeComponentEncoding(components, protocol);\n        }\n        //perform scheme specific parsing\n        if (schemeHandler && schemeHandler.parse) {\n            schemeHandler.parse(components, options);\n        }\n    } else {\n        components.error = components.error || \"URI can not be parsed.\";\n    }\n    return components;\n}\n\nfunction _recomposeAuthority(components, options) {\n    var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;\n    var uriTokens = [];\n    if (components.userinfo !== undefined) {\n        uriTokens.push(components.userinfo);\n        uriTokens.push(\"@\");\n    }\n    if (components.host !== undefined) {\n        //normalize IP hosts, add brackets and escape zone separator for IPv6\n        uriTokens.push(_normalizeIPv6(_normalizeIPv4(String(components.host), protocol), protocol).replace(protocol.IPV6ADDRESS, function (_, $1, $2) {\n            return \"[\" + $1 + ($2 ? \"%25\" + $2 : \"\") + \"]\";\n        }));\n    }\n    if (typeof components.port === \"number\" || typeof components.port === \"string\") {\n        uriTokens.push(\":\");\n        uriTokens.push(String(components.port));\n    }\n    return uriTokens.length ? uriTokens.join(\"\") : undefined;\n}\n\nvar RDS1 = /^\\.\\.?\\//;\nvar RDS2 = /^\\/\\.(\\/|$)/;\nvar RDS3 = /^\\/\\.\\.(\\/|$)/;\nvar RDS5 = /^\\/?(?:.|\\n)*?(?=\\/|$)/;\nfunction removeDotSegments(input) {\n    var output = [];\n    while (input.length) {\n        if (input.match(RDS1)) {\n            input = input.replace(RDS1, \"\");\n        } else if (input.match(RDS2)) {\n            input = input.replace(RDS2, \"/\");\n        } else if (input.match(RDS3)) {\n            input = input.replace(RDS3, \"/\");\n            output.pop();\n        } else if (input === \".\" || input === \"..\") {\n            input = \"\";\n        } else {\n            var im = input.match(RDS5);\n            if (im) {\n                var s = im[0];\n                input = input.slice(s.length);\n                output.push(s);\n            } else {\n                throw new Error(\"Unexpected dot segment condition\");\n            }\n        }\n    }\n    return output.join(\"\");\n}\n\nfunction serialize(components) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    var protocol = options.iri ? IRI_PROTOCOL : URI_PROTOCOL;\n    var uriTokens = [];\n    //find scheme handler\n    var schemeHandler = SCHEMES[(options.scheme || components.scheme || \"\").toLowerCase()];\n    //perform scheme specific serialization\n    if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(components, options);\n    if (components.host) {\n        //if host component is an IPv6 address\n        if (protocol.IPV6ADDRESS.test(components.host)) {}\n        //TODO: normalize IPv6 address as per RFC 5952\n\n        //if host component is a domain name\n        else if (options.domainHost || schemeHandler && schemeHandler.domainHost) {\n                //convert IDN via punycode\n                try {\n                    components.host = !options.iri ? punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase()) : punycode.toUnicode(components.host);\n                } catch (e) {\n                    components.error = components.error || \"Host's domain name can not be converted to \" + (!options.iri ? \"ASCII\" : \"Unicode\") + \" via punycode: \" + e;\n                }\n            }\n    }\n    //normalize encoding\n    _normalizeComponentEncoding(components, protocol);\n    if (options.reference !== \"suffix\" && components.scheme) {\n        uriTokens.push(components.scheme);\n        uriTokens.push(\":\");\n    }\n    var authority = _recomposeAuthority(components, options);\n    if (authority !== undefined) {\n        if (options.reference !== \"suffix\") {\n            uriTokens.push(\"//\");\n        }\n        uriTokens.push(authority);\n        if (components.path && components.path.charAt(0) !== \"/\") {\n            uriTokens.push(\"/\");\n        }\n    }\n    if (components.path !== undefined) {\n        var s = components.path;\n        if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {\n            s = removeDotSegments(s);\n        }\n        if (authority === undefined) {\n            s = s.replace(/^\\/\\//, \"/%2F\"); //don't allow the path to start with \"//\"\n        }\n        uriTokens.push(s);\n    }\n    if (components.query !== undefined) {\n        uriTokens.push(\"?\");\n        uriTokens.push(components.query);\n    }\n    if (components.fragment !== undefined) {\n        uriTokens.push(\"#\");\n        uriTokens.push(components.fragment);\n    }\n    return uriTokens.join(\"\"); //merge tokens into a string\n}\n\nfunction resolveComponents(base, relative) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var skipNormalization = arguments[3];\n\n    var target = {};\n    if (!skipNormalization) {\n        base = parse(serialize(base, options), options); //normalize base components\n        relative = parse(serialize(relative, options), options); //normalize relative components\n    }\n    options = options || {};\n    if (!options.tolerant && relative.scheme) {\n        target.scheme = relative.scheme;\n        //target.authority = relative.authority;\n        target.userinfo = relative.userinfo;\n        target.host = relative.host;\n        target.port = relative.port;\n        target.path = removeDotSegments(relative.path || \"\");\n        target.query = relative.query;\n    } else {\n        if (relative.userinfo !== undefined || relative.host !== undefined || relative.port !== undefined) {\n            //target.authority = relative.authority;\n            target.userinfo = relative.userinfo;\n            target.host = relative.host;\n            target.port = relative.port;\n            target.path = removeDotSegments(relative.path || \"\");\n            target.query = relative.query;\n        } else {\n            if (!relative.path) {\n                target.path = base.path;\n                if (relative.query !== undefined) {\n                    target.query = relative.query;\n                } else {\n                    target.query = base.query;\n                }\n            } else {\n                if (relative.path.charAt(0) === \"/\") {\n                    target.path = removeDotSegments(relative.path);\n                } else {\n                    if ((base.userinfo !== undefined || base.host !== undefined || base.port !== undefined) && !base.path) {\n                        target.path = \"/\" + relative.path;\n                    } else if (!base.path) {\n                        target.path = relative.path;\n                    } else {\n                        target.path = base.path.slice(0, base.path.lastIndexOf(\"/\") + 1) + relative.path;\n                    }\n                    target.path = removeDotSegments(target.path);\n                }\n                target.query = relative.query;\n            }\n            //target.authority = base.authority;\n            target.userinfo = base.userinfo;\n            target.host = base.host;\n            target.port = base.port;\n        }\n        target.scheme = base.scheme;\n    }\n    target.fragment = relative.fragment;\n    return target;\n}\n\nfunction resolve(baseURI, relativeURI, options) {\n    var schemelessOptions = assign({ scheme: 'null' }, options);\n    return serialize(resolveComponents(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true), schemelessOptions);\n}\n\nfunction normalize(uri, options) {\n    if (typeof uri === \"string\") {\n        uri = serialize(parse(uri, options), options);\n    } else if (typeOf(uri) === \"object\") {\n        uri = parse(serialize(uri, options), options);\n    }\n    return uri;\n}\n\nfunction equal(uriA, uriB, options) {\n    if (typeof uriA === \"string\") {\n        uriA = serialize(parse(uriA, options), options);\n    } else if (typeOf(uriA) === \"object\") {\n        uriA = serialize(uriA, options);\n    }\n    if (typeof uriB === \"string\") {\n        uriB = serialize(parse(uriB, options), options);\n    } else if (typeOf(uriB) === \"object\") {\n        uriB = serialize(uriB, options);\n    }\n    return uriA === uriB;\n}\n\nfunction escapeComponent(str, options) {\n    return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.ESCAPE : IRI_PROTOCOL.ESCAPE, pctEncChar);\n}\n\nfunction unescapeComponent(str, options) {\n    return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.PCT_ENCODED : IRI_PROTOCOL.PCT_ENCODED, pctDecChars);\n}\n\nvar handler = {\n    scheme: \"http\",\n    domainHost: true,\n    parse: function parse(components, options) {\n        //report missing host\n        if (!components.host) {\n            components.error = components.error || \"HTTP URIs must have a host.\";\n        }\n        return components;\n    },\n    serialize: function serialize(components, options) {\n        var secure = String(components.scheme).toLowerCase() === \"https\";\n        //normalize the default port\n        if (components.port === (secure ? 443 : 80) || components.port === \"\") {\n            components.port = undefined;\n        }\n        //normalize the empty path\n        if (!components.path) {\n            components.path = \"/\";\n        }\n        //NOTE: We do not parse query strings for HTTP URIs\n        //as WWW Form Url Encoded query strings are part of the HTML4+ spec,\n        //and not the HTTP spec.\n        return components;\n    }\n};\n\nvar handler$1 = {\n    scheme: \"https\",\n    domainHost: handler.domainHost,\n    parse: handler.parse,\n    serialize: handler.serialize\n};\n\nfunction isSecure(wsComponents) {\n    return typeof wsComponents.secure === 'boolean' ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === \"wss\";\n}\n//RFC 6455\nvar handler$2 = {\n    scheme: \"ws\",\n    domainHost: true,\n    parse: function parse(components, options) {\n        var wsComponents = components;\n        //indicate if the secure flag is set\n        wsComponents.secure = isSecure(wsComponents);\n        //construct resouce name\n        wsComponents.resourceName = (wsComponents.path || '/') + (wsComponents.query ? '?' + wsComponents.query : '');\n        wsComponents.path = undefined;\n        wsComponents.query = undefined;\n        return wsComponents;\n    },\n    serialize: function serialize(wsComponents, options) {\n        //normalize the default port\n        if (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === \"\") {\n            wsComponents.port = undefined;\n        }\n        //ensure scheme matches secure flag\n        if (typeof wsComponents.secure === 'boolean') {\n            wsComponents.scheme = wsComponents.secure ? 'wss' : 'ws';\n            wsComponents.secure = undefined;\n        }\n        //reconstruct path from resource name\n        if (wsComponents.resourceName) {\n            var _wsComponents$resourc = wsComponents.resourceName.split('?'),\n                _wsComponents$resourc2 = slicedToArray(_wsComponents$resourc, 2),\n                path = _wsComponents$resourc2[0],\n                query = _wsComponents$resourc2[1];\n\n            wsComponents.path = path && path !== '/' ? path : undefined;\n            wsComponents.query = query;\n            wsComponents.resourceName = undefined;\n        }\n        //forbid fragment component\n        wsComponents.fragment = undefined;\n        return wsComponents;\n    }\n};\n\nvar handler$3 = {\n    scheme: \"wss\",\n    domainHost: handler$2.domainHost,\n    parse: handler$2.parse,\n    serialize: handler$2.serialize\n};\n\nvar O = {};\nvar isIRI = true;\n//RFC 3986\nvar UNRESERVED$$ = \"[A-Za-z0-9\\\\-\\\\.\\\\_\\\\~\" + (isIRI ? \"\\\\xA0-\\\\u200D\\\\u2010-\\\\u2029\\\\u202F-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFEF\" : \"\") + \"]\";\nvar HEXDIG$$ = \"[0-9A-Fa-f]\"; //case-insensitive\nvar PCT_ENCODED$ = subexp(subexp(\"%[EFef]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%[89A-Fa-f]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%\" + HEXDIG$$ + HEXDIG$$)); //expanded\n//RFC 5322, except these symbols as per RFC 6068: @ : / ? # [ ] & ; =\n//const ATEXT$$ = \"[A-Za-z0-9\\\\!\\\\#\\\\$\\\\%\\\\&\\\\'\\\\*\\\\+\\\\-\\\\/\\\\=\\\\?\\\\^\\\\_\\\\`\\\\{\\\\|\\\\}\\\\~]\";\n//const WSP$$ = \"[\\\\x20\\\\x09]\";\n//const OBS_QTEXT$$ = \"[\\\\x01-\\\\x08\\\\x0B\\\\x0C\\\\x0E-\\\\x1F\\\\x7F]\";  //(%d1-8 / %d11-12 / %d14-31 / %d127)\n//const QTEXT$$ = merge(\"[\\\\x21\\\\x23-\\\\x5B\\\\x5D-\\\\x7E]\", OBS_QTEXT$$);  //%d33 / %d35-91 / %d93-126 / obs-qtext\n//const VCHAR$$ = \"[\\\\x21-\\\\x7E]\";\n//const WSP$$ = \"[\\\\x20\\\\x09]\";\n//const OBS_QP$ = subexp(\"\\\\\\\\\" + merge(\"[\\\\x00\\\\x0D\\\\x0A]\", OBS_QTEXT$$));  //%d0 / CR / LF / obs-qtext\n//const FWS$ = subexp(subexp(WSP$$ + \"*\" + \"\\\\x0D\\\\x0A\") + \"?\" + WSP$$ + \"+\");\n//const QUOTED_PAIR$ = subexp(subexp(\"\\\\\\\\\" + subexp(VCHAR$$ + \"|\" + WSP$$)) + \"|\" + OBS_QP$);\n//const QUOTED_STRING$ = subexp('\\\\\"' + subexp(FWS$ + \"?\" + QCONTENT$) + \"*\" + FWS$ + \"?\" + '\\\\\"');\nvar ATEXT$$ = \"[A-Za-z0-9\\\\!\\\\$\\\\%\\\\'\\\\*\\\\+\\\\-\\\\^\\\\_\\\\`\\\\{\\\\|\\\\}\\\\~]\";\nvar QTEXT$$ = \"[\\\\!\\\\$\\\\%\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\-\\\\.0-9\\\\<\\\\>A-Z\\\\x5E-\\\\x7E]\";\nvar VCHAR$$ = merge(QTEXT$$, \"[\\\\\\\"\\\\\\\\]\");\nvar SOME_DELIMS$$ = \"[\\\\!\\\\$\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\;\\\\:\\\\@]\";\nvar UNRESERVED = new RegExp(UNRESERVED$$, \"g\");\nvar PCT_ENCODED = new RegExp(PCT_ENCODED$, \"g\");\nvar NOT_LOCAL_PART = new RegExp(merge(\"[^]\", ATEXT$$, \"[\\\\.]\", '[\\\\\"]', VCHAR$$), \"g\");\nvar NOT_HFNAME = new RegExp(merge(\"[^]\", UNRESERVED$$, SOME_DELIMS$$), \"g\");\nvar NOT_HFVALUE = NOT_HFNAME;\nfunction decodeUnreserved(str) {\n    var decStr = pctDecChars(str);\n    return !decStr.match(UNRESERVED) ? str : decStr;\n}\nvar handler$4 = {\n    scheme: \"mailto\",\n    parse: function parse$$1(components, options) {\n        var mailtoComponents = components;\n        var to = mailtoComponents.to = mailtoComponents.path ? mailtoComponents.path.split(\",\") : [];\n        mailtoComponents.path = undefined;\n        if (mailtoComponents.query) {\n            var unknownHeaders = false;\n            var headers = {};\n            var hfields = mailtoComponents.query.split(\"&\");\n            for (var x = 0, xl = hfields.length; x < xl; ++x) {\n                var hfield = hfields[x].split(\"=\");\n                switch (hfield[0]) {\n                    case \"to\":\n                        var toAddrs = hfield[1].split(\",\");\n                        for (var _x = 0, _xl = toAddrs.length; _x < _xl; ++_x) {\n                            to.push(toAddrs[_x]);\n                        }\n                        break;\n                    case \"subject\":\n                        mailtoComponents.subject = unescapeComponent(hfield[1], options);\n                        break;\n                    case \"body\":\n                        mailtoComponents.body = unescapeComponent(hfield[1], options);\n                        break;\n                    default:\n                        unknownHeaders = true;\n                        headers[unescapeComponent(hfield[0], options)] = unescapeComponent(hfield[1], options);\n                        break;\n                }\n            }\n            if (unknownHeaders) mailtoComponents.headers = headers;\n        }\n        mailtoComponents.query = undefined;\n        for (var _x2 = 0, _xl2 = to.length; _x2 < _xl2; ++_x2) {\n            var addr = to[_x2].split(\"@\");\n            addr[0] = unescapeComponent(addr[0]);\n            if (!options.unicodeSupport) {\n                //convert Unicode IDN -> ASCII IDN\n                try {\n                    addr[1] = punycode.toASCII(unescapeComponent(addr[1], options).toLowerCase());\n                } catch (e) {\n                    mailtoComponents.error = mailtoComponents.error || \"Email address's domain name can not be converted to ASCII via punycode: \" + e;\n                }\n            } else {\n                addr[1] = unescapeComponent(addr[1], options).toLowerCase();\n            }\n            to[_x2] = addr.join(\"@\");\n        }\n        return mailtoComponents;\n    },\n    serialize: function serialize$$1(mailtoComponents, options) {\n        var components = mailtoComponents;\n        var to = toArray(mailtoComponents.to);\n        if (to) {\n            for (var x = 0, xl = to.length; x < xl; ++x) {\n                var toAddr = String(to[x]);\n                var atIdx = toAddr.lastIndexOf(\"@\");\n                var localPart = toAddr.slice(0, atIdx).replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_LOCAL_PART, pctEncChar);\n                var domain = toAddr.slice(atIdx + 1);\n                //convert IDN via punycode\n                try {\n                    domain = !options.iri ? punycode.toASCII(unescapeComponent(domain, options).toLowerCase()) : punycode.toUnicode(domain);\n                } catch (e) {\n                    components.error = components.error || \"Email address's domain name can not be converted to \" + (!options.iri ? \"ASCII\" : \"Unicode\") + \" via punycode: \" + e;\n                }\n                to[x] = localPart + \"@\" + domain;\n            }\n            components.path = to.join(\",\");\n        }\n        var headers = mailtoComponents.headers = mailtoComponents.headers || {};\n        if (mailtoComponents.subject) headers[\"subject\"] = mailtoComponents.subject;\n        if (mailtoComponents.body) headers[\"body\"] = mailtoComponents.body;\n        var fields = [];\n        for (var name in headers) {\n            if (headers[name] !== O[name]) {\n                fields.push(name.replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFNAME, pctEncChar) + \"=\" + headers[name].replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFVALUE, pctEncChar));\n            }\n        }\n        if (fields.length) {\n            components.query = fields.join(\"&\");\n        }\n        return components;\n    }\n};\n\nvar URN_PARSE = /^([^\\:]+)\\:(.*)/;\n//RFC 2141\nvar handler$5 = {\n    scheme: \"urn\",\n    parse: function parse$$1(components, options) {\n        var matches = components.path && components.path.match(URN_PARSE);\n        var urnComponents = components;\n        if (matches) {\n            var scheme = options.scheme || urnComponents.scheme || \"urn\";\n            var nid = matches[1].toLowerCase();\n            var nss = matches[2];\n            var urnScheme = scheme + \":\" + (options.nid || nid);\n            var schemeHandler = SCHEMES[urnScheme];\n            urnComponents.nid = nid;\n            urnComponents.nss = nss;\n            urnComponents.path = undefined;\n            if (schemeHandler) {\n                urnComponents = schemeHandler.parse(urnComponents, options);\n            }\n        } else {\n            urnComponents.error = urnComponents.error || \"URN can not be parsed.\";\n        }\n        return urnComponents;\n    },\n    serialize: function serialize$$1(urnComponents, options) {\n        var scheme = options.scheme || urnComponents.scheme || \"urn\";\n        var nid = urnComponents.nid;\n        var urnScheme = scheme + \":\" + (options.nid || nid);\n        var schemeHandler = SCHEMES[urnScheme];\n        if (schemeHandler) {\n            urnComponents = schemeHandler.serialize(urnComponents, options);\n        }\n        var uriComponents = urnComponents;\n        var nss = urnComponents.nss;\n        uriComponents.path = (nid || options.nid) + \":\" + nss;\n        return uriComponents;\n    }\n};\n\nvar UUID = /^[0-9A-Fa-f]{8}(?:\\-[0-9A-Fa-f]{4}){3}\\-[0-9A-Fa-f]{12}$/;\n//RFC 4122\nvar handler$6 = {\n    scheme: \"urn:uuid\",\n    parse: function parse(urnComponents, options) {\n        var uuidComponents = urnComponents;\n        uuidComponents.uuid = uuidComponents.nss;\n        uuidComponents.nss = undefined;\n        if (!options.tolerant && (!uuidComponents.uuid || !uuidComponents.uuid.match(UUID))) {\n            uuidComponents.error = uuidComponents.error || \"UUID is not valid.\";\n        }\n        return uuidComponents;\n    },\n    serialize: function serialize(uuidComponents, options) {\n        var urnComponents = uuidComponents;\n        //normalize UUID\n        urnComponents.nss = (uuidComponents.uuid || \"\").toLowerCase();\n        return urnComponents;\n    }\n};\n\nSCHEMES[handler.scheme] = handler;\nSCHEMES[handler$1.scheme] = handler$1;\nSCHEMES[handler$2.scheme] = handler$2;\nSCHEMES[handler$3.scheme] = handler$3;\nSCHEMES[handler$4.scheme] = handler$4;\nSCHEMES[handler$5.scheme] = handler$5;\nSCHEMES[handler$6.scheme] = handler$6;\n\nexports.SCHEMES = SCHEMES;\nexports.pctEncChar = pctEncChar;\nexports.pctDecChars = pctDecChars;\nexports.parse = parse;\nexports.removeDotSegments = removeDotSegments;\nexports.serialize = serialize;\nexports.resolveComponents = resolveComponents;\nexports.resolve = resolve;\nexports.normalize = normalize;\nexports.equal = equal;\nexports.escapeComponent = escapeComponent;\nexports.unescapeComponent = unescapeComponent;\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n})));\n//# sourceMappingURL=uri.all.js.map\n\n\n//# sourceURL=webpack://javascript/./node_modules/uri-js/dist/es5/uri.all.js?");

/***/ }),

/***/ "./node_modules/util/support/isBufferBrowser.js":
/*!******************************************************!*\
  !*** ./node_modules/util/support/isBufferBrowser.js ***!
  \******************************************************/
/***/ ((module) => {

eval("module.exports = function isBuffer(arg) {\n  return arg && typeof arg === 'object'\n    && typeof arg.copy === 'function'\n    && typeof arg.fill === 'function'\n    && typeof arg.readUInt8 === 'function';\n}\n\n//# sourceURL=webpack://javascript/./node_modules/util/support/isBufferBrowser.js?");

/***/ }),

/***/ "./node_modules/util/support/types.js":
/*!********************************************!*\
  !*** ./node_modules/util/support/types.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("// Currently in sync with Node.js lib/internal/util/types.js\n// https://github.com/nodejs/node/commit/112cc7c27551254aa2b17098fb774867f05ed0d9\n\n\n\nvar isArgumentsObject = __webpack_require__(/*! is-arguments */ \"./node_modules/is-arguments/index.js\");\nvar isGeneratorFunction = __webpack_require__(/*! is-generator-function */ \"./node_modules/is-generator-function/index.js\");\nvar whichTypedArray = __webpack_require__(/*! which-typed-array */ \"./node_modules/which-typed-array/index.js\");\nvar isTypedArray = __webpack_require__(/*! is-typed-array */ \"./node_modules/is-typed-array/index.js\");\n\nfunction uncurryThis(f) {\n  return f.call.bind(f);\n}\n\nvar BigIntSupported = typeof BigInt !== 'undefined';\nvar SymbolSupported = typeof Symbol !== 'undefined';\n\nvar ObjectToString = uncurryThis(Object.prototype.toString);\n\nvar numberValue = uncurryThis(Number.prototype.valueOf);\nvar stringValue = uncurryThis(String.prototype.valueOf);\nvar booleanValue = uncurryThis(Boolean.prototype.valueOf);\n\nif (BigIntSupported) {\n  var bigIntValue = uncurryThis(BigInt.prototype.valueOf);\n}\n\nif (SymbolSupported) {\n  var symbolValue = uncurryThis(Symbol.prototype.valueOf);\n}\n\nfunction checkBoxedPrimitive(value, prototypeValueOf) {\n  if (typeof value !== 'object') {\n    return false;\n  }\n  try {\n    prototypeValueOf(value);\n    return true;\n  } catch(e) {\n    return false;\n  }\n}\n\nexports.isArgumentsObject = isArgumentsObject;\nexports.isGeneratorFunction = isGeneratorFunction;\nexports.isTypedArray = isTypedArray;\n\n// Taken from here and modified for better browser support\n// https://github.com/sindresorhus/p-is-promise/blob/cda35a513bda03f977ad5cde3a079d237e82d7ef/index.js\nfunction isPromise(input) {\n\treturn (\n\t\t(\n\t\t\ttypeof Promise !== 'undefined' &&\n\t\t\tinput instanceof Promise\n\t\t) ||\n\t\t(\n\t\t\tinput !== null &&\n\t\t\ttypeof input === 'object' &&\n\t\t\ttypeof input.then === 'function' &&\n\t\t\ttypeof input.catch === 'function'\n\t\t)\n\t);\n}\nexports.isPromise = isPromise;\n\nfunction isArrayBufferView(value) {\n  if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {\n    return ArrayBuffer.isView(value);\n  }\n\n  return (\n    isTypedArray(value) ||\n    isDataView(value)\n  );\n}\nexports.isArrayBufferView = isArrayBufferView;\n\n\nfunction isUint8Array(value) {\n  return whichTypedArray(value) === 'Uint8Array';\n}\nexports.isUint8Array = isUint8Array;\n\nfunction isUint8ClampedArray(value) {\n  return whichTypedArray(value) === 'Uint8ClampedArray';\n}\nexports.isUint8ClampedArray = isUint8ClampedArray;\n\nfunction isUint16Array(value) {\n  return whichTypedArray(value) === 'Uint16Array';\n}\nexports.isUint16Array = isUint16Array;\n\nfunction isUint32Array(value) {\n  return whichTypedArray(value) === 'Uint32Array';\n}\nexports.isUint32Array = isUint32Array;\n\nfunction isInt8Array(value) {\n  return whichTypedArray(value) === 'Int8Array';\n}\nexports.isInt8Array = isInt8Array;\n\nfunction isInt16Array(value) {\n  return whichTypedArray(value) === 'Int16Array';\n}\nexports.isInt16Array = isInt16Array;\n\nfunction isInt32Array(value) {\n  return whichTypedArray(value) === 'Int32Array';\n}\nexports.isInt32Array = isInt32Array;\n\nfunction isFloat32Array(value) {\n  return whichTypedArray(value) === 'Float32Array';\n}\nexports.isFloat32Array = isFloat32Array;\n\nfunction isFloat64Array(value) {\n  return whichTypedArray(value) === 'Float64Array';\n}\nexports.isFloat64Array = isFloat64Array;\n\nfunction isBigInt64Array(value) {\n  return whichTypedArray(value) === 'BigInt64Array';\n}\nexports.isBigInt64Array = isBigInt64Array;\n\nfunction isBigUint64Array(value) {\n  return whichTypedArray(value) === 'BigUint64Array';\n}\nexports.isBigUint64Array = isBigUint64Array;\n\nfunction isMapToString(value) {\n  return ObjectToString(value) === '[object Map]';\n}\nisMapToString.working = (\n  typeof Map !== 'undefined' &&\n  isMapToString(new Map())\n);\n\nfunction isMap(value) {\n  if (typeof Map === 'undefined') {\n    return false;\n  }\n\n  return isMapToString.working\n    ? isMapToString(value)\n    : value instanceof Map;\n}\nexports.isMap = isMap;\n\nfunction isSetToString(value) {\n  return ObjectToString(value) === '[object Set]';\n}\nisSetToString.working = (\n  typeof Set !== 'undefined' &&\n  isSetToString(new Set())\n);\nfunction isSet(value) {\n  if (typeof Set === 'undefined') {\n    return false;\n  }\n\n  return isSetToString.working\n    ? isSetToString(value)\n    : value instanceof Set;\n}\nexports.isSet = isSet;\n\nfunction isWeakMapToString(value) {\n  return ObjectToString(value) === '[object WeakMap]';\n}\nisWeakMapToString.working = (\n  typeof WeakMap !== 'undefined' &&\n  isWeakMapToString(new WeakMap())\n);\nfunction isWeakMap(value) {\n  if (typeof WeakMap === 'undefined') {\n    return false;\n  }\n\n  return isWeakMapToString.working\n    ? isWeakMapToString(value)\n    : value instanceof WeakMap;\n}\nexports.isWeakMap = isWeakMap;\n\nfunction isWeakSetToString(value) {\n  return ObjectToString(value) === '[object WeakSet]';\n}\nisWeakSetToString.working = (\n  typeof WeakSet !== 'undefined' &&\n  isWeakSetToString(new WeakSet())\n);\nfunction isWeakSet(value) {\n  return isWeakSetToString(value);\n}\nexports.isWeakSet = isWeakSet;\n\nfunction isArrayBufferToString(value) {\n  return ObjectToString(value) === '[object ArrayBuffer]';\n}\nisArrayBufferToString.working = (\n  typeof ArrayBuffer !== 'undefined' &&\n  isArrayBufferToString(new ArrayBuffer())\n);\nfunction isArrayBuffer(value) {\n  if (typeof ArrayBuffer === 'undefined') {\n    return false;\n  }\n\n  return isArrayBufferToString.working\n    ? isArrayBufferToString(value)\n    : value instanceof ArrayBuffer;\n}\nexports.isArrayBuffer = isArrayBuffer;\n\nfunction isDataViewToString(value) {\n  return ObjectToString(value) === '[object DataView]';\n}\nisDataViewToString.working = (\n  typeof ArrayBuffer !== 'undefined' &&\n  typeof DataView !== 'undefined' &&\n  isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1))\n);\nfunction isDataView(value) {\n  if (typeof DataView === 'undefined') {\n    return false;\n  }\n\n  return isDataViewToString.working\n    ? isDataViewToString(value)\n    : value instanceof DataView;\n}\nexports.isDataView = isDataView;\n\n// Store a copy of SharedArrayBuffer in case it's deleted elsewhere\nvar SharedArrayBufferCopy = typeof SharedArrayBuffer !== 'undefined' ? SharedArrayBuffer : undefined;\nfunction isSharedArrayBufferToString(value) {\n  return ObjectToString(value) === '[object SharedArrayBuffer]';\n}\nfunction isSharedArrayBuffer(value) {\n  if (typeof SharedArrayBufferCopy === 'undefined') {\n    return false;\n  }\n\n  if (typeof isSharedArrayBufferToString.working === 'undefined') {\n    isSharedArrayBufferToString.working = isSharedArrayBufferToString(new SharedArrayBufferCopy());\n  }\n\n  return isSharedArrayBufferToString.working\n    ? isSharedArrayBufferToString(value)\n    : value instanceof SharedArrayBufferCopy;\n}\nexports.isSharedArrayBuffer = isSharedArrayBuffer;\n\nfunction isAsyncFunction(value) {\n  return ObjectToString(value) === '[object AsyncFunction]';\n}\nexports.isAsyncFunction = isAsyncFunction;\n\nfunction isMapIterator(value) {\n  return ObjectToString(value) === '[object Map Iterator]';\n}\nexports.isMapIterator = isMapIterator;\n\nfunction isSetIterator(value) {\n  return ObjectToString(value) === '[object Set Iterator]';\n}\nexports.isSetIterator = isSetIterator;\n\nfunction isGeneratorObject(value) {\n  return ObjectToString(value) === '[object Generator]';\n}\nexports.isGeneratorObject = isGeneratorObject;\n\nfunction isWebAssemblyCompiledModule(value) {\n  return ObjectToString(value) === '[object WebAssembly.Module]';\n}\nexports.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;\n\nfunction isNumberObject(value) {\n  return checkBoxedPrimitive(value, numberValue);\n}\nexports.isNumberObject = isNumberObject;\n\nfunction isStringObject(value) {\n  return checkBoxedPrimitive(value, stringValue);\n}\nexports.isStringObject = isStringObject;\n\nfunction isBooleanObject(value) {\n  return checkBoxedPrimitive(value, booleanValue);\n}\nexports.isBooleanObject = isBooleanObject;\n\nfunction isBigIntObject(value) {\n  return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);\n}\nexports.isBigIntObject = isBigIntObject;\n\nfunction isSymbolObject(value) {\n  return SymbolSupported && checkBoxedPrimitive(value, symbolValue);\n}\nexports.isSymbolObject = isSymbolObject;\n\nfunction isBoxedPrimitive(value) {\n  return (\n    isNumberObject(value) ||\n    isStringObject(value) ||\n    isBooleanObject(value) ||\n    isBigIntObject(value) ||\n    isSymbolObject(value)\n  );\n}\nexports.isBoxedPrimitive = isBoxedPrimitive;\n\nfunction isAnyArrayBuffer(value) {\n  return typeof Uint8Array !== 'undefined' && (\n    isArrayBuffer(value) ||\n    isSharedArrayBuffer(value)\n  );\n}\nexports.isAnyArrayBuffer = isAnyArrayBuffer;\n\n['isProxy', 'isExternal', 'isModuleNamespaceObject'].forEach(function(method) {\n  Object.defineProperty(exports, method, {\n    enumerable: false,\n    value: function() {\n      throw new Error(method + ' is not supported in userland');\n    }\n  });\n});\n\n\n//# sourceURL=webpack://javascript/./node_modules/util/support/types.js?");

/***/ }),

/***/ "./node_modules/util/util.js":
/*!***********************************!*\
  !*** ./node_modules/util/util.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/* provided dependency */ var process = __webpack_require__(/*! ./node_modules/process/browser.js */ \"./node_modules/process/browser.js\");\n/* provided dependency */ var console = __webpack_require__(/*! ./node_modules/console-browserify/index.js */ \"./node_modules/console-browserify/index.js\");\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors ||\n  function getOwnPropertyDescriptors(obj) {\n    var keys = Object.keys(obj);\n    var descriptors = {};\n    for (var i = 0; i < keys.length; i++) {\n      descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);\n    }\n    return descriptors;\n  };\n\nvar formatRegExp = /%[sdj%]/g;\nexports.format = function(f) {\n  if (!isString(f)) {\n    var objects = [];\n    for (var i = 0; i < arguments.length; i++) {\n      objects.push(inspect(arguments[i]));\n    }\n    return objects.join(' ');\n  }\n\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  var str = String(f).replace(formatRegExp, function(x) {\n    if (x === '%%') return '%';\n    if (i >= len) return x;\n    switch (x) {\n      case '%s': return String(args[i++]);\n      case '%d': return Number(args[i++]);\n      case '%j':\n        try {\n          return JSON.stringify(args[i++]);\n        } catch (_) {\n          return '[Circular]';\n        }\n      default:\n        return x;\n    }\n  });\n  for (var x = args[i]; i < len; x = args[++i]) {\n    if (isNull(x) || !isObject(x)) {\n      str += ' ' + x;\n    } else {\n      str += ' ' + inspect(x);\n    }\n  }\n  return str;\n};\n\n\n// Mark that a method should not be used.\n// Returns a modified function which warns once by default.\n// If --no-deprecation is set, then it is a no-op.\nexports.deprecate = function(fn, msg) {\n  if (typeof process !== 'undefined' && process.noDeprecation === true) {\n    return fn;\n  }\n\n  // Allow for deprecating things in the process of starting up.\n  if (typeof process === 'undefined') {\n    return function() {\n      return exports.deprecate(fn, msg).apply(this, arguments);\n    };\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (process.throwDeprecation) {\n        throw new Error(msg);\n      } else if (process.traceDeprecation) {\n        console.trace(msg);\n      } else {\n        console.error(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n};\n\n\nvar debugs = {};\nvar debugEnvRegex = /^$/;\n\nif (process.env.NODE_DEBUG) {\n  var debugEnv = process.env.NODE_DEBUG;\n  debugEnv = debugEnv.replace(/[|\\\\{}()[\\]^$+?.]/g, '\\\\$&')\n    .replace(/\\*/g, '.*')\n    .replace(/,/g, '$|^')\n    .toUpperCase();\n  debugEnvRegex = new RegExp('^' + debugEnv + '$', 'i');\n}\nexports.debuglog = function(set) {\n  set = set.toUpperCase();\n  if (!debugs[set]) {\n    if (debugEnvRegex.test(set)) {\n      var pid = process.pid;\n      debugs[set] = function() {\n        var msg = exports.format.apply(exports, arguments);\n        console.error('%s %d: %s', set, pid, msg);\n      };\n    } else {\n      debugs[set] = function() {};\n    }\n  }\n  return debugs[set];\n};\n\n\n/**\n * Echos the value of a value. Trys to print the value out\n * in the best way possible given the different types.\n *\n * @param {Object} obj The object to print out.\n * @param {Object} opts Optional options object that alters the output.\n */\n/* legacy: obj, showHidden, depth, colors*/\nfunction inspect(obj, opts) {\n  // default options\n  var ctx = {\n    seen: [],\n    stylize: stylizeNoColor\n  };\n  // legacy...\n  if (arguments.length >= 3) ctx.depth = arguments[2];\n  if (arguments.length >= 4) ctx.colors = arguments[3];\n  if (isBoolean(opts)) {\n    // legacy...\n    ctx.showHidden = opts;\n  } else if (opts) {\n    // got an \"options\" object\n    exports._extend(ctx, opts);\n  }\n  // set default options\n  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;\n  if (isUndefined(ctx.depth)) ctx.depth = 2;\n  if (isUndefined(ctx.colors)) ctx.colors = false;\n  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;\n  if (ctx.colors) ctx.stylize = stylizeWithColor;\n  return formatValue(ctx, obj, ctx.depth);\n}\nexports.inspect = inspect;\n\n\n// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\ninspect.colors = {\n  'bold' : [1, 22],\n  'italic' : [3, 23],\n  'underline' : [4, 24],\n  'inverse' : [7, 27],\n  'white' : [37, 39],\n  'grey' : [90, 39],\n  'black' : [30, 39],\n  'blue' : [34, 39],\n  'cyan' : [36, 39],\n  'green' : [32, 39],\n  'magenta' : [35, 39],\n  'red' : [31, 39],\n  'yellow' : [33, 39]\n};\n\n// Don't use 'blue' not visible on cmd.exe\ninspect.styles = {\n  'special': 'cyan',\n  'number': 'yellow',\n  'boolean': 'yellow',\n  'undefined': 'grey',\n  'null': 'bold',\n  'string': 'green',\n  'date': 'magenta',\n  // \"name\": intentionally not styling\n  'regexp': 'red'\n};\n\n\nfunction stylizeWithColor(str, styleType) {\n  var style = inspect.styles[styleType];\n\n  if (style) {\n    return '\\u001b[' + inspect.colors[style][0] + 'm' + str +\n           '\\u001b[' + inspect.colors[style][1] + 'm';\n  } else {\n    return str;\n  }\n}\n\n\nfunction stylizeNoColor(str, styleType) {\n  return str;\n}\n\n\nfunction arrayToHash(array) {\n  var hash = {};\n\n  array.forEach(function(val, idx) {\n    hash[val] = true;\n  });\n\n  return hash;\n}\n\n\nfunction formatValue(ctx, value, recurseTimes) {\n  // Provide a hook for user-specified inspect functions.\n  // Check that value is an object with an inspect function on it\n  if (ctx.customInspect &&\n      value &&\n      isFunction(value.inspect) &&\n      // Filter out the util module, it's inspect function is special\n      value.inspect !== exports.inspect &&\n      // Also filter out any prototype objects using the circular check.\n      !(value.constructor && value.constructor.prototype === value)) {\n    var ret = value.inspect(recurseTimes, ctx);\n    if (!isString(ret)) {\n      ret = formatValue(ctx, ret, recurseTimes);\n    }\n    return ret;\n  }\n\n  // Primitive types cannot have properties\n  var primitive = formatPrimitive(ctx, value);\n  if (primitive) {\n    return primitive;\n  }\n\n  // Look up the keys of the object.\n  var keys = Object.keys(value);\n  var visibleKeys = arrayToHash(keys);\n\n  if (ctx.showHidden) {\n    keys = Object.getOwnPropertyNames(value);\n  }\n\n  // IE doesn't make error fields non-enumerable\n  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx\n  if (isError(value)\n      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {\n    return formatError(value);\n  }\n\n  // Some type of object without properties can be shortcutted.\n  if (keys.length === 0) {\n    if (isFunction(value)) {\n      var name = value.name ? ': ' + value.name : '';\n      return ctx.stylize('[Function' + name + ']', 'special');\n    }\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    }\n    if (isDate(value)) {\n      return ctx.stylize(Date.prototype.toString.call(value), 'date');\n    }\n    if (isError(value)) {\n      return formatError(value);\n    }\n  }\n\n  var base = '', array = false, braces = ['{', '}'];\n\n  // Make Array say that they are Array\n  if (isArray(value)) {\n    array = true;\n    braces = ['[', ']'];\n  }\n\n  // Make functions say that they are functions\n  if (isFunction(value)) {\n    var n = value.name ? ': ' + value.name : '';\n    base = ' [Function' + n + ']';\n  }\n\n  // Make RegExps say that they are RegExps\n  if (isRegExp(value)) {\n    base = ' ' + RegExp.prototype.toString.call(value);\n  }\n\n  // Make dates with properties first say the date\n  if (isDate(value)) {\n    base = ' ' + Date.prototype.toUTCString.call(value);\n  }\n\n  // Make error with message first say the error\n  if (isError(value)) {\n    base = ' ' + formatError(value);\n  }\n\n  if (keys.length === 0 && (!array || value.length == 0)) {\n    return braces[0] + base + braces[1];\n  }\n\n  if (recurseTimes < 0) {\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    } else {\n      return ctx.stylize('[Object]', 'special');\n    }\n  }\n\n  ctx.seen.push(value);\n\n  var output;\n  if (array) {\n    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n  } else {\n    output = keys.map(function(key) {\n      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n    });\n  }\n\n  ctx.seen.pop();\n\n  return reduceToSingleString(output, base, braces);\n}\n\n\nfunction formatPrimitive(ctx, value) {\n  if (isUndefined(value))\n    return ctx.stylize('undefined', 'undefined');\n  if (isString(value)) {\n    var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n                                             .replace(/'/g, \"\\\\'\")\n                                             .replace(/\\\\\"/g, '\"') + '\\'';\n    return ctx.stylize(simple, 'string');\n  }\n  if (isNumber(value))\n    return ctx.stylize('' + value, 'number');\n  if (isBoolean(value))\n    return ctx.stylize('' + value, 'boolean');\n  // For some reason typeof null is \"object\", so special case here.\n  if (isNull(value))\n    return ctx.stylize('null', 'null');\n}\n\n\nfunction formatError(value) {\n  return '[' + Error.prototype.toString.call(value) + ']';\n}\n\n\nfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n  var output = [];\n  for (var i = 0, l = value.length; i < l; ++i) {\n    if (hasOwnProperty(value, String(i))) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          String(i), true));\n    } else {\n      output.push('');\n    }\n  }\n  keys.forEach(function(key) {\n    if (!key.match(/^\\d+$/)) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          key, true));\n    }\n  });\n  return output;\n}\n\n\nfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n  var name, str, desc;\n  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };\n  if (desc.get) {\n    if (desc.set) {\n      str = ctx.stylize('[Getter/Setter]', 'special');\n    } else {\n      str = ctx.stylize('[Getter]', 'special');\n    }\n  } else {\n    if (desc.set) {\n      str = ctx.stylize('[Setter]', 'special');\n    }\n  }\n  if (!hasOwnProperty(visibleKeys, key)) {\n    name = '[' + key + ']';\n  }\n  if (!str) {\n    if (ctx.seen.indexOf(desc.value) < 0) {\n      if (isNull(recurseTimes)) {\n        str = formatValue(ctx, desc.value, null);\n      } else {\n        str = formatValue(ctx, desc.value, recurseTimes - 1);\n      }\n      if (str.indexOf('\\n') > -1) {\n        if (array) {\n          str = str.split('\\n').map(function(line) {\n            return '  ' + line;\n          }).join('\\n').substr(2);\n        } else {\n          str = '\\n' + str.split('\\n').map(function(line) {\n            return '   ' + line;\n          }).join('\\n');\n        }\n      }\n    } else {\n      str = ctx.stylize('[Circular]', 'special');\n    }\n  }\n  if (isUndefined(name)) {\n    if (array && key.match(/^\\d+$/)) {\n      return str;\n    }\n    name = JSON.stringify('' + key);\n    if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n      name = name.substr(1, name.length - 2);\n      name = ctx.stylize(name, 'name');\n    } else {\n      name = name.replace(/'/g, \"\\\\'\")\n                 .replace(/\\\\\"/g, '\"')\n                 .replace(/(^\"|\"$)/g, \"'\");\n      name = ctx.stylize(name, 'string');\n    }\n  }\n\n  return name + ': ' + str;\n}\n\n\nfunction reduceToSingleString(output, base, braces) {\n  var numLinesEst = 0;\n  var length = output.reduce(function(prev, cur) {\n    numLinesEst++;\n    if (cur.indexOf('\\n') >= 0) numLinesEst++;\n    return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, '').length + 1;\n  }, 0);\n\n  if (length > 60) {\n    return braces[0] +\n           (base === '' ? '' : base + '\\n ') +\n           ' ' +\n           output.join(',\\n  ') +\n           ' ' +\n           braces[1];\n  }\n\n  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n}\n\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\nexports.types = __webpack_require__(/*! ./support/types */ \"./node_modules/util/support/types.js\");\n\nfunction isArray(ar) {\n  return Array.isArray(ar);\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return isObject(re) && objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\nexports.types.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return isObject(d) && objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\nexports.types.isDate = isDate;\n\nfunction isError(e) {\n  return isObject(e) &&\n      (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\nexports.types.isNativeError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = __webpack_require__(/*! ./support/isBuffer */ \"./node_modules/util/support/isBufferBrowser.js\");\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n\nfunction pad(n) {\n  return n < 10 ? '0' + n.toString(10) : n.toString(10);\n}\n\n\nvar months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\n              'Oct', 'Nov', 'Dec'];\n\n// 26 Feb 16:19:34\nfunction timestamp() {\n  var d = new Date();\n  var time = [pad(d.getHours()),\n              pad(d.getMinutes()),\n              pad(d.getSeconds())].join(':');\n  return [d.getDate(), months[d.getMonth()], time].join(' ');\n}\n\n\n// log is just a thin wrapper to console.log that prepends a timestamp\nexports.log = function() {\n  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));\n};\n\n\n/**\n * Inherit the prototype methods from one constructor into another.\n *\n * The Function.prototype.inherits from lang.js rewritten as a standalone\n * function (not on Function.prototype). NOTE: If this file is to be loaded\n * during bootstrapping this function needs to be rewritten using some native\n * functions as prototype setup using normal JavaScript does not work as\n * expected during bootstrapping (see mirror.js in r114903).\n *\n * @param {function} ctor Constructor function which needs to inherit the\n *     prototype.\n * @param {function} superCtor Constructor function to inherit prototype from.\n */\nexports.inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\");\n\nexports._extend = function(origin, add) {\n  // Don't do anything if add isn't an object\n  if (!add || !isObject(add)) return origin;\n\n  var keys = Object.keys(add);\n  var i = keys.length;\n  while (i--) {\n    origin[keys[i]] = add[keys[i]];\n  }\n  return origin;\n};\n\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nvar kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;\n\nexports.promisify = function promisify(original) {\n  if (typeof original !== 'function')\n    throw new TypeError('The \"original\" argument must be of type Function');\n\n  if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {\n    var fn = original[kCustomPromisifiedSymbol];\n    if (typeof fn !== 'function') {\n      throw new TypeError('The \"util.promisify.custom\" argument must be of type Function');\n    }\n    Object.defineProperty(fn, kCustomPromisifiedSymbol, {\n      value: fn, enumerable: false, writable: false, configurable: true\n    });\n    return fn;\n  }\n\n  function fn() {\n    var promiseResolve, promiseReject;\n    var promise = new Promise(function (resolve, reject) {\n      promiseResolve = resolve;\n      promiseReject = reject;\n    });\n\n    var args = [];\n    for (var i = 0; i < arguments.length; i++) {\n      args.push(arguments[i]);\n    }\n    args.push(function (err, value) {\n      if (err) {\n        promiseReject(err);\n      } else {\n        promiseResolve(value);\n      }\n    });\n\n    try {\n      original.apply(this, args);\n    } catch (err) {\n      promiseReject(err);\n    }\n\n    return promise;\n  }\n\n  Object.setPrototypeOf(fn, Object.getPrototypeOf(original));\n\n  if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {\n    value: fn, enumerable: false, writable: false, configurable: true\n  });\n  return Object.defineProperties(\n    fn,\n    getOwnPropertyDescriptors(original)\n  );\n}\n\nexports.promisify.custom = kCustomPromisifiedSymbol\n\nfunction callbackifyOnRejected(reason, cb) {\n  // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).\n  // Because `null` is a special error value in callbacks which means \"no error\n  // occurred\", we error-wrap so the callback consumer can distinguish between\n  // \"the promise rejected with null\" or \"the promise fulfilled with undefined\".\n  if (!reason) {\n    var newReason = new Error('Promise was rejected with a falsy value');\n    newReason.reason = reason;\n    reason = newReason;\n  }\n  return cb(reason);\n}\n\nfunction callbackify(original) {\n  if (typeof original !== 'function') {\n    throw new TypeError('The \"original\" argument must be of type Function');\n  }\n\n  // We DO NOT return the promise as it gives the user a false sense that\n  // the promise is actually somehow related to the callback's execution\n  // and that the callback throwing will reject the promise.\n  function callbackified() {\n    var args = [];\n    for (var i = 0; i < arguments.length; i++) {\n      args.push(arguments[i]);\n    }\n\n    var maybeCb = args.pop();\n    if (typeof maybeCb !== 'function') {\n      throw new TypeError('The last argument must be of type Function');\n    }\n    var self = this;\n    var cb = function() {\n      return maybeCb.apply(self, arguments);\n    };\n    // In true node style we process the callback on `nextTick` with all the\n    // implications (stack, `uncaughtException`, `async_hooks`)\n    original.apply(this, args)\n      .then(function(ret) { process.nextTick(cb.bind(null, null, ret)) },\n            function(rej) { process.nextTick(callbackifyOnRejected.bind(null, rej, cb)) });\n  }\n\n  Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));\n  Object.defineProperties(callbackified,\n                          getOwnPropertyDescriptors(original));\n  return callbackified;\n}\nexports.callbackify = callbackify;\n\n\n//# sourceURL=webpack://javascript/./node_modules/util/util.js?");

/***/ }),

/***/ "./node_modules/which-typed-array/index.js":
/*!*************************************************!*\
  !*** ./node_modules/which-typed-array/index.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar forEach = __webpack_require__(/*! foreach */ \"./node_modules/foreach/index.js\");\nvar availableTypedArrays = __webpack_require__(/*! available-typed-arrays */ \"./node_modules/available-typed-arrays/index.js\");\nvar callBound = __webpack_require__(/*! call-bind/callBound */ \"./node_modules/call-bind/callBound.js\");\n\nvar $toString = callBound('Object.prototype.toString');\nvar hasToStringTag = __webpack_require__(/*! has-tostringtag/shams */ \"./node_modules/has-tostringtag/shams.js\")();\n\nvar g = typeof globalThis === 'undefined' ? __webpack_require__.g : globalThis;\nvar typedArrays = availableTypedArrays();\n\nvar $slice = callBound('String.prototype.slice');\nvar toStrTags = {};\nvar gOPD = __webpack_require__(/*! es-abstract/helpers/getOwnPropertyDescriptor */ \"./node_modules/es-abstract/helpers/getOwnPropertyDescriptor.js\");\nvar getPrototypeOf = Object.getPrototypeOf; // require('getprototypeof');\nif (hasToStringTag && gOPD && getPrototypeOf) {\n\tforEach(typedArrays, function (typedArray) {\n\t\tif (typeof g[typedArray] === 'function') {\n\t\t\tvar arr = new g[typedArray]();\n\t\t\tif (Symbol.toStringTag in arr) {\n\t\t\t\tvar proto = getPrototypeOf(arr);\n\t\t\t\tvar descriptor = gOPD(proto, Symbol.toStringTag);\n\t\t\t\tif (!descriptor) {\n\t\t\t\t\tvar superProto = getPrototypeOf(proto);\n\t\t\t\t\tdescriptor = gOPD(superProto, Symbol.toStringTag);\n\t\t\t\t}\n\t\t\t\ttoStrTags[typedArray] = descriptor.get;\n\t\t\t}\n\t\t}\n\t});\n}\n\nvar tryTypedArrays = function tryAllTypedArrays(value) {\n\tvar foundName = false;\n\tforEach(toStrTags, function (getter, typedArray) {\n\t\tif (!foundName) {\n\t\t\ttry {\n\t\t\t\tvar name = getter.call(value);\n\t\t\t\tif (name === typedArray) {\n\t\t\t\t\tfoundName = name;\n\t\t\t\t}\n\t\t\t} catch (e) {}\n\t\t}\n\t});\n\treturn foundName;\n};\n\nvar isTypedArray = __webpack_require__(/*! is-typed-array */ \"./node_modules/is-typed-array/index.js\");\n\nmodule.exports = function whichTypedArray(value) {\n\tif (!isTypedArray(value)) { return false; }\n\tif (!hasToStringTag || !(Symbol.toStringTag in value)) { return $slice($toString(value), 8, -1); }\n\treturn tryTypedArrays(value);\n};\n\n\n//# sourceURL=webpack://javascript/./node_modules/which-typed-array/index.js?");

/***/ }),

/***/ "./node_modules/available-typed-arrays/index.js":
/*!******************************************************!*\
  !*** ./node_modules/available-typed-arrays/index.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar possibleNames = [\n\t'BigInt64Array',\n\t'BigUint64Array',\n\t'Float32Array',\n\t'Float64Array',\n\t'Int16Array',\n\t'Int32Array',\n\t'Int8Array',\n\t'Uint16Array',\n\t'Uint32Array',\n\t'Uint8Array',\n\t'Uint8ClampedArray'\n];\n\nvar g = typeof globalThis === 'undefined' ? __webpack_require__.g : globalThis;\n\nmodule.exports = function availableTypedArrays() {\n\tvar out = [];\n\tfor (var i = 0; i < possibleNames.length; i++) {\n\t\tif (typeof g[possibleNames[i]] === 'function') {\n\t\t\tout[out.length] = possibleNames[i];\n\t\t}\n\t}\n\treturn out;\n};\n\n\n//# sourceURL=webpack://javascript/./node_modules/available-typed-arrays/index.js?");

/***/ }),

/***/ "./node_modules/es-abstract/helpers/getOwnPropertyDescriptor.js":
/*!**********************************************************************!*\
  !*** ./node_modules/es-abstract/helpers/getOwnPropertyDescriptor.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar GetIntrinsic = __webpack_require__(/*! get-intrinsic */ \"./node_modules/get-intrinsic/index.js\");\n\nvar $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%', true);\nif ($gOPD) {\n\ttry {\n\t\t$gOPD([], 'length');\n\t} catch (e) {\n\t\t// IE 8 has a broken gOPD\n\t\t$gOPD = null;\n\t}\n}\n\nmodule.exports = $gOPD;\n\n\n//# sourceURL=webpack://javascript/./node_modules/es-abstract/helpers/getOwnPropertyDescriptor.js?");

/***/ }),

/***/ "./node_modules/eslint-utils/index.mjs":
/*!*********************************************!*\
  !*** ./node_modules/eslint-utils/index.mjs ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CALL\": () => (/* binding */ CALL),\n/* harmony export */   \"CONSTRUCT\": () => (/* binding */ CONSTRUCT),\n/* harmony export */   \"ESM\": () => (/* binding */ ESM),\n/* harmony export */   \"PatternMatcher\": () => (/* binding */ PatternMatcher),\n/* harmony export */   \"READ\": () => (/* binding */ READ),\n/* harmony export */   \"ReferenceTracker\": () => (/* binding */ ReferenceTracker),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   \"findVariable\": () => (/* binding */ findVariable),\n/* harmony export */   \"getFunctionHeadLocation\": () => (/* binding */ getFunctionHeadLocation),\n/* harmony export */   \"getFunctionNameWithKind\": () => (/* binding */ getFunctionNameWithKind),\n/* harmony export */   \"getInnermostScope\": () => (/* binding */ getInnermostScope),\n/* harmony export */   \"getPropertyName\": () => (/* binding */ getPropertyName),\n/* harmony export */   \"getStaticValue\": () => (/* binding */ getStaticValue),\n/* harmony export */   \"getStringIfConstant\": () => (/* binding */ getStringIfConstant),\n/* harmony export */   \"hasSideEffect\": () => (/* binding */ hasSideEffect),\n/* harmony export */   \"isArrowToken\": () => (/* binding */ isArrowToken),\n/* harmony export */   \"isClosingBraceToken\": () => (/* binding */ isClosingBraceToken),\n/* harmony export */   \"isClosingBracketToken\": () => (/* binding */ isClosingBracketToken),\n/* harmony export */   \"isClosingParenToken\": () => (/* binding */ isClosingParenToken),\n/* harmony export */   \"isColonToken\": () => (/* binding */ isColonToken),\n/* harmony export */   \"isCommaToken\": () => (/* binding */ isCommaToken),\n/* harmony export */   \"isCommentToken\": () => (/* binding */ isCommentToken),\n/* harmony export */   \"isNotArrowToken\": () => (/* binding */ isNotArrowToken),\n/* harmony export */   \"isNotClosingBraceToken\": () => (/* binding */ isNotClosingBraceToken),\n/* harmony export */   \"isNotClosingBracketToken\": () => (/* binding */ isNotClosingBracketToken),\n/* harmony export */   \"isNotClosingParenToken\": () => (/* binding */ isNotClosingParenToken),\n/* harmony export */   \"isNotColonToken\": () => (/* binding */ isNotColonToken),\n/* harmony export */   \"isNotCommaToken\": () => (/* binding */ isNotCommaToken),\n/* harmony export */   \"isNotCommentToken\": () => (/* binding */ isNotCommentToken),\n/* harmony export */   \"isNotOpeningBraceToken\": () => (/* binding */ isNotOpeningBraceToken),\n/* harmony export */   \"isNotOpeningBracketToken\": () => (/* binding */ isNotOpeningBracketToken),\n/* harmony export */   \"isNotOpeningParenToken\": () => (/* binding */ isNotOpeningParenToken),\n/* harmony export */   \"isNotSemicolonToken\": () => (/* binding */ isNotSemicolonToken),\n/* harmony export */   \"isOpeningBraceToken\": () => (/* binding */ isOpeningBraceToken),\n/* harmony export */   \"isOpeningBracketToken\": () => (/* binding */ isOpeningBracketToken),\n/* harmony export */   \"isOpeningParenToken\": () => (/* binding */ isOpeningParenToken),\n/* harmony export */   \"isParenthesized\": () => (/* binding */ isParenthesized),\n/* harmony export */   \"isSemicolonToken\": () => (/* binding */ isSemicolonToken)\n/* harmony export */ });\n/* harmony import */ var eslint_visitor_keys__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! eslint-visitor-keys */ \"./node_modules/eslint-visitor-keys/lib/index.js\");\n/*! @author Toru Nagashima <https://github.com/mysticatea> */\n\n\n/**\n * Get the innermost scope which contains a given location.\n * @param {Scope} initialScope The initial scope to search.\n * @param {Node} node The location to search.\n * @returns {Scope} The innermost scope.\n */\nfunction getInnermostScope(initialScope, node) {\n    const location = node.range[0];\n\n    let scope = initialScope;\n    let found = false;\n    do {\n        found = false;\n        for (const childScope of scope.childScopes) {\n            const range = childScope.block.range;\n\n            if (range[0] <= location && location < range[1]) {\n                scope = childScope;\n                found = true;\n                break\n            }\n        }\n    } while (found)\n\n    return scope\n}\n\n/**\n * Find the variable of a given name.\n * @param {Scope} initialScope The scope to start finding.\n * @param {string|Node} nameOrNode The variable name to find. If this is a Node object then it should be an Identifier node.\n * @returns {Variable|null} The found variable or null.\n */\nfunction findVariable(initialScope, nameOrNode) {\n    let name = \"\";\n    let scope = initialScope;\n\n    if (typeof nameOrNode === \"string\") {\n        name = nameOrNode;\n    } else {\n        name = nameOrNode.name;\n        scope = getInnermostScope(scope, nameOrNode);\n    }\n\n    while (scope != null) {\n        const variable = scope.set.get(name);\n        if (variable != null) {\n            return variable\n        }\n        scope = scope.upper;\n    }\n\n    return null\n}\n\n/**\n * Negate the result of `this` calling.\n * @param {Token} token The token to check.\n * @returns {boolean} `true` if the result of `this(token)` is `false`.\n */\nfunction negate0(token) {\n    return !this(token) //eslint-disable-line no-invalid-this\n}\n\n/**\n * Creates the negate function of the given function.\n * @param {function(Token):boolean} f - The function to negate.\n * @returns {function(Token):boolean} Negated function.\n */\nfunction negate(f) {\n    return negate0.bind(f)\n}\n\n/**\n * Checks if the given token is an arrow token or not.\n * @param {Token} token - The token to check.\n * @returns {boolean} `true` if the token is an arrow token.\n */\nfunction isArrowToken(token) {\n    return token.value === \"=>\" && token.type === \"Punctuator\"\n}\n\n/**\n * Checks if the given token is a comma token or not.\n * @param {Token} token - The token to check.\n * @returns {boolean} `true` if the token is a comma token.\n */\nfunction isCommaToken(token) {\n    return token.value === \",\" && token.type === \"Punctuator\"\n}\n\n/**\n * Checks if the given token is a semicolon token or not.\n * @param {Token} token - The token to check.\n * @returns {boolean} `true` if the token is a semicolon token.\n */\nfunction isSemicolonToken(token) {\n    return token.value === \";\" && token.type === \"Punctuator\"\n}\n\n/**\n * Checks if the given token is a colon token or not.\n * @param {Token} token - The token to check.\n * @returns {boolean} `true` if the token is a colon token.\n */\nfunction isColonToken(token) {\n    return token.value === \":\" && token.type === \"Punctuator\"\n}\n\n/**\n * Checks if the given token is an opening parenthesis token or not.\n * @param {Token} token - The token to check.\n * @returns {boolean} `true` if the token is an opening parenthesis token.\n */\nfunction isOpeningParenToken(token) {\n    return token.value === \"(\" && token.type === \"Punctuator\"\n}\n\n/**\n * Checks if the given token is a closing parenthesis token or not.\n * @param {Token} token - The token to check.\n * @returns {boolean} `true` if the token is a closing parenthesis token.\n */\nfunction isClosingParenToken(token) {\n    return token.value === \")\" && token.type === \"Punctuator\"\n}\n\n/**\n * Checks if the given token is an opening square bracket token or not.\n * @param {Token} token - The token to check.\n * @returns {boolean} `true` if the token is an opening square bracket token.\n */\nfunction isOpeningBracketToken(token) {\n    return token.value === \"[\" && token.type === \"Punctuator\"\n}\n\n/**\n * Checks if the given token is a closing square bracket token or not.\n * @param {Token} token - The token to check.\n * @returns {boolean} `true` if the token is a closing square bracket token.\n */\nfunction isClosingBracketToken(token) {\n    return token.value === \"]\" && token.type === \"Punctuator\"\n}\n\n/**\n * Checks if the given token is an opening brace token or not.\n * @param {Token} token - The token to check.\n * @returns {boolean} `true` if the token is an opening brace token.\n */\nfunction isOpeningBraceToken(token) {\n    return token.value === \"{\" && token.type === \"Punctuator\"\n}\n\n/**\n * Checks if the given token is a closing brace token or not.\n * @param {Token} token - The token to check.\n * @returns {boolean} `true` if the token is a closing brace token.\n */\nfunction isClosingBraceToken(token) {\n    return token.value === \"}\" && token.type === \"Punctuator\"\n}\n\n/**\n * Checks if the given token is a comment token or not.\n * @param {Token} token - The token to check.\n * @returns {boolean} `true` if the token is a comment token.\n */\nfunction isCommentToken(token) {\n    return (\n        token.type === \"Line\" ||\n        token.type === \"Block\" ||\n        token.type === \"Shebang\"\n    )\n}\n\nconst isNotArrowToken = negate(isArrowToken);\nconst isNotCommaToken = negate(isCommaToken);\nconst isNotSemicolonToken = negate(isSemicolonToken);\nconst isNotColonToken = negate(isColonToken);\nconst isNotOpeningParenToken = negate(isOpeningParenToken);\nconst isNotClosingParenToken = negate(isClosingParenToken);\nconst isNotOpeningBracketToken = negate(isOpeningBracketToken);\nconst isNotClosingBracketToken = negate(isClosingBracketToken);\nconst isNotOpeningBraceToken = negate(isOpeningBraceToken);\nconst isNotClosingBraceToken = negate(isClosingBraceToken);\nconst isNotCommentToken = negate(isCommentToken);\n\n/**\n * Get the `(` token of the given function node.\n * @param {Node} node - The function node to get.\n * @param {SourceCode} sourceCode - The source code object to get tokens.\n * @returns {Token} `(` token.\n */\nfunction getOpeningParenOfParams(node, sourceCode) {\n    return node.id\n        ? sourceCode.getTokenAfter(node.id, isOpeningParenToken)\n        : sourceCode.getFirstToken(node, isOpeningParenToken)\n}\n\n/**\n * Get the location of the given function node for reporting.\n * @param {Node} node - The function node to get.\n * @param {SourceCode} sourceCode - The source code object to get tokens.\n * @returns {string} The location of the function node for reporting.\n */\nfunction getFunctionHeadLocation(node, sourceCode) {\n    const parent = node.parent;\n    let start = null;\n    let end = null;\n\n    if (node.type === \"ArrowFunctionExpression\") {\n        const arrowToken = sourceCode.getTokenBefore(node.body, isArrowToken);\n\n        start = arrowToken.loc.start;\n        end = arrowToken.loc.end;\n    } else if (\n        parent.type === \"Property\" ||\n        parent.type === \"MethodDefinition\"\n    ) {\n        start = parent.loc.start;\n        end = getOpeningParenOfParams(node, sourceCode).loc.start;\n    } else {\n        start = node.loc.start;\n        end = getOpeningParenOfParams(node, sourceCode).loc.start;\n    }\n\n    return {\n        start: Object.assign({}, start),\n        end: Object.assign({}, end),\n    }\n}\n\n/* globals BigInt, globalThis, global, self, window */\n\nconst globalObject =\n    typeof globalThis !== \"undefined\"\n        ? globalThis\n        : typeof self !== \"undefined\"\n        ? self\n        : typeof window !== \"undefined\"\n        ? window\n        : typeof global !== \"undefined\"\n        ? global\n        : {};\n\nconst builtinNames = Object.freeze(\n    new Set([\n        \"Array\",\n        \"ArrayBuffer\",\n        \"BigInt\",\n        \"BigInt64Array\",\n        \"BigUint64Array\",\n        \"Boolean\",\n        \"DataView\",\n        \"Date\",\n        \"decodeURI\",\n        \"decodeURIComponent\",\n        \"encodeURI\",\n        \"encodeURIComponent\",\n        \"escape\",\n        \"Float32Array\",\n        \"Float64Array\",\n        \"Function\",\n        \"Infinity\",\n        \"Int16Array\",\n        \"Int32Array\",\n        \"Int8Array\",\n        \"isFinite\",\n        \"isNaN\",\n        \"isPrototypeOf\",\n        \"JSON\",\n        \"Map\",\n        \"Math\",\n        \"NaN\",\n        \"Number\",\n        \"Object\",\n        \"parseFloat\",\n        \"parseInt\",\n        \"Promise\",\n        \"Proxy\",\n        \"Reflect\",\n        \"RegExp\",\n        \"Set\",\n        \"String\",\n        \"Symbol\",\n        \"Uint16Array\",\n        \"Uint32Array\",\n        \"Uint8Array\",\n        \"Uint8ClampedArray\",\n        \"undefined\",\n        \"unescape\",\n        \"WeakMap\",\n        \"WeakSet\",\n    ])\n);\nconst callAllowed = new Set(\n    [\n        Array.isArray,\n        typeof BigInt === \"function\" ? BigInt : undefined,\n        Boolean,\n        Date,\n        Date.parse,\n        decodeURI,\n        decodeURIComponent,\n        encodeURI,\n        encodeURIComponent,\n        escape,\n        isFinite,\n        isNaN,\n        isPrototypeOf,\n        ...Object.getOwnPropertyNames(Math)\n            .map(k => Math[k])\n            .filter(f => typeof f === \"function\"),\n        Number,\n        Number.isFinite,\n        Number.isNaN,\n        Number.parseFloat,\n        Number.parseInt,\n        Object,\n        Object.entries,\n        Object.is,\n        Object.isExtensible,\n        Object.isFrozen,\n        Object.isSealed,\n        Object.keys,\n        Object.values,\n        parseFloat,\n        parseInt,\n        RegExp,\n        String,\n        String.fromCharCode,\n        String.fromCodePoint,\n        String.raw,\n        Symbol,\n        Symbol.for,\n        Symbol.keyFor,\n        unescape,\n    ].filter(f => typeof f === \"function\")\n);\nconst callPassThrough = new Set([\n    Object.freeze,\n    Object.preventExtensions,\n    Object.seal,\n]);\n\n/**\n * Get the property descriptor.\n * @param {object} object The object to get.\n * @param {string|number|symbol} name The property name to get.\n */\nfunction getPropertyDescriptor(object, name) {\n    let x = object;\n    while ((typeof x === \"object\" || typeof x === \"function\") && x !== null) {\n        const d = Object.getOwnPropertyDescriptor(x, name);\n        if (d) {\n            return d\n        }\n        x = Object.getPrototypeOf(x);\n    }\n    return null\n}\n\n/**\n * Check if a property is getter or not.\n * @param {object} object The object to check.\n * @param {string|number|symbol} name The property name to check.\n */\nfunction isGetter(object, name) {\n    const d = getPropertyDescriptor(object, name);\n    return d != null && d.get != null\n}\n\n/**\n * Get the element values of a given node list.\n * @param {Node[]} nodeList The node list to get values.\n * @param {Scope|undefined} initialScope The initial scope to find variables.\n * @returns {any[]|null} The value list if all nodes are constant. Otherwise, null.\n */\nfunction getElementValues(nodeList, initialScope) {\n    const valueList = [];\n\n    for (let i = 0; i < nodeList.length; ++i) {\n        const elementNode = nodeList[i];\n\n        if (elementNode == null) {\n            valueList.length = i + 1;\n        } else if (elementNode.type === \"SpreadElement\") {\n            const argument = getStaticValueR(elementNode.argument, initialScope);\n            if (argument == null) {\n                return null\n            }\n            valueList.push(...argument.value);\n        } else {\n            const element = getStaticValueR(elementNode, initialScope);\n            if (element == null) {\n                return null\n            }\n            valueList.push(element.value);\n        }\n    }\n\n    return valueList\n}\n\nconst operations = Object.freeze({\n    ArrayExpression(node, initialScope) {\n        const elements = getElementValues(node.elements, initialScope);\n        return elements != null ? { value: elements } : null\n    },\n\n    AssignmentExpression(node, initialScope) {\n        if (node.operator === \"=\") {\n            return getStaticValueR(node.right, initialScope)\n        }\n        return null\n    },\n\n    //eslint-disable-next-line complexity\n    BinaryExpression(node, initialScope) {\n        if (node.operator === \"in\" || node.operator === \"instanceof\") {\n            // Not supported.\n            return null\n        }\n\n        const left = getStaticValueR(node.left, initialScope);\n        const right = getStaticValueR(node.right, initialScope);\n        if (left != null && right != null) {\n            switch (node.operator) {\n                case \"==\":\n                    return { value: left.value == right.value } //eslint-disable-line eqeqeq\n                case \"!=\":\n                    return { value: left.value != right.value } //eslint-disable-line eqeqeq\n                case \"===\":\n                    return { value: left.value === right.value }\n                case \"!==\":\n                    return { value: left.value !== right.value }\n                case \"<\":\n                    return { value: left.value < right.value }\n                case \"<=\":\n                    return { value: left.value <= right.value }\n                case \">\":\n                    return { value: left.value > right.value }\n                case \">=\":\n                    return { value: left.value >= right.value }\n                case \"<<\":\n                    return { value: left.value << right.value }\n                case \">>\":\n                    return { value: left.value >> right.value }\n                case \">>>\":\n                    return { value: left.value >>> right.value }\n                case \"+\":\n                    return { value: left.value + right.value }\n                case \"-\":\n                    return { value: left.value - right.value }\n                case \"*\":\n                    return { value: left.value * right.value }\n                case \"/\":\n                    return { value: left.value / right.value }\n                case \"%\":\n                    return { value: left.value % right.value }\n                case \"**\":\n                    return { value: Math.pow(left.value, right.value) }\n                case \"|\":\n                    return { value: left.value | right.value }\n                case \"^\":\n                    return { value: left.value ^ right.value }\n                case \"&\":\n                    return { value: left.value & right.value }\n\n                // no default\n            }\n        }\n\n        return null\n    },\n\n    CallExpression(node, initialScope) {\n        const calleeNode = node.callee;\n        const args = getElementValues(node.arguments, initialScope);\n\n        if (args != null) {\n            if (calleeNode.type === \"MemberExpression\") {\n                const object = getStaticValueR(calleeNode.object, initialScope);\n                if (object != null) {\n                    if (\n                        object.value == null &&\n                        (object.optional || node.optional)\n                    ) {\n                        return { value: undefined, optional: true }\n                    }\n                    const property = calleeNode.computed\n                        ? getStaticValueR(calleeNode.property, initialScope)\n                        : { value: calleeNode.property.name };\n\n                    if (property != null) {\n                        const receiver = object.value;\n                        const methodName = property.value;\n                        if (callAllowed.has(receiver[methodName])) {\n                            return { value: receiver[methodName](...args) }\n                        }\n                        if (callPassThrough.has(receiver[methodName])) {\n                            return { value: args[0] }\n                        }\n                    }\n                }\n            } else {\n                const callee = getStaticValueR(calleeNode, initialScope);\n                if (callee != null) {\n                    if (callee.value == null && node.optional) {\n                        return { value: undefined, optional: true }\n                    }\n                    const func = callee.value;\n                    if (callAllowed.has(func)) {\n                        return { value: func(...args) }\n                    }\n                    if (callPassThrough.has(func)) {\n                        return { value: args[0] }\n                    }\n                }\n            }\n        }\n\n        return null\n    },\n\n    ConditionalExpression(node, initialScope) {\n        const test = getStaticValueR(node.test, initialScope);\n        if (test != null) {\n            return test.value\n                ? getStaticValueR(node.consequent, initialScope)\n                : getStaticValueR(node.alternate, initialScope)\n        }\n        return null\n    },\n\n    ExpressionStatement(node, initialScope) {\n        return getStaticValueR(node.expression, initialScope)\n    },\n\n    Identifier(node, initialScope) {\n        if (initialScope != null) {\n            const variable = findVariable(initialScope, node);\n\n            // Built-in globals.\n            if (\n                variable != null &&\n                variable.defs.length === 0 &&\n                builtinNames.has(variable.name) &&\n                variable.name in globalObject\n            ) {\n                return { value: globalObject[variable.name] }\n            }\n\n            // Constants.\n            if (variable != null && variable.defs.length === 1) {\n                const def = variable.defs[0];\n                if (\n                    def.parent &&\n                    def.parent.kind === \"const\" &&\n                    // TODO(mysticatea): don't support destructuring here.\n                    def.node.id.type === \"Identifier\"\n                ) {\n                    return getStaticValueR(def.node.init, initialScope)\n                }\n            }\n        }\n        return null\n    },\n\n    Literal(node) {\n        //istanbul ignore if : this is implementation-specific behavior.\n        if ((node.regex != null || node.bigint != null) && node.value == null) {\n            // It was a RegExp/BigInt literal, but Node.js didn't support it.\n            return null\n        }\n        return { value: node.value }\n    },\n\n    LogicalExpression(node, initialScope) {\n        const left = getStaticValueR(node.left, initialScope);\n        if (left != null) {\n            if (\n                (node.operator === \"||\" && Boolean(left.value) === true) ||\n                (node.operator === \"&&\" && Boolean(left.value) === false) ||\n                (node.operator === \"??\" && left.value != null)\n            ) {\n                return left\n            }\n\n            const right = getStaticValueR(node.right, initialScope);\n            if (right != null) {\n                return right\n            }\n        }\n\n        return null\n    },\n\n    MemberExpression(node, initialScope) {\n        const object = getStaticValueR(node.object, initialScope);\n        if (object != null) {\n            if (object.value == null && (object.optional || node.optional)) {\n                return { value: undefined, optional: true }\n            }\n            const property = node.computed\n                ? getStaticValueR(node.property, initialScope)\n                : { value: node.property.name };\n\n            if (property != null && !isGetter(object.value, property.value)) {\n                return { value: object.value[property.value] }\n            }\n        }\n        return null\n    },\n\n    ChainExpression(node, initialScope) {\n        const expression = getStaticValueR(node.expression, initialScope);\n        if (expression != null) {\n            return { value: expression.value }\n        }\n        return null\n    },\n\n    NewExpression(node, initialScope) {\n        const callee = getStaticValueR(node.callee, initialScope);\n        const args = getElementValues(node.arguments, initialScope);\n\n        if (callee != null && args != null) {\n            const Func = callee.value;\n            if (callAllowed.has(Func)) {\n                return { value: new Func(...args) }\n            }\n        }\n\n        return null\n    },\n\n    ObjectExpression(node, initialScope) {\n        const object = {};\n\n        for (const propertyNode of node.properties) {\n            if (propertyNode.type === \"Property\") {\n                if (propertyNode.kind !== \"init\") {\n                    return null\n                }\n                const key = propertyNode.computed\n                    ? getStaticValueR(propertyNode.key, initialScope)\n                    : { value: propertyNode.key.name };\n                const value = getStaticValueR(propertyNode.value, initialScope);\n                if (key == null || value == null) {\n                    return null\n                }\n                object[key.value] = value.value;\n            } else if (\n                propertyNode.type === \"SpreadElement\" ||\n                propertyNode.type === \"ExperimentalSpreadProperty\"\n            ) {\n                const argument = getStaticValueR(\n                    propertyNode.argument,\n                    initialScope\n                );\n                if (argument == null) {\n                    return null\n                }\n                Object.assign(object, argument.value);\n            } else {\n                return null\n            }\n        }\n\n        return { value: object }\n    },\n\n    SequenceExpression(node, initialScope) {\n        const last = node.expressions[node.expressions.length - 1];\n        return getStaticValueR(last, initialScope)\n    },\n\n    TaggedTemplateExpression(node, initialScope) {\n        const tag = getStaticValueR(node.tag, initialScope);\n        const expressions = getElementValues(\n            node.quasi.expressions,\n            initialScope\n        );\n\n        if (tag != null && expressions != null) {\n            const func = tag.value;\n            const strings = node.quasi.quasis.map(q => q.value.cooked);\n            strings.raw = node.quasi.quasis.map(q => q.value.raw);\n\n            if (func === String.raw) {\n                return { value: func(strings, ...expressions) }\n            }\n        }\n\n        return null\n    },\n\n    TemplateLiteral(node, initialScope) {\n        const expressions = getElementValues(node.expressions, initialScope);\n        if (expressions != null) {\n            let value = node.quasis[0].value.cooked;\n            for (let i = 0; i < expressions.length; ++i) {\n                value += expressions[i];\n                value += node.quasis[i + 1].value.cooked;\n            }\n            return { value }\n        }\n        return null\n    },\n\n    UnaryExpression(node, initialScope) {\n        if (node.operator === \"delete\") {\n            // Not supported.\n            return null\n        }\n        if (node.operator === \"void\") {\n            return { value: undefined }\n        }\n\n        const arg = getStaticValueR(node.argument, initialScope);\n        if (arg != null) {\n            switch (node.operator) {\n                case \"-\":\n                    return { value: -arg.value }\n                case \"+\":\n                    return { value: +arg.value } //eslint-disable-line no-implicit-coercion\n                case \"!\":\n                    return { value: !arg.value }\n                case \"~\":\n                    return { value: ~arg.value }\n                case \"typeof\":\n                    return { value: typeof arg.value }\n\n                // no default\n            }\n        }\n\n        return null\n    },\n});\n\n/**\n * Get the value of a given node if it's a static value.\n * @param {Node} node The node to get.\n * @param {Scope|undefined} initialScope The scope to start finding variable.\n * @returns {{value:any}|{value:undefined,optional?:true}|null} The static value of the node, or `null`.\n */\nfunction getStaticValueR(node, initialScope) {\n    if (node != null && Object.hasOwnProperty.call(operations, node.type)) {\n        return operations[node.type](node, initialScope)\n    }\n    return null\n}\n\n/**\n * Get the value of a given node if it's a static value.\n * @param {Node} node The node to get.\n * @param {Scope} [initialScope] The scope to start finding variable. Optional. If this scope was given, this tries to resolve identifier references which are in the given node as much as possible.\n * @returns {{value:any}|{value:undefined,optional?:true}|null} The static value of the node, or `null`.\n */\nfunction getStaticValue(node, initialScope = null) {\n    try {\n        return getStaticValueR(node, initialScope)\n    } catch (_error) {\n        return null\n    }\n}\n\n/**\n * Get the value of a given node if it's a literal or a template literal.\n * @param {Node} node The node to get.\n * @param {Scope} [initialScope] The scope to start finding variable. Optional. If the node is an Identifier node and this scope was given, this checks the variable of the identifier, and returns the value of it if the variable is a constant.\n * @returns {string|null} The value of the node, or `null`.\n */\nfunction getStringIfConstant(node, initialScope = null) {\n    // Handle the literals that the platform doesn't support natively.\n    if (node && node.type === \"Literal\" && node.value === null) {\n        if (node.regex) {\n            return `/${node.regex.pattern}/${node.regex.flags}`\n        }\n        if (node.bigint) {\n            return node.bigint\n        }\n    }\n\n    const evaluated = getStaticValue(node, initialScope);\n    return evaluated && String(evaluated.value)\n}\n\n/**\n * Get the property name from a MemberExpression node or a Property node.\n * @param {Node} node The node to get.\n * @param {Scope} [initialScope] The scope to start finding variable. Optional. If the node is a computed property node and this scope was given, this checks the computed property name by the `getStringIfConstant` function with the scope, and returns the value of it.\n * @returns {string|null} The property name of the node.\n */\nfunction getPropertyName(node, initialScope) {\n    switch (node.type) {\n        case \"MemberExpression\":\n            if (node.computed) {\n                return getStringIfConstant(node.property, initialScope)\n            }\n            return node.property.name\n\n        case \"Property\":\n        case \"MethodDefinition\":\n            if (node.computed) {\n                return getStringIfConstant(node.key, initialScope)\n            }\n            if (node.key.type === \"Literal\") {\n                return String(node.key.value)\n            }\n            return node.key.name\n\n        // no default\n    }\n\n    return null\n}\n\n/**\n * Get the name and kind of the given function node.\n * @param {ASTNode} node - The function node to get.\n * @returns {string} The name and kind of the function node.\n */\nfunction getFunctionNameWithKind(node) {\n    const parent = node.parent;\n    const tokens = [];\n\n    if (parent.type === \"MethodDefinition\" && parent.static) {\n        tokens.push(\"static\");\n    }\n    if (node.async) {\n        tokens.push(\"async\");\n    }\n    if (node.generator) {\n        tokens.push(\"generator\");\n    }\n\n    if (node.type === \"ArrowFunctionExpression\") {\n        tokens.push(\"arrow\", \"function\");\n    } else if (\n        parent.type === \"Property\" ||\n        parent.type === \"MethodDefinition\"\n    ) {\n        if (parent.kind === \"constructor\") {\n            return \"constructor\"\n        }\n        if (parent.kind === \"get\") {\n            tokens.push(\"getter\");\n        } else if (parent.kind === \"set\") {\n            tokens.push(\"setter\");\n        } else {\n            tokens.push(\"method\");\n        }\n    } else {\n        tokens.push(\"function\");\n    }\n\n    if (node.id) {\n        tokens.push(`'${node.id.name}'`);\n    } else {\n        const name = getPropertyName(parent);\n\n        if (name) {\n            tokens.push(`'${name}'`);\n        }\n    }\n\n    if (node.type === \"ArrowFunctionExpression\") {\n        if (\n            parent.type === \"VariableDeclarator\" &&\n            parent.id &&\n            parent.id.type === \"Identifier\"\n        ) {\n            tokens.push(`'${parent.id.name}'`);\n        }\n        if (\n            parent.type === \"AssignmentExpression\" &&\n            parent.left &&\n            parent.left.type === \"Identifier\"\n        ) {\n            tokens.push(`'${parent.left.name}'`);\n        }\n    }\n\n    return tokens.join(\" \")\n}\n\nconst typeConversionBinaryOps = Object.freeze(\n    new Set([\n        \"==\",\n        \"!=\",\n        \"<\",\n        \"<=\",\n        \">\",\n        \">=\",\n        \"<<\",\n        \">>\",\n        \">>>\",\n        \"+\",\n        \"-\",\n        \"*\",\n        \"/\",\n        \"%\",\n        \"|\",\n        \"^\",\n        \"&\",\n        \"in\",\n    ])\n);\nconst typeConversionUnaryOps = Object.freeze(new Set([\"-\", \"+\", \"!\", \"~\"]));\n\n/**\n * Check whether the given value is an ASTNode or not.\n * @param {any} x The value to check.\n * @returns {boolean} `true` if the value is an ASTNode.\n */\nfunction isNode(x) {\n    return x !== null && typeof x === \"object\" && typeof x.type === \"string\"\n}\n\nconst visitor = Object.freeze(\n    Object.assign(Object.create(null), {\n        $visit(node, options, visitorKeys) {\n            const { type } = node;\n\n            if (typeof this[type] === \"function\") {\n                return this[type](node, options, visitorKeys)\n            }\n\n            return this.$visitChildren(node, options, visitorKeys)\n        },\n\n        $visitChildren(node, options, visitorKeys) {\n            const { type } = node;\n\n            for (const key of visitorKeys[type] || eslint_visitor_keys__WEBPACK_IMPORTED_MODULE_0__.getKeys(node)) {\n                const value = node[key];\n\n                if (Array.isArray(value)) {\n                    for (const element of value) {\n                        if (\n                            isNode(element) &&\n                            this.$visit(element, options, visitorKeys)\n                        ) {\n                            return true\n                        }\n                    }\n                } else if (\n                    isNode(value) &&\n                    this.$visit(value, options, visitorKeys)\n                ) {\n                    return true\n                }\n            }\n\n            return false\n        },\n\n        ArrowFunctionExpression() {\n            return false\n        },\n        AssignmentExpression() {\n            return true\n        },\n        AwaitExpression() {\n            return true\n        },\n        BinaryExpression(node, options, visitorKeys) {\n            if (\n                options.considerImplicitTypeConversion &&\n                typeConversionBinaryOps.has(node.operator) &&\n                (node.left.type !== \"Literal\" || node.right.type !== \"Literal\")\n            ) {\n                return true\n            }\n            return this.$visitChildren(node, options, visitorKeys)\n        },\n        CallExpression() {\n            return true\n        },\n        FunctionExpression() {\n            return false\n        },\n        ImportExpression() {\n            return true\n        },\n        MemberExpression(node, options, visitorKeys) {\n            if (options.considerGetters) {\n                return true\n            }\n            if (\n                options.considerImplicitTypeConversion &&\n                node.computed &&\n                node.property.type !== \"Literal\"\n            ) {\n                return true\n            }\n            return this.$visitChildren(node, options, visitorKeys)\n        },\n        MethodDefinition(node, options, visitorKeys) {\n            if (\n                options.considerImplicitTypeConversion &&\n                node.computed &&\n                node.key.type !== \"Literal\"\n            ) {\n                return true\n            }\n            return this.$visitChildren(node, options, visitorKeys)\n        },\n        NewExpression() {\n            return true\n        },\n        Property(node, options, visitorKeys) {\n            if (\n                options.considerImplicitTypeConversion &&\n                node.computed &&\n                node.key.type !== \"Literal\"\n            ) {\n                return true\n            }\n            return this.$visitChildren(node, options, visitorKeys)\n        },\n        UnaryExpression(node, options, visitorKeys) {\n            if (node.operator === \"delete\") {\n                return true\n            }\n            if (\n                options.considerImplicitTypeConversion &&\n                typeConversionUnaryOps.has(node.operator) &&\n                node.argument.type !== \"Literal\"\n            ) {\n                return true\n            }\n            return this.$visitChildren(node, options, visitorKeys)\n        },\n        UpdateExpression() {\n            return true\n        },\n        YieldExpression() {\n            return true\n        },\n    })\n);\n\n/**\n * Check whether a given node has any side effect or not.\n * @param {Node} node The node to get.\n * @param {SourceCode} sourceCode The source code object.\n * @param {object} [options] The option object.\n * @param {boolean} [options.considerGetters=false] If `true` then it considers member accesses as the node which has side effects.\n * @param {boolean} [options.considerImplicitTypeConversion=false] If `true` then it considers implicit type conversion as the node which has side effects.\n * @param {object} [options.visitorKeys=evk.KEYS] The keys to traverse nodes. Use `context.getSourceCode().visitorKeys`.\n * @returns {boolean} `true` if the node has a certain side effect.\n */\nfunction hasSideEffect(\n    node,\n    sourceCode,\n    { considerGetters = false, considerImplicitTypeConversion = false } = {}\n) {\n    return visitor.$visit(\n        node,\n        { considerGetters, considerImplicitTypeConversion },\n        sourceCode.visitorKeys || eslint_visitor_keys__WEBPACK_IMPORTED_MODULE_0__.KEYS\n    )\n}\n\n/**\n * Get the left parenthesis of the parent node syntax if it exists.\n * E.g., `if (a) {}` then the `(`.\n * @param {Node} node The AST node to check.\n * @param {SourceCode} sourceCode The source code object to get tokens.\n * @returns {Token|null} The left parenthesis of the parent node syntax\n */\nfunction getParentSyntaxParen(node, sourceCode) {\n    const parent = node.parent;\n\n    switch (parent.type) {\n        case \"CallExpression\":\n        case \"NewExpression\":\n            if (parent.arguments.length === 1 && parent.arguments[0] === node) {\n                return sourceCode.getTokenAfter(\n                    parent.callee,\n                    isOpeningParenToken\n                )\n            }\n            return null\n\n        case \"DoWhileStatement\":\n            if (parent.test === node) {\n                return sourceCode.getTokenAfter(\n                    parent.body,\n                    isOpeningParenToken\n                )\n            }\n            return null\n\n        case \"IfStatement\":\n        case \"WhileStatement\":\n            if (parent.test === node) {\n                return sourceCode.getFirstToken(parent, 1)\n            }\n            return null\n\n        case \"ImportExpression\":\n            if (parent.source === node) {\n                return sourceCode.getFirstToken(parent, 1)\n            }\n            return null\n\n        case \"SwitchStatement\":\n            if (parent.discriminant === node) {\n                return sourceCode.getFirstToken(parent, 1)\n            }\n            return null\n\n        case \"WithStatement\":\n            if (parent.object === node) {\n                return sourceCode.getFirstToken(parent, 1)\n            }\n            return null\n\n        default:\n            return null\n    }\n}\n\n/**\n * Check whether a given node is parenthesized or not.\n * @param {number} times The number of parantheses.\n * @param {Node} node The AST node to check.\n * @param {SourceCode} sourceCode The source code object to get tokens.\n * @returns {boolean} `true` if the node is parenthesized the given times.\n */\n/**\n * Check whether a given node is parenthesized or not.\n * @param {Node} node The AST node to check.\n * @param {SourceCode} sourceCode The source code object to get tokens.\n * @returns {boolean} `true` if the node is parenthesized.\n */\nfunction isParenthesized(\n    timesOrNode,\n    nodeOrSourceCode,\n    optionalSourceCode\n) {\n    let times, node, sourceCode, maybeLeftParen, maybeRightParen;\n    if (typeof timesOrNode === \"number\") {\n        times = timesOrNode | 0;\n        node = nodeOrSourceCode;\n        sourceCode = optionalSourceCode;\n        if (!(times >= 1)) {\n            throw new TypeError(\"'times' should be a positive integer.\")\n        }\n    } else {\n        times = 1;\n        node = timesOrNode;\n        sourceCode = nodeOrSourceCode;\n    }\n\n    if (node == null) {\n        return false\n    }\n\n    maybeLeftParen = maybeRightParen = node;\n    do {\n        maybeLeftParen = sourceCode.getTokenBefore(maybeLeftParen);\n        maybeRightParen = sourceCode.getTokenAfter(maybeRightParen);\n    } while (\n        maybeLeftParen != null &&\n        maybeRightParen != null &&\n        isOpeningParenToken(maybeLeftParen) &&\n        isClosingParenToken(maybeRightParen) &&\n        // Avoid false positive such as `if (a) {}`\n        maybeLeftParen !== getParentSyntaxParen(node, sourceCode) &&\n        --times > 0\n    )\n\n    return times === 0\n}\n\n/**\n * @author Toru Nagashima <https://github.com/mysticatea>\n * See LICENSE file in root directory for full license.\n */\n\nconst placeholder = /\\$(?:[$&`']|[1-9][0-9]?)/gu;\n\n/** @type {WeakMap<PatternMatcher, {pattern:RegExp,escaped:boolean}>} */\nconst internal = new WeakMap();\n\n/**\n * Check whether a given character is escaped or not.\n * @param {string} str The string to check.\n * @param {number} index The location of the character to check.\n * @returns {boolean} `true` if the character is escaped.\n */\nfunction isEscaped(str, index) {\n    let escaped = false;\n    for (let i = index - 1; i >= 0 && str.charCodeAt(i) === 0x5c; --i) {\n        escaped = !escaped;\n    }\n    return escaped\n}\n\n/**\n * Replace a given string by a given matcher.\n * @param {PatternMatcher} matcher The pattern matcher.\n * @param {string} str The string to be replaced.\n * @param {string} replacement The new substring to replace each matched part.\n * @returns {string} The replaced string.\n */\nfunction replaceS(matcher, str, replacement) {\n    const chunks = [];\n    let index = 0;\n\n    /** @type {RegExpExecArray} */\n    let match = null;\n\n    /**\n     * @param {string} key The placeholder.\n     * @returns {string} The replaced string.\n     */\n    function replacer(key) {\n        switch (key) {\n            case \"$$\":\n                return \"$\"\n            case \"$&\":\n                return match[0]\n            case \"$`\":\n                return str.slice(0, match.index)\n            case \"$'\":\n                return str.slice(match.index + match[0].length)\n            default: {\n                const i = key.slice(1);\n                if (i in match) {\n                    return match[i]\n                }\n                return key\n            }\n        }\n    }\n\n    for (match of matcher.execAll(str)) {\n        chunks.push(str.slice(index, match.index));\n        chunks.push(replacement.replace(placeholder, replacer));\n        index = match.index + match[0].length;\n    }\n    chunks.push(str.slice(index));\n\n    return chunks.join(\"\")\n}\n\n/**\n * Replace a given string by a given matcher.\n * @param {PatternMatcher} matcher The pattern matcher.\n * @param {string} str The string to be replaced.\n * @param {(...strs[])=>string} replace The function to replace each matched part.\n * @returns {string} The replaced string.\n */\nfunction replaceF(matcher, str, replace) {\n    const chunks = [];\n    let index = 0;\n\n    for (const match of matcher.execAll(str)) {\n        chunks.push(str.slice(index, match.index));\n        chunks.push(String(replace(...match, match.index, match.input)));\n        index = match.index + match[0].length;\n    }\n    chunks.push(str.slice(index));\n\n    return chunks.join(\"\")\n}\n\n/**\n * The class to find patterns as considering escape sequences.\n */\nclass PatternMatcher {\n    /**\n     * Initialize this matcher.\n     * @param {RegExp} pattern The pattern to match.\n     * @param {{escaped:boolean}} options The options.\n     */\n    constructor(pattern, { escaped = false } = {}) {\n        if (!(pattern instanceof RegExp)) {\n            throw new TypeError(\"'pattern' should be a RegExp instance.\")\n        }\n        if (!pattern.flags.includes(\"g\")) {\n            throw new Error(\"'pattern' should contains 'g' flag.\")\n        }\n\n        internal.set(this, {\n            pattern: new RegExp(pattern.source, pattern.flags),\n            escaped: Boolean(escaped),\n        });\n    }\n\n    /**\n     * Find the pattern in a given string.\n     * @param {string} str The string to find.\n     * @returns {IterableIterator<RegExpExecArray>} The iterator which iterate the matched information.\n     */\n    *execAll(str) {\n        const { pattern, escaped } = internal.get(this);\n        let match = null;\n        let lastIndex = 0;\n\n        pattern.lastIndex = 0;\n        while ((match = pattern.exec(str)) != null) {\n            if (escaped || !isEscaped(str, match.index)) {\n                lastIndex = pattern.lastIndex;\n                yield match;\n                pattern.lastIndex = lastIndex;\n            }\n        }\n    }\n\n    /**\n     * Check whether the pattern is found in a given string.\n     * @param {string} str The string to check.\n     * @returns {boolean} `true` if the pattern was found in the string.\n     */\n    test(str) {\n        const it = this.execAll(str);\n        const ret = it.next();\n        return !ret.done\n    }\n\n    /**\n     * Replace a given string.\n     * @param {string} str The string to be replaced.\n     * @param {(string|((...strs:string[])=>string))} replacer The string or function to replace. This is the same as the 2nd argument of `String.prototype.replace`.\n     * @returns {string} The replaced string.\n     */\n    [Symbol.replace](str, replacer) {\n        return typeof replacer === \"function\"\n            ? replaceF(this, String(str), replacer)\n            : replaceS(this, String(str), String(replacer))\n    }\n}\n\nconst IMPORT_TYPE = /^(?:Import|Export(?:All|Default|Named))Declaration$/u;\nconst has = Function.call.bind(Object.hasOwnProperty);\n\nconst READ = Symbol(\"read\");\nconst CALL = Symbol(\"call\");\nconst CONSTRUCT = Symbol(\"construct\");\nconst ESM = Symbol(\"esm\");\n\nconst requireCall = { require: { [CALL]: true } };\n\n/**\n * Check whether a given variable is modified or not.\n * @param {Variable} variable The variable to check.\n * @returns {boolean} `true` if the variable is modified.\n */\nfunction isModifiedGlobal(variable) {\n    return (\n        variable == null ||\n        variable.defs.length !== 0 ||\n        variable.references.some(r => r.isWrite())\n    )\n}\n\n/**\n * Check if the value of a given node is passed through to the parent syntax as-is.\n * For example, `a` and `b` in (`a || b` and `c ? a : b`) are passed through.\n * @param {Node} node A node to check.\n * @returns {boolean} `true` if the node is passed through.\n */\nfunction isPassThrough(node) {\n    const parent = node.parent;\n\n    switch (parent && parent.type) {\n        case \"ConditionalExpression\":\n            return parent.consequent === node || parent.alternate === node\n        case \"LogicalExpression\":\n            return true\n        case \"SequenceExpression\":\n            return parent.expressions[parent.expressions.length - 1] === node\n        case \"ChainExpression\":\n            return true\n\n        default:\n            return false\n    }\n}\n\n/**\n * The reference tracker.\n */\nclass ReferenceTracker {\n    /**\n     * Initialize this tracker.\n     * @param {Scope} globalScope The global scope.\n     * @param {object} [options] The options.\n     * @param {\"legacy\"|\"strict\"} [options.mode=\"strict\"] The mode to determine the ImportDeclaration's behavior for CJS modules.\n     * @param {string[]} [options.globalObjectNames=[\"global\",\"globalThis\",\"self\",\"window\"]] The variable names for Global Object.\n     */\n    constructor(\n        globalScope,\n        {\n            mode = \"strict\",\n            globalObjectNames = [\"global\", \"globalThis\", \"self\", \"window\"],\n        } = {}\n    ) {\n        this.variableStack = [];\n        this.globalScope = globalScope;\n        this.mode = mode;\n        this.globalObjectNames = globalObjectNames.slice(0);\n    }\n\n    /**\n     * Iterate the references of global variables.\n     * @param {object} traceMap The trace map.\n     * @returns {IterableIterator<{node:Node,path:string[],type:symbol,info:any}>} The iterator to iterate references.\n     */\n    *iterateGlobalReferences(traceMap) {\n        for (const key of Object.keys(traceMap)) {\n            const nextTraceMap = traceMap[key];\n            const path = [key];\n            const variable = this.globalScope.set.get(key);\n\n            if (isModifiedGlobal(variable)) {\n                continue\n            }\n\n            yield* this._iterateVariableReferences(\n                variable,\n                path,\n                nextTraceMap,\n                true\n            );\n        }\n\n        for (const key of this.globalObjectNames) {\n            const path = [];\n            const variable = this.globalScope.set.get(key);\n\n            if (isModifiedGlobal(variable)) {\n                continue\n            }\n\n            yield* this._iterateVariableReferences(\n                variable,\n                path,\n                traceMap,\n                false\n            );\n        }\n    }\n\n    /**\n     * Iterate the references of CommonJS modules.\n     * @param {object} traceMap The trace map.\n     * @returns {IterableIterator<{node:Node,path:string[],type:symbol,info:any}>} The iterator to iterate references.\n     */\n    *iterateCjsReferences(traceMap) {\n        for (const { node } of this.iterateGlobalReferences(requireCall)) {\n            const key = getStringIfConstant(node.arguments[0]);\n            if (key == null || !has(traceMap, key)) {\n                continue\n            }\n\n            const nextTraceMap = traceMap[key];\n            const path = [key];\n\n            if (nextTraceMap[READ]) {\n                yield {\n                    node,\n                    path,\n                    type: READ,\n                    info: nextTraceMap[READ],\n                };\n            }\n            yield* this._iteratePropertyReferences(node, path, nextTraceMap);\n        }\n    }\n\n    /**\n     * Iterate the references of ES modules.\n     * @param {object} traceMap The trace map.\n     * @returns {IterableIterator<{node:Node,path:string[],type:symbol,info:any}>} The iterator to iterate references.\n     */\n    *iterateEsmReferences(traceMap) {\n        const programNode = this.globalScope.block;\n\n        for (const node of programNode.body) {\n            if (!IMPORT_TYPE.test(node.type) || node.source == null) {\n                continue\n            }\n            const moduleId = node.source.value;\n\n            if (!has(traceMap, moduleId)) {\n                continue\n            }\n            const nextTraceMap = traceMap[moduleId];\n            const path = [moduleId];\n\n            if (nextTraceMap[READ]) {\n                yield { node, path, type: READ, info: nextTraceMap[READ] };\n            }\n\n            if (node.type === \"ExportAllDeclaration\") {\n                for (const key of Object.keys(nextTraceMap)) {\n                    const exportTraceMap = nextTraceMap[key];\n                    if (exportTraceMap[READ]) {\n                        yield {\n                            node,\n                            path: path.concat(key),\n                            type: READ,\n                            info: exportTraceMap[READ],\n                        };\n                    }\n                }\n            } else {\n                for (const specifier of node.specifiers) {\n                    const esm = has(nextTraceMap, ESM);\n                    const it = this._iterateImportReferences(\n                        specifier,\n                        path,\n                        esm\n                            ? nextTraceMap\n                            : this.mode === \"legacy\"\n                            ? Object.assign(\n                                  { default: nextTraceMap },\n                                  nextTraceMap\n                              )\n                            : { default: nextTraceMap }\n                    );\n\n                    if (esm) {\n                        yield* it;\n                    } else {\n                        for (const report of it) {\n                            report.path = report.path.filter(exceptDefault);\n                            if (\n                                report.path.length >= 2 ||\n                                report.type !== READ\n                            ) {\n                                yield report;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Iterate the references for a given variable.\n     * @param {Variable} variable The variable to iterate that references.\n     * @param {string[]} path The current path.\n     * @param {object} traceMap The trace map.\n     * @param {boolean} shouldReport = The flag to report those references.\n     * @returns {IterableIterator<{node:Node,path:string[],type:symbol,info:any}>} The iterator to iterate references.\n     */\n    *_iterateVariableReferences(variable, path, traceMap, shouldReport) {\n        if (this.variableStack.includes(variable)) {\n            return\n        }\n        this.variableStack.push(variable);\n        try {\n            for (const reference of variable.references) {\n                if (!reference.isRead()) {\n                    continue\n                }\n                const node = reference.identifier;\n\n                if (shouldReport && traceMap[READ]) {\n                    yield { node, path, type: READ, info: traceMap[READ] };\n                }\n                yield* this._iteratePropertyReferences(node, path, traceMap);\n            }\n        } finally {\n            this.variableStack.pop();\n        }\n    }\n\n    /**\n     * Iterate the references for a given AST node.\n     * @param rootNode The AST node to iterate references.\n     * @param {string[]} path The current path.\n     * @param {object} traceMap The trace map.\n     * @returns {IterableIterator<{node:Node,path:string[],type:symbol,info:any}>} The iterator to iterate references.\n     */\n    //eslint-disable-next-line complexity\n    *_iteratePropertyReferences(rootNode, path, traceMap) {\n        let node = rootNode;\n        while (isPassThrough(node)) {\n            node = node.parent;\n        }\n\n        const parent = node.parent;\n        if (parent.type === \"MemberExpression\") {\n            if (parent.object === node) {\n                const key = getPropertyName(parent);\n                if (key == null || !has(traceMap, key)) {\n                    return\n                }\n\n                path = path.concat(key); //eslint-disable-line no-param-reassign\n                const nextTraceMap = traceMap[key];\n                if (nextTraceMap[READ]) {\n                    yield {\n                        node: parent,\n                        path,\n                        type: READ,\n                        info: nextTraceMap[READ],\n                    };\n                }\n                yield* this._iteratePropertyReferences(\n                    parent,\n                    path,\n                    nextTraceMap\n                );\n            }\n            return\n        }\n        if (parent.type === \"CallExpression\") {\n            if (parent.callee === node && traceMap[CALL]) {\n                yield { node: parent, path, type: CALL, info: traceMap[CALL] };\n            }\n            return\n        }\n        if (parent.type === \"NewExpression\") {\n            if (parent.callee === node && traceMap[CONSTRUCT]) {\n                yield {\n                    node: parent,\n                    path,\n                    type: CONSTRUCT,\n                    info: traceMap[CONSTRUCT],\n                };\n            }\n            return\n        }\n        if (parent.type === \"AssignmentExpression\") {\n            if (parent.right === node) {\n                yield* this._iterateLhsReferences(parent.left, path, traceMap);\n                yield* this._iteratePropertyReferences(parent, path, traceMap);\n            }\n            return\n        }\n        if (parent.type === \"AssignmentPattern\") {\n            if (parent.right === node) {\n                yield* this._iterateLhsReferences(parent.left, path, traceMap);\n            }\n            return\n        }\n        if (parent.type === \"VariableDeclarator\") {\n            if (parent.init === node) {\n                yield* this._iterateLhsReferences(parent.id, path, traceMap);\n            }\n        }\n    }\n\n    /**\n     * Iterate the references for a given Pattern node.\n     * @param {Node} patternNode The Pattern node to iterate references.\n     * @param {string[]} path The current path.\n     * @param {object} traceMap The trace map.\n     * @returns {IterableIterator<{node:Node,path:string[],type:symbol,info:any}>} The iterator to iterate references.\n     */\n    *_iterateLhsReferences(patternNode, path, traceMap) {\n        if (patternNode.type === \"Identifier\") {\n            const variable = findVariable(this.globalScope, patternNode);\n            if (variable != null) {\n                yield* this._iterateVariableReferences(\n                    variable,\n                    path,\n                    traceMap,\n                    false\n                );\n            }\n            return\n        }\n        if (patternNode.type === \"ObjectPattern\") {\n            for (const property of patternNode.properties) {\n                const key = getPropertyName(property);\n\n                if (key == null || !has(traceMap, key)) {\n                    continue\n                }\n\n                const nextPath = path.concat(key);\n                const nextTraceMap = traceMap[key];\n                if (nextTraceMap[READ]) {\n                    yield {\n                        node: property,\n                        path: nextPath,\n                        type: READ,\n                        info: nextTraceMap[READ],\n                    };\n                }\n                yield* this._iterateLhsReferences(\n                    property.value,\n                    nextPath,\n                    nextTraceMap\n                );\n            }\n            return\n        }\n        if (patternNode.type === \"AssignmentPattern\") {\n            yield* this._iterateLhsReferences(patternNode.left, path, traceMap);\n        }\n    }\n\n    /**\n     * Iterate the references for a given ModuleSpecifier node.\n     * @param {Node} specifierNode The ModuleSpecifier node to iterate references.\n     * @param {string[]} path The current path.\n     * @param {object} traceMap The trace map.\n     * @returns {IterableIterator<{node:Node,path:string[],type:symbol,info:any}>} The iterator to iterate references.\n     */\n    *_iterateImportReferences(specifierNode, path, traceMap) {\n        const type = specifierNode.type;\n\n        if (type === \"ImportSpecifier\" || type === \"ImportDefaultSpecifier\") {\n            const key =\n                type === \"ImportDefaultSpecifier\"\n                    ? \"default\"\n                    : specifierNode.imported.name;\n            if (!has(traceMap, key)) {\n                return\n            }\n\n            path = path.concat(key); //eslint-disable-line no-param-reassign\n            const nextTraceMap = traceMap[key];\n            if (nextTraceMap[READ]) {\n                yield {\n                    node: specifierNode,\n                    path,\n                    type: READ,\n                    info: nextTraceMap[READ],\n                };\n            }\n            yield* this._iterateVariableReferences(\n                findVariable(this.globalScope, specifierNode.local),\n                path,\n                nextTraceMap,\n                false\n            );\n\n            return\n        }\n\n        if (type === \"ImportNamespaceSpecifier\") {\n            yield* this._iterateVariableReferences(\n                findVariable(this.globalScope, specifierNode.local),\n                path,\n                traceMap,\n                false\n            );\n            return\n        }\n\n        if (type === \"ExportSpecifier\") {\n            const key = specifierNode.local.name;\n            if (!has(traceMap, key)) {\n                return\n            }\n\n            path = path.concat(key); //eslint-disable-line no-param-reassign\n            const nextTraceMap = traceMap[key];\n            if (nextTraceMap[READ]) {\n                yield {\n                    node: specifierNode,\n                    path,\n                    type: READ,\n                    info: nextTraceMap[READ],\n                };\n            }\n        }\n    }\n}\n\nReferenceTracker.READ = READ;\nReferenceTracker.CALL = CALL;\nReferenceTracker.CONSTRUCT = CONSTRUCT;\nReferenceTracker.ESM = ESM;\n\n/**\n * This is a predicate function for Array#filter.\n * @param {string} name A name part.\n * @param {number} index The index of the name.\n * @returns {boolean} `false` if it's default.\n */\nfunction exceptDefault(name, index) {\n    return !(index === 1 && name === \"default\")\n}\n\nvar index = {\n    CALL,\n    CONSTRUCT,\n    ESM,\n    findVariable,\n    getFunctionHeadLocation,\n    getFunctionNameWithKind,\n    getInnermostScope,\n    getPropertyName,\n    getStaticValue,\n    getStringIfConstant,\n    hasSideEffect,\n    isArrowToken,\n    isClosingBraceToken,\n    isClosingBracketToken,\n    isClosingParenToken,\n    isColonToken,\n    isCommaToken,\n    isCommentToken,\n    isNotArrowToken,\n    isNotClosingBraceToken,\n    isNotClosingBracketToken,\n    isNotClosingParenToken,\n    isNotColonToken,\n    isNotCommaToken,\n    isNotCommentToken,\n    isNotOpeningBraceToken,\n    isNotOpeningBracketToken,\n    isNotOpeningParenToken,\n    isNotSemicolonToken,\n    isOpeningBraceToken,\n    isOpeningBracketToken,\n    isOpeningParenToken,\n    isParenthesized,\n    isSemicolonToken,\n    PatternMatcher,\n    READ,\n    ReferenceTracker,\n};\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (index);\n\n//# sourceMappingURL=index.mjs.map\n\n\n//# sourceURL=webpack://javascript/./node_modules/eslint-utils/index.mjs?");

/***/ }),

/***/ "./node_modules/espree/node_modules/acorn/dist/acorn.mjs":
/*!***************************************************************!*\
  !*** ./node_modules/espree/node_modules/acorn/dist/acorn.mjs ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Node\": () => (/* binding */ Node),\n/* harmony export */   \"Parser\": () => (/* binding */ Parser),\n/* harmony export */   \"Position\": () => (/* binding */ Position),\n/* harmony export */   \"SourceLocation\": () => (/* binding */ SourceLocation),\n/* harmony export */   \"TokContext\": () => (/* binding */ TokContext),\n/* harmony export */   \"Token\": () => (/* binding */ Token),\n/* harmony export */   \"TokenType\": () => (/* binding */ TokenType),\n/* harmony export */   \"defaultOptions\": () => (/* binding */ defaultOptions),\n/* harmony export */   \"getLineInfo\": () => (/* binding */ getLineInfo),\n/* harmony export */   \"isIdentifierChar\": () => (/* binding */ isIdentifierChar),\n/* harmony export */   \"isIdentifierStart\": () => (/* binding */ isIdentifierStart),\n/* harmony export */   \"isNewLine\": () => (/* binding */ isNewLine),\n/* harmony export */   \"keywordTypes\": () => (/* binding */ keywords$1),\n/* harmony export */   \"lineBreak\": () => (/* binding */ lineBreak),\n/* harmony export */   \"lineBreakG\": () => (/* binding */ lineBreakG),\n/* harmony export */   \"nonASCIIwhitespace\": () => (/* binding */ nonASCIIwhitespace),\n/* harmony export */   \"parse\": () => (/* binding */ parse),\n/* harmony export */   \"parseExpressionAt\": () => (/* binding */ parseExpressionAt),\n/* harmony export */   \"tokContexts\": () => (/* binding */ types$1),\n/* harmony export */   \"tokTypes\": () => (/* binding */ types),\n/* harmony export */   \"tokenizer\": () => (/* binding */ tokenizer),\n/* harmony export */   \"version\": () => (/* binding */ version)\n/* harmony export */ });\n// Reserved word lists for various dialects of the language\n\nvar reservedWords = {\n  3: \"abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile\",\n  5: \"class enum extends super const export import\",\n  6: \"enum\",\n  strict: \"implements interface let package private protected public static yield\",\n  strictBind: \"eval arguments\"\n};\n\n// And the keywords\n\nvar ecma5AndLessKeywords = \"break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this\";\n\nvar keywords = {\n  5: ecma5AndLessKeywords,\n  \"5module\": ecma5AndLessKeywords + \" export import\",\n  6: ecma5AndLessKeywords + \" const class extends export import super\"\n};\n\nvar keywordRelationalOperator = /^in(stanceof)?$/;\n\n// ## Character categories\n\n// Big ugly regular expressions that match characters in the\n// whitespace, identifier, and identifier-start categories. These\n// are only applied when a character is found to actually have a\n// code point above 128.\n// Generated by `bin/generate-identifier-regex.js`.\nvar nonASCIIidentifierStartChars = \"\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u037f\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u052f\\u0531-\\u0556\\u0559\\u0560-\\u0588\\u05d0-\\u05ea\\u05ef-\\u05f2\\u0620-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06e5\\u06e6\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u0860-\\u086a\\u08a0-\\u08b4\\u08b6-\\u08c7\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc\\u09dd\\u09df-\\u09e1\\u09f0\\u09f1\\u09fc\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0\\u0ae1\\u0af9\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c39\\u0c3d\\u0c58-\\u0c5a\\u0c60\\u0c61\\u0c80\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cde\\u0ce0\\u0ce1\\u0cf1\\u0cf2\\u0d04-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d54-\\u0d56\\u0d5f-\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32\\u0e33\\u0e40-\\u0e46\\u0e81\\u0e82\\u0e84\\u0e86-\\u0e8a\\u0e8c-\\u0ea3\\u0ea5\\u0ea7-\\u0eb0\\u0eb2\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f5\\u13f8-\\u13fd\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f8\\u1700-\\u170c\\u170e-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1878\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191e\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19b0-\\u19c9\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4b\\u1b83-\\u1ba0\\u1bae\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1c80-\\u1c88\\u1c90-\\u1cba\\u1cbd-\\u1cbf\\u1ce9-\\u1cec\\u1cee-\\u1cf3\\u1cf5\\u1cf6\\u1cfa\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2118-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2c2e\\u2c30-\\u2c5e\\u2c60-\\u2ce4\\u2ceb-\\u2cee\\u2cf2\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309b-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312f\\u3131-\\u318e\\u31a0-\\u31bf\\u31f0-\\u31ff\\u3400-\\u4dbf\\u4e00-\\u9ffc\\ua000-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a\\ua62b\\ua640-\\ua66e\\ua67f-\\ua69d\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua7bf\\ua7c2-\\ua7ca\\ua7f5-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua8fd\\ua8fe\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\ua9e0-\\ua9e4\\ua9e6-\\ua9ef\\ua9fa-\\ua9fe\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa7e-\\uaaaf\\uaab1\\uaab5\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uab30-\\uab5a\\uab5c-\\uab69\\uab70-\\uabe2\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc\";\nvar nonASCIIidentifierChars = \"\\u200c\\u200d\\xb7\\u0300-\\u036f\\u0387\\u0483-\\u0487\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u0669\\u0670\\u06d6-\\u06dc\\u06df-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u06f0-\\u06f9\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07c0-\\u07c9\\u07eb-\\u07f3\\u07fd\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0859-\\u085b\\u08d3-\\u08e1\\u08e3-\\u0903\\u093a-\\u093c\\u093e-\\u094f\\u0951-\\u0957\\u0962\\u0963\\u0966-\\u096f\\u0981-\\u0983\\u09bc\\u09be-\\u09c4\\u09c7\\u09c8\\u09cb-\\u09cd\\u09d7\\u09e2\\u09e3\\u09e6-\\u09ef\\u09fe\\u0a01-\\u0a03\\u0a3c\\u0a3e-\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a66-\\u0a71\\u0a75\\u0a81-\\u0a83\\u0abc\\u0abe-\\u0ac5\\u0ac7-\\u0ac9\\u0acb-\\u0acd\\u0ae2\\u0ae3\\u0ae6-\\u0aef\\u0afa-\\u0aff\\u0b01-\\u0b03\\u0b3c\\u0b3e-\\u0b44\\u0b47\\u0b48\\u0b4b-\\u0b4d\\u0b55-\\u0b57\\u0b62\\u0b63\\u0b66-\\u0b6f\\u0b82\\u0bbe-\\u0bc2\\u0bc6-\\u0bc8\\u0bca-\\u0bcd\\u0bd7\\u0be6-\\u0bef\\u0c00-\\u0c04\\u0c3e-\\u0c44\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0c66-\\u0c6f\\u0c81-\\u0c83\\u0cbc\\u0cbe-\\u0cc4\\u0cc6-\\u0cc8\\u0cca-\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0ce6-\\u0cef\\u0d00-\\u0d03\\u0d3b\\u0d3c\\u0d3e-\\u0d44\\u0d46-\\u0d48\\u0d4a-\\u0d4d\\u0d57\\u0d62\\u0d63\\u0d66-\\u0d6f\\u0d81-\\u0d83\\u0dca\\u0dcf-\\u0dd4\\u0dd6\\u0dd8-\\u0ddf\\u0de6-\\u0def\\u0df2\\u0df3\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0e50-\\u0e59\\u0eb1\\u0eb4-\\u0ebc\\u0ec8-\\u0ecd\\u0ed0-\\u0ed9\\u0f18\\u0f19\\u0f20-\\u0f29\\u0f35\\u0f37\\u0f39\\u0f3e\\u0f3f\\u0f71-\\u0f84\\u0f86\\u0f87\\u0f8d-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102b-\\u103e\\u1040-\\u1049\\u1056-\\u1059\\u105e-\\u1060\\u1062-\\u1064\\u1067-\\u106d\\u1071-\\u1074\\u1082-\\u108d\\u108f-\\u109d\\u135d-\\u135f\\u1369-\\u1371\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b4-\\u17d3\\u17dd\\u17e0-\\u17e9\\u180b-\\u180d\\u1810-\\u1819\\u18a9\\u1920-\\u192b\\u1930-\\u193b\\u1946-\\u194f\\u19d0-\\u19da\\u1a17-\\u1a1b\\u1a55-\\u1a5e\\u1a60-\\u1a7c\\u1a7f-\\u1a89\\u1a90-\\u1a99\\u1ab0-\\u1abd\\u1abf\\u1ac0\\u1b00-\\u1b04\\u1b34-\\u1b44\\u1b50-\\u1b59\\u1b6b-\\u1b73\\u1b80-\\u1b82\\u1ba1-\\u1bad\\u1bb0-\\u1bb9\\u1be6-\\u1bf3\\u1c24-\\u1c37\\u1c40-\\u1c49\\u1c50-\\u1c59\\u1cd0-\\u1cd2\\u1cd4-\\u1ce8\\u1ced\\u1cf4\\u1cf7-\\u1cf9\\u1dc0-\\u1df9\\u1dfb-\\u1dff\\u203f\\u2040\\u2054\\u20d0-\\u20dc\\u20e1\\u20e5-\\u20f0\\u2cef-\\u2cf1\\u2d7f\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\ua620-\\ua629\\ua66f\\ua674-\\ua67d\\ua69e\\ua69f\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua823-\\ua827\\ua82c\\ua880\\ua881\\ua8b4-\\ua8c5\\ua8d0-\\ua8d9\\ua8e0-\\ua8f1\\ua8ff-\\ua909\\ua926-\\ua92d\\ua947-\\ua953\\ua980-\\ua983\\ua9b3-\\ua9c0\\ua9d0-\\ua9d9\\ua9e5\\ua9f0-\\ua9f9\\uaa29-\\uaa36\\uaa43\\uaa4c\\uaa4d\\uaa50-\\uaa59\\uaa7b-\\uaa7d\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uaaeb-\\uaaef\\uaaf5\\uaaf6\\uabe3-\\uabea\\uabec\\uabed\\uabf0-\\uabf9\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe2f\\ufe33\\ufe34\\ufe4d-\\ufe4f\\uff10-\\uff19\\uff3f\";\n\nvar nonASCIIidentifierStart = new RegExp(\"[\" + nonASCIIidentifierStartChars + \"]\");\nvar nonASCIIidentifier = new RegExp(\"[\" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + \"]\");\n\nnonASCIIidentifierStartChars = nonASCIIidentifierChars = null;\n\n// These are a run-length and offset encoded representation of the\n// >0xffff code points that are a valid part of identifiers. The\n// offset starts at 0x10000, and each pair of numbers represents an\n// offset to the next range, and then a size of the range. They were\n// generated by bin/generate-identifier-regex.js\n\n// eslint-disable-next-line comma-spacing\nvar astralIdentifierStartCodes = [0,11,2,25,2,18,2,1,2,14,3,13,35,122,70,52,268,28,4,48,48,31,14,29,6,37,11,29,3,35,5,7,2,4,43,157,19,35,5,35,5,39,9,51,157,310,10,21,11,7,153,5,3,0,2,43,2,1,4,0,3,22,11,22,10,30,66,18,2,1,11,21,11,25,71,55,7,1,65,0,16,3,2,2,2,28,43,28,4,28,36,7,2,27,28,53,11,21,11,18,14,17,111,72,56,50,14,50,14,35,349,41,7,1,79,28,11,0,9,21,107,20,28,22,13,52,76,44,33,24,27,35,30,0,3,0,9,34,4,0,13,47,15,3,22,0,2,0,36,17,2,24,85,6,2,0,2,3,2,14,2,9,8,46,39,7,3,1,3,21,2,6,2,1,2,4,4,0,19,0,13,4,159,52,19,3,21,2,31,47,21,1,2,0,185,46,42,3,37,47,21,0,60,42,14,0,72,26,230,43,117,63,32,7,3,0,3,7,2,1,2,23,16,0,2,0,95,7,3,38,17,0,2,0,29,0,11,39,8,0,22,0,12,45,20,0,35,56,264,8,2,36,18,0,50,29,113,6,2,1,2,37,22,0,26,5,2,1,2,31,15,0,328,18,190,0,80,921,103,110,18,195,2749,1070,4050,582,8634,568,8,30,114,29,19,47,17,3,32,20,6,18,689,63,129,74,6,0,67,12,65,1,2,0,29,6135,9,1237,43,8,8952,286,50,2,18,3,9,395,2309,106,6,12,4,8,8,9,5991,84,2,70,2,1,3,0,3,1,3,3,2,11,2,0,2,6,2,64,2,3,3,7,2,6,2,27,2,3,2,4,2,0,4,6,2,339,3,24,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,7,2357,44,11,6,17,0,370,43,1301,196,60,67,8,0,1205,3,2,26,2,1,2,0,3,0,2,9,2,3,2,0,2,0,7,0,5,0,2,0,2,0,2,2,2,1,2,0,3,0,2,0,2,0,2,0,2,0,2,1,2,0,3,3,2,6,2,3,2,3,2,0,2,9,2,16,6,2,2,4,2,16,4421,42717,35,4148,12,221,3,5761,15,7472,3104,541,1507,4938];\n\n// eslint-disable-next-line comma-spacing\nvar astralIdentifierCodes = [509,0,227,0,150,4,294,9,1368,2,2,1,6,3,41,2,5,0,166,1,574,3,9,9,370,1,154,10,176,2,54,14,32,9,16,3,46,10,54,9,7,2,37,13,2,9,6,1,45,0,13,2,49,13,9,3,2,11,83,11,7,0,161,11,6,9,7,3,56,1,2,6,3,1,3,2,10,0,11,1,3,6,4,4,193,17,10,9,5,0,82,19,13,9,214,6,3,8,28,1,83,16,16,9,82,12,9,9,84,14,5,9,243,14,166,9,71,5,2,1,3,3,2,0,2,1,13,9,120,6,3,6,4,0,29,9,41,6,2,3,9,0,10,10,47,15,406,7,2,7,17,9,57,21,2,13,123,5,4,0,2,1,2,6,2,0,9,9,49,4,2,1,2,4,9,9,330,3,19306,9,135,4,60,6,26,9,1014,0,2,54,8,3,82,0,12,1,19628,1,5319,4,4,5,9,7,3,6,31,3,149,2,1418,49,513,54,5,49,9,0,15,0,23,4,2,14,1361,6,2,16,3,6,2,1,2,4,262,6,10,9,419,13,1495,6,110,6,6,9,4759,9,787719,239];\n\n// This has a complexity linear to the value of the code. The\n// assumption is that looking up astral identifier characters is\n// rare.\nfunction isInAstralSet(code, set) {\n  var pos = 0x10000;\n  for (var i = 0; i < set.length; i += 2) {\n    pos += set[i];\n    if (pos > code) { return false }\n    pos += set[i + 1];\n    if (pos >= code) { return true }\n  }\n}\n\n// Test whether a given character code starts an identifier.\n\nfunction isIdentifierStart(code, astral) {\n  if (code < 65) { return code === 36 }\n  if (code < 91) { return true }\n  if (code < 97) { return code === 95 }\n  if (code < 123) { return true }\n  if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code)) }\n  if (astral === false) { return false }\n  return isInAstralSet(code, astralIdentifierStartCodes)\n}\n\n// Test whether a given character is part of an identifier.\n\nfunction isIdentifierChar(code, astral) {\n  if (code < 48) { return code === 36 }\n  if (code < 58) { return true }\n  if (code < 65) { return false }\n  if (code < 91) { return true }\n  if (code < 97) { return code === 95 }\n  if (code < 123) { return true }\n  if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code)) }\n  if (astral === false) { return false }\n  return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes)\n}\n\n// ## Token types\n\n// The assignment of fine-grained, information-carrying type objects\n// allows the tokenizer to store the information it has about a\n// token in a way that is very cheap for the parser to look up.\n\n// All token type variables start with an underscore, to make them\n// easy to recognize.\n\n// The `beforeExpr` property is used to disambiguate between regular\n// expressions and divisions. It is set on all token types that can\n// be followed by an expression (thus, a slash after them would be a\n// regular expression).\n//\n// The `startsExpr` property is used to check if the token ends a\n// `yield` expression. It is set on all token types that either can\n// directly start an expression (like a quotation mark) or can\n// continue an expression (like the body of a string).\n//\n// `isLoop` marks a keyword as starting a loop, which is important\n// to know when parsing a label, in order to allow or disallow\n// continue jumps to that label.\n\nvar TokenType = function TokenType(label, conf) {\n  if ( conf === void 0 ) conf = {};\n\n  this.label = label;\n  this.keyword = conf.keyword;\n  this.beforeExpr = !!conf.beforeExpr;\n  this.startsExpr = !!conf.startsExpr;\n  this.isLoop = !!conf.isLoop;\n  this.isAssign = !!conf.isAssign;\n  this.prefix = !!conf.prefix;\n  this.postfix = !!conf.postfix;\n  this.binop = conf.binop || null;\n  this.updateContext = null;\n};\n\nfunction binop(name, prec) {\n  return new TokenType(name, {beforeExpr: true, binop: prec})\n}\nvar beforeExpr = {beforeExpr: true}, startsExpr = {startsExpr: true};\n\n// Map keyword names to token types.\n\nvar keywords$1 = {};\n\n// Succinct definitions of keyword token types\nfunction kw(name, options) {\n  if ( options === void 0 ) options = {};\n\n  options.keyword = name;\n  return keywords$1[name] = new TokenType(name, options)\n}\n\nvar types = {\n  num: new TokenType(\"num\", startsExpr),\n  regexp: new TokenType(\"regexp\", startsExpr),\n  string: new TokenType(\"string\", startsExpr),\n  name: new TokenType(\"name\", startsExpr),\n  eof: new TokenType(\"eof\"),\n\n  // Punctuation token types.\n  bracketL: new TokenType(\"[\", {beforeExpr: true, startsExpr: true}),\n  bracketR: new TokenType(\"]\"),\n  braceL: new TokenType(\"{\", {beforeExpr: true, startsExpr: true}),\n  braceR: new TokenType(\"}\"),\n  parenL: new TokenType(\"(\", {beforeExpr: true, startsExpr: true}),\n  parenR: new TokenType(\")\"),\n  comma: new TokenType(\",\", beforeExpr),\n  semi: new TokenType(\";\", beforeExpr),\n  colon: new TokenType(\":\", beforeExpr),\n  dot: new TokenType(\".\"),\n  question: new TokenType(\"?\", beforeExpr),\n  questionDot: new TokenType(\"?.\"),\n  arrow: new TokenType(\"=>\", beforeExpr),\n  template: new TokenType(\"template\"),\n  invalidTemplate: new TokenType(\"invalidTemplate\"),\n  ellipsis: new TokenType(\"...\", beforeExpr),\n  backQuote: new TokenType(\"`\", startsExpr),\n  dollarBraceL: new TokenType(\"${\", {beforeExpr: true, startsExpr: true}),\n\n  // Operators. These carry several kinds of properties to help the\n  // parser use them properly (the presence of these properties is\n  // what categorizes them as operators).\n  //\n  // `binop`, when present, specifies that this operator is a binary\n  // operator, and will refer to its precedence.\n  //\n  // `prefix` and `postfix` mark the operator as a prefix or postfix\n  // unary operator.\n  //\n  // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as\n  // binary operators with a very low precedence, that should result\n  // in AssignmentExpression nodes.\n\n  eq: new TokenType(\"=\", {beforeExpr: true, isAssign: true}),\n  assign: new TokenType(\"_=\", {beforeExpr: true, isAssign: true}),\n  incDec: new TokenType(\"++/--\", {prefix: true, postfix: true, startsExpr: true}),\n  prefix: new TokenType(\"!/~\", {beforeExpr: true, prefix: true, startsExpr: true}),\n  logicalOR: binop(\"||\", 1),\n  logicalAND: binop(\"&&\", 2),\n  bitwiseOR: binop(\"|\", 3),\n  bitwiseXOR: binop(\"^\", 4),\n  bitwiseAND: binop(\"&\", 5),\n  equality: binop(\"==/!=/===/!==\", 6),\n  relational: binop(\"</>/<=/>=\", 7),\n  bitShift: binop(\"<</>>/>>>\", 8),\n  plusMin: new TokenType(\"+/-\", {beforeExpr: true, binop: 9, prefix: true, startsExpr: true}),\n  modulo: binop(\"%\", 10),\n  star: binop(\"*\", 10),\n  slash: binop(\"/\", 10),\n  starstar: new TokenType(\"**\", {beforeExpr: true}),\n  coalesce: binop(\"??\", 1),\n\n  // Keyword token types.\n  _break: kw(\"break\"),\n  _case: kw(\"case\", beforeExpr),\n  _catch: kw(\"catch\"),\n  _continue: kw(\"continue\"),\n  _debugger: kw(\"debugger\"),\n  _default: kw(\"default\", beforeExpr),\n  _do: kw(\"do\", {isLoop: true, beforeExpr: true}),\n  _else: kw(\"else\", beforeExpr),\n  _finally: kw(\"finally\"),\n  _for: kw(\"for\", {isLoop: true}),\n  _function: kw(\"function\", startsExpr),\n  _if: kw(\"if\"),\n  _return: kw(\"return\", beforeExpr),\n  _switch: kw(\"switch\"),\n  _throw: kw(\"throw\", beforeExpr),\n  _try: kw(\"try\"),\n  _var: kw(\"var\"),\n  _const: kw(\"const\"),\n  _while: kw(\"while\", {isLoop: true}),\n  _with: kw(\"with\"),\n  _new: kw(\"new\", {beforeExpr: true, startsExpr: true}),\n  _this: kw(\"this\", startsExpr),\n  _super: kw(\"super\", startsExpr),\n  _class: kw(\"class\", startsExpr),\n  _extends: kw(\"extends\", beforeExpr),\n  _export: kw(\"export\"),\n  _import: kw(\"import\", startsExpr),\n  _null: kw(\"null\", startsExpr),\n  _true: kw(\"true\", startsExpr),\n  _false: kw(\"false\", startsExpr),\n  _in: kw(\"in\", {beforeExpr: true, binop: 7}),\n  _instanceof: kw(\"instanceof\", {beforeExpr: true, binop: 7}),\n  _typeof: kw(\"typeof\", {beforeExpr: true, prefix: true, startsExpr: true}),\n  _void: kw(\"void\", {beforeExpr: true, prefix: true, startsExpr: true}),\n  _delete: kw(\"delete\", {beforeExpr: true, prefix: true, startsExpr: true})\n};\n\n// Matches a whole line break (where CRLF is considered a single\n// line break). Used to count lines.\n\nvar lineBreak = /\\r\\n?|\\n|\\u2028|\\u2029/;\nvar lineBreakG = new RegExp(lineBreak.source, \"g\");\n\nfunction isNewLine(code, ecma2019String) {\n  return code === 10 || code === 13 || (!ecma2019String && (code === 0x2028 || code === 0x2029))\n}\n\nvar nonASCIIwhitespace = /[\\u1680\\u2000-\\u200a\\u202f\\u205f\\u3000\\ufeff]/;\n\nvar skipWhiteSpace = /(?:\\s|\\/\\/.*|\\/\\*[^]*?\\*\\/)*/g;\n\nvar ref = Object.prototype;\nvar hasOwnProperty = ref.hasOwnProperty;\nvar toString = ref.toString;\n\n// Checks if an object has a property.\n\nfunction has(obj, propName) {\n  return hasOwnProperty.call(obj, propName)\n}\n\nvar isArray = Array.isArray || (function (obj) { return (\n  toString.call(obj) === \"[object Array]\"\n); });\n\nfunction wordsRegexp(words) {\n  return new RegExp(\"^(?:\" + words.replace(/ /g, \"|\") + \")$\")\n}\n\n// These are used when `options.locations` is on, for the\n// `startLoc` and `endLoc` properties.\n\nvar Position = function Position(line, col) {\n  this.line = line;\n  this.column = col;\n};\n\nPosition.prototype.offset = function offset (n) {\n  return new Position(this.line, this.column + n)\n};\n\nvar SourceLocation = function SourceLocation(p, start, end) {\n  this.start = start;\n  this.end = end;\n  if (p.sourceFile !== null) { this.source = p.sourceFile; }\n};\n\n// The `getLineInfo` function is mostly useful when the\n// `locations` option is off (for performance reasons) and you\n// want to find the line/column position for a given character\n// offset. `input` should be the code string that the offset refers\n// into.\n\nfunction getLineInfo(input, offset) {\n  for (var line = 1, cur = 0;;) {\n    lineBreakG.lastIndex = cur;\n    var match = lineBreakG.exec(input);\n    if (match && match.index < offset) {\n      ++line;\n      cur = match.index + match[0].length;\n    } else {\n      return new Position(line, offset - cur)\n    }\n  }\n}\n\n// A second optional argument can be given to further configure\n// the parser process. These options are recognized:\n\nvar defaultOptions = {\n  // `ecmaVersion` indicates the ECMAScript version to parse. Must be\n  // either 3, 5, 6 (2015), 7 (2016), 8 (2017), 9 (2018), or 10\n  // (2019). This influences support for strict mode, the set of\n  // reserved words, and support for new syntax features. The default\n  // is 10.\n  ecmaVersion: 10,\n  // `sourceType` indicates the mode the code should be parsed in.\n  // Can be either `\"script\"` or `\"module\"`. This influences global\n  // strict mode and parsing of `import` and `export` declarations.\n  sourceType: \"script\",\n  // `onInsertedSemicolon` can be a callback that will be called\n  // when a semicolon is automatically inserted. It will be passed\n  // the position of the comma as an offset, and if `locations` is\n  // enabled, it is given the location as a `{line, column}` object\n  // as second argument.\n  onInsertedSemicolon: null,\n  // `onTrailingComma` is similar to `onInsertedSemicolon`, but for\n  // trailing commas.\n  onTrailingComma: null,\n  // By default, reserved words are only enforced if ecmaVersion >= 5.\n  // Set `allowReserved` to a boolean value to explicitly turn this on\n  // an off. When this option has the value \"never\", reserved words\n  // and keywords can also not be used as property names.\n  allowReserved: null,\n  // When enabled, a return at the top level is not considered an\n  // error.\n  allowReturnOutsideFunction: false,\n  // When enabled, import/export statements are not constrained to\n  // appearing at the top of the program.\n  allowImportExportEverywhere: false,\n  // When enabled, await identifiers are allowed to appear at the top-level scope,\n  // but they are still not allowed in non-async functions.\n  allowAwaitOutsideFunction: false,\n  // When enabled, hashbang directive in the beginning of file\n  // is allowed and treated as a line comment.\n  allowHashBang: false,\n  // When `locations` is on, `loc` properties holding objects with\n  // `start` and `end` properties in `{line, column}` form (with\n  // line being 1-based and column 0-based) will be attached to the\n  // nodes.\n  locations: false,\n  // A function can be passed as `onToken` option, which will\n  // cause Acorn to call that function with object in the same\n  // format as tokens returned from `tokenizer().getToken()`. Note\n  // that you are not allowed to call the parser from the\n  // callbackthat will corrupt its internal state.\n  onToken: null,\n  // A function can be passed as `onComment` option, which will\n  // cause Acorn to call that function with `(block, text, start,\n  // end)` parameters whenever a comment is skipped. `block` is a\n  // boolean indicating whether this is a block (`/* */`) comment,\n  // `text` is the content of the comment, and `start` and `end` are\n  // character offsets that denote the start and end of the comment.\n  // When the `locations` option is on, two more parameters are\n  // passed, the full `{line, column}` locations of the start and\n  // end of the comments. Note that you are not allowed to call the\n  // parser from the callbackthat will corrupt its internal state.\n  onComment: null,\n  // Nodes have their start and end characters offsets recorded in\n  // `start` and `end` properties (directly on the node, rather than\n  // the `loc` object, which holds line/column data. To also add a\n  // [semi-standardized][range] `range` property holding a `[start,\n  // end]` array with the same numbers, set the `ranges` option to\n  // `true`.\n  //\n  // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678\n  ranges: false,\n  // It is possible to parse multiple files into a single AST by\n  // passing the tree produced by parsing the first file as\n  // `program` option in subsequent parses. This will add the\n  // toplevel forms of the parsed file to the `Program` (top) node\n  // of an existing parse tree.\n  program: null,\n  // When `locations` is on, you can pass this to record the source\n  // file in every node's `loc` object.\n  sourceFile: null,\n  // This value, if given, is stored in every node, whether\n  // `locations` is on or off.\n  directSourceFile: null,\n  // When enabled, parenthesized expressions are represented by\n  // (non-standard) ParenthesizedExpression nodes\n  preserveParens: false\n};\n\n// Interpret and default an options object\n\nfunction getOptions(opts) {\n  var options = {};\n\n  for (var opt in defaultOptions)\n    { options[opt] = opts && has(opts, opt) ? opts[opt] : defaultOptions[opt]; }\n\n  if (options.ecmaVersion >= 2015)\n    { options.ecmaVersion -= 2009; }\n\n  if (options.allowReserved == null)\n    { options.allowReserved = options.ecmaVersion < 5; }\n\n  if (isArray(options.onToken)) {\n    var tokens = options.onToken;\n    options.onToken = function (token) { return tokens.push(token); };\n  }\n  if (isArray(options.onComment))\n    { options.onComment = pushComment(options, options.onComment); }\n\n  return options\n}\n\nfunction pushComment(options, array) {\n  return function(block, text, start, end, startLoc, endLoc) {\n    var comment = {\n      type: block ? \"Block\" : \"Line\",\n      value: text,\n      start: start,\n      end: end\n    };\n    if (options.locations)\n      { comment.loc = new SourceLocation(this, startLoc, endLoc); }\n    if (options.ranges)\n      { comment.range = [start, end]; }\n    array.push(comment);\n  }\n}\n\n// Each scope gets a bitset that may contain these flags\nvar\n    SCOPE_TOP = 1,\n    SCOPE_FUNCTION = 2,\n    SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION,\n    SCOPE_ASYNC = 4,\n    SCOPE_GENERATOR = 8,\n    SCOPE_ARROW = 16,\n    SCOPE_SIMPLE_CATCH = 32,\n    SCOPE_SUPER = 64,\n    SCOPE_DIRECT_SUPER = 128;\n\nfunction functionFlags(async, generator) {\n  return SCOPE_FUNCTION | (async ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0)\n}\n\n// Used in checkLVal and declareName to determine the type of a binding\nvar\n    BIND_NONE = 0, // Not a binding\n    BIND_VAR = 1, // Var-style binding\n    BIND_LEXICAL = 2, // Let- or const-style binding\n    BIND_FUNCTION = 3, // Function declaration\n    BIND_SIMPLE_CATCH = 4, // Simple (identifier pattern) catch binding\n    BIND_OUTSIDE = 5; // Special case for function names as bound inside the function\n\nvar Parser = function Parser(options, input, startPos) {\n  this.options = options = getOptions(options);\n  this.sourceFile = options.sourceFile;\n  this.keywords = wordsRegexp(keywords[options.ecmaVersion >= 6 ? 6 : options.sourceType === \"module\" ? \"5module\" : 5]);\n  var reserved = \"\";\n  if (options.allowReserved !== true) {\n    for (var v = options.ecmaVersion;; v--)\n      { if (reserved = reservedWords[v]) { break } }\n    if (options.sourceType === \"module\") { reserved += \" await\"; }\n  }\n  this.reservedWords = wordsRegexp(reserved);\n  var reservedStrict = (reserved ? reserved + \" \" : \"\") + reservedWords.strict;\n  this.reservedWordsStrict = wordsRegexp(reservedStrict);\n  this.reservedWordsStrictBind = wordsRegexp(reservedStrict + \" \" + reservedWords.strictBind);\n  this.input = String(input);\n\n  // Used to signal to callers of `readWord1` whether the word\n  // contained any escape sequences. This is needed because words with\n  // escape sequences must not be interpreted as keywords.\n  this.containsEsc = false;\n\n  // Set up token state\n\n  // The current position of the tokenizer in the input.\n  if (startPos) {\n    this.pos = startPos;\n    this.lineStart = this.input.lastIndexOf(\"\\n\", startPos - 1) + 1;\n    this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;\n  } else {\n    this.pos = this.lineStart = 0;\n    this.curLine = 1;\n  }\n\n  // Properties of the current token:\n  // Its type\n  this.type = types.eof;\n  // For tokens that include more information than their type, the value\n  this.value = null;\n  // Its start and end offset\n  this.start = this.end = this.pos;\n  // And, if locations are used, the {line, column} object\n  // corresponding to those offsets\n  this.startLoc = this.endLoc = this.curPosition();\n\n  // Position information for the previous token\n  this.lastTokEndLoc = this.lastTokStartLoc = null;\n  this.lastTokStart = this.lastTokEnd = this.pos;\n\n  // The context stack is used to superficially track syntactic\n  // context to predict whether a regular expression is allowed in a\n  // given position.\n  this.context = this.initialContext();\n  this.exprAllowed = true;\n\n  // Figure out if it's a module code.\n  this.inModule = options.sourceType === \"module\";\n  this.strict = this.inModule || this.strictDirective(this.pos);\n\n  // Used to signify the start of a potential arrow function\n  this.potentialArrowAt = -1;\n\n  // Positions to delayed-check that yield/await does not exist in default parameters.\n  this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;\n  // Labels in scope.\n  this.labels = [];\n  // Thus-far undefined exports.\n  this.undefinedExports = {};\n\n  // If enabled, skip leading hashbang line.\n  if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === \"#!\")\n    { this.skipLineComment(2); }\n\n  // Scope tracking for duplicate variable names (see scope.js)\n  this.scopeStack = [];\n  this.enterScope(SCOPE_TOP);\n\n  // For RegExp validation\n  this.regexpState = null;\n};\n\nvar prototypeAccessors = { inFunction: { configurable: true },inGenerator: { configurable: true },inAsync: { configurable: true },allowSuper: { configurable: true },allowDirectSuper: { configurable: true },treatFunctionsAsVar: { configurable: true } };\n\nParser.prototype.parse = function parse () {\n  var node = this.options.program || this.startNode();\n  this.nextToken();\n  return this.parseTopLevel(node)\n};\n\nprototypeAccessors.inFunction.get = function () { return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0 };\nprototypeAccessors.inGenerator.get = function () { return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0 };\nprototypeAccessors.inAsync.get = function () { return (this.currentVarScope().flags & SCOPE_ASYNC) > 0 };\nprototypeAccessors.allowSuper.get = function () { return (this.currentThisScope().flags & SCOPE_SUPER) > 0 };\nprototypeAccessors.allowDirectSuper.get = function () { return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0 };\nprototypeAccessors.treatFunctionsAsVar.get = function () { return this.treatFunctionsAsVarInScope(this.currentScope()) };\n\n// Switch to a getter for 7.0.0.\nParser.prototype.inNonArrowFunction = function inNonArrowFunction () { return (this.currentThisScope().flags & SCOPE_FUNCTION) > 0 };\n\nParser.extend = function extend () {\n    var plugins = [], len = arguments.length;\n    while ( len-- ) plugins[ len ] = arguments[ len ];\n\n  var cls = this;\n  for (var i = 0; i < plugins.length; i++) { cls = plugins[i](cls); }\n  return cls\n};\n\nParser.parse = function parse (input, options) {\n  return new this(options, input).parse()\n};\n\nParser.parseExpressionAt = function parseExpressionAt (input, pos, options) {\n  var parser = new this(options, input, pos);\n  parser.nextToken();\n  return parser.parseExpression()\n};\n\nParser.tokenizer = function tokenizer (input, options) {\n  return new this(options, input)\n};\n\nObject.defineProperties( Parser.prototype, prototypeAccessors );\n\nvar pp = Parser.prototype;\n\n// ## Parser utilities\n\nvar literal = /^(?:'((?:\\\\.|[^'\\\\])*?)'|\"((?:\\\\.|[^\"\\\\])*?)\")/;\npp.strictDirective = function(start) {\n  for (;;) {\n    // Try to find string literal.\n    skipWhiteSpace.lastIndex = start;\n    start += skipWhiteSpace.exec(this.input)[0].length;\n    var match = literal.exec(this.input.slice(start));\n    if (!match) { return false }\n    if ((match[1] || match[2]) === \"use strict\") {\n      skipWhiteSpace.lastIndex = start + match[0].length;\n      var spaceAfter = skipWhiteSpace.exec(this.input), end = spaceAfter.index + spaceAfter[0].length;\n      var next = this.input.charAt(end);\n      return next === \";\" || next === \"}\" ||\n        (lineBreak.test(spaceAfter[0]) &&\n         !(/[(`.[+\\-/*%<>=,?^&]/.test(next) || next === \"!\" && this.input.charAt(end + 1) === \"=\"))\n    }\n    start += match[0].length;\n\n    // Skip semicolon, if any.\n    skipWhiteSpace.lastIndex = start;\n    start += skipWhiteSpace.exec(this.input)[0].length;\n    if (this.input[start] === \";\")\n      { start++; }\n  }\n};\n\n// Predicate that tests whether the next token is of the given\n// type, and if yes, consumes it as a side effect.\n\npp.eat = function(type) {\n  if (this.type === type) {\n    this.next();\n    return true\n  } else {\n    return false\n  }\n};\n\n// Tests whether parsed token is a contextual keyword.\n\npp.isContextual = function(name) {\n  return this.type === types.name && this.value === name && !this.containsEsc\n};\n\n// Consumes contextual keyword if possible.\n\npp.eatContextual = function(name) {\n  if (!this.isContextual(name)) { return false }\n  this.next();\n  return true\n};\n\n// Asserts that following token is given contextual keyword.\n\npp.expectContextual = function(name) {\n  if (!this.eatContextual(name)) { this.unexpected(); }\n};\n\n// Test whether a semicolon can be inserted at the current position.\n\npp.canInsertSemicolon = function() {\n  return this.type === types.eof ||\n    this.type === types.braceR ||\n    lineBreak.test(this.input.slice(this.lastTokEnd, this.start))\n};\n\npp.insertSemicolon = function() {\n  if (this.canInsertSemicolon()) {\n    if (this.options.onInsertedSemicolon)\n      { this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc); }\n    return true\n  }\n};\n\n// Consume a semicolon, or, failing that, see if we are allowed to\n// pretend that there is a semicolon at this position.\n\npp.semicolon = function() {\n  if (!this.eat(types.semi) && !this.insertSemicolon()) { this.unexpected(); }\n};\n\npp.afterTrailingComma = function(tokType, notNext) {\n  if (this.type === tokType) {\n    if (this.options.onTrailingComma)\n      { this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc); }\n    if (!notNext)\n      { this.next(); }\n    return true\n  }\n};\n\n// Expect a token of a given type. If found, consume it, otherwise,\n// raise an unexpected token error.\n\npp.expect = function(type) {\n  this.eat(type) || this.unexpected();\n};\n\n// Raise an unexpected token error.\n\npp.unexpected = function(pos) {\n  this.raise(pos != null ? pos : this.start, \"Unexpected token\");\n};\n\nfunction DestructuringErrors() {\n  this.shorthandAssign =\n  this.trailingComma =\n  this.parenthesizedAssign =\n  this.parenthesizedBind =\n  this.doubleProto =\n    -1;\n}\n\npp.checkPatternErrors = function(refDestructuringErrors, isAssign) {\n  if (!refDestructuringErrors) { return }\n  if (refDestructuringErrors.trailingComma > -1)\n    { this.raiseRecoverable(refDestructuringErrors.trailingComma, \"Comma is not permitted after the rest element\"); }\n  var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;\n  if (parens > -1) { this.raiseRecoverable(parens, \"Parenthesized pattern\"); }\n};\n\npp.checkExpressionErrors = function(refDestructuringErrors, andThrow) {\n  if (!refDestructuringErrors) { return false }\n  var shorthandAssign = refDestructuringErrors.shorthandAssign;\n  var doubleProto = refDestructuringErrors.doubleProto;\n  if (!andThrow) { return shorthandAssign >= 0 || doubleProto >= 0 }\n  if (shorthandAssign >= 0)\n    { this.raise(shorthandAssign, \"Shorthand property assignments are valid only in destructuring patterns\"); }\n  if (doubleProto >= 0)\n    { this.raiseRecoverable(doubleProto, \"Redefinition of __proto__ property\"); }\n};\n\npp.checkYieldAwaitInDefaultParams = function() {\n  if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos))\n    { this.raise(this.yieldPos, \"Yield expression cannot be a default value\"); }\n  if (this.awaitPos)\n    { this.raise(this.awaitPos, \"Await expression cannot be a default value\"); }\n};\n\npp.isSimpleAssignTarget = function(expr) {\n  if (expr.type === \"ParenthesizedExpression\")\n    { return this.isSimpleAssignTarget(expr.expression) }\n  return expr.type === \"Identifier\" || expr.type === \"MemberExpression\"\n};\n\nvar pp$1 = Parser.prototype;\n\n// ### Statement parsing\n\n// Parse a program. Initializes the parser, reads any number of\n// statements, and wraps them in a Program node.  Optionally takes a\n// `program` argument.  If present, the statements will be appended\n// to its body instead of creating a new node.\n\npp$1.parseTopLevel = function(node) {\n  var exports = {};\n  if (!node.body) { node.body = []; }\n  while (this.type !== types.eof) {\n    var stmt = this.parseStatement(null, true, exports);\n    node.body.push(stmt);\n  }\n  if (this.inModule)\n    { for (var i = 0, list = Object.keys(this.undefinedExports); i < list.length; i += 1)\n      {\n        var name = list[i];\n\n        this.raiseRecoverable(this.undefinedExports[name].start, (\"Export '\" + name + \"' is not defined\"));\n      } }\n  this.adaptDirectivePrologue(node.body);\n  this.next();\n  node.sourceType = this.options.sourceType;\n  return this.finishNode(node, \"Program\")\n};\n\nvar loopLabel = {kind: \"loop\"}, switchLabel = {kind: \"switch\"};\n\npp$1.isLet = function(context) {\n  if (this.options.ecmaVersion < 6 || !this.isContextual(\"let\")) { return false }\n  skipWhiteSpace.lastIndex = this.pos;\n  var skip = skipWhiteSpace.exec(this.input);\n  var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);\n  // For ambiguous cases, determine if a LexicalDeclaration (or only a\n  // Statement) is allowed here. If context is not empty then only a Statement\n  // is allowed. However, `let [` is an explicit negative lookahead for\n  // ExpressionStatement, so special-case it first.\n  if (nextCh === 91) { return true } // '['\n  if (context) { return false }\n\n  if (nextCh === 123) { return true } // '{'\n  if (isIdentifierStart(nextCh, true)) {\n    var pos = next + 1;\n    while (isIdentifierChar(this.input.charCodeAt(pos), true)) { ++pos; }\n    var ident = this.input.slice(next, pos);\n    if (!keywordRelationalOperator.test(ident)) { return true }\n  }\n  return false\n};\n\n// check 'async [no LineTerminator here] function'\n// - 'async /*foo*/ function' is OK.\n// - 'async /*\\n*/ function' is invalid.\npp$1.isAsyncFunction = function() {\n  if (this.options.ecmaVersion < 8 || !this.isContextual(\"async\"))\n    { return false }\n\n  skipWhiteSpace.lastIndex = this.pos;\n  var skip = skipWhiteSpace.exec(this.input);\n  var next = this.pos + skip[0].length;\n  return !lineBreak.test(this.input.slice(this.pos, next)) &&\n    this.input.slice(next, next + 8) === \"function\" &&\n    (next + 8 === this.input.length || !isIdentifierChar(this.input.charAt(next + 8)))\n};\n\n// Parse a single statement.\n//\n// If expecting a statement and finding a slash operator, parse a\n// regular expression literal. This is to handle cases like\n// `if (foo) /blah/.exec(foo)`, where looking at the previous token\n// does not help.\n\npp$1.parseStatement = function(context, topLevel, exports) {\n  var starttype = this.type, node = this.startNode(), kind;\n\n  if (this.isLet(context)) {\n    starttype = types._var;\n    kind = \"let\";\n  }\n\n  // Most types of statements are recognized by the keyword they\n  // start with. Many are trivial to parse, some require a bit of\n  // complexity.\n\n  switch (starttype) {\n  case types._break: case types._continue: return this.parseBreakContinueStatement(node, starttype.keyword)\n  case types._debugger: return this.parseDebuggerStatement(node)\n  case types._do: return this.parseDoStatement(node)\n  case types._for: return this.parseForStatement(node)\n  case types._function:\n    // Function as sole body of either an if statement or a labeled statement\n    // works, but not when it is part of a labeled statement that is the sole\n    // body of an if statement.\n    if ((context && (this.strict || context !== \"if\" && context !== \"label\")) && this.options.ecmaVersion >= 6) { this.unexpected(); }\n    return this.parseFunctionStatement(node, false, !context)\n  case types._class:\n    if (context) { this.unexpected(); }\n    return this.parseClass(node, true)\n  case types._if: return this.parseIfStatement(node)\n  case types._return: return this.parseReturnStatement(node)\n  case types._switch: return this.parseSwitchStatement(node)\n  case types._throw: return this.parseThrowStatement(node)\n  case types._try: return this.parseTryStatement(node)\n  case types._const: case types._var:\n    kind = kind || this.value;\n    if (context && kind !== \"var\") { this.unexpected(); }\n    return this.parseVarStatement(node, kind)\n  case types._while: return this.parseWhileStatement(node)\n  case types._with: return this.parseWithStatement(node)\n  case types.braceL: return this.parseBlock(true, node)\n  case types.semi: return this.parseEmptyStatement(node)\n  case types._export:\n  case types._import:\n    if (this.options.ecmaVersion > 10 && starttype === types._import) {\n      skipWhiteSpace.lastIndex = this.pos;\n      var skip = skipWhiteSpace.exec(this.input);\n      var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);\n      if (nextCh === 40 || nextCh === 46) // '(' or '.'\n        { return this.parseExpressionStatement(node, this.parseExpression()) }\n    }\n\n    if (!this.options.allowImportExportEverywhere) {\n      if (!topLevel)\n        { this.raise(this.start, \"'import' and 'export' may only appear at the top level\"); }\n      if (!this.inModule)\n        { this.raise(this.start, \"'import' and 'export' may appear only with 'sourceType: module'\"); }\n    }\n    return starttype === types._import ? this.parseImport(node) : this.parseExport(node, exports)\n\n    // If the statement does not start with a statement keyword or a\n    // brace, it's an ExpressionStatement or LabeledStatement. We\n    // simply start parsing an expression, and afterwards, if the\n    // next token is a colon and the expression was a simple\n    // Identifier node, we switch to interpreting it as a label.\n  default:\n    if (this.isAsyncFunction()) {\n      if (context) { this.unexpected(); }\n      this.next();\n      return this.parseFunctionStatement(node, true, !context)\n    }\n\n    var maybeName = this.value, expr = this.parseExpression();\n    if (starttype === types.name && expr.type === \"Identifier\" && this.eat(types.colon))\n      { return this.parseLabeledStatement(node, maybeName, expr, context) }\n    else { return this.parseExpressionStatement(node, expr) }\n  }\n};\n\npp$1.parseBreakContinueStatement = function(node, keyword) {\n  var isBreak = keyword === \"break\";\n  this.next();\n  if (this.eat(types.semi) || this.insertSemicolon()) { node.label = null; }\n  else if (this.type !== types.name) { this.unexpected(); }\n  else {\n    node.label = this.parseIdent();\n    this.semicolon();\n  }\n\n  // Verify that there is an actual destination to break or\n  // continue to.\n  var i = 0;\n  for (; i < this.labels.length; ++i) {\n    var lab = this.labels[i];\n    if (node.label == null || lab.name === node.label.name) {\n      if (lab.kind != null && (isBreak || lab.kind === \"loop\")) { break }\n      if (node.label && isBreak) { break }\n    }\n  }\n  if (i === this.labels.length) { this.raise(node.start, \"Unsyntactic \" + keyword); }\n  return this.finishNode(node, isBreak ? \"BreakStatement\" : \"ContinueStatement\")\n};\n\npp$1.parseDebuggerStatement = function(node) {\n  this.next();\n  this.semicolon();\n  return this.finishNode(node, \"DebuggerStatement\")\n};\n\npp$1.parseDoStatement = function(node) {\n  this.next();\n  this.labels.push(loopLabel);\n  node.body = this.parseStatement(\"do\");\n  this.labels.pop();\n  this.expect(types._while);\n  node.test = this.parseParenExpression();\n  if (this.options.ecmaVersion >= 6)\n    { this.eat(types.semi); }\n  else\n    { this.semicolon(); }\n  return this.finishNode(node, \"DoWhileStatement\")\n};\n\n// Disambiguating between a `for` and a `for`/`in` or `for`/`of`\n// loop is non-trivial. Basically, we have to parse the init `var`\n// statement or expression, disallowing the `in` operator (see\n// the second parameter to `parseExpression`), and then check\n// whether the next token is `in` or `of`. When there is no init\n// part (semicolon immediately after the opening parenthesis), it\n// is a regular `for` loop.\n\npp$1.parseForStatement = function(node) {\n  this.next();\n  var awaitAt = (this.options.ecmaVersion >= 9 && (this.inAsync || (!this.inFunction && this.options.allowAwaitOutsideFunction)) && this.eatContextual(\"await\")) ? this.lastTokStart : -1;\n  this.labels.push(loopLabel);\n  this.enterScope(0);\n  this.expect(types.parenL);\n  if (this.type === types.semi) {\n    if (awaitAt > -1) { this.unexpected(awaitAt); }\n    return this.parseFor(node, null)\n  }\n  var isLet = this.isLet();\n  if (this.type === types._var || this.type === types._const || isLet) {\n    var init$1 = this.startNode(), kind = isLet ? \"let\" : this.value;\n    this.next();\n    this.parseVar(init$1, true, kind);\n    this.finishNode(init$1, \"VariableDeclaration\");\n    if ((this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual(\"of\"))) && init$1.declarations.length === 1) {\n      if (this.options.ecmaVersion >= 9) {\n        if (this.type === types._in) {\n          if (awaitAt > -1) { this.unexpected(awaitAt); }\n        } else { node.await = awaitAt > -1; }\n      }\n      return this.parseForIn(node, init$1)\n    }\n    if (awaitAt > -1) { this.unexpected(awaitAt); }\n    return this.parseFor(node, init$1)\n  }\n  var refDestructuringErrors = new DestructuringErrors;\n  var init = this.parseExpression(true, refDestructuringErrors);\n  if (this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual(\"of\"))) {\n    if (this.options.ecmaVersion >= 9) {\n      if (this.type === types._in) {\n        if (awaitAt > -1) { this.unexpected(awaitAt); }\n      } else { node.await = awaitAt > -1; }\n    }\n    this.toAssignable(init, false, refDestructuringErrors);\n    this.checkLVal(init);\n    return this.parseForIn(node, init)\n  } else {\n    this.checkExpressionErrors(refDestructuringErrors, true);\n  }\n  if (awaitAt > -1) { this.unexpected(awaitAt); }\n  return this.parseFor(node, init)\n};\n\npp$1.parseFunctionStatement = function(node, isAsync, declarationPosition) {\n  this.next();\n  return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync)\n};\n\npp$1.parseIfStatement = function(node) {\n  this.next();\n  node.test = this.parseParenExpression();\n  // allow function declarations in branches, but only in non-strict mode\n  node.consequent = this.parseStatement(\"if\");\n  node.alternate = this.eat(types._else) ? this.parseStatement(\"if\") : null;\n  return this.finishNode(node, \"IfStatement\")\n};\n\npp$1.parseReturnStatement = function(node) {\n  if (!this.inFunction && !this.options.allowReturnOutsideFunction)\n    { this.raise(this.start, \"'return' outside of function\"); }\n  this.next();\n\n  // In `return` (and `break`/`continue`), the keywords with\n  // optional arguments, we eagerly look for a semicolon or the\n  // possibility to insert one.\n\n  if (this.eat(types.semi) || this.insertSemicolon()) { node.argument = null; }\n  else { node.argument = this.parseExpression(); this.semicolon(); }\n  return this.finishNode(node, \"ReturnStatement\")\n};\n\npp$1.parseSwitchStatement = function(node) {\n  this.next();\n  node.discriminant = this.parseParenExpression();\n  node.cases = [];\n  this.expect(types.braceL);\n  this.labels.push(switchLabel);\n  this.enterScope(0);\n\n  // Statements under must be grouped (by label) in SwitchCase\n  // nodes. `cur` is used to keep the node that we are currently\n  // adding statements to.\n\n  var cur;\n  for (var sawDefault = false; this.type !== types.braceR;) {\n    if (this.type === types._case || this.type === types._default) {\n      var isCase = this.type === types._case;\n      if (cur) { this.finishNode(cur, \"SwitchCase\"); }\n      node.cases.push(cur = this.startNode());\n      cur.consequent = [];\n      this.next();\n      if (isCase) {\n        cur.test = this.parseExpression();\n      } else {\n        if (sawDefault) { this.raiseRecoverable(this.lastTokStart, \"Multiple default clauses\"); }\n        sawDefault = true;\n        cur.test = null;\n      }\n      this.expect(types.colon);\n    } else {\n      if (!cur) { this.unexpected(); }\n      cur.consequent.push(this.parseStatement(null));\n    }\n  }\n  this.exitScope();\n  if (cur) { this.finishNode(cur, \"SwitchCase\"); }\n  this.next(); // Closing brace\n  this.labels.pop();\n  return this.finishNode(node, \"SwitchStatement\")\n};\n\npp$1.parseThrowStatement = function(node) {\n  this.next();\n  if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start)))\n    { this.raise(this.lastTokEnd, \"Illegal newline after throw\"); }\n  node.argument = this.parseExpression();\n  this.semicolon();\n  return this.finishNode(node, \"ThrowStatement\")\n};\n\n// Reused empty array added for node fields that are always empty.\n\nvar empty = [];\n\npp$1.parseTryStatement = function(node) {\n  this.next();\n  node.block = this.parseBlock();\n  node.handler = null;\n  if (this.type === types._catch) {\n    var clause = this.startNode();\n    this.next();\n    if (this.eat(types.parenL)) {\n      clause.param = this.parseBindingAtom();\n      var simple = clause.param.type === \"Identifier\";\n      this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);\n      this.checkLVal(clause.param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL);\n      this.expect(types.parenR);\n    } else {\n      if (this.options.ecmaVersion < 10) { this.unexpected(); }\n      clause.param = null;\n      this.enterScope(0);\n    }\n    clause.body = this.parseBlock(false);\n    this.exitScope();\n    node.handler = this.finishNode(clause, \"CatchClause\");\n  }\n  node.finalizer = this.eat(types._finally) ? this.parseBlock() : null;\n  if (!node.handler && !node.finalizer)\n    { this.raise(node.start, \"Missing catch or finally clause\"); }\n  return this.finishNode(node, \"TryStatement\")\n};\n\npp$1.parseVarStatement = function(node, kind) {\n  this.next();\n  this.parseVar(node, false, kind);\n  this.semicolon();\n  return this.finishNode(node, \"VariableDeclaration\")\n};\n\npp$1.parseWhileStatement = function(node) {\n  this.next();\n  node.test = this.parseParenExpression();\n  this.labels.push(loopLabel);\n  node.body = this.parseStatement(\"while\");\n  this.labels.pop();\n  return this.finishNode(node, \"WhileStatement\")\n};\n\npp$1.parseWithStatement = function(node) {\n  if (this.strict) { this.raise(this.start, \"'with' in strict mode\"); }\n  this.next();\n  node.object = this.parseParenExpression();\n  node.body = this.parseStatement(\"with\");\n  return this.finishNode(node, \"WithStatement\")\n};\n\npp$1.parseEmptyStatement = function(node) {\n  this.next();\n  return this.finishNode(node, \"EmptyStatement\")\n};\n\npp$1.parseLabeledStatement = function(node, maybeName, expr, context) {\n  for (var i$1 = 0, list = this.labels; i$1 < list.length; i$1 += 1)\n    {\n    var label = list[i$1];\n\n    if (label.name === maybeName)\n      { this.raise(expr.start, \"Label '\" + maybeName + \"' is already declared\");\n  } }\n  var kind = this.type.isLoop ? \"loop\" : this.type === types._switch ? \"switch\" : null;\n  for (var i = this.labels.length - 1; i >= 0; i--) {\n    var label$1 = this.labels[i];\n    if (label$1.statementStart === node.start) {\n      // Update information about previous labels on this node\n      label$1.statementStart = this.start;\n      label$1.kind = kind;\n    } else { break }\n  }\n  this.labels.push({name: maybeName, kind: kind, statementStart: this.start});\n  node.body = this.parseStatement(context ? context.indexOf(\"label\") === -1 ? context + \"label\" : context : \"label\");\n  this.labels.pop();\n  node.label = expr;\n  return this.finishNode(node, \"LabeledStatement\")\n};\n\npp$1.parseExpressionStatement = function(node, expr) {\n  node.expression = expr;\n  this.semicolon();\n  return this.finishNode(node, \"ExpressionStatement\")\n};\n\n// Parse a semicolon-enclosed block of statements, handling `\"use\n// strict\"` declarations when `allowStrict` is true (used for\n// function bodies).\n\npp$1.parseBlock = function(createNewLexicalScope, node, exitStrict) {\n  if ( createNewLexicalScope === void 0 ) createNewLexicalScope = true;\n  if ( node === void 0 ) node = this.startNode();\n\n  node.body = [];\n  this.expect(types.braceL);\n  if (createNewLexicalScope) { this.enterScope(0); }\n  while (this.type !== types.braceR) {\n    var stmt = this.parseStatement(null);\n    node.body.push(stmt);\n  }\n  if (exitStrict) { this.strict = false; }\n  this.next();\n  if (createNewLexicalScope) { this.exitScope(); }\n  return this.finishNode(node, \"BlockStatement\")\n};\n\n// Parse a regular `for` loop. The disambiguation code in\n// `parseStatement` will already have parsed the init statement or\n// expression.\n\npp$1.parseFor = function(node, init) {\n  node.init = init;\n  this.expect(types.semi);\n  node.test = this.type === types.semi ? null : this.parseExpression();\n  this.expect(types.semi);\n  node.update = this.type === types.parenR ? null : this.parseExpression();\n  this.expect(types.parenR);\n  node.body = this.parseStatement(\"for\");\n  this.exitScope();\n  this.labels.pop();\n  return this.finishNode(node, \"ForStatement\")\n};\n\n// Parse a `for`/`in` and `for`/`of` loop, which are almost\n// same from parser's perspective.\n\npp$1.parseForIn = function(node, init) {\n  var isForIn = this.type === types._in;\n  this.next();\n\n  if (\n    init.type === \"VariableDeclaration\" &&\n    init.declarations[0].init != null &&\n    (\n      !isForIn ||\n      this.options.ecmaVersion < 8 ||\n      this.strict ||\n      init.kind !== \"var\" ||\n      init.declarations[0].id.type !== \"Identifier\"\n    )\n  ) {\n    this.raise(\n      init.start,\n      ((isForIn ? \"for-in\" : \"for-of\") + \" loop variable declaration may not have an initializer\")\n    );\n  } else if (init.type === \"AssignmentPattern\") {\n    this.raise(init.start, \"Invalid left-hand side in for-loop\");\n  }\n  node.left = init;\n  node.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();\n  this.expect(types.parenR);\n  node.body = this.parseStatement(\"for\");\n  this.exitScope();\n  this.labels.pop();\n  return this.finishNode(node, isForIn ? \"ForInStatement\" : \"ForOfStatement\")\n};\n\n// Parse a list of variable declarations.\n\npp$1.parseVar = function(node, isFor, kind) {\n  node.declarations = [];\n  node.kind = kind;\n  for (;;) {\n    var decl = this.startNode();\n    this.parseVarId(decl, kind);\n    if (this.eat(types.eq)) {\n      decl.init = this.parseMaybeAssign(isFor);\n    } else if (kind === \"const\" && !(this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual(\"of\")))) {\n      this.unexpected();\n    } else if (decl.id.type !== \"Identifier\" && !(isFor && (this.type === types._in || this.isContextual(\"of\")))) {\n      this.raise(this.lastTokEnd, \"Complex binding patterns require an initialization value\");\n    } else {\n      decl.init = null;\n    }\n    node.declarations.push(this.finishNode(decl, \"VariableDeclarator\"));\n    if (!this.eat(types.comma)) { break }\n  }\n  return node\n};\n\npp$1.parseVarId = function(decl, kind) {\n  decl.id = this.parseBindingAtom();\n  this.checkLVal(decl.id, kind === \"var\" ? BIND_VAR : BIND_LEXICAL, false);\n};\n\nvar FUNC_STATEMENT = 1, FUNC_HANGING_STATEMENT = 2, FUNC_NULLABLE_ID = 4;\n\n// Parse a function declaration or literal (depending on the\n// `statement & FUNC_STATEMENT`).\n\n// Remove `allowExpressionBody` for 7.0.0, as it is only called with false\npp$1.parseFunction = function(node, statement, allowExpressionBody, isAsync) {\n  this.initFunction(node);\n  if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {\n    if (this.type === types.star && (statement & FUNC_HANGING_STATEMENT))\n      { this.unexpected(); }\n    node.generator = this.eat(types.star);\n  }\n  if (this.options.ecmaVersion >= 8)\n    { node.async = !!isAsync; }\n\n  if (statement & FUNC_STATEMENT) {\n    node.id = (statement & FUNC_NULLABLE_ID) && this.type !== types.name ? null : this.parseIdent();\n    if (node.id && !(statement & FUNC_HANGING_STATEMENT))\n      // If it is a regular function declaration in sloppy mode, then it is\n      // subject to Annex B semantics (BIND_FUNCTION). Otherwise, the binding\n      // mode depends on properties of the current scope (see\n      // treatFunctionsAsVar).\n      { this.checkLVal(node.id, (this.strict || node.generator || node.async) ? this.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION); }\n  }\n\n  var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;\n  this.yieldPos = 0;\n  this.awaitPos = 0;\n  this.awaitIdentPos = 0;\n  this.enterScope(functionFlags(node.async, node.generator));\n\n  if (!(statement & FUNC_STATEMENT))\n    { node.id = this.type === types.name ? this.parseIdent() : null; }\n\n  this.parseFunctionParams(node);\n  this.parseFunctionBody(node, allowExpressionBody, false);\n\n  this.yieldPos = oldYieldPos;\n  this.awaitPos = oldAwaitPos;\n  this.awaitIdentPos = oldAwaitIdentPos;\n  return this.finishNode(node, (statement & FUNC_STATEMENT) ? \"FunctionDeclaration\" : \"FunctionExpression\")\n};\n\npp$1.parseFunctionParams = function(node) {\n  this.expect(types.parenL);\n  node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);\n  this.checkYieldAwaitInDefaultParams();\n};\n\n// Parse a class declaration or literal (depending on the\n// `isStatement` parameter).\n\npp$1.parseClass = function(node, isStatement) {\n  this.next();\n\n  // ecma-262 14.6 Class Definitions\n  // A class definition is always strict mode code.\n  var oldStrict = this.strict;\n  this.strict = true;\n\n  this.parseClassId(node, isStatement);\n  this.parseClassSuper(node);\n  var classBody = this.startNode();\n  var hadConstructor = false;\n  classBody.body = [];\n  this.expect(types.braceL);\n  while (this.type !== types.braceR) {\n    var element = this.parseClassElement(node.superClass !== null);\n    if (element) {\n      classBody.body.push(element);\n      if (element.type === \"MethodDefinition\" && element.kind === \"constructor\") {\n        if (hadConstructor) { this.raise(element.start, \"Duplicate constructor in the same class\"); }\n        hadConstructor = true;\n      }\n    }\n  }\n  this.strict = oldStrict;\n  this.next();\n  node.body = this.finishNode(classBody, \"ClassBody\");\n  return this.finishNode(node, isStatement ? \"ClassDeclaration\" : \"ClassExpression\")\n};\n\npp$1.parseClassElement = function(constructorAllowsSuper) {\n  var this$1 = this;\n\n  if (this.eat(types.semi)) { return null }\n\n  var method = this.startNode();\n  var tryContextual = function (k, noLineBreak) {\n    if ( noLineBreak === void 0 ) noLineBreak = false;\n\n    var start = this$1.start, startLoc = this$1.startLoc;\n    if (!this$1.eatContextual(k)) { return false }\n    if (this$1.type !== types.parenL && (!noLineBreak || !this$1.canInsertSemicolon())) { return true }\n    if (method.key) { this$1.unexpected(); }\n    method.computed = false;\n    method.key = this$1.startNodeAt(start, startLoc);\n    method.key.name = k;\n    this$1.finishNode(method.key, \"Identifier\");\n    return false\n  };\n\n  method.kind = \"method\";\n  method.static = tryContextual(\"static\");\n  var isGenerator = this.eat(types.star);\n  var isAsync = false;\n  if (!isGenerator) {\n    if (this.options.ecmaVersion >= 8 && tryContextual(\"async\", true)) {\n      isAsync = true;\n      isGenerator = this.options.ecmaVersion >= 9 && this.eat(types.star);\n    } else if (tryContextual(\"get\")) {\n      method.kind = \"get\";\n    } else if (tryContextual(\"set\")) {\n      method.kind = \"set\";\n    }\n  }\n  if (!method.key) { this.parsePropertyName(method); }\n  var key = method.key;\n  var allowsDirectSuper = false;\n  if (!method.computed && !method.static && (key.type === \"Identifier\" && key.name === \"constructor\" ||\n      key.type === \"Literal\" && key.value === \"constructor\")) {\n    if (method.kind !== \"method\") { this.raise(key.start, \"Constructor can't have get/set modifier\"); }\n    if (isGenerator) { this.raise(key.start, \"Constructor can't be a generator\"); }\n    if (isAsync) { this.raise(key.start, \"Constructor can't be an async method\"); }\n    method.kind = \"constructor\";\n    allowsDirectSuper = constructorAllowsSuper;\n  } else if (method.static && key.type === \"Identifier\" && key.name === \"prototype\") {\n    this.raise(key.start, \"Classes may not have a static property named prototype\");\n  }\n  this.parseClassMethod(method, isGenerator, isAsync, allowsDirectSuper);\n  if (method.kind === \"get\" && method.value.params.length !== 0)\n    { this.raiseRecoverable(method.value.start, \"getter should have no params\"); }\n  if (method.kind === \"set\" && method.value.params.length !== 1)\n    { this.raiseRecoverable(method.value.start, \"setter should have exactly one param\"); }\n  if (method.kind === \"set\" && method.value.params[0].type === \"RestElement\")\n    { this.raiseRecoverable(method.value.params[0].start, \"Setter cannot use rest params\"); }\n  return method\n};\n\npp$1.parseClassMethod = function(method, isGenerator, isAsync, allowsDirectSuper) {\n  method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);\n  return this.finishNode(method, \"MethodDefinition\")\n};\n\npp$1.parseClassId = function(node, isStatement) {\n  if (this.type === types.name) {\n    node.id = this.parseIdent();\n    if (isStatement)\n      { this.checkLVal(node.id, BIND_LEXICAL, false); }\n  } else {\n    if (isStatement === true)\n      { this.unexpected(); }\n    node.id = null;\n  }\n};\n\npp$1.parseClassSuper = function(node) {\n  node.superClass = this.eat(types._extends) ? this.parseExprSubscripts() : null;\n};\n\n// Parses module export declaration.\n\npp$1.parseExport = function(node, exports) {\n  this.next();\n  // export * from '...'\n  if (this.eat(types.star)) {\n    if (this.options.ecmaVersion >= 11) {\n      if (this.eatContextual(\"as\")) {\n        node.exported = this.parseIdent(true);\n        this.checkExport(exports, node.exported.name, this.lastTokStart);\n      } else {\n        node.exported = null;\n      }\n    }\n    this.expectContextual(\"from\");\n    if (this.type !== types.string) { this.unexpected(); }\n    node.source = this.parseExprAtom();\n    this.semicolon();\n    return this.finishNode(node, \"ExportAllDeclaration\")\n  }\n  if (this.eat(types._default)) { // export default ...\n    this.checkExport(exports, \"default\", this.lastTokStart);\n    var isAsync;\n    if (this.type === types._function || (isAsync = this.isAsyncFunction())) {\n      var fNode = this.startNode();\n      this.next();\n      if (isAsync) { this.next(); }\n      node.declaration = this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);\n    } else if (this.type === types._class) {\n      var cNode = this.startNode();\n      node.declaration = this.parseClass(cNode, \"nullableID\");\n    } else {\n      node.declaration = this.parseMaybeAssign();\n      this.semicolon();\n    }\n    return this.finishNode(node, \"ExportDefaultDeclaration\")\n  }\n  // export var|const|let|function|class ...\n  if (this.shouldParseExportStatement()) {\n    node.declaration = this.parseStatement(null);\n    if (node.declaration.type === \"VariableDeclaration\")\n      { this.checkVariableExport(exports, node.declaration.declarations); }\n    else\n      { this.checkExport(exports, node.declaration.id.name, node.declaration.id.start); }\n    node.specifiers = [];\n    node.source = null;\n  } else { // export { x, y as z } [from '...']\n    node.declaration = null;\n    node.specifiers = this.parseExportSpecifiers(exports);\n    if (this.eatContextual(\"from\")) {\n      if (this.type !== types.string) { this.unexpected(); }\n      node.source = this.parseExprAtom();\n    } else {\n      for (var i = 0, list = node.specifiers; i < list.length; i += 1) {\n        // check for keywords used as local names\n        var spec = list[i];\n\n        this.checkUnreserved(spec.local);\n        // check if export is defined\n        this.checkLocalExport(spec.local);\n      }\n\n      node.source = null;\n    }\n    this.semicolon();\n  }\n  return this.finishNode(node, \"ExportNamedDeclaration\")\n};\n\npp$1.checkExport = function(exports, name, pos) {\n  if (!exports) { return }\n  if (has(exports, name))\n    { this.raiseRecoverable(pos, \"Duplicate export '\" + name + \"'\"); }\n  exports[name] = true;\n};\n\npp$1.checkPatternExport = function(exports, pat) {\n  var type = pat.type;\n  if (type === \"Identifier\")\n    { this.checkExport(exports, pat.name, pat.start); }\n  else if (type === \"ObjectPattern\")\n    { for (var i = 0, list = pat.properties; i < list.length; i += 1)\n      {\n        var prop = list[i];\n\n        this.checkPatternExport(exports, prop);\n      } }\n  else if (type === \"ArrayPattern\")\n    { for (var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1) {\n      var elt = list$1[i$1];\n\n        if (elt) { this.checkPatternExport(exports, elt); }\n    } }\n  else if (type === \"Property\")\n    { this.checkPatternExport(exports, pat.value); }\n  else if (type === \"AssignmentPattern\")\n    { this.checkPatternExport(exports, pat.left); }\n  else if (type === \"RestElement\")\n    { this.checkPatternExport(exports, pat.argument); }\n  else if (type === \"ParenthesizedExpression\")\n    { this.checkPatternExport(exports, pat.expression); }\n};\n\npp$1.checkVariableExport = function(exports, decls) {\n  if (!exports) { return }\n  for (var i = 0, list = decls; i < list.length; i += 1)\n    {\n    var decl = list[i];\n\n    this.checkPatternExport(exports, decl.id);\n  }\n};\n\npp$1.shouldParseExportStatement = function() {\n  return this.type.keyword === \"var\" ||\n    this.type.keyword === \"const\" ||\n    this.type.keyword === \"class\" ||\n    this.type.keyword === \"function\" ||\n    this.isLet() ||\n    this.isAsyncFunction()\n};\n\n// Parses a comma-separated list of module exports.\n\npp$1.parseExportSpecifiers = function(exports) {\n  var nodes = [], first = true;\n  // export { x, y as z } [from '...']\n  this.expect(types.braceL);\n  while (!this.eat(types.braceR)) {\n    if (!first) {\n      this.expect(types.comma);\n      if (this.afterTrailingComma(types.braceR)) { break }\n    } else { first = false; }\n\n    var node = this.startNode();\n    node.local = this.parseIdent(true);\n    node.exported = this.eatContextual(\"as\") ? this.parseIdent(true) : node.local;\n    this.checkExport(exports, node.exported.name, node.exported.start);\n    nodes.push(this.finishNode(node, \"ExportSpecifier\"));\n  }\n  return nodes\n};\n\n// Parses import declaration.\n\npp$1.parseImport = function(node) {\n  this.next();\n  // import '...'\n  if (this.type === types.string) {\n    node.specifiers = empty;\n    node.source = this.parseExprAtom();\n  } else {\n    node.specifiers = this.parseImportSpecifiers();\n    this.expectContextual(\"from\");\n    node.source = this.type === types.string ? this.parseExprAtom() : this.unexpected();\n  }\n  this.semicolon();\n  return this.finishNode(node, \"ImportDeclaration\")\n};\n\n// Parses a comma-separated list of module imports.\n\npp$1.parseImportSpecifiers = function() {\n  var nodes = [], first = true;\n  if (this.type === types.name) {\n    // import defaultObj, { x, y as z } from '...'\n    var node = this.startNode();\n    node.local = this.parseIdent();\n    this.checkLVal(node.local, BIND_LEXICAL);\n    nodes.push(this.finishNode(node, \"ImportDefaultSpecifier\"));\n    if (!this.eat(types.comma)) { return nodes }\n  }\n  if (this.type === types.star) {\n    var node$1 = this.startNode();\n    this.next();\n    this.expectContextual(\"as\");\n    node$1.local = this.parseIdent();\n    this.checkLVal(node$1.local, BIND_LEXICAL);\n    nodes.push(this.finishNode(node$1, \"ImportNamespaceSpecifier\"));\n    return nodes\n  }\n  this.expect(types.braceL);\n  while (!this.eat(types.braceR)) {\n    if (!first) {\n      this.expect(types.comma);\n      if (this.afterTrailingComma(types.braceR)) { break }\n    } else { first = false; }\n\n    var node$2 = this.startNode();\n    node$2.imported = this.parseIdent(true);\n    if (this.eatContextual(\"as\")) {\n      node$2.local = this.parseIdent();\n    } else {\n      this.checkUnreserved(node$2.imported);\n      node$2.local = node$2.imported;\n    }\n    this.checkLVal(node$2.local, BIND_LEXICAL);\n    nodes.push(this.finishNode(node$2, \"ImportSpecifier\"));\n  }\n  return nodes\n};\n\n// Set `ExpressionStatement#directive` property for directive prologues.\npp$1.adaptDirectivePrologue = function(statements) {\n  for (var i = 0; i < statements.length && this.isDirectiveCandidate(statements[i]); ++i) {\n    statements[i].directive = statements[i].expression.raw.slice(1, -1);\n  }\n};\npp$1.isDirectiveCandidate = function(statement) {\n  return (\n    statement.type === \"ExpressionStatement\" &&\n    statement.expression.type === \"Literal\" &&\n    typeof statement.expression.value === \"string\" &&\n    // Reject parenthesized strings.\n    (this.input[statement.start] === \"\\\"\" || this.input[statement.start] === \"'\")\n  )\n};\n\nvar pp$2 = Parser.prototype;\n\n// Convert existing expression atom to assignable pattern\n// if possible.\n\npp$2.toAssignable = function(node, isBinding, refDestructuringErrors) {\n  if (this.options.ecmaVersion >= 6 && node) {\n    switch (node.type) {\n    case \"Identifier\":\n      if (this.inAsync && node.name === \"await\")\n        { this.raise(node.start, \"Cannot use 'await' as identifier inside an async function\"); }\n      break\n\n    case \"ObjectPattern\":\n    case \"ArrayPattern\":\n    case \"RestElement\":\n      break\n\n    case \"ObjectExpression\":\n      node.type = \"ObjectPattern\";\n      if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }\n      for (var i = 0, list = node.properties; i < list.length; i += 1) {\n        var prop = list[i];\n\n      this.toAssignable(prop, isBinding);\n        // Early error:\n        //   AssignmentRestProperty[Yield, Await] :\n        //     `...` DestructuringAssignmentTarget[Yield, Await]\n        //\n        //   It is a Syntax Error if |DestructuringAssignmentTarget| is an |ArrayLiteral| or an |ObjectLiteral|.\n        if (\n          prop.type === \"RestElement\" &&\n          (prop.argument.type === \"ArrayPattern\" || prop.argument.type === \"ObjectPattern\")\n        ) {\n          this.raise(prop.argument.start, \"Unexpected token\");\n        }\n      }\n      break\n\n    case \"Property\":\n      // AssignmentProperty has type === \"Property\"\n      if (node.kind !== \"init\") { this.raise(node.key.start, \"Object pattern can't contain getter or setter\"); }\n      this.toAssignable(node.value, isBinding);\n      break\n\n    case \"ArrayExpression\":\n      node.type = \"ArrayPattern\";\n      if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }\n      this.toAssignableList(node.elements, isBinding);\n      break\n\n    case \"SpreadElement\":\n      node.type = \"RestElement\";\n      this.toAssignable(node.argument, isBinding);\n      if (node.argument.type === \"AssignmentPattern\")\n        { this.raise(node.argument.start, \"Rest elements cannot have a default value\"); }\n      break\n\n    case \"AssignmentExpression\":\n      if (node.operator !== \"=\") { this.raise(node.left.end, \"Only '=' operator can be used for specifying default value.\"); }\n      node.type = \"AssignmentPattern\";\n      delete node.operator;\n      this.toAssignable(node.left, isBinding);\n      // falls through to AssignmentPattern\n\n    case \"AssignmentPattern\":\n      break\n\n    case \"ParenthesizedExpression\":\n      this.toAssignable(node.expression, isBinding, refDestructuringErrors);\n      break\n\n    case \"ChainExpression\":\n      this.raiseRecoverable(node.start, \"Optional chaining cannot appear in left-hand side\");\n      break\n\n    case \"MemberExpression\":\n      if (!isBinding) { break }\n\n    default:\n      this.raise(node.start, \"Assigning to rvalue\");\n    }\n  } else if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }\n  return node\n};\n\n// Convert list of expression atoms to binding list.\n\npp$2.toAssignableList = function(exprList, isBinding) {\n  var end = exprList.length;\n  for (var i = 0; i < end; i++) {\n    var elt = exprList[i];\n    if (elt) { this.toAssignable(elt, isBinding); }\n  }\n  if (end) {\n    var last = exprList[end - 1];\n    if (this.options.ecmaVersion === 6 && isBinding && last && last.type === \"RestElement\" && last.argument.type !== \"Identifier\")\n      { this.unexpected(last.argument.start); }\n  }\n  return exprList\n};\n\n// Parses spread element.\n\npp$2.parseSpread = function(refDestructuringErrors) {\n  var node = this.startNode();\n  this.next();\n  node.argument = this.parseMaybeAssign(false, refDestructuringErrors);\n  return this.finishNode(node, \"SpreadElement\")\n};\n\npp$2.parseRestBinding = function() {\n  var node = this.startNode();\n  this.next();\n\n  // RestElement inside of a function parameter must be an identifier\n  if (this.options.ecmaVersion === 6 && this.type !== types.name)\n    { this.unexpected(); }\n\n  node.argument = this.parseBindingAtom();\n\n  return this.finishNode(node, \"RestElement\")\n};\n\n// Parses lvalue (assignable) atom.\n\npp$2.parseBindingAtom = function() {\n  if (this.options.ecmaVersion >= 6) {\n    switch (this.type) {\n    case types.bracketL:\n      var node = this.startNode();\n      this.next();\n      node.elements = this.parseBindingList(types.bracketR, true, true);\n      return this.finishNode(node, \"ArrayPattern\")\n\n    case types.braceL:\n      return this.parseObj(true)\n    }\n  }\n  return this.parseIdent()\n};\n\npp$2.parseBindingList = function(close, allowEmpty, allowTrailingComma) {\n  var elts = [], first = true;\n  while (!this.eat(close)) {\n    if (first) { first = false; }\n    else { this.expect(types.comma); }\n    if (allowEmpty && this.type === types.comma) {\n      elts.push(null);\n    } else if (allowTrailingComma && this.afterTrailingComma(close)) {\n      break\n    } else if (this.type === types.ellipsis) {\n      var rest = this.parseRestBinding();\n      this.parseBindingListItem(rest);\n      elts.push(rest);\n      if (this.type === types.comma) { this.raise(this.start, \"Comma is not permitted after the rest element\"); }\n      this.expect(close);\n      break\n    } else {\n      var elem = this.parseMaybeDefault(this.start, this.startLoc);\n      this.parseBindingListItem(elem);\n      elts.push(elem);\n    }\n  }\n  return elts\n};\n\npp$2.parseBindingListItem = function(param) {\n  return param\n};\n\n// Parses assignment pattern around given atom if possible.\n\npp$2.parseMaybeDefault = function(startPos, startLoc, left) {\n  left = left || this.parseBindingAtom();\n  if (this.options.ecmaVersion < 6 || !this.eat(types.eq)) { return left }\n  var node = this.startNodeAt(startPos, startLoc);\n  node.left = left;\n  node.right = this.parseMaybeAssign();\n  return this.finishNode(node, \"AssignmentPattern\")\n};\n\n// Verify that a node is an lval  something that can be assigned\n// to.\n// bindingType can be either:\n// 'var' indicating that the lval creates a 'var' binding\n// 'let' indicating that the lval creates a lexical ('let' or 'const') binding\n// 'none' indicating that the binding should be checked for illegal identifiers, but not for duplicate references\n\npp$2.checkLVal = function(expr, bindingType, checkClashes) {\n  if ( bindingType === void 0 ) bindingType = BIND_NONE;\n\n  switch (expr.type) {\n  case \"Identifier\":\n    if (bindingType === BIND_LEXICAL && expr.name === \"let\")\n      { this.raiseRecoverable(expr.start, \"let is disallowed as a lexically bound name\"); }\n    if (this.strict && this.reservedWordsStrictBind.test(expr.name))\n      { this.raiseRecoverable(expr.start, (bindingType ? \"Binding \" : \"Assigning to \") + expr.name + \" in strict mode\"); }\n    if (checkClashes) {\n      if (has(checkClashes, expr.name))\n        { this.raiseRecoverable(expr.start, \"Argument name clash\"); }\n      checkClashes[expr.name] = true;\n    }\n    if (bindingType !== BIND_NONE && bindingType !== BIND_OUTSIDE) { this.declareName(expr.name, bindingType, expr.start); }\n    break\n\n  case \"ChainExpression\":\n    this.raiseRecoverable(expr.start, \"Optional chaining cannot appear in left-hand side\");\n    break\n\n  case \"MemberExpression\":\n    if (bindingType) { this.raiseRecoverable(expr.start, \"Binding member expression\"); }\n    break\n\n  case \"ObjectPattern\":\n    for (var i = 0, list = expr.properties; i < list.length; i += 1)\n      {\n    var prop = list[i];\n\n    this.checkLVal(prop, bindingType, checkClashes);\n  }\n    break\n\n  case \"Property\":\n    // AssignmentProperty has type === \"Property\"\n    this.checkLVal(expr.value, bindingType, checkClashes);\n    break\n\n  case \"ArrayPattern\":\n    for (var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1) {\n      var elem = list$1[i$1];\n\n    if (elem) { this.checkLVal(elem, bindingType, checkClashes); }\n    }\n    break\n\n  case \"AssignmentPattern\":\n    this.checkLVal(expr.left, bindingType, checkClashes);\n    break\n\n  case \"RestElement\":\n    this.checkLVal(expr.argument, bindingType, checkClashes);\n    break\n\n  case \"ParenthesizedExpression\":\n    this.checkLVal(expr.expression, bindingType, checkClashes);\n    break\n\n  default:\n    this.raise(expr.start, (bindingType ? \"Binding\" : \"Assigning to\") + \" rvalue\");\n  }\n};\n\n// A recursive descent parser operates by defining functions for all\n\nvar pp$3 = Parser.prototype;\n\n// Check if property name clashes with already added.\n// Object/class getters and setters are not allowed to clash \n// either with each other or with an init property  and in\n// strict mode, init properties are also not allowed to be repeated.\n\npp$3.checkPropClash = function(prop, propHash, refDestructuringErrors) {\n  if (this.options.ecmaVersion >= 9 && prop.type === \"SpreadElement\")\n    { return }\n  if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand))\n    { return }\n  var key = prop.key;\n  var name;\n  switch (key.type) {\n  case \"Identifier\": name = key.name; break\n  case \"Literal\": name = String(key.value); break\n  default: return\n  }\n  var kind = prop.kind;\n  if (this.options.ecmaVersion >= 6) {\n    if (name === \"__proto__\" && kind === \"init\") {\n      if (propHash.proto) {\n        if (refDestructuringErrors) {\n          if (refDestructuringErrors.doubleProto < 0)\n            { refDestructuringErrors.doubleProto = key.start; }\n          // Backwards-compat kludge. Can be removed in version 6.0\n        } else { this.raiseRecoverable(key.start, \"Redefinition of __proto__ property\"); }\n      }\n      propHash.proto = true;\n    }\n    return\n  }\n  name = \"$\" + name;\n  var other = propHash[name];\n  if (other) {\n    var redefinition;\n    if (kind === \"init\") {\n      redefinition = this.strict && other.init || other.get || other.set;\n    } else {\n      redefinition = other.init || other[kind];\n    }\n    if (redefinition)\n      { this.raiseRecoverable(key.start, \"Redefinition of property\"); }\n  } else {\n    other = propHash[name] = {\n      init: false,\n      get: false,\n      set: false\n    };\n  }\n  other[kind] = true;\n};\n\n// ### Expression parsing\n\n// These nest, from the most general expression type at the top to\n// 'atomic', nondivisible expression types at the bottom. Most of\n// the functions will simply let the function(s) below them parse,\n// and, *if* the syntactic construct they handle is present, wrap\n// the AST node that the inner parser gave them in another node.\n\n// Parse a full expression. The optional arguments are used to\n// forbid the `in` operator (in for loops initalization expressions)\n// and provide reference for storing '=' operator inside shorthand\n// property assignment in contexts where both object expression\n// and object pattern might appear (so it's possible to raise\n// delayed syntax error at correct position).\n\npp$3.parseExpression = function(noIn, refDestructuringErrors) {\n  var startPos = this.start, startLoc = this.startLoc;\n  var expr = this.parseMaybeAssign(noIn, refDestructuringErrors);\n  if (this.type === types.comma) {\n    var node = this.startNodeAt(startPos, startLoc);\n    node.expressions = [expr];\n    while (this.eat(types.comma)) { node.expressions.push(this.parseMaybeAssign(noIn, refDestructuringErrors)); }\n    return this.finishNode(node, \"SequenceExpression\")\n  }\n  return expr\n};\n\n// Parse an assignment expression. This includes applications of\n// operators like `+=`.\n\npp$3.parseMaybeAssign = function(noIn, refDestructuringErrors, afterLeftParse) {\n  if (this.isContextual(\"yield\")) {\n    if (this.inGenerator) { return this.parseYield(noIn) }\n    // The tokenizer will assume an expression is allowed after\n    // `yield`, but this isn't that kind of yield\n    else { this.exprAllowed = false; }\n  }\n\n  var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1;\n  if (refDestructuringErrors) {\n    oldParenAssign = refDestructuringErrors.parenthesizedAssign;\n    oldTrailingComma = refDestructuringErrors.trailingComma;\n    refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;\n  } else {\n    refDestructuringErrors = new DestructuringErrors;\n    ownDestructuringErrors = true;\n  }\n\n  var startPos = this.start, startLoc = this.startLoc;\n  if (this.type === types.parenL || this.type === types.name)\n    { this.potentialArrowAt = this.start; }\n  var left = this.parseMaybeConditional(noIn, refDestructuringErrors);\n  if (afterLeftParse) { left = afterLeftParse.call(this, left, startPos, startLoc); }\n  if (this.type.isAssign) {\n    var node = this.startNodeAt(startPos, startLoc);\n    node.operator = this.value;\n    node.left = this.type === types.eq ? this.toAssignable(left, false, refDestructuringErrors) : left;\n    if (!ownDestructuringErrors) {\n      refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.doubleProto = -1;\n    }\n    if (refDestructuringErrors.shorthandAssign >= node.left.start)\n      { refDestructuringErrors.shorthandAssign = -1; } // reset because shorthand default was used correctly\n    this.checkLVal(left);\n    this.next();\n    node.right = this.parseMaybeAssign(noIn);\n    return this.finishNode(node, \"AssignmentExpression\")\n  } else {\n    if (ownDestructuringErrors) { this.checkExpressionErrors(refDestructuringErrors, true); }\n  }\n  if (oldParenAssign > -1) { refDestructuringErrors.parenthesizedAssign = oldParenAssign; }\n  if (oldTrailingComma > -1) { refDestructuringErrors.trailingComma = oldTrailingComma; }\n  return left\n};\n\n// Parse a ternary conditional (`?:`) operator.\n\npp$3.parseMaybeConditional = function(noIn, refDestructuringErrors) {\n  var startPos = this.start, startLoc = this.startLoc;\n  var expr = this.parseExprOps(noIn, refDestructuringErrors);\n  if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }\n  if (this.eat(types.question)) {\n    var node = this.startNodeAt(startPos, startLoc);\n    node.test = expr;\n    node.consequent = this.parseMaybeAssign();\n    this.expect(types.colon);\n    node.alternate = this.parseMaybeAssign(noIn);\n    return this.finishNode(node, \"ConditionalExpression\")\n  }\n  return expr\n};\n\n// Start the precedence parser.\n\npp$3.parseExprOps = function(noIn, refDestructuringErrors) {\n  var startPos = this.start, startLoc = this.startLoc;\n  var expr = this.parseMaybeUnary(refDestructuringErrors, false);\n  if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }\n  return expr.start === startPos && expr.type === \"ArrowFunctionExpression\" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, noIn)\n};\n\n// Parse binary operators with the operator precedence parsing\n// algorithm. `left` is the left-hand side of the operator.\n// `minPrec` provides context that allows the function to stop and\n// defer further parser to one of its callers when it encounters an\n// operator that has a lower precedence than the set it is parsing.\n\npp$3.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, noIn) {\n  var prec = this.type.binop;\n  if (prec != null && (!noIn || this.type !== types._in)) {\n    if (prec > minPrec) {\n      var logical = this.type === types.logicalOR || this.type === types.logicalAND;\n      var coalesce = this.type === types.coalesce;\n      if (coalesce) {\n        // Handle the precedence of `tt.coalesce` as equal to the range of logical expressions.\n        // In other words, `node.right` shouldn't contain logical expressions in order to check the mixed error.\n        prec = types.logicalAND.binop;\n      }\n      var op = this.value;\n      this.next();\n      var startPos = this.start, startLoc = this.startLoc;\n      var right = this.parseExprOp(this.parseMaybeUnary(null, false), startPos, startLoc, prec, noIn);\n      var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical || coalesce);\n      if ((logical && this.type === types.coalesce) || (coalesce && (this.type === types.logicalOR || this.type === types.logicalAND))) {\n        this.raiseRecoverable(this.start, \"Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses\");\n      }\n      return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn)\n    }\n  }\n  return left\n};\n\npp$3.buildBinary = function(startPos, startLoc, left, right, op, logical) {\n  var node = this.startNodeAt(startPos, startLoc);\n  node.left = left;\n  node.operator = op;\n  node.right = right;\n  return this.finishNode(node, logical ? \"LogicalExpression\" : \"BinaryExpression\")\n};\n\n// Parse unary operators, both prefix and postfix.\n\npp$3.parseMaybeUnary = function(refDestructuringErrors, sawUnary) {\n  var startPos = this.start, startLoc = this.startLoc, expr;\n  if (this.isContextual(\"await\") && (this.inAsync || (!this.inFunction && this.options.allowAwaitOutsideFunction))) {\n    expr = this.parseAwait();\n    sawUnary = true;\n  } else if (this.type.prefix) {\n    var node = this.startNode(), update = this.type === types.incDec;\n    node.operator = this.value;\n    node.prefix = true;\n    this.next();\n    node.argument = this.parseMaybeUnary(null, true);\n    this.checkExpressionErrors(refDestructuringErrors, true);\n    if (update) { this.checkLVal(node.argument); }\n    else if (this.strict && node.operator === \"delete\" &&\n             node.argument.type === \"Identifier\")\n      { this.raiseRecoverable(node.start, \"Deleting local variable in strict mode\"); }\n    else { sawUnary = true; }\n    expr = this.finishNode(node, update ? \"UpdateExpression\" : \"UnaryExpression\");\n  } else {\n    expr = this.parseExprSubscripts(refDestructuringErrors);\n    if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }\n    while (this.type.postfix && !this.canInsertSemicolon()) {\n      var node$1 = this.startNodeAt(startPos, startLoc);\n      node$1.operator = this.value;\n      node$1.prefix = false;\n      node$1.argument = expr;\n      this.checkLVal(expr);\n      this.next();\n      expr = this.finishNode(node$1, \"UpdateExpression\");\n    }\n  }\n\n  if (!sawUnary && this.eat(types.starstar))\n    { return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false), \"**\", false) }\n  else\n    { return expr }\n};\n\n// Parse call, dot, and `[]`-subscript expressions.\n\npp$3.parseExprSubscripts = function(refDestructuringErrors) {\n  var startPos = this.start, startLoc = this.startLoc;\n  var expr = this.parseExprAtom(refDestructuringErrors);\n  if (expr.type === \"ArrowFunctionExpression\" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== \")\")\n    { return expr }\n  var result = this.parseSubscripts(expr, startPos, startLoc);\n  if (refDestructuringErrors && result.type === \"MemberExpression\") {\n    if (refDestructuringErrors.parenthesizedAssign >= result.start) { refDestructuringErrors.parenthesizedAssign = -1; }\n    if (refDestructuringErrors.parenthesizedBind >= result.start) { refDestructuringErrors.parenthesizedBind = -1; }\n  }\n  return result\n};\n\npp$3.parseSubscripts = function(base, startPos, startLoc, noCalls) {\n  var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === \"Identifier\" && base.name === \"async\" &&\n      this.lastTokEnd === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 &&\n      this.potentialArrowAt === base.start;\n  var optionalChained = false;\n\n  while (true) {\n    var element = this.parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained);\n\n    if (element.optional) { optionalChained = true; }\n    if (element === base || element.type === \"ArrowFunctionExpression\") {\n      if (optionalChained) {\n        var chainNode = this.startNodeAt(startPos, startLoc);\n        chainNode.expression = element;\n        element = this.finishNode(chainNode, \"ChainExpression\");\n      }\n      return element\n    }\n\n    base = element;\n  }\n};\n\npp$3.parseSubscript = function(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained) {\n  var optionalSupported = this.options.ecmaVersion >= 11;\n  var optional = optionalSupported && this.eat(types.questionDot);\n  if (noCalls && optional) { this.raise(this.lastTokStart, \"Optional chaining cannot appear in the callee of new expressions\"); }\n\n  var computed = this.eat(types.bracketL);\n  if (computed || (optional && this.type !== types.parenL && this.type !== types.backQuote) || this.eat(types.dot)) {\n    var node = this.startNodeAt(startPos, startLoc);\n    node.object = base;\n    node.property = computed ? this.parseExpression() : this.parseIdent(this.options.allowReserved !== \"never\");\n    node.computed = !!computed;\n    if (computed) { this.expect(types.bracketR); }\n    if (optionalSupported) {\n      node.optional = optional;\n    }\n    base = this.finishNode(node, \"MemberExpression\");\n  } else if (!noCalls && this.eat(types.parenL)) {\n    var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;\n    this.yieldPos = 0;\n    this.awaitPos = 0;\n    this.awaitIdentPos = 0;\n    var exprList = this.parseExprList(types.parenR, this.options.ecmaVersion >= 8, false, refDestructuringErrors);\n    if (maybeAsyncArrow && !optional && !this.canInsertSemicolon() && this.eat(types.arrow)) {\n      this.checkPatternErrors(refDestructuringErrors, false);\n      this.checkYieldAwaitInDefaultParams();\n      if (this.awaitIdentPos > 0)\n        { this.raise(this.awaitIdentPos, \"Cannot use 'await' as identifier inside an async function\"); }\n      this.yieldPos = oldYieldPos;\n      this.awaitPos = oldAwaitPos;\n      this.awaitIdentPos = oldAwaitIdentPos;\n      return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true)\n    }\n    this.checkExpressionErrors(refDestructuringErrors, true);\n    this.yieldPos = oldYieldPos || this.yieldPos;\n    this.awaitPos = oldAwaitPos || this.awaitPos;\n    this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;\n    var node$1 = this.startNodeAt(startPos, startLoc);\n    node$1.callee = base;\n    node$1.arguments = exprList;\n    if (optionalSupported) {\n      node$1.optional = optional;\n    }\n    base = this.finishNode(node$1, \"CallExpression\");\n  } else if (this.type === types.backQuote) {\n    if (optional || optionalChained) {\n      this.raise(this.start, \"Optional chaining cannot appear in the tag of tagged template expressions\");\n    }\n    var node$2 = this.startNodeAt(startPos, startLoc);\n    node$2.tag = base;\n    node$2.quasi = this.parseTemplate({isTagged: true});\n    base = this.finishNode(node$2, \"TaggedTemplateExpression\");\n  }\n  return base\n};\n\n// Parse an atomic expression  either a single token that is an\n// expression, an expression started by a keyword like `function` or\n// `new`, or an expression wrapped in punctuation like `()`, `[]`,\n// or `{}`.\n\npp$3.parseExprAtom = function(refDestructuringErrors) {\n  // If a division operator appears in an expression position, the\n  // tokenizer got confused, and we force it to read a regexp instead.\n  if (this.type === types.slash) { this.readRegexp(); }\n\n  var node, canBeArrow = this.potentialArrowAt === this.start;\n  switch (this.type) {\n  case types._super:\n    if (!this.allowSuper)\n      { this.raise(this.start, \"'super' keyword outside a method\"); }\n    node = this.startNode();\n    this.next();\n    if (this.type === types.parenL && !this.allowDirectSuper)\n      { this.raise(node.start, \"super() call outside constructor of a subclass\"); }\n    // The `super` keyword can appear at below:\n    // SuperProperty:\n    //     super [ Expression ]\n    //     super . IdentifierName\n    // SuperCall:\n    //     super ( Arguments )\n    if (this.type !== types.dot && this.type !== types.bracketL && this.type !== types.parenL)\n      { this.unexpected(); }\n    return this.finishNode(node, \"Super\")\n\n  case types._this:\n    node = this.startNode();\n    this.next();\n    return this.finishNode(node, \"ThisExpression\")\n\n  case types.name:\n    var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;\n    var id = this.parseIdent(false);\n    if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === \"async\" && !this.canInsertSemicolon() && this.eat(types._function))\n      { return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true) }\n    if (canBeArrow && !this.canInsertSemicolon()) {\n      if (this.eat(types.arrow))\n        { return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false) }\n      if (this.options.ecmaVersion >= 8 && id.name === \"async\" && this.type === types.name && !containsEsc) {\n        id = this.parseIdent(false);\n        if (this.canInsertSemicolon() || !this.eat(types.arrow))\n          { this.unexpected(); }\n        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true)\n      }\n    }\n    return id\n\n  case types.regexp:\n    var value = this.value;\n    node = this.parseLiteral(value.value);\n    node.regex = {pattern: value.pattern, flags: value.flags};\n    return node\n\n  case types.num: case types.string:\n    return this.parseLiteral(this.value)\n\n  case types._null: case types._true: case types._false:\n    node = this.startNode();\n    node.value = this.type === types._null ? null : this.type === types._true;\n    node.raw = this.type.keyword;\n    this.next();\n    return this.finishNode(node, \"Literal\")\n\n  case types.parenL:\n    var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow);\n    if (refDestructuringErrors) {\n      if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr))\n        { refDestructuringErrors.parenthesizedAssign = start; }\n      if (refDestructuringErrors.parenthesizedBind < 0)\n        { refDestructuringErrors.parenthesizedBind = start; }\n    }\n    return expr\n\n  case types.bracketL:\n    node = this.startNode();\n    this.next();\n    node.elements = this.parseExprList(types.bracketR, true, true, refDestructuringErrors);\n    return this.finishNode(node, \"ArrayExpression\")\n\n  case types.braceL:\n    return this.parseObj(false, refDestructuringErrors)\n\n  case types._function:\n    node = this.startNode();\n    this.next();\n    return this.parseFunction(node, 0)\n\n  case types._class:\n    return this.parseClass(this.startNode(), false)\n\n  case types._new:\n    return this.parseNew()\n\n  case types.backQuote:\n    return this.parseTemplate()\n\n  case types._import:\n    if (this.options.ecmaVersion >= 11) {\n      return this.parseExprImport()\n    } else {\n      return this.unexpected()\n    }\n\n  default:\n    this.unexpected();\n  }\n};\n\npp$3.parseExprImport = function() {\n  var node = this.startNode();\n\n  // Consume `import` as an identifier for `import.meta`.\n  // Because `this.parseIdent(true)` doesn't check escape sequences, it needs the check of `this.containsEsc`.\n  if (this.containsEsc) { this.raiseRecoverable(this.start, \"Escape sequence in keyword import\"); }\n  var meta = this.parseIdent(true);\n\n  switch (this.type) {\n  case types.parenL:\n    return this.parseDynamicImport(node)\n  case types.dot:\n    node.meta = meta;\n    return this.parseImportMeta(node)\n  default:\n    this.unexpected();\n  }\n};\n\npp$3.parseDynamicImport = function(node) {\n  this.next(); // skip `(`\n\n  // Parse node.source.\n  node.source = this.parseMaybeAssign();\n\n  // Verify ending.\n  if (!this.eat(types.parenR)) {\n    var errorPos = this.start;\n    if (this.eat(types.comma) && this.eat(types.parenR)) {\n      this.raiseRecoverable(errorPos, \"Trailing comma is not allowed in import()\");\n    } else {\n      this.unexpected(errorPos);\n    }\n  }\n\n  return this.finishNode(node, \"ImportExpression\")\n};\n\npp$3.parseImportMeta = function(node) {\n  this.next(); // skip `.`\n\n  var containsEsc = this.containsEsc;\n  node.property = this.parseIdent(true);\n\n  if (node.property.name !== \"meta\")\n    { this.raiseRecoverable(node.property.start, \"The only valid meta property for import is 'import.meta'\"); }\n  if (containsEsc)\n    { this.raiseRecoverable(node.start, \"'import.meta' must not contain escaped characters\"); }\n  if (this.options.sourceType !== \"module\")\n    { this.raiseRecoverable(node.start, \"Cannot use 'import.meta' outside a module\"); }\n\n  return this.finishNode(node, \"MetaProperty\")\n};\n\npp$3.parseLiteral = function(value) {\n  var node = this.startNode();\n  node.value = value;\n  node.raw = this.input.slice(this.start, this.end);\n  if (node.raw.charCodeAt(node.raw.length - 1) === 110) { node.bigint = node.raw.slice(0, -1).replace(/_/g, \"\"); }\n  this.next();\n  return this.finishNode(node, \"Literal\")\n};\n\npp$3.parseParenExpression = function() {\n  this.expect(types.parenL);\n  var val = this.parseExpression();\n  this.expect(types.parenR);\n  return val\n};\n\npp$3.parseParenAndDistinguishExpression = function(canBeArrow) {\n  var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;\n  if (this.options.ecmaVersion >= 6) {\n    this.next();\n\n    var innerStartPos = this.start, innerStartLoc = this.startLoc;\n    var exprList = [], first = true, lastIsComma = false;\n    var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;\n    this.yieldPos = 0;\n    this.awaitPos = 0;\n    // Do not save awaitIdentPos to allow checking awaits nested in parameters\n    while (this.type !== types.parenR) {\n      first ? first = false : this.expect(types.comma);\n      if (allowTrailingComma && this.afterTrailingComma(types.parenR, true)) {\n        lastIsComma = true;\n        break\n      } else if (this.type === types.ellipsis) {\n        spreadStart = this.start;\n        exprList.push(this.parseParenItem(this.parseRestBinding()));\n        if (this.type === types.comma) { this.raise(this.start, \"Comma is not permitted after the rest element\"); }\n        break\n      } else {\n        exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));\n      }\n    }\n    var innerEndPos = this.start, innerEndLoc = this.startLoc;\n    this.expect(types.parenR);\n\n    if (canBeArrow && !this.canInsertSemicolon() && this.eat(types.arrow)) {\n      this.checkPatternErrors(refDestructuringErrors, false);\n      this.checkYieldAwaitInDefaultParams();\n      this.yieldPos = oldYieldPos;\n      this.awaitPos = oldAwaitPos;\n      return this.parseParenArrowList(startPos, startLoc, exprList)\n    }\n\n    if (!exprList.length || lastIsComma) { this.unexpected(this.lastTokStart); }\n    if (spreadStart) { this.unexpected(spreadStart); }\n    this.checkExpressionErrors(refDestructuringErrors, true);\n    this.yieldPos = oldYieldPos || this.yieldPos;\n    this.awaitPos = oldAwaitPos || this.awaitPos;\n\n    if (exprList.length > 1) {\n      val = this.startNodeAt(innerStartPos, innerStartLoc);\n      val.expressions = exprList;\n      this.finishNodeAt(val, \"SequenceExpression\", innerEndPos, innerEndLoc);\n    } else {\n      val = exprList[0];\n    }\n  } else {\n    val = this.parseParenExpression();\n  }\n\n  if (this.options.preserveParens) {\n    var par = this.startNodeAt(startPos, startLoc);\n    par.expression = val;\n    return this.finishNode(par, \"ParenthesizedExpression\")\n  } else {\n    return val\n  }\n};\n\npp$3.parseParenItem = function(item) {\n  return item\n};\n\npp$3.parseParenArrowList = function(startPos, startLoc, exprList) {\n  return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList)\n};\n\n// New's precedence is slightly tricky. It must allow its argument to\n// be a `[]` or dot subscript expression, but not a call  at least,\n// not without wrapping it in parentheses. Thus, it uses the noCalls\n// argument to parseSubscripts to prevent it from consuming the\n// argument list.\n\nvar empty$1 = [];\n\npp$3.parseNew = function() {\n  if (this.containsEsc) { this.raiseRecoverable(this.start, \"Escape sequence in keyword new\"); }\n  var node = this.startNode();\n  var meta = this.parseIdent(true);\n  if (this.options.ecmaVersion >= 6 && this.eat(types.dot)) {\n    node.meta = meta;\n    var containsEsc = this.containsEsc;\n    node.property = this.parseIdent(true);\n    if (node.property.name !== \"target\")\n      { this.raiseRecoverable(node.property.start, \"The only valid meta property for new is 'new.target'\"); }\n    if (containsEsc)\n      { this.raiseRecoverable(node.start, \"'new.target' must not contain escaped characters\"); }\n    if (!this.inNonArrowFunction())\n      { this.raiseRecoverable(node.start, \"'new.target' can only be used in functions\"); }\n    return this.finishNode(node, \"MetaProperty\")\n  }\n  var startPos = this.start, startLoc = this.startLoc, isImport = this.type === types._import;\n  node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);\n  if (isImport && node.callee.type === \"ImportExpression\") {\n    this.raise(startPos, \"Cannot use new with import()\");\n  }\n  if (this.eat(types.parenL)) { node.arguments = this.parseExprList(types.parenR, this.options.ecmaVersion >= 8, false); }\n  else { node.arguments = empty$1; }\n  return this.finishNode(node, \"NewExpression\")\n};\n\n// Parse template expression.\n\npp$3.parseTemplateElement = function(ref) {\n  var isTagged = ref.isTagged;\n\n  var elem = this.startNode();\n  if (this.type === types.invalidTemplate) {\n    if (!isTagged) {\n      this.raiseRecoverable(this.start, \"Bad escape sequence in untagged template literal\");\n    }\n    elem.value = {\n      raw: this.value,\n      cooked: null\n    };\n  } else {\n    elem.value = {\n      raw: this.input.slice(this.start, this.end).replace(/\\r\\n?/g, \"\\n\"),\n      cooked: this.value\n    };\n  }\n  this.next();\n  elem.tail = this.type === types.backQuote;\n  return this.finishNode(elem, \"TemplateElement\")\n};\n\npp$3.parseTemplate = function(ref) {\n  if ( ref === void 0 ) ref = {};\n  var isTagged = ref.isTagged; if ( isTagged === void 0 ) isTagged = false;\n\n  var node = this.startNode();\n  this.next();\n  node.expressions = [];\n  var curElt = this.parseTemplateElement({isTagged: isTagged});\n  node.quasis = [curElt];\n  while (!curElt.tail) {\n    if (this.type === types.eof) { this.raise(this.pos, \"Unterminated template literal\"); }\n    this.expect(types.dollarBraceL);\n    node.expressions.push(this.parseExpression());\n    this.expect(types.braceR);\n    node.quasis.push(curElt = this.parseTemplateElement({isTagged: isTagged}));\n  }\n  this.next();\n  return this.finishNode(node, \"TemplateLiteral\")\n};\n\npp$3.isAsyncProp = function(prop) {\n  return !prop.computed && prop.key.type === \"Identifier\" && prop.key.name === \"async\" &&\n    (this.type === types.name || this.type === types.num || this.type === types.string || this.type === types.bracketL || this.type.keyword || (this.options.ecmaVersion >= 9 && this.type === types.star)) &&\n    !lineBreak.test(this.input.slice(this.lastTokEnd, this.start))\n};\n\n// Parse an object literal or binding pattern.\n\npp$3.parseObj = function(isPattern, refDestructuringErrors) {\n  var node = this.startNode(), first = true, propHash = {};\n  node.properties = [];\n  this.next();\n  while (!this.eat(types.braceR)) {\n    if (!first) {\n      this.expect(types.comma);\n      if (this.options.ecmaVersion >= 5 && this.afterTrailingComma(types.braceR)) { break }\n    } else { first = false; }\n\n    var prop = this.parseProperty(isPattern, refDestructuringErrors);\n    if (!isPattern) { this.checkPropClash(prop, propHash, refDestructuringErrors); }\n    node.properties.push(prop);\n  }\n  return this.finishNode(node, isPattern ? \"ObjectPattern\" : \"ObjectExpression\")\n};\n\npp$3.parseProperty = function(isPattern, refDestructuringErrors) {\n  var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;\n  if (this.options.ecmaVersion >= 9 && this.eat(types.ellipsis)) {\n    if (isPattern) {\n      prop.argument = this.parseIdent(false);\n      if (this.type === types.comma) {\n        this.raise(this.start, \"Comma is not permitted after the rest element\");\n      }\n      return this.finishNode(prop, \"RestElement\")\n    }\n    // To disallow parenthesized identifier via `this.toAssignable()`.\n    if (this.type === types.parenL && refDestructuringErrors) {\n      if (refDestructuringErrors.parenthesizedAssign < 0) {\n        refDestructuringErrors.parenthesizedAssign = this.start;\n      }\n      if (refDestructuringErrors.parenthesizedBind < 0) {\n        refDestructuringErrors.parenthesizedBind = this.start;\n      }\n    }\n    // Parse argument.\n    prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);\n    // To disallow trailing comma via `this.toAssignable()`.\n    if (this.type === types.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {\n      refDestructuringErrors.trailingComma = this.start;\n    }\n    // Finish\n    return this.finishNode(prop, \"SpreadElement\")\n  }\n  if (this.options.ecmaVersion >= 6) {\n    prop.method = false;\n    prop.shorthand = false;\n    if (isPattern || refDestructuringErrors) {\n      startPos = this.start;\n      startLoc = this.startLoc;\n    }\n    if (!isPattern)\n      { isGenerator = this.eat(types.star); }\n  }\n  var containsEsc = this.containsEsc;\n  this.parsePropertyName(prop);\n  if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {\n    isAsync = true;\n    isGenerator = this.options.ecmaVersion >= 9 && this.eat(types.star);\n    this.parsePropertyName(prop, refDestructuringErrors);\n  } else {\n    isAsync = false;\n  }\n  this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);\n  return this.finishNode(prop, \"Property\")\n};\n\npp$3.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {\n  if ((isGenerator || isAsync) && this.type === types.colon)\n    { this.unexpected(); }\n\n  if (this.eat(types.colon)) {\n    prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);\n    prop.kind = \"init\";\n  } else if (this.options.ecmaVersion >= 6 && this.type === types.parenL) {\n    if (isPattern) { this.unexpected(); }\n    prop.kind = \"init\";\n    prop.method = true;\n    prop.value = this.parseMethod(isGenerator, isAsync);\n  } else if (!isPattern && !containsEsc &&\n             this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === \"Identifier\" &&\n             (prop.key.name === \"get\" || prop.key.name === \"set\") &&\n             (this.type !== types.comma && this.type !== types.braceR && this.type !== types.eq)) {\n    if (isGenerator || isAsync) { this.unexpected(); }\n    prop.kind = prop.key.name;\n    this.parsePropertyName(prop);\n    prop.value = this.parseMethod(false);\n    var paramCount = prop.kind === \"get\" ? 0 : 1;\n    if (prop.value.params.length !== paramCount) {\n      var start = prop.value.start;\n      if (prop.kind === \"get\")\n        { this.raiseRecoverable(start, \"getter should have no params\"); }\n      else\n        { this.raiseRecoverable(start, \"setter should have exactly one param\"); }\n    } else {\n      if (prop.kind === \"set\" && prop.value.params[0].type === \"RestElement\")\n        { this.raiseRecoverable(prop.value.params[0].start, \"Setter cannot use rest params\"); }\n    }\n  } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === \"Identifier\") {\n    if (isGenerator || isAsync) { this.unexpected(); }\n    this.checkUnreserved(prop.key);\n    if (prop.key.name === \"await\" && !this.awaitIdentPos)\n      { this.awaitIdentPos = startPos; }\n    prop.kind = \"init\";\n    if (isPattern) {\n      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);\n    } else if (this.type === types.eq && refDestructuringErrors) {\n      if (refDestructuringErrors.shorthandAssign < 0)\n        { refDestructuringErrors.shorthandAssign = this.start; }\n      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);\n    } else {\n      prop.value = prop.key;\n    }\n    prop.shorthand = true;\n  } else { this.unexpected(); }\n};\n\npp$3.parsePropertyName = function(prop) {\n  if (this.options.ecmaVersion >= 6) {\n    if (this.eat(types.bracketL)) {\n      prop.computed = true;\n      prop.key = this.parseMaybeAssign();\n      this.expect(types.bracketR);\n      return prop.key\n    } else {\n      prop.computed = false;\n    }\n  }\n  return prop.key = this.type === types.num || this.type === types.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== \"never\")\n};\n\n// Initialize empty function node.\n\npp$3.initFunction = function(node) {\n  node.id = null;\n  if (this.options.ecmaVersion >= 6) { node.generator = node.expression = false; }\n  if (this.options.ecmaVersion >= 8) { node.async = false; }\n};\n\n// Parse object or class method.\n\npp$3.parseMethod = function(isGenerator, isAsync, allowDirectSuper) {\n  var node = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;\n\n  this.initFunction(node);\n  if (this.options.ecmaVersion >= 6)\n    { node.generator = isGenerator; }\n  if (this.options.ecmaVersion >= 8)\n    { node.async = !!isAsync; }\n\n  this.yieldPos = 0;\n  this.awaitPos = 0;\n  this.awaitIdentPos = 0;\n  this.enterScope(functionFlags(isAsync, node.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));\n\n  this.expect(types.parenL);\n  node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);\n  this.checkYieldAwaitInDefaultParams();\n  this.parseFunctionBody(node, false, true);\n\n  this.yieldPos = oldYieldPos;\n  this.awaitPos = oldAwaitPos;\n  this.awaitIdentPos = oldAwaitIdentPos;\n  return this.finishNode(node, \"FunctionExpression\")\n};\n\n// Parse arrow function expression with given parameters.\n\npp$3.parseArrowExpression = function(node, params, isAsync) {\n  var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;\n\n  this.enterScope(functionFlags(isAsync, false) | SCOPE_ARROW);\n  this.initFunction(node);\n  if (this.options.ecmaVersion >= 8) { node.async = !!isAsync; }\n\n  this.yieldPos = 0;\n  this.awaitPos = 0;\n  this.awaitIdentPos = 0;\n\n  node.params = this.toAssignableList(params, true);\n  this.parseFunctionBody(node, true, false);\n\n  this.yieldPos = oldYieldPos;\n  this.awaitPos = oldAwaitPos;\n  this.awaitIdentPos = oldAwaitIdentPos;\n  return this.finishNode(node, \"ArrowFunctionExpression\")\n};\n\n// Parse function body and check parameters.\n\npp$3.parseFunctionBody = function(node, isArrowFunction, isMethod) {\n  var isExpression = isArrowFunction && this.type !== types.braceL;\n  var oldStrict = this.strict, useStrict = false;\n\n  if (isExpression) {\n    node.body = this.parseMaybeAssign();\n    node.expression = true;\n    this.checkParams(node, false);\n  } else {\n    var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);\n    if (!oldStrict || nonSimple) {\n      useStrict = this.strictDirective(this.end);\n      // If this is a strict mode function, verify that argument names\n      // are not repeated, and it does not try to bind the words `eval`\n      // or `arguments`.\n      if (useStrict && nonSimple)\n        { this.raiseRecoverable(node.start, \"Illegal 'use strict' directive in function with non-simple parameter list\"); }\n    }\n    // Start a new scope with regard to labels and the `inFunction`\n    // flag (restore them to their old value afterwards).\n    var oldLabels = this.labels;\n    this.labels = [];\n    if (useStrict) { this.strict = true; }\n\n    // Add the params to varDeclaredNames to ensure that an error is thrown\n    // if a let/const declaration in the function clashes with one of the params.\n    this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node.params));\n    // Ensure the function name isn't a forbidden identifier in strict mode, e.g. 'eval'\n    if (this.strict && node.id) { this.checkLVal(node.id, BIND_OUTSIDE); }\n    node.body = this.parseBlock(false, undefined, useStrict && !oldStrict);\n    node.expression = false;\n    this.adaptDirectivePrologue(node.body.body);\n    this.labels = oldLabels;\n  }\n  this.exitScope();\n};\n\npp$3.isSimpleParamList = function(params) {\n  for (var i = 0, list = params; i < list.length; i += 1)\n    {\n    var param = list[i];\n\n    if (param.type !== \"Identifier\") { return false\n  } }\n  return true\n};\n\n// Checks function params for various disallowed patterns such as using \"eval\"\n// or \"arguments\" and duplicate parameters.\n\npp$3.checkParams = function(node, allowDuplicates) {\n  var nameHash = {};\n  for (var i = 0, list = node.params; i < list.length; i += 1)\n    {\n    var param = list[i];\n\n    this.checkLVal(param, BIND_VAR, allowDuplicates ? null : nameHash);\n  }\n};\n\n// Parses a comma-separated list of expressions, and returns them as\n// an array. `close` is the token type that ends the list, and\n// `allowEmpty` can be turned on to allow subsequent commas with\n// nothing in between them to be parsed as `null` (which is needed\n// for array literals).\n\npp$3.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {\n  var elts = [], first = true;\n  while (!this.eat(close)) {\n    if (!first) {\n      this.expect(types.comma);\n      if (allowTrailingComma && this.afterTrailingComma(close)) { break }\n    } else { first = false; }\n\n    var elt = (void 0);\n    if (allowEmpty && this.type === types.comma)\n      { elt = null; }\n    else if (this.type === types.ellipsis) {\n      elt = this.parseSpread(refDestructuringErrors);\n      if (refDestructuringErrors && this.type === types.comma && refDestructuringErrors.trailingComma < 0)\n        { refDestructuringErrors.trailingComma = this.start; }\n    } else {\n      elt = this.parseMaybeAssign(false, refDestructuringErrors);\n    }\n    elts.push(elt);\n  }\n  return elts\n};\n\npp$3.checkUnreserved = function(ref) {\n  var start = ref.start;\n  var end = ref.end;\n  var name = ref.name;\n\n  if (this.inGenerator && name === \"yield\")\n    { this.raiseRecoverable(start, \"Cannot use 'yield' as identifier inside a generator\"); }\n  if (this.inAsync && name === \"await\")\n    { this.raiseRecoverable(start, \"Cannot use 'await' as identifier inside an async function\"); }\n  if (this.keywords.test(name))\n    { this.raise(start, (\"Unexpected keyword '\" + name + \"'\")); }\n  if (this.options.ecmaVersion < 6 &&\n    this.input.slice(start, end).indexOf(\"\\\\\") !== -1) { return }\n  var re = this.strict ? this.reservedWordsStrict : this.reservedWords;\n  if (re.test(name)) {\n    if (!this.inAsync && name === \"await\")\n      { this.raiseRecoverable(start, \"Cannot use keyword 'await' outside an async function\"); }\n    this.raiseRecoverable(start, (\"The keyword '\" + name + \"' is reserved\"));\n  }\n};\n\n// Parse the next token as an identifier. If `liberal` is true (used\n// when parsing properties), it will also convert keywords into\n// identifiers.\n\npp$3.parseIdent = function(liberal, isBinding) {\n  var node = this.startNode();\n  if (this.type === types.name) {\n    node.name = this.value;\n  } else if (this.type.keyword) {\n    node.name = this.type.keyword;\n\n    // To fix https://github.com/acornjs/acorn/issues/575\n    // `class` and `function` keywords push new context into this.context.\n    // But there is no chance to pop the context if the keyword is consumed as an identifier such as a property name.\n    // If the previous token is a dot, this does not apply because the context-managing code already ignored the keyword\n    if ((node.name === \"class\" || node.name === \"function\") &&\n        (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {\n      this.context.pop();\n    }\n  } else {\n    this.unexpected();\n  }\n  this.next(!!liberal);\n  this.finishNode(node, \"Identifier\");\n  if (!liberal) {\n    this.checkUnreserved(node);\n    if (node.name === \"await\" && !this.awaitIdentPos)\n      { this.awaitIdentPos = node.start; }\n  }\n  return node\n};\n\n// Parses yield expression inside generator.\n\npp$3.parseYield = function(noIn) {\n  if (!this.yieldPos) { this.yieldPos = this.start; }\n\n  var node = this.startNode();\n  this.next();\n  if (this.type === types.semi || this.canInsertSemicolon() || (this.type !== types.star && !this.type.startsExpr)) {\n    node.delegate = false;\n    node.argument = null;\n  } else {\n    node.delegate = this.eat(types.star);\n    node.argument = this.parseMaybeAssign(noIn);\n  }\n  return this.finishNode(node, \"YieldExpression\")\n};\n\npp$3.parseAwait = function() {\n  if (!this.awaitPos) { this.awaitPos = this.start; }\n\n  var node = this.startNode();\n  this.next();\n  node.argument = this.parseMaybeUnary(null, false);\n  return this.finishNode(node, \"AwaitExpression\")\n};\n\nvar pp$4 = Parser.prototype;\n\n// This function is used to raise exceptions on parse errors. It\n// takes an offset integer (into the current `input`) to indicate\n// the location of the error, attaches the position to the end\n// of the error message, and then raises a `SyntaxError` with that\n// message.\n\npp$4.raise = function(pos, message) {\n  var loc = getLineInfo(this.input, pos);\n  message += \" (\" + loc.line + \":\" + loc.column + \")\";\n  var err = new SyntaxError(message);\n  err.pos = pos; err.loc = loc; err.raisedAt = this.pos;\n  throw err\n};\n\npp$4.raiseRecoverable = pp$4.raise;\n\npp$4.curPosition = function() {\n  if (this.options.locations) {\n    return new Position(this.curLine, this.pos - this.lineStart)\n  }\n};\n\nvar pp$5 = Parser.prototype;\n\nvar Scope = function Scope(flags) {\n  this.flags = flags;\n  // A list of var-declared names in the current lexical scope\n  this.var = [];\n  // A list of lexically-declared names in the current lexical scope\n  this.lexical = [];\n  // A list of lexically-declared FunctionDeclaration names in the current lexical scope\n  this.functions = [];\n};\n\n// The functions in this module keep track of declared variables in the current scope in order to detect duplicate variable names.\n\npp$5.enterScope = function(flags) {\n  this.scopeStack.push(new Scope(flags));\n};\n\npp$5.exitScope = function() {\n  this.scopeStack.pop();\n};\n\n// The spec says:\n// > At the top level of a function, or script, function declarations are\n// > treated like var declarations rather than like lexical declarations.\npp$5.treatFunctionsAsVarInScope = function(scope) {\n  return (scope.flags & SCOPE_FUNCTION) || !this.inModule && (scope.flags & SCOPE_TOP)\n};\n\npp$5.declareName = function(name, bindingType, pos) {\n  var redeclared = false;\n  if (bindingType === BIND_LEXICAL) {\n    var scope = this.currentScope();\n    redeclared = scope.lexical.indexOf(name) > -1 || scope.functions.indexOf(name) > -1 || scope.var.indexOf(name) > -1;\n    scope.lexical.push(name);\n    if (this.inModule && (scope.flags & SCOPE_TOP))\n      { delete this.undefinedExports[name]; }\n  } else if (bindingType === BIND_SIMPLE_CATCH) {\n    var scope$1 = this.currentScope();\n    scope$1.lexical.push(name);\n  } else if (bindingType === BIND_FUNCTION) {\n    var scope$2 = this.currentScope();\n    if (this.treatFunctionsAsVar)\n      { redeclared = scope$2.lexical.indexOf(name) > -1; }\n    else\n      { redeclared = scope$2.lexical.indexOf(name) > -1 || scope$2.var.indexOf(name) > -1; }\n    scope$2.functions.push(name);\n  } else {\n    for (var i = this.scopeStack.length - 1; i >= 0; --i) {\n      var scope$3 = this.scopeStack[i];\n      if (scope$3.lexical.indexOf(name) > -1 && !((scope$3.flags & SCOPE_SIMPLE_CATCH) && scope$3.lexical[0] === name) ||\n          !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name) > -1) {\n        redeclared = true;\n        break\n      }\n      scope$3.var.push(name);\n      if (this.inModule && (scope$3.flags & SCOPE_TOP))\n        { delete this.undefinedExports[name]; }\n      if (scope$3.flags & SCOPE_VAR) { break }\n    }\n  }\n  if (redeclared) { this.raiseRecoverable(pos, (\"Identifier '\" + name + \"' has already been declared\")); }\n};\n\npp$5.checkLocalExport = function(id) {\n  // scope.functions must be empty as Module code is always strict.\n  if (this.scopeStack[0].lexical.indexOf(id.name) === -1 &&\n      this.scopeStack[0].var.indexOf(id.name) === -1) {\n    this.undefinedExports[id.name] = id;\n  }\n};\n\npp$5.currentScope = function() {\n  return this.scopeStack[this.scopeStack.length - 1]\n};\n\npp$5.currentVarScope = function() {\n  for (var i = this.scopeStack.length - 1;; i--) {\n    var scope = this.scopeStack[i];\n    if (scope.flags & SCOPE_VAR) { return scope }\n  }\n};\n\n// Could be useful for `this`, `new.target`, `super()`, `super.property`, and `super[property]`.\npp$5.currentThisScope = function() {\n  for (var i = this.scopeStack.length - 1;; i--) {\n    var scope = this.scopeStack[i];\n    if (scope.flags & SCOPE_VAR && !(scope.flags & SCOPE_ARROW)) { return scope }\n  }\n};\n\nvar Node = function Node(parser, pos, loc) {\n  this.type = \"\";\n  this.start = pos;\n  this.end = 0;\n  if (parser.options.locations)\n    { this.loc = new SourceLocation(parser, loc); }\n  if (parser.options.directSourceFile)\n    { this.sourceFile = parser.options.directSourceFile; }\n  if (parser.options.ranges)\n    { this.range = [pos, 0]; }\n};\n\n// Start an AST node, attaching a start offset.\n\nvar pp$6 = Parser.prototype;\n\npp$6.startNode = function() {\n  return new Node(this, this.start, this.startLoc)\n};\n\npp$6.startNodeAt = function(pos, loc) {\n  return new Node(this, pos, loc)\n};\n\n// Finish an AST node, adding `type` and `end` properties.\n\nfunction finishNodeAt(node, type, pos, loc) {\n  node.type = type;\n  node.end = pos;\n  if (this.options.locations)\n    { node.loc.end = loc; }\n  if (this.options.ranges)\n    { node.range[1] = pos; }\n  return node\n}\n\npp$6.finishNode = function(node, type) {\n  return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc)\n};\n\n// Finish node at given position\n\npp$6.finishNodeAt = function(node, type, pos, loc) {\n  return finishNodeAt.call(this, node, type, pos, loc)\n};\n\n// The algorithm used to determine whether a regexp can appear at a\n\nvar TokContext = function TokContext(token, isExpr, preserveSpace, override, generator) {\n  this.token = token;\n  this.isExpr = !!isExpr;\n  this.preserveSpace = !!preserveSpace;\n  this.override = override;\n  this.generator = !!generator;\n};\n\nvar types$1 = {\n  b_stat: new TokContext(\"{\", false),\n  b_expr: new TokContext(\"{\", true),\n  b_tmpl: new TokContext(\"${\", false),\n  p_stat: new TokContext(\"(\", false),\n  p_expr: new TokContext(\"(\", true),\n  q_tmpl: new TokContext(\"`\", true, true, function (p) { return p.tryReadTemplateToken(); }),\n  f_stat: new TokContext(\"function\", false),\n  f_expr: new TokContext(\"function\", true),\n  f_expr_gen: new TokContext(\"function\", true, false, null, true),\n  f_gen: new TokContext(\"function\", false, false, null, true)\n};\n\nvar pp$7 = Parser.prototype;\n\npp$7.initialContext = function() {\n  return [types$1.b_stat]\n};\n\npp$7.braceIsBlock = function(prevType) {\n  var parent = this.curContext();\n  if (parent === types$1.f_expr || parent === types$1.f_stat)\n    { return true }\n  if (prevType === types.colon && (parent === types$1.b_stat || parent === types$1.b_expr))\n    { return !parent.isExpr }\n\n  // The check for `tt.name && exprAllowed` detects whether we are\n  // after a `yield` or `of` construct. See the `updateContext` for\n  // `tt.name`.\n  if (prevType === types._return || prevType === types.name && this.exprAllowed)\n    { return lineBreak.test(this.input.slice(this.lastTokEnd, this.start)) }\n  if (prevType === types._else || prevType === types.semi || prevType === types.eof || prevType === types.parenR || prevType === types.arrow)\n    { return true }\n  if (prevType === types.braceL)\n    { return parent === types$1.b_stat }\n  if (prevType === types._var || prevType === types._const || prevType === types.name)\n    { return false }\n  return !this.exprAllowed\n};\n\npp$7.inGeneratorContext = function() {\n  for (var i = this.context.length - 1; i >= 1; i--) {\n    var context = this.context[i];\n    if (context.token === \"function\")\n      { return context.generator }\n  }\n  return false\n};\n\npp$7.updateContext = function(prevType) {\n  var update, type = this.type;\n  if (type.keyword && prevType === types.dot)\n    { this.exprAllowed = false; }\n  else if (update = type.updateContext)\n    { update.call(this, prevType); }\n  else\n    { this.exprAllowed = type.beforeExpr; }\n};\n\n// Token-specific context update code\n\ntypes.parenR.updateContext = types.braceR.updateContext = function() {\n  if (this.context.length === 1) {\n    this.exprAllowed = true;\n    return\n  }\n  var out = this.context.pop();\n  if (out === types$1.b_stat && this.curContext().token === \"function\") {\n    out = this.context.pop();\n  }\n  this.exprAllowed = !out.isExpr;\n};\n\ntypes.braceL.updateContext = function(prevType) {\n  this.context.push(this.braceIsBlock(prevType) ? types$1.b_stat : types$1.b_expr);\n  this.exprAllowed = true;\n};\n\ntypes.dollarBraceL.updateContext = function() {\n  this.context.push(types$1.b_tmpl);\n  this.exprAllowed = true;\n};\n\ntypes.parenL.updateContext = function(prevType) {\n  var statementParens = prevType === types._if || prevType === types._for || prevType === types._with || prevType === types._while;\n  this.context.push(statementParens ? types$1.p_stat : types$1.p_expr);\n  this.exprAllowed = true;\n};\n\ntypes.incDec.updateContext = function() {\n  // tokExprAllowed stays unchanged\n};\n\ntypes._function.updateContext = types._class.updateContext = function(prevType) {\n  if (prevType.beforeExpr && prevType !== types.semi && prevType !== types._else &&\n      !(prevType === types._return && lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) &&\n      !((prevType === types.colon || prevType === types.braceL) && this.curContext() === types$1.b_stat))\n    { this.context.push(types$1.f_expr); }\n  else\n    { this.context.push(types$1.f_stat); }\n  this.exprAllowed = false;\n};\n\ntypes.backQuote.updateContext = function() {\n  if (this.curContext() === types$1.q_tmpl)\n    { this.context.pop(); }\n  else\n    { this.context.push(types$1.q_tmpl); }\n  this.exprAllowed = false;\n};\n\ntypes.star.updateContext = function(prevType) {\n  if (prevType === types._function) {\n    var index = this.context.length - 1;\n    if (this.context[index] === types$1.f_expr)\n      { this.context[index] = types$1.f_expr_gen; }\n    else\n      { this.context[index] = types$1.f_gen; }\n  }\n  this.exprAllowed = true;\n};\n\ntypes.name.updateContext = function(prevType) {\n  var allowed = false;\n  if (this.options.ecmaVersion >= 6 && prevType !== types.dot) {\n    if (this.value === \"of\" && !this.exprAllowed ||\n        this.value === \"yield\" && this.inGeneratorContext())\n      { allowed = true; }\n  }\n  this.exprAllowed = allowed;\n};\n\n// This file contains Unicode properties extracted from the ECMAScript\n// specification. The lists are extracted like so:\n// $$('#table-binary-unicode-properties > figure > table > tbody > tr > td:nth-child(1) code').map(el => el.innerText)\n\n// #table-binary-unicode-properties\nvar ecma9BinaryProperties = \"ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS\";\nvar ecma10BinaryProperties = ecma9BinaryProperties + \" Extended_Pictographic\";\nvar ecma11BinaryProperties = ecma10BinaryProperties;\nvar unicodeBinaryProperties = {\n  9: ecma9BinaryProperties,\n  10: ecma10BinaryProperties,\n  11: ecma11BinaryProperties\n};\n\n// #table-unicode-general-category-values\nvar unicodeGeneralCategoryValues = \"Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu\";\n\n// #table-unicode-script-values\nvar ecma9ScriptValues = \"Adlam Adlm Ahom Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb\";\nvar ecma10ScriptValues = ecma9ScriptValues + \" Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd\";\nvar ecma11ScriptValues = ecma10ScriptValues + \" Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho\";\nvar unicodeScriptValues = {\n  9: ecma9ScriptValues,\n  10: ecma10ScriptValues,\n  11: ecma11ScriptValues\n};\n\nvar data = {};\nfunction buildUnicodeData(ecmaVersion) {\n  var d = data[ecmaVersion] = {\n    binary: wordsRegexp(unicodeBinaryProperties[ecmaVersion] + \" \" + unicodeGeneralCategoryValues),\n    nonBinary: {\n      General_Category: wordsRegexp(unicodeGeneralCategoryValues),\n      Script: wordsRegexp(unicodeScriptValues[ecmaVersion])\n    }\n  };\n  d.nonBinary.Script_Extensions = d.nonBinary.Script;\n\n  d.nonBinary.gc = d.nonBinary.General_Category;\n  d.nonBinary.sc = d.nonBinary.Script;\n  d.nonBinary.scx = d.nonBinary.Script_Extensions;\n}\nbuildUnicodeData(9);\nbuildUnicodeData(10);\nbuildUnicodeData(11);\n\nvar pp$8 = Parser.prototype;\n\nvar RegExpValidationState = function RegExpValidationState(parser) {\n  this.parser = parser;\n  this.validFlags = \"gim\" + (parser.options.ecmaVersion >= 6 ? \"uy\" : \"\") + (parser.options.ecmaVersion >= 9 ? \"s\" : \"\");\n  this.unicodeProperties = data[parser.options.ecmaVersion >= 11 ? 11 : parser.options.ecmaVersion];\n  this.source = \"\";\n  this.flags = \"\";\n  this.start = 0;\n  this.switchU = false;\n  this.switchN = false;\n  this.pos = 0;\n  this.lastIntValue = 0;\n  this.lastStringValue = \"\";\n  this.lastAssertionIsQuantifiable = false;\n  this.numCapturingParens = 0;\n  this.maxBackReference = 0;\n  this.groupNames = [];\n  this.backReferenceNames = [];\n};\n\nRegExpValidationState.prototype.reset = function reset (start, pattern, flags) {\n  var unicode = flags.indexOf(\"u\") !== -1;\n  this.start = start | 0;\n  this.source = pattern + \"\";\n  this.flags = flags;\n  this.switchU = unicode && this.parser.options.ecmaVersion >= 6;\n  this.switchN = unicode && this.parser.options.ecmaVersion >= 9;\n};\n\nRegExpValidationState.prototype.raise = function raise (message) {\n  this.parser.raiseRecoverable(this.start, (\"Invalid regular expression: /\" + (this.source) + \"/: \" + message));\n};\n\n// If u flag is given, this returns the code point at the index (it combines a surrogate pair).\n// Otherwise, this returns the code unit of the index (can be a part of a surrogate pair).\nRegExpValidationState.prototype.at = function at (i, forceU) {\n    if ( forceU === void 0 ) forceU = false;\n\n  var s = this.source;\n  var l = s.length;\n  if (i >= l) {\n    return -1\n  }\n  var c = s.charCodeAt(i);\n  if (!(forceU || this.switchU) || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l) {\n    return c\n  }\n  var next = s.charCodeAt(i + 1);\n  return next >= 0xDC00 && next <= 0xDFFF ? (c << 10) + next - 0x35FDC00 : c\n};\n\nRegExpValidationState.prototype.nextIndex = function nextIndex (i, forceU) {\n    if ( forceU === void 0 ) forceU = false;\n\n  var s = this.source;\n  var l = s.length;\n  if (i >= l) {\n    return l\n  }\n  var c = s.charCodeAt(i), next;\n  if (!(forceU || this.switchU) || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l ||\n      (next = s.charCodeAt(i + 1)) < 0xDC00 || next > 0xDFFF) {\n    return i + 1\n  }\n  return i + 2\n};\n\nRegExpValidationState.prototype.current = function current (forceU) {\n    if ( forceU === void 0 ) forceU = false;\n\n  return this.at(this.pos, forceU)\n};\n\nRegExpValidationState.prototype.lookahead = function lookahead (forceU) {\n    if ( forceU === void 0 ) forceU = false;\n\n  return this.at(this.nextIndex(this.pos, forceU), forceU)\n};\n\nRegExpValidationState.prototype.advance = function advance (forceU) {\n    if ( forceU === void 0 ) forceU = false;\n\n  this.pos = this.nextIndex(this.pos, forceU);\n};\n\nRegExpValidationState.prototype.eat = function eat (ch, forceU) {\n    if ( forceU === void 0 ) forceU = false;\n\n  if (this.current(forceU) === ch) {\n    this.advance(forceU);\n    return true\n  }\n  return false\n};\n\nfunction codePointToString(ch) {\n  if (ch <= 0xFFFF) { return String.fromCharCode(ch) }\n  ch -= 0x10000;\n  return String.fromCharCode((ch >> 10) + 0xD800, (ch & 0x03FF) + 0xDC00)\n}\n\n/**\n * Validate the flags part of a given RegExpLiteral.\n *\n * @param {RegExpValidationState} state The state to validate RegExp.\n * @returns {void}\n */\npp$8.validateRegExpFlags = function(state) {\n  var validFlags = state.validFlags;\n  var flags = state.flags;\n\n  for (var i = 0; i < flags.length; i++) {\n    var flag = flags.charAt(i);\n    if (validFlags.indexOf(flag) === -1) {\n      this.raise(state.start, \"Invalid regular expression flag\");\n    }\n    if (flags.indexOf(flag, i + 1) > -1) {\n      this.raise(state.start, \"Duplicate regular expression flag\");\n    }\n  }\n};\n\n/**\n * Validate the pattern part of a given RegExpLiteral.\n *\n * @param {RegExpValidationState} state The state to validate RegExp.\n * @returns {void}\n */\npp$8.validateRegExpPattern = function(state) {\n  this.regexp_pattern(state);\n\n  // The goal symbol for the parse is |Pattern[~U, ~N]|. If the result of\n  // parsing contains a |GroupName|, reparse with the goal symbol\n  // |Pattern[~U, +N]| and use this result instead. Throw a *SyntaxError*\n  // exception if _P_ did not conform to the grammar, if any elements of _P_\n  // were not matched by the parse, or if any Early Error conditions exist.\n  if (!state.switchN && this.options.ecmaVersion >= 9 && state.groupNames.length > 0) {\n    state.switchN = true;\n    this.regexp_pattern(state);\n  }\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-Pattern\npp$8.regexp_pattern = function(state) {\n  state.pos = 0;\n  state.lastIntValue = 0;\n  state.lastStringValue = \"\";\n  state.lastAssertionIsQuantifiable = false;\n  state.numCapturingParens = 0;\n  state.maxBackReference = 0;\n  state.groupNames.length = 0;\n  state.backReferenceNames.length = 0;\n\n  this.regexp_disjunction(state);\n\n  if (state.pos !== state.source.length) {\n    // Make the same messages as V8.\n    if (state.eat(0x29 /* ) */)) {\n      state.raise(\"Unmatched ')'\");\n    }\n    if (state.eat(0x5D /* ] */) || state.eat(0x7D /* } */)) {\n      state.raise(\"Lone quantifier brackets\");\n    }\n  }\n  if (state.maxBackReference > state.numCapturingParens) {\n    state.raise(\"Invalid escape\");\n  }\n  for (var i = 0, list = state.backReferenceNames; i < list.length; i += 1) {\n    var name = list[i];\n\n    if (state.groupNames.indexOf(name) === -1) {\n      state.raise(\"Invalid named capture referenced\");\n    }\n  }\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-Disjunction\npp$8.regexp_disjunction = function(state) {\n  this.regexp_alternative(state);\n  while (state.eat(0x7C /* | */)) {\n    this.regexp_alternative(state);\n  }\n\n  // Make the same message as V8.\n  if (this.regexp_eatQuantifier(state, true)) {\n    state.raise(\"Nothing to repeat\");\n  }\n  if (state.eat(0x7B /* { */)) {\n    state.raise(\"Lone quantifier brackets\");\n  }\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-Alternative\npp$8.regexp_alternative = function(state) {\n  while (state.pos < state.source.length && this.regexp_eatTerm(state))\n    { }\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Term\npp$8.regexp_eatTerm = function(state) {\n  if (this.regexp_eatAssertion(state)) {\n    // Handle `QuantifiableAssertion Quantifier` alternative.\n    // `state.lastAssertionIsQuantifiable` is true if the last eaten Assertion\n    // is a QuantifiableAssertion.\n    if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {\n      // Make the same message as V8.\n      if (state.switchU) {\n        state.raise(\"Invalid quantifier\");\n      }\n    }\n    return true\n  }\n\n  if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {\n    this.regexp_eatQuantifier(state);\n    return true\n  }\n\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Assertion\npp$8.regexp_eatAssertion = function(state) {\n  var start = state.pos;\n  state.lastAssertionIsQuantifiable = false;\n\n  // ^, $\n  if (state.eat(0x5E /* ^ */) || state.eat(0x24 /* $ */)) {\n    return true\n  }\n\n  // \\b \\B\n  if (state.eat(0x5C /* \\ */)) {\n    if (state.eat(0x42 /* B */) || state.eat(0x62 /* b */)) {\n      return true\n    }\n    state.pos = start;\n  }\n\n  // Lookahead / Lookbehind\n  if (state.eat(0x28 /* ( */) && state.eat(0x3F /* ? */)) {\n    var lookbehind = false;\n    if (this.options.ecmaVersion >= 9) {\n      lookbehind = state.eat(0x3C /* < */);\n    }\n    if (state.eat(0x3D /* = */) || state.eat(0x21 /* ! */)) {\n      this.regexp_disjunction(state);\n      if (!state.eat(0x29 /* ) */)) {\n        state.raise(\"Unterminated group\");\n      }\n      state.lastAssertionIsQuantifiable = !lookbehind;\n      return true\n    }\n  }\n\n  state.pos = start;\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-Quantifier\npp$8.regexp_eatQuantifier = function(state, noError) {\n  if ( noError === void 0 ) noError = false;\n\n  if (this.regexp_eatQuantifierPrefix(state, noError)) {\n    state.eat(0x3F /* ? */);\n    return true\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-QuantifierPrefix\npp$8.regexp_eatQuantifierPrefix = function(state, noError) {\n  return (\n    state.eat(0x2A /* * */) ||\n    state.eat(0x2B /* + */) ||\n    state.eat(0x3F /* ? */) ||\n    this.regexp_eatBracedQuantifier(state, noError)\n  )\n};\npp$8.regexp_eatBracedQuantifier = function(state, noError) {\n  var start = state.pos;\n  if (state.eat(0x7B /* { */)) {\n    var min = 0, max = -1;\n    if (this.regexp_eatDecimalDigits(state)) {\n      min = state.lastIntValue;\n      if (state.eat(0x2C /* , */) && this.regexp_eatDecimalDigits(state)) {\n        max = state.lastIntValue;\n      }\n      if (state.eat(0x7D /* } */)) {\n        // SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-term\n        if (max !== -1 && max < min && !noError) {\n          state.raise(\"numbers out of order in {} quantifier\");\n        }\n        return true\n      }\n    }\n    if (state.switchU && !noError) {\n      state.raise(\"Incomplete quantifier\");\n    }\n    state.pos = start;\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-Atom\npp$8.regexp_eatAtom = function(state) {\n  return (\n    this.regexp_eatPatternCharacters(state) ||\n    state.eat(0x2E /* . */) ||\n    this.regexp_eatReverseSolidusAtomEscape(state) ||\n    this.regexp_eatCharacterClass(state) ||\n    this.regexp_eatUncapturingGroup(state) ||\n    this.regexp_eatCapturingGroup(state)\n  )\n};\npp$8.regexp_eatReverseSolidusAtomEscape = function(state) {\n  var start = state.pos;\n  if (state.eat(0x5C /* \\ */)) {\n    if (this.regexp_eatAtomEscape(state)) {\n      return true\n    }\n    state.pos = start;\n  }\n  return false\n};\npp$8.regexp_eatUncapturingGroup = function(state) {\n  var start = state.pos;\n  if (state.eat(0x28 /* ( */)) {\n    if (state.eat(0x3F /* ? */) && state.eat(0x3A /* : */)) {\n      this.regexp_disjunction(state);\n      if (state.eat(0x29 /* ) */)) {\n        return true\n      }\n      state.raise(\"Unterminated group\");\n    }\n    state.pos = start;\n  }\n  return false\n};\npp$8.regexp_eatCapturingGroup = function(state) {\n  if (state.eat(0x28 /* ( */)) {\n    if (this.options.ecmaVersion >= 9) {\n      this.regexp_groupSpecifier(state);\n    } else if (state.current() === 0x3F /* ? */) {\n      state.raise(\"Invalid group\");\n    }\n    this.regexp_disjunction(state);\n    if (state.eat(0x29 /* ) */)) {\n      state.numCapturingParens += 1;\n      return true\n    }\n    state.raise(\"Unterminated group\");\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedAtom\npp$8.regexp_eatExtendedAtom = function(state) {\n  return (\n    state.eat(0x2E /* . */) ||\n    this.regexp_eatReverseSolidusAtomEscape(state) ||\n    this.regexp_eatCharacterClass(state) ||\n    this.regexp_eatUncapturingGroup(state) ||\n    this.regexp_eatCapturingGroup(state) ||\n    this.regexp_eatInvalidBracedQuantifier(state) ||\n    this.regexp_eatExtendedPatternCharacter(state)\n  )\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-InvalidBracedQuantifier\npp$8.regexp_eatInvalidBracedQuantifier = function(state) {\n  if (this.regexp_eatBracedQuantifier(state, true)) {\n    state.raise(\"Nothing to repeat\");\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-SyntaxCharacter\npp$8.regexp_eatSyntaxCharacter = function(state) {\n  var ch = state.current();\n  if (isSyntaxCharacter(ch)) {\n    state.lastIntValue = ch;\n    state.advance();\n    return true\n  }\n  return false\n};\nfunction isSyntaxCharacter(ch) {\n  return (\n    ch === 0x24 /* $ */ ||\n    ch >= 0x28 /* ( */ && ch <= 0x2B /* + */ ||\n    ch === 0x2E /* . */ ||\n    ch === 0x3F /* ? */ ||\n    ch >= 0x5B /* [ */ && ch <= 0x5E /* ^ */ ||\n    ch >= 0x7B /* { */ && ch <= 0x7D /* } */\n  )\n}\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-PatternCharacter\n// But eat eager.\npp$8.regexp_eatPatternCharacters = function(state) {\n  var start = state.pos;\n  var ch = 0;\n  while ((ch = state.current()) !== -1 && !isSyntaxCharacter(ch)) {\n    state.advance();\n  }\n  return state.pos !== start\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedPatternCharacter\npp$8.regexp_eatExtendedPatternCharacter = function(state) {\n  var ch = state.current();\n  if (\n    ch !== -1 &&\n    ch !== 0x24 /* $ */ &&\n    !(ch >= 0x28 /* ( */ && ch <= 0x2B /* + */) &&\n    ch !== 0x2E /* . */ &&\n    ch !== 0x3F /* ? */ &&\n    ch !== 0x5B /* [ */ &&\n    ch !== 0x5E /* ^ */ &&\n    ch !== 0x7C /* | */\n  ) {\n    state.advance();\n    return true\n  }\n  return false\n};\n\n// GroupSpecifier ::\n//   [empty]\n//   `?` GroupName\npp$8.regexp_groupSpecifier = function(state) {\n  if (state.eat(0x3F /* ? */)) {\n    if (this.regexp_eatGroupName(state)) {\n      if (state.groupNames.indexOf(state.lastStringValue) !== -1) {\n        state.raise(\"Duplicate capture group name\");\n      }\n      state.groupNames.push(state.lastStringValue);\n      return\n    }\n    state.raise(\"Invalid group\");\n  }\n};\n\n// GroupName ::\n//   `<` RegExpIdentifierName `>`\n// Note: this updates `state.lastStringValue` property with the eaten name.\npp$8.regexp_eatGroupName = function(state) {\n  state.lastStringValue = \"\";\n  if (state.eat(0x3C /* < */)) {\n    if (this.regexp_eatRegExpIdentifierName(state) && state.eat(0x3E /* > */)) {\n      return true\n    }\n    state.raise(\"Invalid capture group name\");\n  }\n  return false\n};\n\n// RegExpIdentifierName ::\n//   RegExpIdentifierStart\n//   RegExpIdentifierName RegExpIdentifierPart\n// Note: this updates `state.lastStringValue` property with the eaten name.\npp$8.regexp_eatRegExpIdentifierName = function(state) {\n  state.lastStringValue = \"\";\n  if (this.regexp_eatRegExpIdentifierStart(state)) {\n    state.lastStringValue += codePointToString(state.lastIntValue);\n    while (this.regexp_eatRegExpIdentifierPart(state)) {\n      state.lastStringValue += codePointToString(state.lastIntValue);\n    }\n    return true\n  }\n  return false\n};\n\n// RegExpIdentifierStart ::\n//   UnicodeIDStart\n//   `$`\n//   `_`\n//   `\\` RegExpUnicodeEscapeSequence[+U]\npp$8.regexp_eatRegExpIdentifierStart = function(state) {\n  var start = state.pos;\n  var forceU = this.options.ecmaVersion >= 11;\n  var ch = state.current(forceU);\n  state.advance(forceU);\n\n  if (ch === 0x5C /* \\ */ && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {\n    ch = state.lastIntValue;\n  }\n  if (isRegExpIdentifierStart(ch)) {\n    state.lastIntValue = ch;\n    return true\n  }\n\n  state.pos = start;\n  return false\n};\nfunction isRegExpIdentifierStart(ch) {\n  return isIdentifierStart(ch, true) || ch === 0x24 /* $ */ || ch === 0x5F /* _ */\n}\n\n// RegExpIdentifierPart ::\n//   UnicodeIDContinue\n//   `$`\n//   `_`\n//   `\\` RegExpUnicodeEscapeSequence[+U]\n//   <ZWNJ>\n//   <ZWJ>\npp$8.regexp_eatRegExpIdentifierPart = function(state) {\n  var start = state.pos;\n  var forceU = this.options.ecmaVersion >= 11;\n  var ch = state.current(forceU);\n  state.advance(forceU);\n\n  if (ch === 0x5C /* \\ */ && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {\n    ch = state.lastIntValue;\n  }\n  if (isRegExpIdentifierPart(ch)) {\n    state.lastIntValue = ch;\n    return true\n  }\n\n  state.pos = start;\n  return false\n};\nfunction isRegExpIdentifierPart(ch) {\n  return isIdentifierChar(ch, true) || ch === 0x24 /* $ */ || ch === 0x5F /* _ */ || ch === 0x200C /* <ZWNJ> */ || ch === 0x200D /* <ZWJ> */\n}\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-AtomEscape\npp$8.regexp_eatAtomEscape = function(state) {\n  if (\n    this.regexp_eatBackReference(state) ||\n    this.regexp_eatCharacterClassEscape(state) ||\n    this.regexp_eatCharacterEscape(state) ||\n    (state.switchN && this.regexp_eatKGroupName(state))\n  ) {\n    return true\n  }\n  if (state.switchU) {\n    // Make the same message as V8.\n    if (state.current() === 0x63 /* c */) {\n      state.raise(\"Invalid unicode escape\");\n    }\n    state.raise(\"Invalid escape\");\n  }\n  return false\n};\npp$8.regexp_eatBackReference = function(state) {\n  var start = state.pos;\n  if (this.regexp_eatDecimalEscape(state)) {\n    var n = state.lastIntValue;\n    if (state.switchU) {\n      // For SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-atomescape\n      if (n > state.maxBackReference) {\n        state.maxBackReference = n;\n      }\n      return true\n    }\n    if (n <= state.numCapturingParens) {\n      return true\n    }\n    state.pos = start;\n  }\n  return false\n};\npp$8.regexp_eatKGroupName = function(state) {\n  if (state.eat(0x6B /* k */)) {\n    if (this.regexp_eatGroupName(state)) {\n      state.backReferenceNames.push(state.lastStringValue);\n      return true\n    }\n    state.raise(\"Invalid named reference\");\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-CharacterEscape\npp$8.regexp_eatCharacterEscape = function(state) {\n  return (\n    this.regexp_eatControlEscape(state) ||\n    this.regexp_eatCControlLetter(state) ||\n    this.regexp_eatZero(state) ||\n    this.regexp_eatHexEscapeSequence(state) ||\n    this.regexp_eatRegExpUnicodeEscapeSequence(state, false) ||\n    (!state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state)) ||\n    this.regexp_eatIdentityEscape(state)\n  )\n};\npp$8.regexp_eatCControlLetter = function(state) {\n  var start = state.pos;\n  if (state.eat(0x63 /* c */)) {\n    if (this.regexp_eatControlLetter(state)) {\n      return true\n    }\n    state.pos = start;\n  }\n  return false\n};\npp$8.regexp_eatZero = function(state) {\n  if (state.current() === 0x30 /* 0 */ && !isDecimalDigit(state.lookahead())) {\n    state.lastIntValue = 0;\n    state.advance();\n    return true\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-ControlEscape\npp$8.regexp_eatControlEscape = function(state) {\n  var ch = state.current();\n  if (ch === 0x74 /* t */) {\n    state.lastIntValue = 0x09; /* \\t */\n    state.advance();\n    return true\n  }\n  if (ch === 0x6E /* n */) {\n    state.lastIntValue = 0x0A; /* \\n */\n    state.advance();\n    return true\n  }\n  if (ch === 0x76 /* v */) {\n    state.lastIntValue = 0x0B; /* \\v */\n    state.advance();\n    return true\n  }\n  if (ch === 0x66 /* f */) {\n    state.lastIntValue = 0x0C; /* \\f */\n    state.advance();\n    return true\n  }\n  if (ch === 0x72 /* r */) {\n    state.lastIntValue = 0x0D; /* \\r */\n    state.advance();\n    return true\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-ControlLetter\npp$8.regexp_eatControlLetter = function(state) {\n  var ch = state.current();\n  if (isControlLetter(ch)) {\n    state.lastIntValue = ch % 0x20;\n    state.advance();\n    return true\n  }\n  return false\n};\nfunction isControlLetter(ch) {\n  return (\n    (ch >= 0x41 /* A */ && ch <= 0x5A /* Z */) ||\n    (ch >= 0x61 /* a */ && ch <= 0x7A /* z */)\n  )\n}\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-RegExpUnicodeEscapeSequence\npp$8.regexp_eatRegExpUnicodeEscapeSequence = function(state, forceU) {\n  if ( forceU === void 0 ) forceU = false;\n\n  var start = state.pos;\n  var switchU = forceU || state.switchU;\n\n  if (state.eat(0x75 /* u */)) {\n    if (this.regexp_eatFixedHexDigits(state, 4)) {\n      var lead = state.lastIntValue;\n      if (switchU && lead >= 0xD800 && lead <= 0xDBFF) {\n        var leadSurrogateEnd = state.pos;\n        if (state.eat(0x5C /* \\ */) && state.eat(0x75 /* u */) && this.regexp_eatFixedHexDigits(state, 4)) {\n          var trail = state.lastIntValue;\n          if (trail >= 0xDC00 && trail <= 0xDFFF) {\n            state.lastIntValue = (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;\n            return true\n          }\n        }\n        state.pos = leadSurrogateEnd;\n        state.lastIntValue = lead;\n      }\n      return true\n    }\n    if (\n      switchU &&\n      state.eat(0x7B /* { */) &&\n      this.regexp_eatHexDigits(state) &&\n      state.eat(0x7D /* } */) &&\n      isValidUnicode(state.lastIntValue)\n    ) {\n      return true\n    }\n    if (switchU) {\n      state.raise(\"Invalid unicode escape\");\n    }\n    state.pos = start;\n  }\n\n  return false\n};\nfunction isValidUnicode(ch) {\n  return ch >= 0 && ch <= 0x10FFFF\n}\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-IdentityEscape\npp$8.regexp_eatIdentityEscape = function(state) {\n  if (state.switchU) {\n    if (this.regexp_eatSyntaxCharacter(state)) {\n      return true\n    }\n    if (state.eat(0x2F /* / */)) {\n      state.lastIntValue = 0x2F; /* / */\n      return true\n    }\n    return false\n  }\n\n  var ch = state.current();\n  if (ch !== 0x63 /* c */ && (!state.switchN || ch !== 0x6B /* k */)) {\n    state.lastIntValue = ch;\n    state.advance();\n    return true\n  }\n\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalEscape\npp$8.regexp_eatDecimalEscape = function(state) {\n  state.lastIntValue = 0;\n  var ch = state.current();\n  if (ch >= 0x31 /* 1 */ && ch <= 0x39 /* 9 */) {\n    do {\n      state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */);\n      state.advance();\n    } while ((ch = state.current()) >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */)\n    return true\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClassEscape\npp$8.regexp_eatCharacterClassEscape = function(state) {\n  var ch = state.current();\n\n  if (isCharacterClassEscape(ch)) {\n    state.lastIntValue = -1;\n    state.advance();\n    return true\n  }\n\n  if (\n    state.switchU &&\n    this.options.ecmaVersion >= 9 &&\n    (ch === 0x50 /* P */ || ch === 0x70 /* p */)\n  ) {\n    state.lastIntValue = -1;\n    state.advance();\n    if (\n      state.eat(0x7B /* { */) &&\n      this.regexp_eatUnicodePropertyValueExpression(state) &&\n      state.eat(0x7D /* } */)\n    ) {\n      return true\n    }\n    state.raise(\"Invalid property name\");\n  }\n\n  return false\n};\nfunction isCharacterClassEscape(ch) {\n  return (\n    ch === 0x64 /* d */ ||\n    ch === 0x44 /* D */ ||\n    ch === 0x73 /* s */ ||\n    ch === 0x53 /* S */ ||\n    ch === 0x77 /* w */ ||\n    ch === 0x57 /* W */\n  )\n}\n\n// UnicodePropertyValueExpression ::\n//   UnicodePropertyName `=` UnicodePropertyValue\n//   LoneUnicodePropertyNameOrValue\npp$8.regexp_eatUnicodePropertyValueExpression = function(state) {\n  var start = state.pos;\n\n  // UnicodePropertyName `=` UnicodePropertyValue\n  if (this.regexp_eatUnicodePropertyName(state) && state.eat(0x3D /* = */)) {\n    var name = state.lastStringValue;\n    if (this.regexp_eatUnicodePropertyValue(state)) {\n      var value = state.lastStringValue;\n      this.regexp_validateUnicodePropertyNameAndValue(state, name, value);\n      return true\n    }\n  }\n  state.pos = start;\n\n  // LoneUnicodePropertyNameOrValue\n  if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {\n    var nameOrValue = state.lastStringValue;\n    this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);\n    return true\n  }\n  return false\n};\npp$8.regexp_validateUnicodePropertyNameAndValue = function(state, name, value) {\n  if (!has(state.unicodeProperties.nonBinary, name))\n    { state.raise(\"Invalid property name\"); }\n  if (!state.unicodeProperties.nonBinary[name].test(value))\n    { state.raise(\"Invalid property value\"); }\n};\npp$8.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {\n  if (!state.unicodeProperties.binary.test(nameOrValue))\n    { state.raise(\"Invalid property name\"); }\n};\n\n// UnicodePropertyName ::\n//   UnicodePropertyNameCharacters\npp$8.regexp_eatUnicodePropertyName = function(state) {\n  var ch = 0;\n  state.lastStringValue = \"\";\n  while (isUnicodePropertyNameCharacter(ch = state.current())) {\n    state.lastStringValue += codePointToString(ch);\n    state.advance();\n  }\n  return state.lastStringValue !== \"\"\n};\nfunction isUnicodePropertyNameCharacter(ch) {\n  return isControlLetter(ch) || ch === 0x5F /* _ */\n}\n\n// UnicodePropertyValue ::\n//   UnicodePropertyValueCharacters\npp$8.regexp_eatUnicodePropertyValue = function(state) {\n  var ch = 0;\n  state.lastStringValue = \"\";\n  while (isUnicodePropertyValueCharacter(ch = state.current())) {\n    state.lastStringValue += codePointToString(ch);\n    state.advance();\n  }\n  return state.lastStringValue !== \"\"\n};\nfunction isUnicodePropertyValueCharacter(ch) {\n  return isUnicodePropertyNameCharacter(ch) || isDecimalDigit(ch)\n}\n\n// LoneUnicodePropertyNameOrValue ::\n//   UnicodePropertyValueCharacters\npp$8.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {\n  return this.regexp_eatUnicodePropertyValue(state)\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClass\npp$8.regexp_eatCharacterClass = function(state) {\n  if (state.eat(0x5B /* [ */)) {\n    state.eat(0x5E /* ^ */);\n    this.regexp_classRanges(state);\n    if (state.eat(0x5D /* ] */)) {\n      return true\n    }\n    // Unreachable since it threw \"unterminated regular expression\" error before.\n    state.raise(\"Unterminated character class\");\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-ClassRanges\n// https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRanges\n// https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRangesNoDash\npp$8.regexp_classRanges = function(state) {\n  while (this.regexp_eatClassAtom(state)) {\n    var left = state.lastIntValue;\n    if (state.eat(0x2D /* - */) && this.regexp_eatClassAtom(state)) {\n      var right = state.lastIntValue;\n      if (state.switchU && (left === -1 || right === -1)) {\n        state.raise(\"Invalid character class\");\n      }\n      if (left !== -1 && right !== -1 && left > right) {\n        state.raise(\"Range out of order in character class\");\n      }\n    }\n  }\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtom\n// https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtomNoDash\npp$8.regexp_eatClassAtom = function(state) {\n  var start = state.pos;\n\n  if (state.eat(0x5C /* \\ */)) {\n    if (this.regexp_eatClassEscape(state)) {\n      return true\n    }\n    if (state.switchU) {\n      // Make the same message as V8.\n      var ch$1 = state.current();\n      if (ch$1 === 0x63 /* c */ || isOctalDigit(ch$1)) {\n        state.raise(\"Invalid class escape\");\n      }\n      state.raise(\"Invalid escape\");\n    }\n    state.pos = start;\n  }\n\n  var ch = state.current();\n  if (ch !== 0x5D /* ] */) {\n    state.lastIntValue = ch;\n    state.advance();\n    return true\n  }\n\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassEscape\npp$8.regexp_eatClassEscape = function(state) {\n  var start = state.pos;\n\n  if (state.eat(0x62 /* b */)) {\n    state.lastIntValue = 0x08; /* <BS> */\n    return true\n  }\n\n  if (state.switchU && state.eat(0x2D /* - */)) {\n    state.lastIntValue = 0x2D; /* - */\n    return true\n  }\n\n  if (!state.switchU && state.eat(0x63 /* c */)) {\n    if (this.regexp_eatClassControlLetter(state)) {\n      return true\n    }\n    state.pos = start;\n  }\n\n  return (\n    this.regexp_eatCharacterClassEscape(state) ||\n    this.regexp_eatCharacterEscape(state)\n  )\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassControlLetter\npp$8.regexp_eatClassControlLetter = function(state) {\n  var ch = state.current();\n  if (isDecimalDigit(ch) || ch === 0x5F /* _ */) {\n    state.lastIntValue = ch % 0x20;\n    state.advance();\n    return true\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence\npp$8.regexp_eatHexEscapeSequence = function(state) {\n  var start = state.pos;\n  if (state.eat(0x78 /* x */)) {\n    if (this.regexp_eatFixedHexDigits(state, 2)) {\n      return true\n    }\n    if (state.switchU) {\n      state.raise(\"Invalid escape\");\n    }\n    state.pos = start;\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalDigits\npp$8.regexp_eatDecimalDigits = function(state) {\n  var start = state.pos;\n  var ch = 0;\n  state.lastIntValue = 0;\n  while (isDecimalDigit(ch = state.current())) {\n    state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */);\n    state.advance();\n  }\n  return state.pos !== start\n};\nfunction isDecimalDigit(ch) {\n  return ch >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */\n}\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigits\npp$8.regexp_eatHexDigits = function(state) {\n  var start = state.pos;\n  var ch = 0;\n  state.lastIntValue = 0;\n  while (isHexDigit(ch = state.current())) {\n    state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);\n    state.advance();\n  }\n  return state.pos !== start\n};\nfunction isHexDigit(ch) {\n  return (\n    (ch >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */) ||\n    (ch >= 0x41 /* A */ && ch <= 0x46 /* F */) ||\n    (ch >= 0x61 /* a */ && ch <= 0x66 /* f */)\n  )\n}\nfunction hexToInt(ch) {\n  if (ch >= 0x41 /* A */ && ch <= 0x46 /* F */) {\n    return 10 + (ch - 0x41 /* A */)\n  }\n  if (ch >= 0x61 /* a */ && ch <= 0x66 /* f */) {\n    return 10 + (ch - 0x61 /* a */)\n  }\n  return ch - 0x30 /* 0 */\n}\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-LegacyOctalEscapeSequence\n// Allows only 0-377(octal) i.e. 0-255(decimal).\npp$8.regexp_eatLegacyOctalEscapeSequence = function(state) {\n  if (this.regexp_eatOctalDigit(state)) {\n    var n1 = state.lastIntValue;\n    if (this.regexp_eatOctalDigit(state)) {\n      var n2 = state.lastIntValue;\n      if (n1 <= 3 && this.regexp_eatOctalDigit(state)) {\n        state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;\n      } else {\n        state.lastIntValue = n1 * 8 + n2;\n      }\n    } else {\n      state.lastIntValue = n1;\n    }\n    return true\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-OctalDigit\npp$8.regexp_eatOctalDigit = function(state) {\n  var ch = state.current();\n  if (isOctalDigit(ch)) {\n    state.lastIntValue = ch - 0x30; /* 0 */\n    state.advance();\n    return true\n  }\n  state.lastIntValue = 0;\n  return false\n};\nfunction isOctalDigit(ch) {\n  return ch >= 0x30 /* 0 */ && ch <= 0x37 /* 7 */\n}\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-Hex4Digits\n// https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigit\n// And HexDigit HexDigit in https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence\npp$8.regexp_eatFixedHexDigits = function(state, length) {\n  var start = state.pos;\n  state.lastIntValue = 0;\n  for (var i = 0; i < length; ++i) {\n    var ch = state.current();\n    if (!isHexDigit(ch)) {\n      state.pos = start;\n      return false\n    }\n    state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);\n    state.advance();\n  }\n  return true\n};\n\n// Object type used to represent tokens. Note that normally, tokens\n// simply exist as properties on the parser object. This is only\n// used for the onToken callback and the external tokenizer.\n\nvar Token = function Token(p) {\n  this.type = p.type;\n  this.value = p.value;\n  this.start = p.start;\n  this.end = p.end;\n  if (p.options.locations)\n    { this.loc = new SourceLocation(p, p.startLoc, p.endLoc); }\n  if (p.options.ranges)\n    { this.range = [p.start, p.end]; }\n};\n\n// ## Tokenizer\n\nvar pp$9 = Parser.prototype;\n\n// Move to the next token\n\npp$9.next = function(ignoreEscapeSequenceInKeyword) {\n  if (!ignoreEscapeSequenceInKeyword && this.type.keyword && this.containsEsc)\n    { this.raiseRecoverable(this.start, \"Escape sequence in keyword \" + this.type.keyword); }\n  if (this.options.onToken)\n    { this.options.onToken(new Token(this)); }\n\n  this.lastTokEnd = this.end;\n  this.lastTokStart = this.start;\n  this.lastTokEndLoc = this.endLoc;\n  this.lastTokStartLoc = this.startLoc;\n  this.nextToken();\n};\n\npp$9.getToken = function() {\n  this.next();\n  return new Token(this)\n};\n\n// If we're in an ES6 environment, make parsers iterable\nif (typeof Symbol !== \"undefined\")\n  { pp$9[Symbol.iterator] = function() {\n    var this$1 = this;\n\n    return {\n      next: function () {\n        var token = this$1.getToken();\n        return {\n          done: token.type === types.eof,\n          value: token\n        }\n      }\n    }\n  }; }\n\n// Toggle strict mode. Re-reads the next number or string to please\n// pedantic tests (`\"use strict\"; 010;` should fail).\n\npp$9.curContext = function() {\n  return this.context[this.context.length - 1]\n};\n\n// Read a single token, updating the parser object's token-related\n// properties.\n\npp$9.nextToken = function() {\n  var curContext = this.curContext();\n  if (!curContext || !curContext.preserveSpace) { this.skipSpace(); }\n\n  this.start = this.pos;\n  if (this.options.locations) { this.startLoc = this.curPosition(); }\n  if (this.pos >= this.input.length) { return this.finishToken(types.eof) }\n\n  if (curContext.override) { return curContext.override(this) }\n  else { this.readToken(this.fullCharCodeAtPos()); }\n};\n\npp$9.readToken = function(code) {\n  // Identifier or keyword. '\\uXXXX' sequences are allowed in\n  // identifiers, so '\\' also dispatches to that.\n  if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92 /* '\\' */)\n    { return this.readWord() }\n\n  return this.getTokenFromCode(code)\n};\n\npp$9.fullCharCodeAtPos = function() {\n  var code = this.input.charCodeAt(this.pos);\n  if (code <= 0xd7ff || code >= 0xe000) { return code }\n  var next = this.input.charCodeAt(this.pos + 1);\n  return (code << 10) + next - 0x35fdc00\n};\n\npp$9.skipBlockComment = function() {\n  var startLoc = this.options.onComment && this.curPosition();\n  var start = this.pos, end = this.input.indexOf(\"*/\", this.pos += 2);\n  if (end === -1) { this.raise(this.pos - 2, \"Unterminated comment\"); }\n  this.pos = end + 2;\n  if (this.options.locations) {\n    lineBreakG.lastIndex = start;\n    var match;\n    while ((match = lineBreakG.exec(this.input)) && match.index < this.pos) {\n      ++this.curLine;\n      this.lineStart = match.index + match[0].length;\n    }\n  }\n  if (this.options.onComment)\n    { this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos,\n                           startLoc, this.curPosition()); }\n};\n\npp$9.skipLineComment = function(startSkip) {\n  var start = this.pos;\n  var startLoc = this.options.onComment && this.curPosition();\n  var ch = this.input.charCodeAt(this.pos += startSkip);\n  while (this.pos < this.input.length && !isNewLine(ch)) {\n    ch = this.input.charCodeAt(++this.pos);\n  }\n  if (this.options.onComment)\n    { this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos,\n                           startLoc, this.curPosition()); }\n};\n\n// Called at the start of the parse and after every token. Skips\n// whitespace and comments, and.\n\npp$9.skipSpace = function() {\n  loop: while (this.pos < this.input.length) {\n    var ch = this.input.charCodeAt(this.pos);\n    switch (ch) {\n    case 32: case 160: // ' '\n      ++this.pos;\n      break\n    case 13:\n      if (this.input.charCodeAt(this.pos + 1) === 10) {\n        ++this.pos;\n      }\n    case 10: case 8232: case 8233:\n      ++this.pos;\n      if (this.options.locations) {\n        ++this.curLine;\n        this.lineStart = this.pos;\n      }\n      break\n    case 47: // '/'\n      switch (this.input.charCodeAt(this.pos + 1)) {\n      case 42: // '*'\n        this.skipBlockComment();\n        break\n      case 47:\n        this.skipLineComment(2);\n        break\n      default:\n        break loop\n      }\n      break\n    default:\n      if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {\n        ++this.pos;\n      } else {\n        break loop\n      }\n    }\n  }\n};\n\n// Called at the end of every token. Sets `end`, `val`, and\n// maintains `context` and `exprAllowed`, and skips the space after\n// the token, so that the next one's `start` will point at the\n// right position.\n\npp$9.finishToken = function(type, val) {\n  this.end = this.pos;\n  if (this.options.locations) { this.endLoc = this.curPosition(); }\n  var prevType = this.type;\n  this.type = type;\n  this.value = val;\n\n  this.updateContext(prevType);\n};\n\n// ### Token reading\n\n// This is the function that is called to fetch the next token. It\n// is somewhat obscure, because it works in character codes rather\n// than characters, and because operator parsing has been inlined\n// into it.\n//\n// All in the name of speed.\n//\npp$9.readToken_dot = function() {\n  var next = this.input.charCodeAt(this.pos + 1);\n  if (next >= 48 && next <= 57) { return this.readNumber(true) }\n  var next2 = this.input.charCodeAt(this.pos + 2);\n  if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) { // 46 = dot '.'\n    this.pos += 3;\n    return this.finishToken(types.ellipsis)\n  } else {\n    ++this.pos;\n    return this.finishToken(types.dot)\n  }\n};\n\npp$9.readToken_slash = function() { // '/'\n  var next = this.input.charCodeAt(this.pos + 1);\n  if (this.exprAllowed) { ++this.pos; return this.readRegexp() }\n  if (next === 61) { return this.finishOp(types.assign, 2) }\n  return this.finishOp(types.slash, 1)\n};\n\npp$9.readToken_mult_modulo_exp = function(code) { // '%*'\n  var next = this.input.charCodeAt(this.pos + 1);\n  var size = 1;\n  var tokentype = code === 42 ? types.star : types.modulo;\n\n  // exponentiation operator ** and **=\n  if (this.options.ecmaVersion >= 7 && code === 42 && next === 42) {\n    ++size;\n    tokentype = types.starstar;\n    next = this.input.charCodeAt(this.pos + 2);\n  }\n\n  if (next === 61) { return this.finishOp(types.assign, size + 1) }\n  return this.finishOp(tokentype, size)\n};\n\npp$9.readToken_pipe_amp = function(code) { // '|&'\n  var next = this.input.charCodeAt(this.pos + 1);\n  if (next === code) {\n    if (this.options.ecmaVersion >= 12) {\n      var next2 = this.input.charCodeAt(this.pos + 2);\n      if (next2 === 61) { return this.finishOp(types.assign, 3) }\n    }\n    return this.finishOp(code === 124 ? types.logicalOR : types.logicalAND, 2)\n  }\n  if (next === 61) { return this.finishOp(types.assign, 2) }\n  return this.finishOp(code === 124 ? types.bitwiseOR : types.bitwiseAND, 1)\n};\n\npp$9.readToken_caret = function() { // '^'\n  var next = this.input.charCodeAt(this.pos + 1);\n  if (next === 61) { return this.finishOp(types.assign, 2) }\n  return this.finishOp(types.bitwiseXOR, 1)\n};\n\npp$9.readToken_plus_min = function(code) { // '+-'\n  var next = this.input.charCodeAt(this.pos + 1);\n  if (next === code) {\n    if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 &&\n        (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {\n      // A `-->` line comment\n      this.skipLineComment(3);\n      this.skipSpace();\n      return this.nextToken()\n    }\n    return this.finishOp(types.incDec, 2)\n  }\n  if (next === 61) { return this.finishOp(types.assign, 2) }\n  return this.finishOp(types.plusMin, 1)\n};\n\npp$9.readToken_lt_gt = function(code) { // '<>'\n  var next = this.input.charCodeAt(this.pos + 1);\n  var size = 1;\n  if (next === code) {\n    size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;\n    if (this.input.charCodeAt(this.pos + size) === 61) { return this.finishOp(types.assign, size + 1) }\n    return this.finishOp(types.bitShift, size)\n  }\n  if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 &&\n      this.input.charCodeAt(this.pos + 3) === 45) {\n    // `<!--`, an XML-style comment that should be interpreted as a line comment\n    this.skipLineComment(4);\n    this.skipSpace();\n    return this.nextToken()\n  }\n  if (next === 61) { size = 2; }\n  return this.finishOp(types.relational, size)\n};\n\npp$9.readToken_eq_excl = function(code) { // '=!'\n  var next = this.input.charCodeAt(this.pos + 1);\n  if (next === 61) { return this.finishOp(types.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2) }\n  if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) { // '=>'\n    this.pos += 2;\n    return this.finishToken(types.arrow)\n  }\n  return this.finishOp(code === 61 ? types.eq : types.prefix, 1)\n};\n\npp$9.readToken_question = function() { // '?'\n  var ecmaVersion = this.options.ecmaVersion;\n  if (ecmaVersion >= 11) {\n    var next = this.input.charCodeAt(this.pos + 1);\n    if (next === 46) {\n      var next2 = this.input.charCodeAt(this.pos + 2);\n      if (next2 < 48 || next2 > 57) { return this.finishOp(types.questionDot, 2) }\n    }\n    if (next === 63) {\n      if (ecmaVersion >= 12) {\n        var next2$1 = this.input.charCodeAt(this.pos + 2);\n        if (next2$1 === 61) { return this.finishOp(types.assign, 3) }\n      }\n      return this.finishOp(types.coalesce, 2)\n    }\n  }\n  return this.finishOp(types.question, 1)\n};\n\npp$9.getTokenFromCode = function(code) {\n  switch (code) {\n  // The interpretation of a dot depends on whether it is followed\n  // by a digit or another two dots.\n  case 46: // '.'\n    return this.readToken_dot()\n\n  // Punctuation tokens.\n  case 40: ++this.pos; return this.finishToken(types.parenL)\n  case 41: ++this.pos; return this.finishToken(types.parenR)\n  case 59: ++this.pos; return this.finishToken(types.semi)\n  case 44: ++this.pos; return this.finishToken(types.comma)\n  case 91: ++this.pos; return this.finishToken(types.bracketL)\n  case 93: ++this.pos; return this.finishToken(types.bracketR)\n  case 123: ++this.pos; return this.finishToken(types.braceL)\n  case 125: ++this.pos; return this.finishToken(types.braceR)\n  case 58: ++this.pos; return this.finishToken(types.colon)\n\n  case 96: // '`'\n    if (this.options.ecmaVersion < 6) { break }\n    ++this.pos;\n    return this.finishToken(types.backQuote)\n\n  case 48: // '0'\n    var next = this.input.charCodeAt(this.pos + 1);\n    if (next === 120 || next === 88) { return this.readRadixNumber(16) } // '0x', '0X' - hex number\n    if (this.options.ecmaVersion >= 6) {\n      if (next === 111 || next === 79) { return this.readRadixNumber(8) } // '0o', '0O' - octal number\n      if (next === 98 || next === 66) { return this.readRadixNumber(2) } // '0b', '0B' - binary number\n    }\n\n  // Anything else beginning with a digit is an integer, octal\n  // number, or float.\n  case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: // 1-9\n    return this.readNumber(false)\n\n  // Quotes produce strings.\n  case 34: case 39: // '\"', \"'\"\n    return this.readString(code)\n\n  // Operators are parsed inline in tiny state machines. '=' (61) is\n  // often referred to. `finishOp` simply skips the amount of\n  // characters it is given as second argument, and returns a token\n  // of the type given by its first argument.\n\n  case 47: // '/'\n    return this.readToken_slash()\n\n  case 37: case 42: // '%*'\n    return this.readToken_mult_modulo_exp(code)\n\n  case 124: case 38: // '|&'\n    return this.readToken_pipe_amp(code)\n\n  case 94: // '^'\n    return this.readToken_caret()\n\n  case 43: case 45: // '+-'\n    return this.readToken_plus_min(code)\n\n  case 60: case 62: // '<>'\n    return this.readToken_lt_gt(code)\n\n  case 61: case 33: // '=!'\n    return this.readToken_eq_excl(code)\n\n  case 63: // '?'\n    return this.readToken_question()\n\n  case 126: // '~'\n    return this.finishOp(types.prefix, 1)\n  }\n\n  this.raise(this.pos, \"Unexpected character '\" + codePointToString$1(code) + \"'\");\n};\n\npp$9.finishOp = function(type, size) {\n  var str = this.input.slice(this.pos, this.pos + size);\n  this.pos += size;\n  return this.finishToken(type, str)\n};\n\npp$9.readRegexp = function() {\n  var escaped, inClass, start = this.pos;\n  for (;;) {\n    if (this.pos >= this.input.length) { this.raise(start, \"Unterminated regular expression\"); }\n    var ch = this.input.charAt(this.pos);\n    if (lineBreak.test(ch)) { this.raise(start, \"Unterminated regular expression\"); }\n    if (!escaped) {\n      if (ch === \"[\") { inClass = true; }\n      else if (ch === \"]\" && inClass) { inClass = false; }\n      else if (ch === \"/\" && !inClass) { break }\n      escaped = ch === \"\\\\\";\n    } else { escaped = false; }\n    ++this.pos;\n  }\n  var pattern = this.input.slice(start, this.pos);\n  ++this.pos;\n  var flagsStart = this.pos;\n  var flags = this.readWord1();\n  if (this.containsEsc) { this.unexpected(flagsStart); }\n\n  // Validate pattern\n  var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));\n  state.reset(start, pattern, flags);\n  this.validateRegExpFlags(state);\n  this.validateRegExpPattern(state);\n\n  // Create Literal#value property value.\n  var value = null;\n  try {\n    value = new RegExp(pattern, flags);\n  } catch (e) {\n    // ESTree requires null if it failed to instantiate RegExp object.\n    // https://github.com/estree/estree/blob/a27003adf4fd7bfad44de9cef372a2eacd527b1c/es5.md#regexpliteral\n  }\n\n  return this.finishToken(types.regexp, {pattern: pattern, flags: flags, value: value})\n};\n\n// Read an integer in the given radix. Return null if zero digits\n// were read, the integer value otherwise. When `len` is given, this\n// will return `null` unless the integer has exactly `len` digits.\n\npp$9.readInt = function(radix, len, maybeLegacyOctalNumericLiteral) {\n  // `len` is used for character escape sequences. In that case, disallow separators.\n  var allowSeparators = this.options.ecmaVersion >= 12 && len === undefined;\n\n  // `maybeLegacyOctalNumericLiteral` is true if it doesn't have prefix (0x,0o,0b)\n  // and isn't fraction part nor exponent part. In that case, if the first digit\n  // is zero then disallow separators.\n  var isLegacyOctalNumericLiteral = maybeLegacyOctalNumericLiteral && this.input.charCodeAt(this.pos) === 48;\n\n  var start = this.pos, total = 0, lastCode = 0;\n  for (var i = 0, e = len == null ? Infinity : len; i < e; ++i, ++this.pos) {\n    var code = this.input.charCodeAt(this.pos), val = (void 0);\n\n    if (allowSeparators && code === 95) {\n      if (isLegacyOctalNumericLiteral) { this.raiseRecoverable(this.pos, \"Numeric separator is not allowed in legacy octal numeric literals\"); }\n      if (lastCode === 95) { this.raiseRecoverable(this.pos, \"Numeric separator must be exactly one underscore\"); }\n      if (i === 0) { this.raiseRecoverable(this.pos, \"Numeric separator is not allowed at the first of digits\"); }\n      lastCode = code;\n      continue\n    }\n\n    if (code >= 97) { val = code - 97 + 10; } // a\n    else if (code >= 65) { val = code - 65 + 10; } // A\n    else if (code >= 48 && code <= 57) { val = code - 48; } // 0-9\n    else { val = Infinity; }\n    if (val >= radix) { break }\n    lastCode = code;\n    total = total * radix + val;\n  }\n\n  if (allowSeparators && lastCode === 95) { this.raiseRecoverable(this.pos - 1, \"Numeric separator is not allowed at the last of digits\"); }\n  if (this.pos === start || len != null && this.pos - start !== len) { return null }\n\n  return total\n};\n\nfunction stringToNumber(str, isLegacyOctalNumericLiteral) {\n  if (isLegacyOctalNumericLiteral) {\n    return parseInt(str, 8)\n  }\n\n  // `parseFloat(value)` stops parsing at the first numeric separator then returns a wrong value.\n  return parseFloat(str.replace(/_/g, \"\"))\n}\n\nfunction stringToBigInt(str) {\n  if (typeof BigInt !== \"function\") {\n    return null\n  }\n\n  // `BigInt(value)` throws syntax error if the string contains numeric separators.\n  return BigInt(str.replace(/_/g, \"\"))\n}\n\npp$9.readRadixNumber = function(radix) {\n  var start = this.pos;\n  this.pos += 2; // 0x\n  var val = this.readInt(radix);\n  if (val == null) { this.raise(this.start + 2, \"Expected number in radix \" + radix); }\n  if (this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110) {\n    val = stringToBigInt(this.input.slice(start, this.pos));\n    ++this.pos;\n  } else if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, \"Identifier directly after number\"); }\n  return this.finishToken(types.num, val)\n};\n\n// Read an integer, octal integer, or floating-point number.\n\npp$9.readNumber = function(startsWithDot) {\n  var start = this.pos;\n  if (!startsWithDot && this.readInt(10, undefined, true) === null) { this.raise(start, \"Invalid number\"); }\n  var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;\n  if (octal && this.strict) { this.raise(start, \"Invalid number\"); }\n  var next = this.input.charCodeAt(this.pos);\n  if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && next === 110) {\n    var val$1 = stringToBigInt(this.input.slice(start, this.pos));\n    ++this.pos;\n    if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, \"Identifier directly after number\"); }\n    return this.finishToken(types.num, val$1)\n  }\n  if (octal && /[89]/.test(this.input.slice(start, this.pos))) { octal = false; }\n  if (next === 46 && !octal) { // '.'\n    ++this.pos;\n    this.readInt(10);\n    next = this.input.charCodeAt(this.pos);\n  }\n  if ((next === 69 || next === 101) && !octal) { // 'eE'\n    next = this.input.charCodeAt(++this.pos);\n    if (next === 43 || next === 45) { ++this.pos; } // '+-'\n    if (this.readInt(10) === null) { this.raise(start, \"Invalid number\"); }\n  }\n  if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, \"Identifier directly after number\"); }\n\n  var val = stringToNumber(this.input.slice(start, this.pos), octal);\n  return this.finishToken(types.num, val)\n};\n\n// Read a string value, interpreting backslash-escapes.\n\npp$9.readCodePoint = function() {\n  var ch = this.input.charCodeAt(this.pos), code;\n\n  if (ch === 123) { // '{'\n    if (this.options.ecmaVersion < 6) { this.unexpected(); }\n    var codePos = ++this.pos;\n    code = this.readHexChar(this.input.indexOf(\"}\", this.pos) - this.pos);\n    ++this.pos;\n    if (code > 0x10FFFF) { this.invalidStringToken(codePos, \"Code point out of bounds\"); }\n  } else {\n    code = this.readHexChar(4);\n  }\n  return code\n};\n\nfunction codePointToString$1(code) {\n  // UTF-16 Decoding\n  if (code <= 0xFFFF) { return String.fromCharCode(code) }\n  code -= 0x10000;\n  return String.fromCharCode((code >> 10) + 0xD800, (code & 1023) + 0xDC00)\n}\n\npp$9.readString = function(quote) {\n  var out = \"\", chunkStart = ++this.pos;\n  for (;;) {\n    if (this.pos >= this.input.length) { this.raise(this.start, \"Unterminated string constant\"); }\n    var ch = this.input.charCodeAt(this.pos);\n    if (ch === quote) { break }\n    if (ch === 92) { // '\\'\n      out += this.input.slice(chunkStart, this.pos);\n      out += this.readEscapedChar(false);\n      chunkStart = this.pos;\n    } else {\n      if (isNewLine(ch, this.options.ecmaVersion >= 10)) { this.raise(this.start, \"Unterminated string constant\"); }\n      ++this.pos;\n    }\n  }\n  out += this.input.slice(chunkStart, this.pos++);\n  return this.finishToken(types.string, out)\n};\n\n// Reads template string tokens.\n\nvar INVALID_TEMPLATE_ESCAPE_ERROR = {};\n\npp$9.tryReadTemplateToken = function() {\n  this.inTemplateElement = true;\n  try {\n    this.readTmplToken();\n  } catch (err) {\n    if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {\n      this.readInvalidTemplateToken();\n    } else {\n      throw err\n    }\n  }\n\n  this.inTemplateElement = false;\n};\n\npp$9.invalidStringToken = function(position, message) {\n  if (this.inTemplateElement && this.options.ecmaVersion >= 9) {\n    throw INVALID_TEMPLATE_ESCAPE_ERROR\n  } else {\n    this.raise(position, message);\n  }\n};\n\npp$9.readTmplToken = function() {\n  var out = \"\", chunkStart = this.pos;\n  for (;;) {\n    if (this.pos >= this.input.length) { this.raise(this.start, \"Unterminated template\"); }\n    var ch = this.input.charCodeAt(this.pos);\n    if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) { // '`', '${'\n      if (this.pos === this.start && (this.type === types.template || this.type === types.invalidTemplate)) {\n        if (ch === 36) {\n          this.pos += 2;\n          return this.finishToken(types.dollarBraceL)\n        } else {\n          ++this.pos;\n          return this.finishToken(types.backQuote)\n        }\n      }\n      out += this.input.slice(chunkStart, this.pos);\n      return this.finishToken(types.template, out)\n    }\n    if (ch === 92) { // '\\'\n      out += this.input.slice(chunkStart, this.pos);\n      out += this.readEscapedChar(true);\n      chunkStart = this.pos;\n    } else if (isNewLine(ch)) {\n      out += this.input.slice(chunkStart, this.pos);\n      ++this.pos;\n      switch (ch) {\n      case 13:\n        if (this.input.charCodeAt(this.pos) === 10) { ++this.pos; }\n      case 10:\n        out += \"\\n\";\n        break\n      default:\n        out += String.fromCharCode(ch);\n        break\n      }\n      if (this.options.locations) {\n        ++this.curLine;\n        this.lineStart = this.pos;\n      }\n      chunkStart = this.pos;\n    } else {\n      ++this.pos;\n    }\n  }\n};\n\n// Reads a template token to search for the end, without validating any escape sequences\npp$9.readInvalidTemplateToken = function() {\n  for (; this.pos < this.input.length; this.pos++) {\n    switch (this.input[this.pos]) {\n    case \"\\\\\":\n      ++this.pos;\n      break\n\n    case \"$\":\n      if (this.input[this.pos + 1] !== \"{\") {\n        break\n      }\n    // falls through\n\n    case \"`\":\n      return this.finishToken(types.invalidTemplate, this.input.slice(this.start, this.pos))\n\n    // no default\n    }\n  }\n  this.raise(this.start, \"Unterminated template\");\n};\n\n// Used to read escaped characters\n\npp$9.readEscapedChar = function(inTemplate) {\n  var ch = this.input.charCodeAt(++this.pos);\n  ++this.pos;\n  switch (ch) {\n  case 110: return \"\\n\" // 'n' -> '\\n'\n  case 114: return \"\\r\" // 'r' -> '\\r'\n  case 120: return String.fromCharCode(this.readHexChar(2)) // 'x'\n  case 117: return codePointToString$1(this.readCodePoint()) // 'u'\n  case 116: return \"\\t\" // 't' -> '\\t'\n  case 98: return \"\\b\" // 'b' -> '\\b'\n  case 118: return \"\\u000b\" // 'v' -> '\\u000b'\n  case 102: return \"\\f\" // 'f' -> '\\f'\n  case 13: if (this.input.charCodeAt(this.pos) === 10) { ++this.pos; } // '\\r\\n'\n  case 10: // ' \\n'\n    if (this.options.locations) { this.lineStart = this.pos; ++this.curLine; }\n    return \"\"\n  case 56:\n  case 57:\n    if (inTemplate) {\n      var codePos = this.pos - 1;\n\n      this.invalidStringToken(\n        codePos,\n        \"Invalid escape sequence in template string\"\n      );\n\n      return null\n    }\n  default:\n    if (ch >= 48 && ch <= 55) {\n      var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];\n      var octal = parseInt(octalStr, 8);\n      if (octal > 255) {\n        octalStr = octalStr.slice(0, -1);\n        octal = parseInt(octalStr, 8);\n      }\n      this.pos += octalStr.length - 1;\n      ch = this.input.charCodeAt(this.pos);\n      if ((octalStr !== \"0\" || ch === 56 || ch === 57) && (this.strict || inTemplate)) {\n        this.invalidStringToken(\n          this.pos - 1 - octalStr.length,\n          inTemplate\n            ? \"Octal literal in template string\"\n            : \"Octal literal in strict mode\"\n        );\n      }\n      return String.fromCharCode(octal)\n    }\n    if (isNewLine(ch)) {\n      // Unicode new line characters after \\ get removed from output in both\n      // template literals and strings\n      return \"\"\n    }\n    return String.fromCharCode(ch)\n  }\n};\n\n// Used to read character escape sequences ('\\x', '\\u', '\\U').\n\npp$9.readHexChar = function(len) {\n  var codePos = this.pos;\n  var n = this.readInt(16, len);\n  if (n === null) { this.invalidStringToken(codePos, \"Bad character escape sequence\"); }\n  return n\n};\n\n// Read an identifier, and return it as a string. Sets `this.containsEsc`\n// to whether the word contained a '\\u' escape.\n//\n// Incrementally adds only escaped chars, adding other chunks as-is\n// as a micro-optimization.\n\npp$9.readWord1 = function() {\n  this.containsEsc = false;\n  var word = \"\", first = true, chunkStart = this.pos;\n  var astral = this.options.ecmaVersion >= 6;\n  while (this.pos < this.input.length) {\n    var ch = this.fullCharCodeAtPos();\n    if (isIdentifierChar(ch, astral)) {\n      this.pos += ch <= 0xffff ? 1 : 2;\n    } else if (ch === 92) { // \"\\\"\n      this.containsEsc = true;\n      word += this.input.slice(chunkStart, this.pos);\n      var escStart = this.pos;\n      if (this.input.charCodeAt(++this.pos) !== 117) // \"u\"\n        { this.invalidStringToken(this.pos, \"Expecting Unicode escape sequence \\\\uXXXX\"); }\n      ++this.pos;\n      var esc = this.readCodePoint();\n      if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral))\n        { this.invalidStringToken(escStart, \"Invalid Unicode escape\"); }\n      word += codePointToString$1(esc);\n      chunkStart = this.pos;\n    } else {\n      break\n    }\n    first = false;\n  }\n  return word + this.input.slice(chunkStart, this.pos)\n};\n\n// Read an identifier or keyword token. Will check for reserved\n// words when necessary.\n\npp$9.readWord = function() {\n  var word = this.readWord1();\n  var type = types.name;\n  if (this.keywords.test(word)) {\n    type = keywords$1[word];\n  }\n  return this.finishToken(type, word)\n};\n\n// Acorn is a tiny, fast JavaScript parser written in JavaScript.\n\nvar version = \"7.4.1\";\n\nParser.acorn = {\n  Parser: Parser,\n  version: version,\n  defaultOptions: defaultOptions,\n  Position: Position,\n  SourceLocation: SourceLocation,\n  getLineInfo: getLineInfo,\n  Node: Node,\n  TokenType: TokenType,\n  tokTypes: types,\n  keywordTypes: keywords$1,\n  TokContext: TokContext,\n  tokContexts: types$1,\n  isIdentifierChar: isIdentifierChar,\n  isIdentifierStart: isIdentifierStart,\n  Token: Token,\n  isNewLine: isNewLine,\n  lineBreak: lineBreak,\n  lineBreakG: lineBreakG,\n  nonASCIIwhitespace: nonASCIIwhitespace\n};\n\n// The main exported interface (under `self.acorn` when in the\n// browser) is a `parse` function that takes a code string and\n// returns an abstract syntax tree as specified by [Mozilla parser\n// API][api].\n//\n// [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API\n\nfunction parse(input, options) {\n  return Parser.parse(input, options)\n}\n\n// This function tries to parse a single expression at a given\n// offset in a string. Useful for parsing mixed-language formats\n// that embed JavaScript expressions.\n\nfunction parseExpressionAt(input, pos, options) {\n  return Parser.parseExpressionAt(input, pos, options)\n}\n\n// Acorn is organized as a tokenizer and a recursive-descent parser.\n// The `tokenizer` export provides an interface to the tokenizer.\n\nfunction tokenizer(input, options) {\n  return Parser.tokenizer(input, options)\n}\n\n\n\n\n//# sourceURL=webpack://javascript/./node_modules/espree/node_modules/acorn/dist/acorn.mjs?");

/***/ }),

/***/ "./node_modules/ajv/lib/refs/data.json":
/*!*********************************************!*\
  !*** ./node_modules/ajv/lib/refs/data.json ***!
  \*********************************************/
/***/ ((module) => {

"use strict";
eval("module.exports = JSON.parse('{\"$schema\":\"http://json-schema.org/draft-07/schema#\",\"$id\":\"https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#\",\"description\":\"Meta-schema for $data reference (JSON Schema extension proposal)\",\"type\":\"object\",\"required\":[\"$data\"],\"properties\":{\"$data\":{\"type\":\"string\",\"anyOf\":[{\"format\":\"relative-json-pointer\"},{\"format\":\"json-pointer\"}]}},\"additionalProperties\":false}');\n\n//# sourceURL=webpack://javascript/./node_modules/ajv/lib/refs/data.json?");

/***/ }),

/***/ "./node_modules/ajv/lib/refs/json-schema-draft-04.json":
/*!*************************************************************!*\
  !*** ./node_modules/ajv/lib/refs/json-schema-draft-04.json ***!
  \*************************************************************/
/***/ ((module) => {

"use strict";
eval("module.exports = JSON.parse('{\"id\":\"http://json-schema.org/draft-04/schema#\",\"$schema\":\"http://json-schema.org/draft-04/schema#\",\"description\":\"Core schema meta-schema\",\"definitions\":{\"schemaArray\":{\"type\":\"array\",\"minItems\":1,\"items\":{\"$ref\":\"#\"}},\"positiveInteger\":{\"type\":\"integer\",\"minimum\":0},\"positiveIntegerDefault0\":{\"allOf\":[{\"$ref\":\"#/definitions/positiveInteger\"},{\"default\":0}]},\"simpleTypes\":{\"enum\":[\"array\",\"boolean\",\"integer\",\"null\",\"number\",\"object\",\"string\"]},\"stringArray\":{\"type\":\"array\",\"items\":{\"type\":\"string\"},\"minItems\":1,\"uniqueItems\":true}},\"type\":\"object\",\"properties\":{\"id\":{\"type\":\"string\"},\"$schema\":{\"type\":\"string\"},\"title\":{\"type\":\"string\"},\"description\":{\"type\":\"string\"},\"default\":{},\"multipleOf\":{\"type\":\"number\",\"minimum\":0,\"exclusiveMinimum\":true},\"maximum\":{\"type\":\"number\"},\"exclusiveMaximum\":{\"type\":\"boolean\",\"default\":false},\"minimum\":{\"type\":\"number\"},\"exclusiveMinimum\":{\"type\":\"boolean\",\"default\":false},\"maxLength\":{\"$ref\":\"#/definitions/positiveInteger\"},\"minLength\":{\"$ref\":\"#/definitions/positiveIntegerDefault0\"},\"pattern\":{\"type\":\"string\",\"format\":\"regex\"},\"additionalItems\":{\"anyOf\":[{\"type\":\"boolean\"},{\"$ref\":\"#\"}],\"default\":{}},\"items\":{\"anyOf\":[{\"$ref\":\"#\"},{\"$ref\":\"#/definitions/schemaArray\"}],\"default\":{}},\"maxItems\":{\"$ref\":\"#/definitions/positiveInteger\"},\"minItems\":{\"$ref\":\"#/definitions/positiveIntegerDefault0\"},\"uniqueItems\":{\"type\":\"boolean\",\"default\":false},\"maxProperties\":{\"$ref\":\"#/definitions/positiveInteger\"},\"minProperties\":{\"$ref\":\"#/definitions/positiveIntegerDefault0\"},\"required\":{\"$ref\":\"#/definitions/stringArray\"},\"additionalProperties\":{\"anyOf\":[{\"type\":\"boolean\"},{\"$ref\":\"#\"}],\"default\":{}},\"definitions\":{\"type\":\"object\",\"additionalProperties\":{\"$ref\":\"#\"},\"default\":{}},\"properties\":{\"type\":\"object\",\"additionalProperties\":{\"$ref\":\"#\"},\"default\":{}},\"patternProperties\":{\"type\":\"object\",\"additionalProperties\":{\"$ref\":\"#\"},\"default\":{}},\"dependencies\":{\"type\":\"object\",\"additionalProperties\":{\"anyOf\":[{\"$ref\":\"#\"},{\"$ref\":\"#/definitions/stringArray\"}]}},\"enum\":{\"type\":\"array\",\"minItems\":1,\"uniqueItems\":true},\"type\":{\"anyOf\":[{\"$ref\":\"#/definitions/simpleTypes\"},{\"type\":\"array\",\"items\":{\"$ref\":\"#/definitions/simpleTypes\"},\"minItems\":1,\"uniqueItems\":true}]},\"format\":{\"type\":\"string\"},\"allOf\":{\"$ref\":\"#/definitions/schemaArray\"},\"anyOf\":{\"$ref\":\"#/definitions/schemaArray\"},\"oneOf\":{\"$ref\":\"#/definitions/schemaArray\"},\"not\":{\"$ref\":\"#\"}},\"dependencies\":{\"exclusiveMaximum\":[\"maximum\"],\"exclusiveMinimum\":[\"minimum\"]},\"default\":{}}');\n\n//# sourceURL=webpack://javascript/./node_modules/ajv/lib/refs/json-schema-draft-04.json?");

/***/ }),

/***/ "./node_modules/ajv/lib/refs/json-schema-draft-07.json":
/*!*************************************************************!*\
  !*** ./node_modules/ajv/lib/refs/json-schema-draft-07.json ***!
  \*************************************************************/
/***/ ((module) => {

"use strict";
eval("module.exports = JSON.parse('{\"$schema\":\"http://json-schema.org/draft-07/schema#\",\"$id\":\"http://json-schema.org/draft-07/schema#\",\"title\":\"Core schema meta-schema\",\"definitions\":{\"schemaArray\":{\"type\":\"array\",\"minItems\":1,\"items\":{\"$ref\":\"#\"}},\"nonNegativeInteger\":{\"type\":\"integer\",\"minimum\":0},\"nonNegativeIntegerDefault0\":{\"allOf\":[{\"$ref\":\"#/definitions/nonNegativeInteger\"},{\"default\":0}]},\"simpleTypes\":{\"enum\":[\"array\",\"boolean\",\"integer\",\"null\",\"number\",\"object\",\"string\"]},\"stringArray\":{\"type\":\"array\",\"items\":{\"type\":\"string\"},\"uniqueItems\":true,\"default\":[]}},\"type\":[\"object\",\"boolean\"],\"properties\":{\"$id\":{\"type\":\"string\",\"format\":\"uri-reference\"},\"$schema\":{\"type\":\"string\",\"format\":\"uri\"},\"$ref\":{\"type\":\"string\",\"format\":\"uri-reference\"},\"$comment\":{\"type\":\"string\"},\"title\":{\"type\":\"string\"},\"description\":{\"type\":\"string\"},\"default\":true,\"readOnly\":{\"type\":\"boolean\",\"default\":false},\"examples\":{\"type\":\"array\",\"items\":true},\"multipleOf\":{\"type\":\"number\",\"exclusiveMinimum\":0},\"maximum\":{\"type\":\"number\"},\"exclusiveMaximum\":{\"type\":\"number\"},\"minimum\":{\"type\":\"number\"},\"exclusiveMinimum\":{\"type\":\"number\"},\"maxLength\":{\"$ref\":\"#/definitions/nonNegativeInteger\"},\"minLength\":{\"$ref\":\"#/definitions/nonNegativeIntegerDefault0\"},\"pattern\":{\"type\":\"string\",\"format\":\"regex\"},\"additionalItems\":{\"$ref\":\"#\"},\"items\":{\"anyOf\":[{\"$ref\":\"#\"},{\"$ref\":\"#/definitions/schemaArray\"}],\"default\":true},\"maxItems\":{\"$ref\":\"#/definitions/nonNegativeInteger\"},\"minItems\":{\"$ref\":\"#/definitions/nonNegativeIntegerDefault0\"},\"uniqueItems\":{\"type\":\"boolean\",\"default\":false},\"contains\":{\"$ref\":\"#\"},\"maxProperties\":{\"$ref\":\"#/definitions/nonNegativeInteger\"},\"minProperties\":{\"$ref\":\"#/definitions/nonNegativeIntegerDefault0\"},\"required\":{\"$ref\":\"#/definitions/stringArray\"},\"additionalProperties\":{\"$ref\":\"#\"},\"definitions\":{\"type\":\"object\",\"additionalProperties\":{\"$ref\":\"#\"},\"default\":{}},\"properties\":{\"type\":\"object\",\"additionalProperties\":{\"$ref\":\"#\"},\"default\":{}},\"patternProperties\":{\"type\":\"object\",\"additionalProperties\":{\"$ref\":\"#\"},\"propertyNames\":{\"format\":\"regex\"},\"default\":{}},\"dependencies\":{\"type\":\"object\",\"additionalProperties\":{\"anyOf\":[{\"$ref\":\"#\"},{\"$ref\":\"#/definitions/stringArray\"}]}},\"propertyNames\":{\"$ref\":\"#\"},\"const\":true,\"enum\":{\"type\":\"array\",\"items\":true,\"minItems\":1,\"uniqueItems\":true},\"type\":{\"anyOf\":[{\"$ref\":\"#/definitions/simpleTypes\"},{\"type\":\"array\",\"items\":{\"$ref\":\"#/definitions/simpleTypes\"},\"minItems\":1,\"uniqueItems\":true}]},\"format\":{\"type\":\"string\"},\"contentMediaType\":{\"type\":\"string\"},\"contentEncoding\":{\"type\":\"string\"},\"if\":{\"$ref\":\"#\"},\"then\":{\"$ref\":\"#\"},\"else\":{\"$ref\":\"#\"},\"allOf\":{\"$ref\":\"#/definitions/schemaArray\"},\"anyOf\":{\"$ref\":\"#/definitions/schemaArray\"},\"oneOf\":{\"$ref\":\"#/definitions/schemaArray\"},\"not\":{\"$ref\":\"#\"}},\"default\":true}');\n\n//# sourceURL=webpack://javascript/./node_modules/ajv/lib/refs/json-schema-draft-07.json?");

/***/ }),

/***/ "./node_modules/doctrine/package.json":
/*!********************************************!*\
  !*** ./node_modules/doctrine/package.json ***!
  \********************************************/
/***/ ((module) => {

"use strict";
eval("module.exports = JSON.parse('{\"name\":\"doctrine\",\"description\":\"JSDoc parser\",\"homepage\":\"https://github.com/eslint/doctrine\",\"main\":\"lib/doctrine.js\",\"version\":\"3.0.0\",\"engines\":{\"node\":\">=6.0.0\"},\"directories\":{\"lib\":\"./lib\"},\"files\":[\"lib\"],\"maintainers\":[{\"name\":\"Nicholas C. Zakas\",\"email\":\"nicholas+npm@nczconsulting.com\",\"web\":\"https://www.nczonline.net\"},{\"name\":\"Yusuke Suzuki\",\"email\":\"utatane.tea@gmail.com\",\"web\":\"https://github.com/Constellation\"}],\"repository\":\"eslint/doctrine\",\"devDependencies\":{\"coveralls\":\"^3.0.1\",\"dateformat\":\"^1.0.11\",\"eslint\":\"^1.10.3\",\"eslint-release\":\"^1.0.0\",\"linefix\":\"^0.1.1\",\"mocha\":\"^3.4.2\",\"npm-license\":\"^0.3.1\",\"nyc\":\"^10.3.2\",\"semver\":\"^5.0.3\",\"shelljs\":\"^0.5.3\",\"shelljs-nodecli\":\"^0.1.1\",\"should\":\"^5.0.1\"},\"license\":\"Apache-2.0\",\"scripts\":{\"pretest\":\"npm run lint\",\"test\":\"nyc mocha\",\"coveralls\":\"nyc report --reporter=text-lcov | coveralls\",\"lint\":\"eslint lib/\",\"generate-release\":\"eslint-generate-release\",\"generate-alpharelease\":\"eslint-generate-prerelease alpha\",\"generate-betarelease\":\"eslint-generate-prerelease beta\",\"generate-rcrelease\":\"eslint-generate-prerelease rc\",\"publish-release\":\"eslint-publish-release\"},\"dependencies\":{\"esutils\":\"^2.0.2\"}}');\n\n//# sourceURL=webpack://javascript/./node_modules/doctrine/package.json?");

/***/ }),

/***/ "./node_modules/eslint-scope/node_modules/estraverse/package.json":
/*!************************************************************************!*\
  !*** ./node_modules/eslint-scope/node_modules/estraverse/package.json ***!
  \************************************************************************/
/***/ ((module) => {

"use strict";
eval("module.exports = JSON.parse('{\"name\":\"estraverse\",\"description\":\"ECMAScript JS AST traversal functions\",\"homepage\":\"https://github.com/estools/estraverse\",\"main\":\"estraverse.js\",\"version\":\"4.3.0\",\"engines\":{\"node\":\">=4.0\"},\"maintainers\":[{\"name\":\"Yusuke Suzuki\",\"email\":\"utatane.tea@gmail.com\",\"web\":\"http://github.com/Constellation\"}],\"repository\":{\"type\":\"git\",\"url\":\"http://github.com/estools/estraverse.git\"},\"devDependencies\":{\"babel-preset-env\":\"^1.6.1\",\"babel-register\":\"^6.3.13\",\"chai\":\"^2.1.1\",\"espree\":\"^1.11.0\",\"gulp\":\"^3.8.10\",\"gulp-bump\":\"^0.2.2\",\"gulp-filter\":\"^2.0.0\",\"gulp-git\":\"^1.0.1\",\"gulp-tag-version\":\"^1.3.0\",\"jshint\":\"^2.5.6\",\"mocha\":\"^2.1.0\"},\"license\":\"BSD-2-Clause\",\"scripts\":{\"test\":\"npm run-script lint && npm run-script unit-test\",\"lint\":\"jshint estraverse.js\",\"unit-test\":\"mocha --compilers js:babel-register\"}}');\n\n//# sourceURL=webpack://javascript/./node_modules/eslint-scope/node_modules/estraverse/package.json?");

/***/ }),

/***/ "./node_modules/eslint-scope/package.json":
/*!************************************************!*\
  !*** ./node_modules/eslint-scope/package.json ***!
  \************************************************/
/***/ ((module) => {

"use strict";
eval("module.exports = JSON.parse('{\"name\":\"eslint-scope\",\"description\":\"ECMAScript scope analyzer for ESLint\",\"homepage\":\"http://github.com/eslint/eslint-scope\",\"main\":\"lib/index.js\",\"version\":\"5.1.1\",\"engines\":{\"node\":\">=8.0.0\"},\"repository\":\"eslint/eslint-scope\",\"bugs\":{\"url\":\"https://github.com/eslint/eslint-scope/issues\"},\"license\":\"BSD-2-Clause\",\"scripts\":{\"test\":\"node Makefile.js test\",\"lint\":\"node Makefile.js lint\",\"generate-release\":\"eslint-generate-release\",\"generate-alpharelease\":\"eslint-generate-prerelease alpha\",\"generate-betarelease\":\"eslint-generate-prerelease beta\",\"generate-rcrelease\":\"eslint-generate-prerelease rc\",\"publish-release\":\"eslint-publish-release\"},\"files\":[\"LICENSE\",\"README.md\",\"lib\"],\"dependencies\":{\"esrecurse\":\"^4.3.0\",\"estraverse\":\"^4.1.1\"},\"devDependencies\":{\"@typescript-eslint/parser\":\"^1.11.0\",\"chai\":\"^4.2.0\",\"eslint\":\"^6.0.1\",\"eslint-config-eslint\":\"^5.0.1\",\"eslint-plugin-node\":\"^9.1.0\",\"eslint-release\":\"^1.0.0\",\"eslint-visitor-keys\":\"^1.2.0\",\"espree\":\"^7.1.0\",\"istanbul\":\"^0.4.5\",\"mocha\":\"^6.1.4\",\"npm-license\":\"^0.3.3\",\"shelljs\":\"^0.8.3\",\"typescript\":\"^3.5.2\"}}');\n\n//# sourceURL=webpack://javascript/./node_modules/eslint-scope/package.json?");

/***/ }),

/***/ "./node_modules/eslint-visitor-keys/lib/visitor-keys.json":
/*!****************************************************************!*\
  !*** ./node_modules/eslint-visitor-keys/lib/visitor-keys.json ***!
  \****************************************************************/
/***/ ((module) => {

"use strict";
eval("module.exports = JSON.parse('{\"AssignmentExpression\":[\"left\",\"right\"],\"AssignmentPattern\":[\"left\",\"right\"],\"ArrayExpression\":[\"elements\"],\"ArrayPattern\":[\"elements\"],\"ArrowFunctionExpression\":[\"params\",\"body\"],\"AwaitExpression\":[\"argument\"],\"BlockStatement\":[\"body\"],\"BinaryExpression\":[\"left\",\"right\"],\"BreakStatement\":[\"label\"],\"CallExpression\":[\"callee\",\"arguments\"],\"CatchClause\":[\"param\",\"body\"],\"ChainExpression\":[\"expression\"],\"ClassBody\":[\"body\"],\"ClassDeclaration\":[\"id\",\"superClass\",\"body\"],\"ClassExpression\":[\"id\",\"superClass\",\"body\"],\"ConditionalExpression\":[\"test\",\"consequent\",\"alternate\"],\"ContinueStatement\":[\"label\"],\"DebuggerStatement\":[],\"DoWhileStatement\":[\"body\",\"test\"],\"EmptyStatement\":[],\"ExportAllDeclaration\":[\"exported\",\"source\"],\"ExportDefaultDeclaration\":[\"declaration\"],\"ExportNamedDeclaration\":[\"declaration\",\"specifiers\",\"source\"],\"ExportSpecifier\":[\"exported\",\"local\"],\"ExpressionStatement\":[\"expression\"],\"ExperimentalRestProperty\":[\"argument\"],\"ExperimentalSpreadProperty\":[\"argument\"],\"ForStatement\":[\"init\",\"test\",\"update\",\"body\"],\"ForInStatement\":[\"left\",\"right\",\"body\"],\"ForOfStatement\":[\"left\",\"right\",\"body\"],\"FunctionDeclaration\":[\"id\",\"params\",\"body\"],\"FunctionExpression\":[\"id\",\"params\",\"body\"],\"Identifier\":[],\"IfStatement\":[\"test\",\"consequent\",\"alternate\"],\"ImportDeclaration\":[\"specifiers\",\"source\"],\"ImportDefaultSpecifier\":[\"local\"],\"ImportExpression\":[\"source\"],\"ImportNamespaceSpecifier\":[\"local\"],\"ImportSpecifier\":[\"imported\",\"local\"],\"JSXAttribute\":[\"name\",\"value\"],\"JSXClosingElement\":[\"name\"],\"JSXElement\":[\"openingElement\",\"children\",\"closingElement\"],\"JSXEmptyExpression\":[],\"JSXExpressionContainer\":[\"expression\"],\"JSXIdentifier\":[],\"JSXMemberExpression\":[\"object\",\"property\"],\"JSXNamespacedName\":[\"namespace\",\"name\"],\"JSXOpeningElement\":[\"name\",\"attributes\"],\"JSXSpreadAttribute\":[\"argument\"],\"JSXText\":[],\"JSXFragment\":[\"openingFragment\",\"children\",\"closingFragment\"],\"Literal\":[],\"LabeledStatement\":[\"label\",\"body\"],\"LogicalExpression\":[\"left\",\"right\"],\"MemberExpression\":[\"object\",\"property\"],\"MetaProperty\":[\"meta\",\"property\"],\"MethodDefinition\":[\"key\",\"value\"],\"NewExpression\":[\"callee\",\"arguments\"],\"ObjectExpression\":[\"properties\"],\"ObjectPattern\":[\"properties\"],\"Program\":[\"body\"],\"Property\":[\"key\",\"value\"],\"RestElement\":[\"argument\"],\"ReturnStatement\":[\"argument\"],\"SequenceExpression\":[\"expressions\"],\"SpreadElement\":[\"argument\"],\"Super\":[],\"SwitchStatement\":[\"discriminant\",\"cases\"],\"SwitchCase\":[\"test\",\"consequent\"],\"TaggedTemplateExpression\":[\"tag\",\"quasi\"],\"TemplateElement\":[],\"TemplateLiteral\":[\"quasis\",\"expressions\"],\"ThisExpression\":[],\"ThrowStatement\":[\"argument\"],\"TryStatement\":[\"block\",\"handler\",\"finalizer\"],\"UnaryExpression\":[\"argument\"],\"UpdateExpression\":[\"argument\"],\"VariableDeclaration\":[\"declarations\"],\"VariableDeclarator\":[\"id\",\"init\"],\"WhileStatement\":[\"test\",\"body\"],\"WithStatement\":[\"object\",\"body\"],\"YieldExpression\":[\"argument\"]}');\n\n//# sourceURL=webpack://javascript/./node_modules/eslint-visitor-keys/lib/visitor-keys.json?");

/***/ }),

/***/ "./node_modules/eslint4b/node_modules/eslint-visitor-keys/lib/visitor-keys.json":
/*!**************************************************************************************!*\
  !*** ./node_modules/eslint4b/node_modules/eslint-visitor-keys/lib/visitor-keys.json ***!
  \**************************************************************************************/
/***/ ((module) => {

"use strict";
eval("module.exports = JSON.parse('{\"AssignmentExpression\":[\"left\",\"right\"],\"AssignmentPattern\":[\"left\",\"right\"],\"ArrayExpression\":[\"elements\"],\"ArrayPattern\":[\"elements\"],\"ArrowFunctionExpression\":[\"params\",\"body\"],\"AwaitExpression\":[\"argument\"],\"BlockStatement\":[\"body\"],\"BinaryExpression\":[\"left\",\"right\"],\"BreakStatement\":[\"label\"],\"CallExpression\":[\"callee\",\"arguments\"],\"CatchClause\":[\"param\",\"body\"],\"ChainExpression\":[\"expression\"],\"ClassBody\":[\"body\"],\"ClassDeclaration\":[\"id\",\"superClass\",\"body\"],\"ClassExpression\":[\"id\",\"superClass\",\"body\"],\"ConditionalExpression\":[\"test\",\"consequent\",\"alternate\"],\"ContinueStatement\":[\"label\"],\"DebuggerStatement\":[],\"DoWhileStatement\":[\"body\",\"test\"],\"EmptyStatement\":[],\"ExportAllDeclaration\":[\"exported\",\"source\"],\"ExportDefaultDeclaration\":[\"declaration\"],\"ExportNamedDeclaration\":[\"declaration\",\"specifiers\",\"source\"],\"ExportSpecifier\":[\"exported\",\"local\"],\"ExpressionStatement\":[\"expression\"],\"ExperimentalRestProperty\":[\"argument\"],\"ExperimentalSpreadProperty\":[\"argument\"],\"ForStatement\":[\"init\",\"test\",\"update\",\"body\"],\"ForInStatement\":[\"left\",\"right\",\"body\"],\"ForOfStatement\":[\"left\",\"right\",\"body\"],\"FunctionDeclaration\":[\"id\",\"params\",\"body\"],\"FunctionExpression\":[\"id\",\"params\",\"body\"],\"Identifier\":[],\"IfStatement\":[\"test\",\"consequent\",\"alternate\"],\"ImportDeclaration\":[\"specifiers\",\"source\"],\"ImportDefaultSpecifier\":[\"local\"],\"ImportExpression\":[\"source\"],\"ImportNamespaceSpecifier\":[\"local\"],\"ImportSpecifier\":[\"imported\",\"local\"],\"JSXAttribute\":[\"name\",\"value\"],\"JSXClosingElement\":[\"name\"],\"JSXElement\":[\"openingElement\",\"children\",\"closingElement\"],\"JSXEmptyExpression\":[],\"JSXExpressionContainer\":[\"expression\"],\"JSXIdentifier\":[],\"JSXMemberExpression\":[\"object\",\"property\"],\"JSXNamespacedName\":[\"namespace\",\"name\"],\"JSXOpeningElement\":[\"name\",\"attributes\"],\"JSXSpreadAttribute\":[\"argument\"],\"JSXText\":[],\"JSXFragment\":[\"openingFragment\",\"children\",\"closingFragment\"],\"Literal\":[],\"LabeledStatement\":[\"label\",\"body\"],\"LogicalExpression\":[\"left\",\"right\"],\"MemberExpression\":[\"object\",\"property\"],\"MetaProperty\":[\"meta\",\"property\"],\"MethodDefinition\":[\"key\",\"value\"],\"NewExpression\":[\"callee\",\"arguments\"],\"ObjectExpression\":[\"properties\"],\"ObjectPattern\":[\"properties\"],\"PrivateIdentifier\":[],\"Program\":[\"body\"],\"Property\":[\"key\",\"value\"],\"PropertyDefinition\":[\"key\",\"value\"],\"RestElement\":[\"argument\"],\"ReturnStatement\":[\"argument\"],\"SequenceExpression\":[\"expressions\"],\"SpreadElement\":[\"argument\"],\"Super\":[],\"SwitchStatement\":[\"discriminant\",\"cases\"],\"SwitchCase\":[\"test\",\"consequent\"],\"TaggedTemplateExpression\":[\"tag\",\"quasi\"],\"TemplateElement\":[],\"TemplateLiteral\":[\"quasis\",\"expressions\"],\"ThisExpression\":[],\"ThrowStatement\":[\"argument\"],\"TryStatement\":[\"block\",\"handler\",\"finalizer\"],\"UnaryExpression\":[\"argument\"],\"UpdateExpression\":[\"argument\"],\"VariableDeclaration\":[\"declarations\"],\"VariableDeclarator\":[\"id\",\"init\"],\"WhileStatement\":[\"test\",\"body\"],\"WithStatement\":[\"object\",\"body\"],\"YieldExpression\":[\"argument\"]}');\n\n//# sourceURL=webpack://javascript/./node_modules/eslint4b/node_modules/eslint-visitor-keys/lib/visitor-keys.json?");

/***/ }),

/***/ "./node_modules/espree/package.json":
/*!******************************************!*\
  !*** ./node_modules/espree/package.json ***!
  \******************************************/
/***/ ((module) => {

"use strict";
eval("module.exports = JSON.parse('{\"name\":\"espree\",\"description\":\"An Esprima-compatible JavaScript parser built on Acorn\",\"author\":\"Nicholas C. Zakas <nicholas+npm@nczconsulting.com>\",\"homepage\":\"https://github.com/eslint/espree\",\"main\":\"espree.js\",\"version\":\"7.3.1\",\"files\":[\"lib\",\"espree.js\"],\"engines\":{\"node\":\"^10.12.0 || >=12.0.0\"},\"repository\":\"eslint/espree\",\"bugs\":{\"url\":\"http://github.com/eslint/espree.git\"},\"license\":\"BSD-2-Clause\",\"dependencies\":{\"acorn\":\"^7.4.0\",\"acorn-jsx\":\"^5.3.1\",\"eslint-visitor-keys\":\"^1.3.0\"},\"devDependencies\":{\"browserify\":\"^16.5.0\",\"chai\":\"^4.2.0\",\"eslint\":\"^6.0.1\",\"eslint-config-eslint\":\"^5.0.1\",\"eslint-plugin-node\":\"^9.1.0\",\"eslint-release\":\"^1.0.0\",\"esprima\":\"latest\",\"esprima-fb\":\"^8001.2001.0-dev-harmony-fb\",\"json-diff\":\"^0.5.4\",\"leche\":\"^2.3.0\",\"mocha\":\"^6.2.0\",\"nyc\":\"^14.1.1\",\"regenerate\":\"^1.4.0\",\"shelljs\":\"^0.3.0\",\"shelljs-nodecli\":\"^0.1.1\",\"unicode-6.3.0\":\"^0.7.5\"},\"keywords\":[\"ast\",\"ecmascript\",\"javascript\",\"parser\",\"syntax\",\"acorn\"],\"scripts\":{\"generate-regex\":\"node tools/generate-identifier-regex.js\",\"test\":\"npm run-script lint && node Makefile.js test\",\"lint\":\"node Makefile.js lint\",\"fixlint\":\"node Makefile.js lint --fix\",\"sync-docs\":\"node Makefile.js docs\",\"browserify\":\"node Makefile.js browserify\",\"generate-release\":\"eslint-generate-release\",\"generate-alpharelease\":\"eslint-generate-prerelease alpha\",\"generate-betarelease\":\"eslint-generate-prerelease beta\",\"generate-rcrelease\":\"eslint-generate-prerelease rc\",\"publish-release\":\"eslint-publish-release\"}}');\n\n//# sourceURL=webpack://javascript/./node_modules/espree/package.json?");

/***/ }),

/***/ "./node_modules/esrecurse/package.json":
/*!*********************************************!*\
  !*** ./node_modules/esrecurse/package.json ***!
  \*********************************************/
/***/ ((module) => {

"use strict";
eval("module.exports = JSON.parse('{\"name\":\"esrecurse\",\"description\":\"ECMAScript AST recursive visitor\",\"homepage\":\"https://github.com/estools/esrecurse\",\"main\":\"esrecurse.js\",\"version\":\"4.3.0\",\"engines\":{\"node\":\">=4.0\"},\"maintainers\":[{\"name\":\"Yusuke Suzuki\",\"email\":\"utatane.tea@gmail.com\",\"web\":\"https://github.com/Constellation\"}],\"repository\":{\"type\":\"git\",\"url\":\"https://github.com/estools/esrecurse.git\"},\"dependencies\":{\"estraverse\":\"^5.2.0\"},\"devDependencies\":{\"babel-cli\":\"^6.24.1\",\"babel-eslint\":\"^7.2.3\",\"babel-preset-es2015\":\"^6.24.1\",\"babel-register\":\"^6.24.1\",\"chai\":\"^4.0.2\",\"esprima\":\"^4.0.0\",\"gulp\":\"^3.9.0\",\"gulp-bump\":\"^2.7.0\",\"gulp-eslint\":\"^4.0.0\",\"gulp-filter\":\"^5.0.0\",\"gulp-git\":\"^2.4.1\",\"gulp-mocha\":\"^4.3.1\",\"gulp-tag-version\":\"^1.2.1\",\"jsdoc\":\"^3.3.0-alpha10\",\"minimist\":\"^1.1.0\"},\"license\":\"BSD-2-Clause\",\"scripts\":{\"test\":\"gulp travis\",\"unit-test\":\"gulp test\",\"lint\":\"gulp lint\"},\"babel\":{\"presets\":[\"es2015\"]}}');\n\n//# sourceURL=webpack://javascript/./node_modules/esrecurse/package.json?");

/***/ }),

/***/ "./node_modules/globals/globals.json":
/*!*******************************************!*\
  !*** ./node_modules/globals/globals.json ***!
  \*******************************************/
/***/ ((module) => {

"use strict";
eval("module.exports = JSON.parse('{\"builtin\":{\"AggregateError\":false,\"Array\":false,\"ArrayBuffer\":false,\"Atomics\":false,\"BigInt\":false,\"BigInt64Array\":false,\"BigUint64Array\":false,\"Boolean\":false,\"constructor\":false,\"DataView\":false,\"Date\":false,\"decodeURI\":false,\"decodeURIComponent\":false,\"encodeURI\":false,\"encodeURIComponent\":false,\"Error\":false,\"escape\":false,\"eval\":false,\"EvalError\":false,\"FinalizationRegistry\":false,\"Float32Array\":false,\"Float64Array\":false,\"Function\":false,\"globalThis\":false,\"hasOwnProperty\":false,\"Infinity\":false,\"Int16Array\":false,\"Int32Array\":false,\"Int8Array\":false,\"isFinite\":false,\"isNaN\":false,\"isPrototypeOf\":false,\"JSON\":false,\"Map\":false,\"Math\":false,\"NaN\":false,\"Number\":false,\"Object\":false,\"parseFloat\":false,\"parseInt\":false,\"Promise\":false,\"propertyIsEnumerable\":false,\"Proxy\":false,\"RangeError\":false,\"ReferenceError\":false,\"Reflect\":false,\"RegExp\":false,\"Set\":false,\"SharedArrayBuffer\":false,\"String\":false,\"Symbol\":false,\"SyntaxError\":false,\"toLocaleString\":false,\"toString\":false,\"TypeError\":false,\"Uint16Array\":false,\"Uint32Array\":false,\"Uint8Array\":false,\"Uint8ClampedArray\":false,\"undefined\":false,\"unescape\":false,\"URIError\":false,\"valueOf\":false,\"WeakMap\":false,\"WeakRef\":false,\"WeakSet\":false},\"es5\":{\"Array\":false,\"Boolean\":false,\"constructor\":false,\"Date\":false,\"decodeURI\":false,\"decodeURIComponent\":false,\"encodeURI\":false,\"encodeURIComponent\":false,\"Error\":false,\"escape\":false,\"eval\":false,\"EvalError\":false,\"Function\":false,\"hasOwnProperty\":false,\"Infinity\":false,\"isFinite\":false,\"isNaN\":false,\"isPrototypeOf\":false,\"JSON\":false,\"Math\":false,\"NaN\":false,\"Number\":false,\"Object\":false,\"parseFloat\":false,\"parseInt\":false,\"propertyIsEnumerable\":false,\"RangeError\":false,\"ReferenceError\":false,\"RegExp\":false,\"String\":false,\"SyntaxError\":false,\"toLocaleString\":false,\"toString\":false,\"TypeError\":false,\"undefined\":false,\"unescape\":false,\"URIError\":false,\"valueOf\":false},\"es2015\":{\"Array\":false,\"ArrayBuffer\":false,\"Boolean\":false,\"constructor\":false,\"DataView\":false,\"Date\":false,\"decodeURI\":false,\"decodeURIComponent\":false,\"encodeURI\":false,\"encodeURIComponent\":false,\"Error\":false,\"escape\":false,\"eval\":false,\"EvalError\":false,\"Float32Array\":false,\"Float64Array\":false,\"Function\":false,\"hasOwnProperty\":false,\"Infinity\":false,\"Int16Array\":false,\"Int32Array\":false,\"Int8Array\":false,\"isFinite\":false,\"isNaN\":false,\"isPrototypeOf\":false,\"JSON\":false,\"Map\":false,\"Math\":false,\"NaN\":false,\"Number\":false,\"Object\":false,\"parseFloat\":false,\"parseInt\":false,\"Promise\":false,\"propertyIsEnumerable\":false,\"Proxy\":false,\"RangeError\":false,\"ReferenceError\":false,\"Reflect\":false,\"RegExp\":false,\"Set\":false,\"String\":false,\"Symbol\":false,\"SyntaxError\":false,\"toLocaleString\":false,\"toString\":false,\"TypeError\":false,\"Uint16Array\":false,\"Uint32Array\":false,\"Uint8Array\":false,\"Uint8ClampedArray\":false,\"undefined\":false,\"unescape\":false,\"URIError\":false,\"valueOf\":false,\"WeakMap\":false,\"WeakSet\":false},\"es2017\":{\"Array\":false,\"ArrayBuffer\":false,\"Atomics\":false,\"Boolean\":false,\"constructor\":false,\"DataView\":false,\"Date\":false,\"decodeURI\":false,\"decodeURIComponent\":false,\"encodeURI\":false,\"encodeURIComponent\":false,\"Error\":false,\"escape\":false,\"eval\":false,\"EvalError\":false,\"Float32Array\":false,\"Float64Array\":false,\"Function\":false,\"hasOwnProperty\":false,\"Infinity\":false,\"Int16Array\":false,\"Int32Array\":false,\"Int8Array\":false,\"isFinite\":false,\"isNaN\":false,\"isPrototypeOf\":false,\"JSON\":false,\"Map\":false,\"Math\":false,\"NaN\":false,\"Number\":false,\"Object\":false,\"parseFloat\":false,\"parseInt\":false,\"Promise\":false,\"propertyIsEnumerable\":false,\"Proxy\":false,\"RangeError\":false,\"ReferenceError\":false,\"Reflect\":false,\"RegExp\":false,\"Set\":false,\"SharedArrayBuffer\":false,\"String\":false,\"Symbol\":false,\"SyntaxError\":false,\"toLocaleString\":false,\"toString\":false,\"TypeError\":false,\"Uint16Array\":false,\"Uint32Array\":false,\"Uint8Array\":false,\"Uint8ClampedArray\":false,\"undefined\":false,\"unescape\":false,\"URIError\":false,\"valueOf\":false,\"WeakMap\":false,\"WeakSet\":false},\"es2020\":{\"Array\":false,\"ArrayBuffer\":false,\"Atomics\":false,\"BigInt\":false,\"BigInt64Array\":false,\"BigUint64Array\":false,\"Boolean\":false,\"constructor\":false,\"DataView\":false,\"Date\":false,\"decodeURI\":false,\"decodeURIComponent\":false,\"encodeURI\":false,\"encodeURIComponent\":false,\"Error\":false,\"escape\":false,\"eval\":false,\"EvalError\":false,\"Float32Array\":false,\"Float64Array\":false,\"Function\":false,\"globalThis\":false,\"hasOwnProperty\":false,\"Infinity\":false,\"Int16Array\":false,\"Int32Array\":false,\"Int8Array\":false,\"isFinite\":false,\"isNaN\":false,\"isPrototypeOf\":false,\"JSON\":false,\"Map\":false,\"Math\":false,\"NaN\":false,\"Number\":false,\"Object\":false,\"parseFloat\":false,\"parseInt\":false,\"Promise\":false,\"propertyIsEnumerable\":false,\"Proxy\":false,\"RangeError\":false,\"ReferenceError\":false,\"Reflect\":false,\"RegExp\":false,\"Set\":false,\"SharedArrayBuffer\":false,\"String\":false,\"Symbol\":false,\"SyntaxError\":false,\"toLocaleString\":false,\"toString\":false,\"TypeError\":false,\"Uint16Array\":false,\"Uint32Array\":false,\"Uint8Array\":false,\"Uint8ClampedArray\":false,\"undefined\":false,\"unescape\":false,\"URIError\":false,\"valueOf\":false,\"WeakMap\":false,\"WeakSet\":false},\"es2021\":{\"AggregateError\":false,\"Array\":false,\"ArrayBuffer\":false,\"Atomics\":false,\"BigInt\":false,\"BigInt64Array\":false,\"BigUint64Array\":false,\"Boolean\":false,\"constructor\":false,\"DataView\":false,\"Date\":false,\"decodeURI\":false,\"decodeURIComponent\":false,\"encodeURI\":false,\"encodeURIComponent\":false,\"Error\":false,\"escape\":false,\"eval\":false,\"EvalError\":false,\"FinalizationRegistry\":false,\"Float32Array\":false,\"Float64Array\":false,\"Function\":false,\"globalThis\":false,\"hasOwnProperty\":false,\"Infinity\":false,\"Int16Array\":false,\"Int32Array\":false,\"Int8Array\":false,\"isFinite\":false,\"isNaN\":false,\"isPrototypeOf\":false,\"JSON\":false,\"Map\":false,\"Math\":false,\"NaN\":false,\"Number\":false,\"Object\":false,\"parseFloat\":false,\"parseInt\":false,\"Promise\":false,\"propertyIsEnumerable\":false,\"Proxy\":false,\"RangeError\":false,\"ReferenceError\":false,\"Reflect\":false,\"RegExp\":false,\"Set\":false,\"SharedArrayBuffer\":false,\"String\":false,\"Symbol\":false,\"SyntaxError\":false,\"toLocaleString\":false,\"toString\":false,\"TypeError\":false,\"Uint16Array\":false,\"Uint32Array\":false,\"Uint8Array\":false,\"Uint8ClampedArray\":false,\"undefined\":false,\"unescape\":false,\"URIError\":false,\"valueOf\":false,\"WeakMap\":false,\"WeakRef\":false,\"WeakSet\":false},\"browser\":{\"AbortController\":false,\"AbortSignal\":false,\"addEventListener\":false,\"alert\":false,\"AnalyserNode\":false,\"Animation\":false,\"AnimationEffectReadOnly\":false,\"AnimationEffectTiming\":false,\"AnimationEffectTimingReadOnly\":false,\"AnimationEvent\":false,\"AnimationPlaybackEvent\":false,\"AnimationTimeline\":false,\"applicationCache\":false,\"ApplicationCache\":false,\"ApplicationCacheErrorEvent\":false,\"atob\":false,\"Attr\":false,\"Audio\":false,\"AudioBuffer\":false,\"AudioBufferSourceNode\":false,\"AudioContext\":false,\"AudioDestinationNode\":false,\"AudioListener\":false,\"AudioNode\":false,\"AudioParam\":false,\"AudioProcessingEvent\":false,\"AudioScheduledSourceNode\":false,\"AudioWorkletGlobalScope\":false,\"AudioWorkletNode\":false,\"AudioWorkletProcessor\":false,\"BarProp\":false,\"BaseAudioContext\":false,\"BatteryManager\":false,\"BeforeUnloadEvent\":false,\"BiquadFilterNode\":false,\"Blob\":false,\"BlobEvent\":false,\"blur\":false,\"BroadcastChannel\":false,\"btoa\":false,\"BudgetService\":false,\"ByteLengthQueuingStrategy\":false,\"Cache\":false,\"caches\":false,\"CacheStorage\":false,\"cancelAnimationFrame\":false,\"cancelIdleCallback\":false,\"CanvasCaptureMediaStreamTrack\":false,\"CanvasGradient\":false,\"CanvasPattern\":false,\"CanvasRenderingContext2D\":false,\"ChannelMergerNode\":false,\"ChannelSplitterNode\":false,\"CharacterData\":false,\"clearInterval\":false,\"clearTimeout\":false,\"clientInformation\":false,\"ClipboardEvent\":false,\"close\":false,\"closed\":false,\"CloseEvent\":false,\"Comment\":false,\"CompositionEvent\":false,\"confirm\":false,\"console\":false,\"ConstantSourceNode\":false,\"ConvolverNode\":false,\"CountQueuingStrategy\":false,\"createImageBitmap\":false,\"Credential\":false,\"CredentialsContainer\":false,\"crypto\":false,\"Crypto\":false,\"CryptoKey\":false,\"CSS\":false,\"CSSConditionRule\":false,\"CSSFontFaceRule\":false,\"CSSGroupingRule\":false,\"CSSImportRule\":false,\"CSSKeyframeRule\":false,\"CSSKeyframesRule\":false,\"CSSMatrixComponent\":false,\"CSSMediaRule\":false,\"CSSNamespaceRule\":false,\"CSSPageRule\":false,\"CSSPerspective\":false,\"CSSRotate\":false,\"CSSRule\":false,\"CSSRuleList\":false,\"CSSScale\":false,\"CSSSkew\":false,\"CSSSkewX\":false,\"CSSSkewY\":false,\"CSSStyleDeclaration\":false,\"CSSStyleRule\":false,\"CSSStyleSheet\":false,\"CSSSupportsRule\":false,\"CSSTransformValue\":false,\"CSSTranslate\":false,\"CustomElementRegistry\":false,\"customElements\":false,\"CustomEvent\":false,\"DataTransfer\":false,\"DataTransferItem\":false,\"DataTransferItemList\":false,\"defaultstatus\":false,\"defaultStatus\":false,\"DelayNode\":false,\"DeviceMotionEvent\":false,\"DeviceOrientationEvent\":false,\"devicePixelRatio\":false,\"dispatchEvent\":false,\"document\":false,\"Document\":false,\"DocumentFragment\":false,\"DocumentType\":false,\"DOMError\":false,\"DOMException\":false,\"DOMImplementation\":false,\"DOMMatrix\":false,\"DOMMatrixReadOnly\":false,\"DOMParser\":false,\"DOMPoint\":false,\"DOMPointReadOnly\":false,\"DOMQuad\":false,\"DOMRect\":false,\"DOMRectList\":false,\"DOMRectReadOnly\":false,\"DOMStringList\":false,\"DOMStringMap\":false,\"DOMTokenList\":false,\"DragEvent\":false,\"DynamicsCompressorNode\":false,\"Element\":false,\"ErrorEvent\":false,\"event\":false,\"Event\":false,\"EventSource\":false,\"EventTarget\":false,\"external\":false,\"fetch\":false,\"File\":false,\"FileList\":false,\"FileReader\":false,\"find\":false,\"focus\":false,\"FocusEvent\":false,\"FontFace\":false,\"FontFaceSetLoadEvent\":false,\"FormData\":false,\"frameElement\":false,\"frames\":false,\"GainNode\":false,\"Gamepad\":false,\"GamepadButton\":false,\"GamepadEvent\":false,\"getComputedStyle\":false,\"getSelection\":false,\"HashChangeEvent\":false,\"Headers\":false,\"history\":false,\"History\":false,\"HTMLAllCollection\":false,\"HTMLAnchorElement\":false,\"HTMLAreaElement\":false,\"HTMLAudioElement\":false,\"HTMLBaseElement\":false,\"HTMLBodyElement\":false,\"HTMLBRElement\":false,\"HTMLButtonElement\":false,\"HTMLCanvasElement\":false,\"HTMLCollection\":false,\"HTMLContentElement\":false,\"HTMLDataElement\":false,\"HTMLDataListElement\":false,\"HTMLDetailsElement\":false,\"HTMLDialogElement\":false,\"HTMLDirectoryElement\":false,\"HTMLDivElement\":false,\"HTMLDListElement\":false,\"HTMLDocument\":false,\"HTMLElement\":false,\"HTMLEmbedElement\":false,\"HTMLFieldSetElement\":false,\"HTMLFontElement\":false,\"HTMLFormControlsCollection\":false,\"HTMLFormElement\":false,\"HTMLFrameElement\":false,\"HTMLFrameSetElement\":false,\"HTMLHeadElement\":false,\"HTMLHeadingElement\":false,\"HTMLHRElement\":false,\"HTMLHtmlElement\":false,\"HTMLIFrameElement\":false,\"HTMLImageElement\":false,\"HTMLInputElement\":false,\"HTMLLabelElement\":false,\"HTMLLegendElement\":false,\"HTMLLIElement\":false,\"HTMLLinkElement\":false,\"HTMLMapElement\":false,\"HTMLMarqueeElement\":false,\"HTMLMediaElement\":false,\"HTMLMenuElement\":false,\"HTMLMetaElement\":false,\"HTMLMeterElement\":false,\"HTMLModElement\":false,\"HTMLObjectElement\":false,\"HTMLOListElement\":false,\"HTMLOptGroupElement\":false,\"HTMLOptionElement\":false,\"HTMLOptionsCollection\":false,\"HTMLOutputElement\":false,\"HTMLParagraphElement\":false,\"HTMLParamElement\":false,\"HTMLPictureElement\":false,\"HTMLPreElement\":false,\"HTMLProgressElement\":false,\"HTMLQuoteElement\":false,\"HTMLScriptElement\":false,\"HTMLSelectElement\":false,\"HTMLShadowElement\":false,\"HTMLSlotElement\":false,\"HTMLSourceElement\":false,\"HTMLSpanElement\":false,\"HTMLStyleElement\":false,\"HTMLTableCaptionElement\":false,\"HTMLTableCellElement\":false,\"HTMLTableColElement\":false,\"HTMLTableElement\":false,\"HTMLTableRowElement\":false,\"HTMLTableSectionElement\":false,\"HTMLTemplateElement\":false,\"HTMLTextAreaElement\":false,\"HTMLTimeElement\":false,\"HTMLTitleElement\":false,\"HTMLTrackElement\":false,\"HTMLUListElement\":false,\"HTMLUnknownElement\":false,\"HTMLVideoElement\":false,\"IDBCursor\":false,\"IDBCursorWithValue\":false,\"IDBDatabase\":false,\"IDBFactory\":false,\"IDBIndex\":false,\"IDBKeyRange\":false,\"IDBObjectStore\":false,\"IDBOpenDBRequest\":false,\"IDBRequest\":false,\"IDBTransaction\":false,\"IDBVersionChangeEvent\":false,\"IdleDeadline\":false,\"IIRFilterNode\":false,\"Image\":false,\"ImageBitmap\":false,\"ImageBitmapRenderingContext\":false,\"ImageCapture\":false,\"ImageData\":false,\"indexedDB\":false,\"innerHeight\":false,\"innerWidth\":false,\"InputEvent\":false,\"IntersectionObserver\":false,\"IntersectionObserverEntry\":false,\"Intl\":false,\"isSecureContext\":false,\"KeyboardEvent\":false,\"KeyframeEffect\":false,\"KeyframeEffectReadOnly\":false,\"length\":false,\"localStorage\":false,\"location\":true,\"Location\":false,\"locationbar\":false,\"matchMedia\":false,\"MediaDeviceInfo\":false,\"MediaDevices\":false,\"MediaElementAudioSourceNode\":false,\"MediaEncryptedEvent\":false,\"MediaError\":false,\"MediaKeyMessageEvent\":false,\"MediaKeySession\":false,\"MediaKeyStatusMap\":false,\"MediaKeySystemAccess\":false,\"MediaList\":false,\"MediaMetadata\":false,\"MediaQueryList\":false,\"MediaQueryListEvent\":false,\"MediaRecorder\":false,\"MediaSettingsRange\":false,\"MediaSource\":false,\"MediaStream\":false,\"MediaStreamAudioDestinationNode\":false,\"MediaStreamAudioSourceNode\":false,\"MediaStreamEvent\":false,\"MediaStreamTrack\":false,\"MediaStreamTrackEvent\":false,\"menubar\":false,\"MessageChannel\":false,\"MessageEvent\":false,\"MessagePort\":false,\"MIDIAccess\":false,\"MIDIConnectionEvent\":false,\"MIDIInput\":false,\"MIDIInputMap\":false,\"MIDIMessageEvent\":false,\"MIDIOutput\":false,\"MIDIOutputMap\":false,\"MIDIPort\":false,\"MimeType\":false,\"MimeTypeArray\":false,\"MouseEvent\":false,\"moveBy\":false,\"moveTo\":false,\"MutationEvent\":false,\"MutationObserver\":false,\"MutationRecord\":false,\"name\":false,\"NamedNodeMap\":false,\"NavigationPreloadManager\":false,\"navigator\":false,\"Navigator\":false,\"NetworkInformation\":false,\"Node\":false,\"NodeFilter\":false,\"NodeIterator\":false,\"NodeList\":false,\"Notification\":false,\"OfflineAudioCompletionEvent\":false,\"OfflineAudioContext\":false,\"offscreenBuffering\":false,\"OffscreenCanvas\":true,\"OffscreenCanvasRenderingContext2D\":false,\"onabort\":true,\"onafterprint\":true,\"onanimationend\":true,\"onanimationiteration\":true,\"onanimationstart\":true,\"onappinstalled\":true,\"onauxclick\":true,\"onbeforeinstallprompt\":true,\"onbeforeprint\":true,\"onbeforeunload\":true,\"onblur\":true,\"oncancel\":true,\"oncanplay\":true,\"oncanplaythrough\":true,\"onchange\":true,\"onclick\":true,\"onclose\":true,\"oncontextmenu\":true,\"oncuechange\":true,\"ondblclick\":true,\"ondevicemotion\":true,\"ondeviceorientation\":true,\"ondeviceorientationabsolute\":true,\"ondrag\":true,\"ondragend\":true,\"ondragenter\":true,\"ondragleave\":true,\"ondragover\":true,\"ondragstart\":true,\"ondrop\":true,\"ondurationchange\":true,\"onemptied\":true,\"onended\":true,\"onerror\":true,\"onfocus\":true,\"ongotpointercapture\":true,\"onhashchange\":true,\"oninput\":true,\"oninvalid\":true,\"onkeydown\":true,\"onkeypress\":true,\"onkeyup\":true,\"onlanguagechange\":true,\"onload\":true,\"onloadeddata\":true,\"onloadedmetadata\":true,\"onloadstart\":true,\"onlostpointercapture\":true,\"onmessage\":true,\"onmessageerror\":true,\"onmousedown\":true,\"onmouseenter\":true,\"onmouseleave\":true,\"onmousemove\":true,\"onmouseout\":true,\"onmouseover\":true,\"onmouseup\":true,\"onmousewheel\":true,\"onoffline\":true,\"ononline\":true,\"onpagehide\":true,\"onpageshow\":true,\"onpause\":true,\"onplay\":true,\"onplaying\":true,\"onpointercancel\":true,\"onpointerdown\":true,\"onpointerenter\":true,\"onpointerleave\":true,\"onpointermove\":true,\"onpointerout\":true,\"onpointerover\":true,\"onpointerup\":true,\"onpopstate\":true,\"onprogress\":true,\"onratechange\":true,\"onrejectionhandled\":true,\"onreset\":true,\"onresize\":true,\"onscroll\":true,\"onsearch\":true,\"onseeked\":true,\"onseeking\":true,\"onselect\":true,\"onstalled\":true,\"onstorage\":true,\"onsubmit\":true,\"onsuspend\":true,\"ontimeupdate\":true,\"ontoggle\":true,\"ontransitionend\":true,\"onunhandledrejection\":true,\"onunload\":true,\"onvolumechange\":true,\"onwaiting\":true,\"onwheel\":true,\"open\":false,\"openDatabase\":false,\"opener\":false,\"Option\":false,\"origin\":false,\"OscillatorNode\":false,\"outerHeight\":false,\"outerWidth\":false,\"OverconstrainedError\":false,\"PageTransitionEvent\":false,\"pageXOffset\":false,\"pageYOffset\":false,\"PannerNode\":false,\"parent\":false,\"Path2D\":false,\"PaymentAddress\":false,\"PaymentRequest\":false,\"PaymentRequestUpdateEvent\":false,\"PaymentResponse\":false,\"performance\":false,\"Performance\":false,\"PerformanceEntry\":false,\"PerformanceLongTaskTiming\":false,\"PerformanceMark\":false,\"PerformanceMeasure\":false,\"PerformanceNavigation\":false,\"PerformanceNavigationTiming\":false,\"PerformanceObserver\":false,\"PerformanceObserverEntryList\":false,\"PerformancePaintTiming\":false,\"PerformanceResourceTiming\":false,\"PerformanceTiming\":false,\"PeriodicWave\":false,\"Permissions\":false,\"PermissionStatus\":false,\"personalbar\":false,\"PhotoCapabilities\":false,\"Plugin\":false,\"PluginArray\":false,\"PointerEvent\":false,\"PopStateEvent\":false,\"postMessage\":false,\"Presentation\":false,\"PresentationAvailability\":false,\"PresentationConnection\":false,\"PresentationConnectionAvailableEvent\":false,\"PresentationConnectionCloseEvent\":false,\"PresentationConnectionList\":false,\"PresentationReceiver\":false,\"PresentationRequest\":false,\"print\":false,\"ProcessingInstruction\":false,\"ProgressEvent\":false,\"PromiseRejectionEvent\":false,\"prompt\":false,\"PushManager\":false,\"PushSubscription\":false,\"PushSubscriptionOptions\":false,\"queueMicrotask\":false,\"RadioNodeList\":false,\"Range\":false,\"ReadableStream\":false,\"registerProcessor\":false,\"RemotePlayback\":false,\"removeEventListener\":false,\"Request\":false,\"requestAnimationFrame\":false,\"requestIdleCallback\":false,\"resizeBy\":false,\"ResizeObserver\":false,\"ResizeObserverEntry\":false,\"resizeTo\":false,\"Response\":false,\"RTCCertificate\":false,\"RTCDataChannel\":false,\"RTCDataChannelEvent\":false,\"RTCDtlsTransport\":false,\"RTCIceCandidate\":false,\"RTCIceGatherer\":false,\"RTCIceTransport\":false,\"RTCPeerConnection\":false,\"RTCPeerConnectionIceEvent\":false,\"RTCRtpContributingSource\":false,\"RTCRtpReceiver\":false,\"RTCRtpSender\":false,\"RTCSctpTransport\":false,\"RTCSessionDescription\":false,\"RTCStatsReport\":false,\"RTCTrackEvent\":false,\"screen\":false,\"Screen\":false,\"screenLeft\":false,\"ScreenOrientation\":false,\"screenTop\":false,\"screenX\":false,\"screenY\":false,\"ScriptProcessorNode\":false,\"scroll\":false,\"scrollbars\":false,\"scrollBy\":false,\"scrollTo\":false,\"scrollX\":false,\"scrollY\":false,\"SecurityPolicyViolationEvent\":false,\"Selection\":false,\"self\":false,\"ServiceWorker\":false,\"ServiceWorkerContainer\":false,\"ServiceWorkerRegistration\":false,\"sessionStorage\":false,\"setInterval\":false,\"setTimeout\":false,\"ShadowRoot\":false,\"SharedWorker\":false,\"SourceBuffer\":false,\"SourceBufferList\":false,\"speechSynthesis\":false,\"SpeechSynthesisEvent\":false,\"SpeechSynthesisUtterance\":false,\"StaticRange\":false,\"status\":false,\"statusbar\":false,\"StereoPannerNode\":false,\"stop\":false,\"Storage\":false,\"StorageEvent\":false,\"StorageManager\":false,\"styleMedia\":false,\"StyleSheet\":false,\"StyleSheetList\":false,\"SubtleCrypto\":false,\"SVGAElement\":false,\"SVGAngle\":false,\"SVGAnimatedAngle\":false,\"SVGAnimatedBoolean\":false,\"SVGAnimatedEnumeration\":false,\"SVGAnimatedInteger\":false,\"SVGAnimatedLength\":false,\"SVGAnimatedLengthList\":false,\"SVGAnimatedNumber\":false,\"SVGAnimatedNumberList\":false,\"SVGAnimatedPreserveAspectRatio\":false,\"SVGAnimatedRect\":false,\"SVGAnimatedString\":false,\"SVGAnimatedTransformList\":false,\"SVGAnimateElement\":false,\"SVGAnimateMotionElement\":false,\"SVGAnimateTransformElement\":false,\"SVGAnimationElement\":false,\"SVGCircleElement\":false,\"SVGClipPathElement\":false,\"SVGComponentTransferFunctionElement\":false,\"SVGDefsElement\":false,\"SVGDescElement\":false,\"SVGDiscardElement\":false,\"SVGElement\":false,\"SVGEllipseElement\":false,\"SVGFEBlendElement\":false,\"SVGFEColorMatrixElement\":false,\"SVGFEComponentTransferElement\":false,\"SVGFECompositeElement\":false,\"SVGFEConvolveMatrixElement\":false,\"SVGFEDiffuseLightingElement\":false,\"SVGFEDisplacementMapElement\":false,\"SVGFEDistantLightElement\":false,\"SVGFEDropShadowElement\":false,\"SVGFEFloodElement\":false,\"SVGFEFuncAElement\":false,\"SVGFEFuncBElement\":false,\"SVGFEFuncGElement\":false,\"SVGFEFuncRElement\":false,\"SVGFEGaussianBlurElement\":false,\"SVGFEImageElement\":false,\"SVGFEMergeElement\":false,\"SVGFEMergeNodeElement\":false,\"SVGFEMorphologyElement\":false,\"SVGFEOffsetElement\":false,\"SVGFEPointLightElement\":false,\"SVGFESpecularLightingElement\":false,\"SVGFESpotLightElement\":false,\"SVGFETileElement\":false,\"SVGFETurbulenceElement\":false,\"SVGFilterElement\":false,\"SVGForeignObjectElement\":false,\"SVGGElement\":false,\"SVGGeometryElement\":false,\"SVGGradientElement\":false,\"SVGGraphicsElement\":false,\"SVGImageElement\":false,\"SVGLength\":false,\"SVGLengthList\":false,\"SVGLinearGradientElement\":false,\"SVGLineElement\":false,\"SVGMarkerElement\":false,\"SVGMaskElement\":false,\"SVGMatrix\":false,\"SVGMetadataElement\":false,\"SVGMPathElement\":false,\"SVGNumber\":false,\"SVGNumberList\":false,\"SVGPathElement\":false,\"SVGPatternElement\":false,\"SVGPoint\":false,\"SVGPointList\":false,\"SVGPolygonElement\":false,\"SVGPolylineElement\":false,\"SVGPreserveAspectRatio\":false,\"SVGRadialGradientElement\":false,\"SVGRect\":false,\"SVGRectElement\":false,\"SVGScriptElement\":false,\"SVGSetElement\":false,\"SVGStopElement\":false,\"SVGStringList\":false,\"SVGStyleElement\":false,\"SVGSVGElement\":false,\"SVGSwitchElement\":false,\"SVGSymbolElement\":false,\"SVGTextContentElement\":false,\"SVGTextElement\":false,\"SVGTextPathElement\":false,\"SVGTextPositioningElement\":false,\"SVGTitleElement\":false,\"SVGTransform\":false,\"SVGTransformList\":false,\"SVGTSpanElement\":false,\"SVGUnitTypes\":false,\"SVGUseElement\":false,\"SVGViewElement\":false,\"TaskAttributionTiming\":false,\"Text\":false,\"TextDecoder\":false,\"TextEncoder\":false,\"TextEvent\":false,\"TextMetrics\":false,\"TextTrack\":false,\"TextTrackCue\":false,\"TextTrackCueList\":false,\"TextTrackList\":false,\"TimeRanges\":false,\"toolbar\":false,\"top\":false,\"Touch\":false,\"TouchEvent\":false,\"TouchList\":false,\"TrackEvent\":false,\"TransitionEvent\":false,\"TreeWalker\":false,\"UIEvent\":false,\"URL\":false,\"URLSearchParams\":false,\"ValidityState\":false,\"visualViewport\":false,\"VisualViewport\":false,\"VTTCue\":false,\"WaveShaperNode\":false,\"WebAssembly\":false,\"WebGL2RenderingContext\":false,\"WebGLActiveInfo\":false,\"WebGLBuffer\":false,\"WebGLContextEvent\":false,\"WebGLFramebuffer\":false,\"WebGLProgram\":false,\"WebGLQuery\":false,\"WebGLRenderbuffer\":false,\"WebGLRenderingContext\":false,\"WebGLSampler\":false,\"WebGLShader\":false,\"WebGLShaderPrecisionFormat\":false,\"WebGLSync\":false,\"WebGLTexture\":false,\"WebGLTransformFeedback\":false,\"WebGLUniformLocation\":false,\"WebGLVertexArrayObject\":false,\"WebSocket\":false,\"WheelEvent\":false,\"window\":false,\"Window\":false,\"Worker\":false,\"WritableStream\":false,\"XMLDocument\":false,\"XMLHttpRequest\":false,\"XMLHttpRequestEventTarget\":false,\"XMLHttpRequestUpload\":false,\"XMLSerializer\":false,\"XPathEvaluator\":false,\"XPathExpression\":false,\"XPathResult\":false,\"XSLTProcessor\":false},\"worker\":{\"addEventListener\":false,\"applicationCache\":false,\"atob\":false,\"Blob\":false,\"BroadcastChannel\":false,\"btoa\":false,\"Cache\":false,\"caches\":false,\"clearInterval\":false,\"clearTimeout\":false,\"close\":true,\"console\":false,\"fetch\":false,\"FileReaderSync\":false,\"FormData\":false,\"Headers\":false,\"IDBCursor\":false,\"IDBCursorWithValue\":false,\"IDBDatabase\":false,\"IDBFactory\":false,\"IDBIndex\":false,\"IDBKeyRange\":false,\"IDBObjectStore\":false,\"IDBOpenDBRequest\":false,\"IDBRequest\":false,\"IDBTransaction\":false,\"IDBVersionChangeEvent\":false,\"ImageData\":false,\"importScripts\":true,\"indexedDB\":false,\"location\":false,\"MessageChannel\":false,\"MessagePort\":false,\"name\":false,\"navigator\":false,\"Notification\":false,\"onclose\":true,\"onconnect\":true,\"onerror\":true,\"onlanguagechange\":true,\"onmessage\":true,\"onoffline\":true,\"ononline\":true,\"onrejectionhandled\":true,\"onunhandledrejection\":true,\"performance\":false,\"Performance\":false,\"PerformanceEntry\":false,\"PerformanceMark\":false,\"PerformanceMeasure\":false,\"PerformanceNavigation\":false,\"PerformanceResourceTiming\":false,\"PerformanceTiming\":false,\"postMessage\":true,\"Promise\":false,\"queueMicrotask\":false,\"removeEventListener\":false,\"Request\":false,\"Response\":false,\"self\":true,\"ServiceWorkerRegistration\":false,\"setInterval\":false,\"setTimeout\":false,\"TextDecoder\":false,\"TextEncoder\":false,\"URL\":false,\"URLSearchParams\":false,\"WebSocket\":false,\"Worker\":false,\"WorkerGlobalScope\":false,\"XMLHttpRequest\":false},\"node\":{\"__dirname\":false,\"__filename\":false,\"AbortController\":false,\"AbortSignal\":false,\"atob\":false,\"btoa\":false,\"Buffer\":false,\"clearImmediate\":false,\"clearInterval\":false,\"clearTimeout\":false,\"console\":false,\"DOMException\":false,\"Event\":false,\"EventTarget\":false,\"exports\":true,\"global\":false,\"Intl\":false,\"MessageChannel\":false,\"MessageEvent\":false,\"MessagePort\":false,\"module\":false,\"performance\":false,\"process\":false,\"queueMicrotask\":false,\"require\":false,\"setImmediate\":false,\"setInterval\":false,\"setTimeout\":false,\"structuredClone\":false,\"TextDecoder\":false,\"TextEncoder\":false,\"URL\":false,\"URLSearchParams\":false},\"nodeBuiltin\":{\"AbortController\":false,\"AbortSignal\":false,\"atob\":false,\"btoa\":false,\"Buffer\":false,\"clearImmediate\":false,\"clearInterval\":false,\"clearTimeout\":false,\"console\":false,\"DOMException\":false,\"Event\":false,\"EventTarget\":false,\"global\":false,\"Intl\":false,\"MessageChannel\":false,\"MessageEvent\":false,\"MessagePort\":false,\"performance\":false,\"process\":false,\"queueMicrotask\":false,\"setImmediate\":false,\"setInterval\":false,\"setTimeout\":false,\"structuredClone\":false,\"TextDecoder\":false,\"TextEncoder\":false,\"URL\":false,\"URLSearchParams\":false},\"commonjs\":{\"exports\":true,\"global\":false,\"module\":false,\"require\":false},\"amd\":{\"define\":false,\"require\":false},\"mocha\":{\"after\":false,\"afterEach\":false,\"before\":false,\"beforeEach\":false,\"context\":false,\"describe\":false,\"it\":false,\"mocha\":false,\"run\":false,\"setup\":false,\"specify\":false,\"suite\":false,\"suiteSetup\":false,\"suiteTeardown\":false,\"teardown\":false,\"test\":false,\"xcontext\":false,\"xdescribe\":false,\"xit\":false,\"xspecify\":false},\"jasmine\":{\"afterAll\":false,\"afterEach\":false,\"beforeAll\":false,\"beforeEach\":false,\"describe\":false,\"expect\":false,\"expectAsync\":false,\"fail\":false,\"fdescribe\":false,\"fit\":false,\"it\":false,\"jasmine\":false,\"pending\":false,\"runs\":false,\"spyOn\":false,\"spyOnAllFunctions\":false,\"spyOnProperty\":false,\"waits\":false,\"waitsFor\":false,\"xdescribe\":false,\"xit\":false},\"jest\":{\"afterAll\":false,\"afterEach\":false,\"beforeAll\":false,\"beforeEach\":false,\"describe\":false,\"expect\":false,\"fdescribe\":false,\"fit\":false,\"it\":false,\"jest\":false,\"pit\":false,\"require\":false,\"test\":false,\"xdescribe\":false,\"xit\":false,\"xtest\":false},\"qunit\":{\"asyncTest\":false,\"deepEqual\":false,\"equal\":false,\"expect\":false,\"module\":false,\"notDeepEqual\":false,\"notEqual\":false,\"notOk\":false,\"notPropEqual\":false,\"notStrictEqual\":false,\"ok\":false,\"propEqual\":false,\"QUnit\":false,\"raises\":false,\"start\":false,\"stop\":false,\"strictEqual\":false,\"test\":false,\"throws\":false},\"phantomjs\":{\"console\":true,\"exports\":true,\"phantom\":true,\"require\":true,\"WebPage\":true},\"couch\":{\"emit\":false,\"exports\":false,\"getRow\":false,\"log\":false,\"module\":false,\"provides\":false,\"require\":false,\"respond\":false,\"send\":false,\"start\":false,\"sum\":false},\"rhino\":{\"defineClass\":false,\"deserialize\":false,\"gc\":false,\"help\":false,\"importClass\":false,\"importPackage\":false,\"java\":false,\"load\":false,\"loadClass\":false,\"Packages\":false,\"print\":false,\"quit\":false,\"readFile\":false,\"readUrl\":false,\"runCommand\":false,\"seal\":false,\"serialize\":false,\"spawn\":false,\"sync\":false,\"toint32\":false,\"version\":false},\"nashorn\":{\"__DIR__\":false,\"__FILE__\":false,\"__LINE__\":false,\"com\":false,\"edu\":false,\"exit\":false,\"java\":false,\"Java\":false,\"javafx\":false,\"JavaImporter\":false,\"javax\":false,\"JSAdapter\":false,\"load\":false,\"loadWithNewGlobal\":false,\"org\":false,\"Packages\":false,\"print\":false,\"quit\":false},\"wsh\":{\"ActiveXObject\":false,\"CollectGarbage\":false,\"Debug\":false,\"Enumerator\":false,\"GetObject\":false,\"RuntimeObject\":false,\"ScriptEngine\":false,\"ScriptEngineBuildVersion\":false,\"ScriptEngineMajorVersion\":false,\"ScriptEngineMinorVersion\":false,\"VBArray\":false,\"WScript\":false,\"WSH\":false},\"jquery\":{\"$\":false,\"jQuery\":false},\"yui\":{\"YAHOO\":false,\"YAHOO_config\":false,\"YUI\":false,\"YUI_config\":false},\"shelljs\":{\"cat\":false,\"cd\":false,\"chmod\":false,\"config\":false,\"cp\":false,\"dirs\":false,\"echo\":false,\"env\":false,\"error\":false,\"exec\":false,\"exit\":false,\"find\":false,\"grep\":false,\"ln\":false,\"ls\":false,\"mkdir\":false,\"mv\":false,\"popd\":false,\"pushd\":false,\"pwd\":false,\"rm\":false,\"sed\":false,\"set\":false,\"target\":false,\"tempdir\":false,\"test\":false,\"touch\":false,\"which\":false},\"prototypejs\":{\"$\":false,\"$$\":false,\"$A\":false,\"$break\":false,\"$continue\":false,\"$F\":false,\"$H\":false,\"$R\":false,\"$w\":false,\"Abstract\":false,\"Ajax\":false,\"Autocompleter\":false,\"Builder\":false,\"Class\":false,\"Control\":false,\"Draggable\":false,\"Draggables\":false,\"Droppables\":false,\"Effect\":false,\"Element\":false,\"Enumerable\":false,\"Event\":false,\"Field\":false,\"Form\":false,\"Hash\":false,\"Insertion\":false,\"ObjectRange\":false,\"PeriodicalExecuter\":false,\"Position\":false,\"Prototype\":false,\"Scriptaculous\":false,\"Selector\":false,\"Sortable\":false,\"SortableObserver\":false,\"Sound\":false,\"Template\":false,\"Toggle\":false,\"Try\":false},\"meteor\":{\"$\":false,\"Accounts\":false,\"AccountsClient\":false,\"AccountsCommon\":false,\"AccountsServer\":false,\"App\":false,\"Assets\":false,\"Blaze\":false,\"check\":false,\"Cordova\":false,\"DDP\":false,\"DDPRateLimiter\":false,\"DDPServer\":false,\"Deps\":false,\"EJSON\":false,\"Email\":false,\"HTTP\":false,\"Log\":false,\"Match\":false,\"Meteor\":false,\"Mongo\":false,\"MongoInternals\":false,\"Npm\":false,\"Package\":false,\"Plugin\":false,\"process\":false,\"Random\":false,\"ReactiveDict\":false,\"ReactiveVar\":false,\"Router\":false,\"ServiceConfiguration\":false,\"Session\":false,\"share\":false,\"Spacebars\":false,\"Template\":false,\"Tinytest\":false,\"Tracker\":false,\"UI\":false,\"Utils\":false,\"WebApp\":false,\"WebAppInternals\":false},\"mongo\":{\"_isWindows\":false,\"_rand\":false,\"BulkWriteResult\":false,\"cat\":false,\"cd\":false,\"connect\":false,\"db\":false,\"getHostName\":false,\"getMemInfo\":false,\"hostname\":false,\"ISODate\":false,\"listFiles\":false,\"load\":false,\"ls\":false,\"md5sumFile\":false,\"mkdir\":false,\"Mongo\":false,\"NumberInt\":false,\"NumberLong\":false,\"ObjectId\":false,\"PlanCache\":false,\"print\":false,\"printjson\":false,\"pwd\":false,\"quit\":false,\"removeFile\":false,\"rs\":false,\"sh\":false,\"UUID\":false,\"version\":false,\"WriteResult\":false},\"applescript\":{\"$\":false,\"Application\":false,\"Automation\":false,\"console\":false,\"delay\":false,\"Library\":false,\"ObjC\":false,\"ObjectSpecifier\":false,\"Path\":false,\"Progress\":false,\"Ref\":false},\"serviceworker\":{\"addEventListener\":false,\"applicationCache\":false,\"atob\":false,\"Blob\":false,\"BroadcastChannel\":false,\"btoa\":false,\"Cache\":false,\"caches\":false,\"CacheStorage\":false,\"clearInterval\":false,\"clearTimeout\":false,\"Client\":false,\"clients\":false,\"Clients\":false,\"close\":true,\"console\":false,\"ExtendableEvent\":false,\"ExtendableMessageEvent\":false,\"fetch\":false,\"FetchEvent\":false,\"FileReaderSync\":false,\"FormData\":false,\"Headers\":false,\"IDBCursor\":false,\"IDBCursorWithValue\":false,\"IDBDatabase\":false,\"IDBFactory\":false,\"IDBIndex\":false,\"IDBKeyRange\":false,\"IDBObjectStore\":false,\"IDBOpenDBRequest\":false,\"IDBRequest\":false,\"IDBTransaction\":false,\"IDBVersionChangeEvent\":false,\"ImageData\":false,\"importScripts\":false,\"indexedDB\":false,\"location\":false,\"MessageChannel\":false,\"MessagePort\":false,\"name\":false,\"navigator\":false,\"Notification\":false,\"onclose\":true,\"onconnect\":true,\"onerror\":true,\"onfetch\":true,\"oninstall\":true,\"onlanguagechange\":true,\"onmessage\":true,\"onmessageerror\":true,\"onnotificationclick\":true,\"onnotificationclose\":true,\"onoffline\":true,\"ononline\":true,\"onpush\":true,\"onpushsubscriptionchange\":true,\"onrejectionhandled\":true,\"onsync\":true,\"onunhandledrejection\":true,\"performance\":false,\"Performance\":false,\"PerformanceEntry\":false,\"PerformanceMark\":false,\"PerformanceMeasure\":false,\"PerformanceNavigation\":false,\"PerformanceResourceTiming\":false,\"PerformanceTiming\":false,\"postMessage\":true,\"Promise\":false,\"queueMicrotask\":false,\"registration\":false,\"removeEventListener\":false,\"Request\":false,\"Response\":false,\"self\":false,\"ServiceWorker\":false,\"ServiceWorkerContainer\":false,\"ServiceWorkerGlobalScope\":false,\"ServiceWorkerMessageEvent\":false,\"ServiceWorkerRegistration\":false,\"setInterval\":false,\"setTimeout\":false,\"skipWaiting\":false,\"TextDecoder\":false,\"TextEncoder\":false,\"URL\":false,\"URLSearchParams\":false,\"WebSocket\":false,\"WindowClient\":false,\"Worker\":false,\"WorkerGlobalScope\":false,\"XMLHttpRequest\":false},\"atomtest\":{\"advanceClock\":false,\"atom\":false,\"fakeClearInterval\":false,\"fakeClearTimeout\":false,\"fakeSetInterval\":false,\"fakeSetTimeout\":false,\"resetTimeouts\":false,\"waitsForPromise\":false},\"embertest\":{\"andThen\":false,\"click\":false,\"currentPath\":false,\"currentRouteName\":false,\"currentURL\":false,\"fillIn\":false,\"find\":false,\"findAll\":false,\"findWithAssert\":false,\"keyEvent\":false,\"pauseTest\":false,\"resumeTest\":false,\"triggerEvent\":false,\"visit\":false,\"wait\":false},\"protractor\":{\"$\":false,\"$$\":false,\"browser\":false,\"by\":false,\"By\":false,\"DartObject\":false,\"element\":false,\"protractor\":false},\"shared-node-browser\":{\"AbortController\":false,\"AbortSignal\":false,\"atob\":false,\"btoa\":false,\"clearInterval\":false,\"clearTimeout\":false,\"console\":false,\"DOMException\":false,\"Event\":false,\"EventTarget\":false,\"Intl\":false,\"MessageChannel\":false,\"MessageEvent\":false,\"MessagePort\":false,\"performance\":false,\"queueMicrotask\":false,\"setInterval\":false,\"setTimeout\":false,\"TextDecoder\":false,\"TextEncoder\":false,\"URL\":false,\"URLSearchParams\":false},\"webextensions\":{\"browser\":false,\"chrome\":false,\"opr\":false},\"greasemonkey\":{\"cloneInto\":false,\"createObjectIn\":false,\"exportFunction\":false,\"GM\":false,\"GM_addElement\":false,\"GM_addStyle\":false,\"GM_addValueChangeListener\":false,\"GM_deleteValue\":false,\"GM_download\":false,\"GM_getResourceText\":false,\"GM_getResourceURL\":false,\"GM_getTab\":false,\"GM_getTabs\":false,\"GM_getValue\":false,\"GM_info\":false,\"GM_listValues\":false,\"GM_log\":false,\"GM_notification\":false,\"GM_openInTab\":false,\"GM_registerMenuCommand\":false,\"GM_removeValueChangeListener\":false,\"GM_saveTab\":false,\"GM_setClipboard\":false,\"GM_setValue\":false,\"GM_unregisterMenuCommand\":false,\"GM_xmlhttpRequest\":false,\"unsafeWindow\":false},\"devtools\":{\"$\":false,\"$_\":false,\"$$\":false,\"$0\":false,\"$1\":false,\"$2\":false,\"$3\":false,\"$4\":false,\"$x\":false,\"chrome\":false,\"clear\":false,\"copy\":false,\"debug\":false,\"dir\":false,\"dirxml\":false,\"getEventListeners\":false,\"inspect\":false,\"keys\":false,\"monitor\":false,\"monitorEvents\":false,\"profile\":false,\"profileEnd\":false,\"queryObjects\":false,\"table\":false,\"undebug\":false,\"unmonitor\":false,\"unmonitorEvents\":false,\"values\":false}}');\n\n//# sourceURL=webpack://javascript/./node_modules/globals/globals.json?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.js");
/******/ 	
/******/ })()
;